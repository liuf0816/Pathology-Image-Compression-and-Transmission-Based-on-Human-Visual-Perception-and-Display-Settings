; Listing generated by Microsoft (R) Optimizing Compiler Version 19.00.23506.0 

	TITLE	E:\study\JPEG2000\visually_lossless_JPEG2000\ModifiedKakadu\coresys\compressed\compressed.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB MSVCRT
INCLUDELIB OLDNAMES

PUBLIC	??_H@YGXPAXIIP6EPAX0@Z@Z			; `vector constructor iterator'
PUBLIC	?__empty_global_delete@@YAXPAX@Z		; __empty_global_delete
PUBLIC	?__empty_global_delete@@YAXPAXI@Z		; __empty_global_delete
PUBLIC	___local_stdio_printf_options
PUBLIC	??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ; __vcrt_va_start_verify_argument_type<char const * const>
PUBLIC	_sprintf
PUBLIC	?put_text@kdu_message@@UAEXPBG@Z		; kdu_message::put_text
PUBLIC	??6kdu_message@@QAEAAV0@H@Z			; kdu_message::operator<<
PUBLIC	?put_text@kdu_message_formatter@@UAEXPBG@Z	; kdu_message_formatter::put_text
PUBLIC	?put_text@kdu_error@@UAEXPBG@Z			; kdu_error::put_text
PUBLIC	?put_text@kdu_warning@@UAEXPBG@Z		; kdu_warning::put_text
PUBLIC	??1kdu_output@@UAE@XZ				; kdu_output::~kdu_output
PUBLIC	?put@kdu_output@@QAEHI@Z			; kdu_output::put
PUBLIC	??_Gkdu_output@@UAEPAXI@Z			; kdu_output::`scalar deleting destructor'
PUBLIC	??0kdu_kernel_step_info@@QAE@XZ			; kdu_kernel_step_info::kdu_kernel_step_info
PUBLIC	??1kdu_kernels@@QAE@XZ				; kdu_kernels::~kdu_kernels
PUBLIC	?release_lock@kdu_thread_entity@@QAEXH@Z	; kdu_thread_entity::release_lock
PUBLIC	??_4kdu_dims@@QAE?AU0@AAU0@@Z			; kdu_dims::operator&=
PUBLIC	?intersects@kdu_dims@@QAE_NAAU1@@Z		; kdu_dims::intersects
PUBLIC	?close@kdu_tile@@QAEXPAVkdu_thread_env@@@Z	; kdu_tile::close
PUBLIC	?get_tnum@kdu_tile@@QAEHXZ			; kdu_tile::get_tnum
PUBLIC	?get_tile_idx@kdu_tile@@QAE?AUkdu_coords@@XZ	; kdu_tile::get_tile_idx
PUBLIC	?get_ycc@kdu_tile@@QAE_NXZ			; kdu_tile::get_ycc
PUBLIC	?set_components_of_interest@kdu_tile@@QAEXHPBH@Z ; kdu_tile::set_components_of_interest
PUBLIC	?get_mct_block_info@kdu_tile@@QAE_NHHAAH000PAH1PAM11@Z ; kdu_tile::get_mct_block_info
PUBLIC	?get_mct_matrix_info@kdu_tile@@QAE_NHHPAM@Z	; kdu_tile::get_mct_matrix_info
PUBLIC	?get_mct_rxform_info@kdu_tile@@QAE_NHHPAH0@Z	; kdu_tile::get_mct_rxform_info
PUBLIC	?get_mct_dependency_info@kdu_tile@@QAE_NHHAA_NPAM1PAH22@Z ; kdu_tile::get_mct_dependency_info
PUBLIC	?get_mct_dwt_info@kdu_tile@@QAEPBUkdu_kernel_step_info@@HHAA_NAAH11100AAPBMPAH3@Z ; kdu_tile::get_mct_dwt_info
PUBLIC	?get_num_components@kdu_tile@@QAEHXZ		; kdu_tile::get_num_components
PUBLIC	?get_num_layers@kdu_tile@@QAEHXZ		; kdu_tile::get_num_layers
PUBLIC	?parse_all_relevant_packets@kdu_tile@@QAE_N_NPAVkdu_thread_env@@@Z ; kdu_tile::parse_all_relevant_packets
PUBLIC	?get_parsed_packet_stats@kdu_tile@@QAE_JHHHPA_J0@Z ; kdu_tile::get_parsed_packet_stats
PUBLIC	?access_component@kdu_tile@@QAE?AVkdu_tile_comp@@H@Z ; kdu_tile::access_component
PUBLIC	?find_component_gain_info@kdu_tile@@QAEMH_N@Z	; kdu_tile::find_component_gain_info
PUBLIC	?get_reversible@kdu_tile_comp@@QAE_NXZ		; kdu_tile_comp::get_reversible
PUBLIC	?get_subsampling@kdu_tile_comp@@QAEXAAUkdu_coords@@@Z ; kdu_tile_comp::get_subsampling
PUBLIC	?get_bit_depth@kdu_tile_comp@@QAEH_N@Z		; kdu_tile_comp::get_bit_depth
PUBLIC	?get_signed@kdu_tile_comp@@QAE_NXZ		; kdu_tile_comp::get_signed
PUBLIC	?get_num_resolutions@kdu_tile_comp@@QAEHXZ	; kdu_tile_comp::get_num_resolutions
PUBLIC	?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@H@Z ; kdu_tile_comp::access_resolution
PUBLIC	?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@XZ ; kdu_tile_comp::access_resolution
PUBLIC	?access_next@kdu_resolution@@QAE?AV1@XZ		; kdu_resolution::access_next
PUBLIC	?which@kdu_resolution@@QAEHXZ			; kdu_resolution::which
PUBLIC	?get_dwt_level@kdu_resolution@@QAEHXZ		; kdu_resolution::get_dwt_level
PUBLIC	?get_comp_idx@kdu_resolution@@QAEHXZ		; kdu_resolution::get_comp_idx
PUBLIC	?get_dims@kdu_resolution@@QAEXAAUkdu_dims@@@Z	; kdu_resolution::get_dims
PUBLIC	?get_valid_precincts@kdu_resolution@@QAEXAAUkdu_dims@@@Z ; kdu_resolution::get_valid_precincts
PUBLIC	?open_precinct@kdu_resolution@@QAE?AVkdu_precinct@@Ukdu_coords@@@Z ; kdu_resolution::open_precinct
PUBLIC	?get_precinct_id@kdu_resolution@@QAE_JUkdu_coords@@@Z ; kdu_resolution::get_precinct_id
PUBLIC	?get_precinct_relevance@kdu_resolution@@QAENUkdu_coords@@@Z ; kdu_resolution::get_precinct_relevance
PUBLIC	?get_precinct_packets@kdu_resolution@@QAEHUkdu_coords@@PAVkdu_thread_env@@_N@Z ; kdu_resolution::get_precinct_packets
PUBLIC	?get_precinct_samples@kdu_resolution@@QAE_JUkdu_coords@@@Z ; kdu_resolution::get_precinct_samples
PUBLIC	?access_node@kdu_resolution@@QAE?AVkdu_node@@XZ	; kdu_resolution::access_node
PUBLIC	?get_valid_band_indices@kdu_resolution@@QAEHAAH@Z ; kdu_resolution::get_valid_band_indices
PUBLIC	?access_subband@kdu_resolution@@QAE?AVkdu_subband@@H@Z ; kdu_resolution::access_subband
PUBLIC	?get_reversible@kdu_resolution@@QAE_NXZ		; kdu_resolution::get_reversible
PUBLIC	?propagate_roi@kdu_resolution@@QAE_NXZ		; kdu_resolution::propagate_roi
PUBLIC	?access_child@kdu_node@@QAE?AV1@H@Z		; kdu_node::access_child
PUBLIC	?get_num_descendants@kdu_node@@QAEHAAH@Z	; kdu_node::get_num_descendants
PUBLIC	?access_subband@kdu_node@@QAE?AVkdu_subband@@XZ	; kdu_node::access_subband
PUBLIC	?access_resolution@kdu_node@@QAE?AVkdu_resolution@@XZ ; kdu_node::access_resolution
PUBLIC	?get_dims@kdu_node@@QAEXAAUkdu_dims@@@Z		; kdu_node::get_dims
PUBLIC	?get_kernel_id@kdu_node@@QAEHXZ			; kdu_node::get_kernel_id
PUBLIC	?get_kernel_info@kdu_node@@QAEPBUkdu_kernel_step_info@@AAHAAM1AA_N20000_N@Z ; kdu_node::get_kernel_info
PUBLIC	?get_kernel_coefficients@kdu_node@@QAEPBM_N@Z	; kdu_node::get_kernel_coefficients
PUBLIC	?get_bibo_gains@kdu_node@@QAEPBMAAH_N@Z		; kdu_node::get_bibo_gains
PUBLIC	?get_band_idx@kdu_subband@@QAEHXZ		; kdu_subband::get_band_idx
PUBLIC	?access_resolution@kdu_subband@@QAE?AVkdu_resolution@@XZ ; kdu_subband::access_resolution
PUBLIC	?get_K_max@kdu_subband@@QAEHXZ			; kdu_subband::get_K_max
PUBLIC	?get_K_max_prime@kdu_subband@@QAEHXZ		; kdu_subband::get_K_max_prime
PUBLIC	?get_reversible@kdu_subband@@QAE_NXZ		; kdu_subband::get_reversible
PUBLIC	?get_delta@kdu_subband@@QAEMXZ			; kdu_subband::get_delta
PUBLIC	?get_msb_wmse@kdu_subband@@QAEMXZ		; kdu_subband::get_msb_wmse
PUBLIC	?get_roi_weight@kdu_subband@@QAE_NAAM@Z		; kdu_subband::get_roi_weight
PUBLIC	?get_dims@kdu_subband@@QAEXAAUkdu_dims@@@Z	; kdu_subband::get_dims
PUBLIC	?get_valid_blocks@kdu_subband@@QAEXAAUkdu_dims@@@Z ; kdu_subband::get_valid_blocks
PUBLIC	?get_block_size@kdu_subband@@QAEXAAUkdu_coords@@0@Z ; kdu_subband::get_block_size
PUBLIC	?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z ; kdu_subband::open_block
PUBLIC	?close_block@kdu_subband@@QAEXPAUkdu_block@@PAVkdu_thread_env@@@Z ; kdu_subband::close_block
PUBLIC	?get_conservative_slope_threshold@kdu_subband@@QAEGXZ ; kdu_subband::get_conservative_slope_threshold
PUBLIC	?check_loaded@kdu_precinct@@QAE_NXZ		; kdu_precinct::check_loaded
PUBLIC	?get_unique_id@kdu_precinct@@QAE_JXZ		; kdu_precinct::get_unique_id
PUBLIC	?get_valid_blocks@kdu_precinct@@QAE_NHAAUkdu_dims@@@Z ; kdu_precinct::get_valid_blocks
PUBLIC	?open_block@kdu_precinct@@QAEPAUkdu_block@@HUkdu_coords@@PAVkdu_thread_env@@@Z ; kdu_precinct::open_block
PUBLIC	?close_block@kdu_precinct@@QAEXPAUkdu_block@@PAVkdu_thread_env@@@Z ; kdu_precinct::close_block
PUBLIC	?size_packets@kdu_precinct@@QAE_NAAH0AA_N@Z	; kdu_precinct::size_packets
PUBLIC	?get_packets@kdu_precinct@@QAE_NHHAAH0PAVkdu_output@@@Z ; kdu_precinct::get_packets
PUBLIC	?restart@kdu_precinct@@QAEXXZ			; kdu_precinct::restart
PUBLIC	?close@kdu_precinct@@QAEXXZ			; kdu_precinct::close
PUBLIC	?set_codestream_buf_server@kd_thread_buf_server@@QAEXPAVkd_buf_server@@@Z ; kd_thread_buf_server::set_codestream_buf_server
PUBLIC	??1kd_input@@UAE@XZ				; kd_input::~kd_input
PUBLIC	?disable_marker_throwing@kd_input@@QAE_NXZ	; kd_input::disable_marker_throwing
PUBLIC	?get@kd_input@@QAE_NAAE@Z			; kd_input::get
PUBLIC	??_Gkd_input@@UAEPAXI@Z				; kd_input::`scalar deleting destructor'
PUBLIC	?set_suspend@kd_compressed_input@@QAEX_N@Z	; kd_compressed_input::set_suspend
PUBLIC	??0kd_pph_input@@QAE@PAVkd_buf_server@@@Z	; kd_pph_input::kd_pph_input
PUBLIC	??_Gkd_pph_input@@UAEPAXI@Z			; kd_pph_input::`scalar deleting destructor'
PUBLIC	?restart@kd_precinct_pointer_server@@QAEXXZ	; kd_precinct_pointer_server::restart
PUBLIC	?initialize@kd_precinct_pointer_server@@QAEXPAVkd_buf_server@@@Z ; kd_precinct_pointer_server::initialize
PUBLIC	?update_stats@kd_compressed_stats@@QAE_NPAUkdu_block@@@Z ; kd_compressed_stats::update_stats
PUBLIC	?update_quant_slope_thresholds@kd_compressed_stats@@QAEXXZ ; kd_compressed_stats::update_quant_slope_thresholds
PUBLIC	??0kd_packet_sequencer@@QAE@PAUkd_tile@@@Z	; kd_packet_sequencer::kd_packet_sequencer
PUBLIC	??0kd_reslength_checker@@QAE@XZ			; kd_reslength_checker::kd_reslength_checker
PUBLIC	??1kd_reslength_checker@@QAE@XZ			; kd_reslength_checker::~kd_reslength_checker
PUBLIC	??_Ekd_reslength_checker@@QAEPAXI@Z		; kd_reslength_checker::`vector deleting destructor'
PUBLIC	??1kd_mct_ss_model@@QAE@XZ			; kd_mct_ss_model::~kd_mct_ss_model
PUBLIC	??1kd_mct_block@@QAE@XZ				; kd_mct_block::~kd_mct_block
PUBLIC	??0kd_tile@@QAE@PAUkd_codestream@@PAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z ; kd_tile::kd_tile
PUBLIC	??1kd_tile@@QAE@XZ				; kd_tile::~kd_tile
PUBLIC	?release@kd_tile@@QAEXXZ			; kd_tile::release
PUBLIC	?initialize@kd_tile@@QAEXXZ			; kd_tile::initialize
PUBLIC	?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z ; kd_tile::recycle
PUBLIC	?restart@kd_tile@@QAEXXZ			; kd_tile::restart
PUBLIC	?reinitialize@kd_tile@@QAEXXZ			; kd_tile::reinitialize
PUBLIC	?open@kd_tile@@QAEXXZ				; kd_tile::open
PUBLIC	?read_tile_part_header@kd_tile@@QAE_NXZ		; kd_tile::read_tile_part_header
PUBLIC	?finished_reading@kd_tile@@QAE_NXZ		; kd_tile::finished_reading
PUBLIC	?generate_tile_part@kd_tile@@QAE_JHQAG@Z	; kd_tile::generate_tile_part
PUBLIC	?remove_from_in_progress_list@kd_tile@@QAEXXZ	; kd_tile::remove_from_in_progress_list
PUBLIC	?adjust_unloadability@kd_tile@@QAEXXZ		; kd_tile::adjust_unloadability
PUBLIC	?set_elements_of_interest@kd_tile@@AAEXXZ	; kd_tile::set_elements_of_interest
PUBLIC	?withdraw_from_unloadable_list@kd_tile@@AAEXXZ	; kd_tile::withdraw_from_unloadable_list
PUBLIC	?add_to_unloadable_list@kd_tile@@AAEXXZ		; kd_tile::add_to_unloadable_list
PUBLIC	?find_multicomponent_energy_gain@kd_tile@@AAEMH_N@Z ; kd_tile::find_multicomponent_energy_gain
PUBLIC	??0kd_tile_comp@@QAE@XZ				; kd_tile_comp::kd_tile_comp
PUBLIC	??1kd_tile_comp@@QAE@XZ				; kd_tile_comp::~kd_tile_comp
PUBLIC	?initialize_kernel_parameters@kd_tile_comp@@QAEXHAAVkdu_kernels@@@Z ; kd_tile_comp::initialize_kernel_parameters
PUBLIC	??_Ekd_tile_comp@@QAEPAXI@Z			; kd_tile_comp::`vector deleting destructor'
PUBLIC	??0kd_precinct_ref@@QAE@XZ			; kd_precinct_ref::kd_precinct_ref
PUBLIC	??1kd_precinct_ref@@QAE@XZ			; kd_precinct_ref::~kd_precinct_ref
PUBLIC	?open@kd_precinct_ref@@QAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@_N@Z ; kd_precinct_ref::open
PUBLIC	?close@kd_precinct_ref@@QAEXXZ			; kd_precinct_ref::close
PUBLIC	?set_address@kd_precinct_ref@@QAE_NPAUkd_resolution@@Ukdu_coords@@_J@Z ; kd_precinct_ref::set_address
PUBLIC	?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z ; kd_precinct_ref::instantiate_precinct
PUBLIC	??_Ekd_precinct_ref@@QAEPAXI@Z			; kd_precinct_ref::`vector deleting destructor'
PUBLIC	?adjust_cover@kd_node@@QAEXUkdu_dims@@HH@Z	; kd_node::adjust_cover
PUBLIC	??0kd_node@@QAE@XZ				; kd_node::kd_node
PUBLIC	??0kd_subband@@QAE@XZ				; kd_subband::kd_subband
PUBLIC	??0kd_resolution@@QAE@XZ			; kd_resolution::kd_resolution
PUBLIC	??1kd_resolution@@QAE@XZ			; kd_resolution::~kd_resolution
PUBLIC	?build_decomposition_structure@kd_resolution@@QAEXPAVkdu_params@@AAVkdu_kernels@@@Z ; kd_resolution::build_decomposition_structure
PUBLIC	?complete_initialization@kd_resolution@@QAEXXZ	; kd_resolution::complete_initialization
PUBLIC	??_Ekd_resolution@@QAEPAXI@Z			; kd_resolution::`vector deleting destructor'
PUBLIC	?get_bit@kd_header_in@@QAEHXZ			; kd_header_in::get_bit
PUBLIC	?finish@kd_header_in@@QAEHXZ			; kd_header_in::finish
PUBLIC	?cleanup@kd_block@@QAEXPAVkd_buf_server@@@Z	; kd_block::cleanup
PUBLIC	?initialize@kd_precinct@@QAEXPAUkd_resolution@@Ukdu_coords@@@Z ; kd_precinct::initialize
PUBLIC	?activate@kd_precinct@@QAEXXZ			; kd_precinct::activate
PUBLIC	?closing@kd_precinct@@QAEXXZ			; kd_precinct::closing
PUBLIC	?release@kd_precinct@@QAEXXZ			; kd_precinct::release
PUBLIC	?desequence_packet@kd_precinct@@QAE_NXZ		; kd_precinct::desequence_packet
PUBLIC	?load_required_packets@kd_precinct@@QAEXXZ	; kd_precinct::load_required_packets
PUBLIC	?simulate_packet@kd_precinct@@QAE_JAA_JHG_N1_J1@Z ; kd_precinct::simulate_packet
PUBLIC	?write_packet@kd_precinct@@QAE_JG_N@Z		; kd_precinct::write_packet
PUBLIC	?read_packet@kd_precinct@@AAE_NXZ		; kd_precinct::read_packet
PUBLIC	?handle_corrupt_packet@kd_precinct@@AAE_NXZ	; kd_precinct::handle_corrupt_packet
PUBLIC	?move_to_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::move_to_inactive_list
PUBLIC	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list
PUBLIC	?augment_free_list@kd_precinct_size_class@@AAEXXZ ; kd_precinct_size_class::augment_free_list
PUBLIC	?get@kd_precinct_server@@QAEPAUkd_precinct@@HH@Z ; kd_precinct_server::get
PUBLIC	?get_block_state@kd_thread_env@@QAEPAUkd_thread_block_state@@PAUkd_codestream@@PAUkd_precinct@@PAVkd_block@@@Z ; kd_thread_env::get_block_state
PUBLIC	?flush_buf@kd_dummy_target@@MAEXXZ		; kd_dummy_target::flush_buf
PUBLIC	??1kd_dummy_target@@UAE@XZ			; kd_dummy_target::~kd_dummy_target
PUBLIC	??_Gkd_dummy_target@@UAEPAXI@Z			; kd_dummy_target::`scalar deleting destructor'
PUBLIC	?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage
PUBLIC	??_C@_02NJNOFBBI@?$CFx?$AA@			; `string'
PUBLIC	??_C@_02DPKJAMEF@?$CFd?$AA@			; `string'
PUBLIC	__TI2PAE
PUBLIC	__CTA2PAE
PUBLIC	??_R0PAE@8					; unsigned char * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAE@84
PUBLIC	??_R0PAX@8					; void * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAX@84
PUBLIC	??_7kdu_output@@6B@				; kdu_output::`vftable'
PUBLIC	__TI1H
PUBLIC	__CTA1H
PUBLIC	??_R0H@8					; int `RTTI Type Descriptor'
PUBLIC	__CT??_R0H@84
PUBLIC	??_7kd_input@@6B@				; kd_input::`vftable'
PUBLIC	??_7kd_pph_input@@6B@				; kd_pph_input::`vftable'
PUBLIC	__TI2PAVkd_header_in@@
PUBLIC	__CTA2PAVkd_header_in@@
PUBLIC	??_R0PAVkd_header_in@@@8			; kd_header_in * `RTTI Type Descriptor'
PUBLIC	__CT??_R0PAVkd_header_in@@@84
PUBLIC	??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@	; `string'
PUBLIC	??_C@_0GL@JBAAPDCE@Coding?5partitions?5?$CIcode?9blocks?5a@ ; `string'
PUBLIC	??_C@_0GG@KMAHIAKO@Coding?5partitions?5?$CInamely?0?5code?9@ ; `string'
PUBLIC	??_C@_0BN@MCFNCJCD@?6?$DO?$DO?5New?5attributes?5for?5tile?5?$AA@ ; `string'
PUBLIC	??_C@_02NDKNKOCB@?3?6?$AA@			; `string'
PUBLIC	??_C@_03LIMJJHMM@COD?$AA@			; `string'
PUBLIC	??_C@_03ELMDPBLM@QCD?$AA@			; `string'
PUBLIC	??_C@_03KEJABOAE@RGN?$AA@			; `string'
PUBLIC	??_C@_03MNMMELJE@ORG?$AA@			; `string'
PUBLIC	??_C@_08DAJNLNLL@Cuse_sop?$AA@			; `string'
PUBLIC	??_C@_08NAIOMJOM@Cuse_eph?$AA@			; `string'
PUBLIC	??_C@_04DEPIIIHA@Cycc?$AA@			; `string'
PUBLIC	??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@		; `string'
PUBLIC	??_C@_07BJCMAMHC@Clayers?$AA@			; `string'
PUBLIC	??_C@_0M@HKNEBDCB@Creslengths?$AA@		; `string'
PUBLIC	??_C@_09CNLDEMAK@ORGtparts?$AA@			; `string'
PUBLIC	??_C@_0L@DMGGEJHL@ORGgen_plt?$AA@		; `string'
PUBLIC	??_C@_07BGFFFHMP@Clevels?$AA@			; `string'
PUBLIC	??_C@_0M@ODOOFFGJ@Creversible?$AA@		; `string'
PUBLIC	??_C@_08IDCJHBJK@Ckernels?$AA@			; `string'
PUBLIC	??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@		; `string'
PUBLIC	??_C@_04HAGFJFNL@Cblk?$AA@			; `string'
PUBLIC	??_C@_06EGDCPANH@Cmodes?$AA@			; `string'
PUBLIC	??_C@_04HAOFMIPN@Catk?$AA@			; `string'
PUBLIC	??_C@_08CCOBJCLJ@Qderived?$AA@			; `string'
PUBLIC	??_C@_0L@ELEFPJIC@Qabs_steps?$AA@		; `string'
PUBLIC	??_C@_0BHA@JBHJNMJO@Tile?9components?5which?5are?5compre@ ; `string'
PUBLIC	??_C@_07KGEEGGHK@Rlevels?$AA@			; `string'
PUBLIC	??_C@_07HDHNGJDI@Cweight?$AA@			; `string'
PUBLIC	??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@ ; `string'
PUBLIC	??_C@_0ML@FMBEAHIM@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0MC@OOKHAIOM@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0KN@KMCHIBHI@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0PN@ECKJOGL@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0L@KGBLICHL@Cprecincts?$AA@		; `string'
PUBLIC	??_C@_0BBK@KIFKIPEK@Tile?9component?9resolution?5encoun@ ; `string'
PUBLIC	??_C@_0BBP@FFHCNMHP@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0MJ@MHJOJOLI@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0N@HICBBPMC@Clev_weights?$AA@		; `string'
PUBLIC	??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@		; `string'
PUBLIC	??_C@_06BGIMBACE@Qguard?$AA@			; `string'
PUBLIC	??_C@_07MDGMFIIN@Rweight?$AA@			; `string'
PUBLIC	??_C@_06LDAKCIBF@Rshift?$AA@			; `string'
PUBLIC	??_C@_0JM@NAEKEAHJ@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0O@GLALLHKC@Cband_weights?$AA@		; `string'
PUBLIC	??_C@_0KN@HAEBDHLJ@Precinct?5partition?5dimensions?5to@ ; `string'
PUBLIC	??_C@_0GC@GCDNIPCG@Illegal?5colour?5transform?5specifi@ ; `string'
PUBLIC	??_C@_07HDMBGKJA@QCD?3RGN?$AA@			; `string'
PUBLIC	??_C@_0DB@CKMBKEOA@You?5must?5close?5a?5tile?5before?5you@ ; `string'
PUBLIC	??_C@_0GH@CBFAGHCH@You?5cannot?5use?5PPM?5or?5PPT?5marker@ ; `string'
PUBLIC	??_C@_0HP@MELIFPKI@Found?5non?9marker?5code?5while?5pars@ ; `string'
PUBLIC	??_C@_0CL@KHMENMGB@Invalid?5marker?5code?5found?5in?5cod@ ; `string'
PUBLIC	??_C@_0BO@BKLJKNEJ@?7Expected?5SOT?5marker?5and?5got?5?$AA@ ; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0IL@OEKPKFDK@Corrupt?5SOT?5marker?5segment?5found@ ; `string'
PUBLIC	??_C@_0DH@BFBKABHP@Missing?5or?5out?9of?9sequence?5tile?9@ ; `string'
PUBLIC	??_C@_0BB@LBOIHLHG@?5in?5code?9stream?$CB?$AA@	; `string'
PUBLIC	??_C@_0CK@JIECJLAN@The?5number?5of?5tile?9parts?5for?5til@ ; `string'
PUBLIC	??_C@_0FD@MEKGJNMP@?5is?5identified?5by?5different?5non?9@ ; `string'
PUBLIC	??_C@_03LFCEPJHK@POC?$AA@			; `string'
PUBLIC	??_C@_0KL@FMHHAPCD@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0JC@HCNJDFHD@Found?5non?9marker?5code?5while?5look@ ; `string'
PUBLIC	??_C@_0DE@HNLKCMOC@Use?5of?5both?5PPM?5and?5PPT?5marker?5s@ ; `string'
PUBLIC	??_C@_0BO@KPHEGGEJ@Too?5many?5tile?9parts?5for?5tile?5?$AA@ ; `string'
PUBLIC	??_C@_0CJ@PEIPJIAP@?4?5?5No?5tile?5may?5have?5more?5than?525@ ; `string'
PUBLIC	??_C@_0GI@GJEHPDEO@?4?5?5The?5maximum?5number?5of?5tile?9pa@ ; `string'
PUBLIC	??_C@_0MP@KJDJEMOL@Profile?5violation?5detected?5?$CIcode@ ; `string'
PUBLIC	??_C@_0KI@NPIDLLIG@Attempting?5to?5generate?5tile?9part@ ; `string'
PUBLIC	??_C@_0NP@BHJNFIFJ@Cannot?5satisfy?5the?5request?5to?5ge@ ; `string'
PUBLIC	??_C@_0OJ@JNMDPNHM@Length?5of?5current?5tile?9part?5exce@ ; `string'
PUBLIC	??_C@_0P@DIALIICI@Mvector_coeffs?$AA@		; `string'
PUBLIC	??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@		; `string'
PUBLIC	??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@		; `string'
PUBLIC	??_C@_0NP@CFEPKMLA@Attempting?5to?5access?5a?5non?9exist@ ; `string'
PUBLIC	??_C@_0BCL@NDBOHLBO@Attempting?5to?5access?5a?5resolutio@ ; `string'
PUBLIC	??_C@_07MIOINIMK@Cdecomp?$AA@			; `string'
PUBLIC	??_C@_0LI@BAKNOCIL@Calls?5to?5?$GAkdu_resolution?3?3open_p@ ; `string'
PUBLIC	??_C@_0MG@MIKKMPNN@The?5precinct?5you?5are?5trying?5to?5a@ ; `string'
PUBLIC	??_C@_0NN@MFAEJGKE@You?5are?5permitted?5to?5open?5each?5c@ ; `string'
PUBLIC	??_C@_0ED@CJMFIANH@Attempting?5to?5open?5the?5same?5code@ ; `string'
PUBLIC	??_C@_0FK@HALGFJID@Out?9of?9sequence?5SOP?5marker?5found@ ; `string'
PUBLIC	??_C@_0BI@NMKGFPMC@?7Found?5sequence?5number?5?$AA@ ; `string'
PUBLIC	??_C@_0BA@BNNPLEHB@?0?5but?5expected?5?$AA@	; `string'
PUBLIC	??_C@_02MIICKFIN@?4?6?$AA@			; `string'
PUBLIC	??_C@_0EO@IEHAKBJH@Use?5the?5resilient?5option?5if?5you?5@ ; `string'
PUBLIC	??_C@_0FD@LOABHKKD@Illegal?5marker?5code?5found?5while?5@ ; `string'
PUBLIC	??_C@_0BJ@HMCGKOMP@?7Illegal?5marker?5code?5is?5?$AA@ ; `string'
PUBLIC	??_C@_0FB@NMDJGOOL@Exhausted?5PPM?1PPT?5marker?5segment@ ; `string'
PUBLIC	??_R0G@8					; unsigned short `RTTI Type Descriptor'
PUBLIC	??_C@_0BDO@LLBNLAKJ@Packet?5header?5contains?5a?5represe@ ; `string'
PUBLIC	??_C@_0CBL@LGBHIIBA@Illegal?5inclusion?5tag?5tree?5encou@ ; `string'
PUBLIC	??_C@_0BAA@PKDCKLHJ@Illegal?5number?5of?5missing?5MSB?8s?5@ ; `string'
PUBLIC	??_C@_0BG@OOKLLMMG@Illegal?5marker?5code?0?5?$AA@ ; `string'
PUBLIC	??_C@_0GA@NALIOIEH@?0?5found?5while?5reading?5packet?5hea@ ; `string'
PUBLIC	??_C@_0DN@IEKEFHF@Expected?5to?5find?5EPH?5marker?5foll@ ; `string'
PUBLIC	??_C@_09LNCLJGMF@?5instead?4?$AA@		; `string'
PUBLIC	??_C@_0FO@KDIMGOKP@?0?5found?5while?5reading?5packet?5bod@ ; `string'
PUBLIC	??_C@_0CD@BIAHNBHE@Packet?5body?5terminated?5with?5an?5F@ ; `string'
PUBLIC	??_C@_0BEO@PKHFIGLM@Encountered?5a?5corrupted?5packet?5w@ ; `string'
PUBLIC	??_C@_0IN@CECCKADH@You?5may?5not?5currently?5flush?5comp@ ; `string'
PUBLIC	??_7kd_dummy_target@@6B@			; kd_dummy_target::`vftable'
PUBLIC	??_C@_0FI@JEJCBJLM@Heap?5exhausted?4?5?5Unable?5to?5alloc@ ; `string'
PUBLIC	??_R4kdu_output@@6B@				; kdu_output::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkdu_output@@@8				; kdu_output `RTTI Type Descriptor'
PUBLIC	??_R3kdu_output@@8				; kdu_output::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kdu_output@@8				; kdu_output::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kdu_output@@8			; kdu_output::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_input@@6B@				; kd_input::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_input@@@8				; kd_input `RTTI Type Descriptor'
PUBLIC	??_R3kd_input@@8				; kd_input::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_input@@8				; kd_input::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_input@@8			; kd_input::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_pph_input@@6B@				; kd_pph_input::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_pph_input@@@8			; kd_pph_input `RTTI Type Descriptor'
PUBLIC	??_R3kd_pph_input@@8				; kd_pph_input::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_pph_input@@8				; kd_pph_input::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_pph_input@@8			; kd_pph_input::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4kd_dummy_target@@6B@			; kd_dummy_target::`RTTI Complete Object Locator'
PUBLIC	??_R0?AVkd_dummy_target@@@8			; kd_dummy_target `RTTI Type Descriptor'
PUBLIC	??_R3kd_dummy_target@@8				; kd_dummy_target::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2kd_dummy_target@@8				; kd_dummy_target::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@kd_dummy_target@@8		; kd_dummy_target::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	__real@00000000
PUBLIC	__real@0000000000000000
PUBLIC	__real@3f1a36e2eb1c432d
PUBLIC	__real@3f800000
PUBLIC	__real@3fb0000000000000
PUBLIC	__real@3fe0000000000000
PUBLIC	__real@3fe2000000000000
PUBLIC	__real@3ff0000000000000
PUBLIC	__real@40000000
PUBLIC	__real@4000000000000000
PUBLIC	__real@40091eafee6fb4c4
PUBLIC	__real@41d0000000000000
PUBLIC	__xmm@3fbe516a0eeb824c0000000000000000
PUBLIC	__xmm@3fe051d7e177e3e53fff731d2e0e3046
EXTRN	??_L@YGXPAXIIP6EX0@Z1@Z:PROC			; `eh vector constructor iterator'
EXTRN	??_M@YGXPAXIIP6EX0@Z@Z:PROC			; `eh vector destructor iterator'
EXTRN	__purecall:PROC
EXTRN	??2@YAPAXI@Z:PROC				; operator new
EXTRN	??3@YAXPAXI@Z:PROC				; operator delete
EXTRN	??_U@YAPAXI@Z:PROC				; operator new[]
EXTRN	??_V@YAXPAX@Z:PROC				; operator delete[]
EXTRN	??_V@YAXPAXI@Z:PROC				; operator delete[]
EXTRN	___std_terminate:PROC
EXTRN	__imp__ReleaseMutex@4:PROC
EXTRN	__imp__WaitForSingleObject@8:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp____stdio_common_vsprintf:PROC
EXTRN	??0kdu_error@@QAE@PBD@Z:PROC			; kdu_error::kdu_error
EXTRN	??1kdu_error@@UAE@XZ:PROC			; kdu_error::~kdu_error
EXTRN	??0kdu_warning@@QAE@PBD@Z:PROC			; kdu_warning::kdu_warning
EXTRN	??1kdu_warning@@UAE@XZ:PROC			; kdu_warning::~kdu_warning
EXTRN	??_Ekdu_output@@UAEPAXI@Z:PROC			; kdu_output::`vector deleting destructor'
EXTRN	?access_cluster@kdu_params@@QAEPAV1@PBD@Z:PROC	; kdu_params::access_cluster
EXTRN	?access_cluster@kdu_params@@QAEPAV1@H@Z:PROC	; kdu_params::access_cluster
EXTRN	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z:PROC ; kdu_params::access_relation
EXTRN	?access_unique@kdu_params@@QAEPAV1@HHH@Z:PROC	; kdu_params::access_unique
EXTRN	?any_changes@kdu_params@@QAE_NXZ:PROC		; kdu_params::any_changes
EXTRN	?check_typical_tile@kdu_params@@QAE_NHPBD@Z:PROC ; kdu_params::check_typical_tile
EXTRN	?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z:PROC ; kdu_params::translate_marker_segment
EXTRN	?generate_marker_segments@kdu_params@@QAEHPAVkdu_output@@HH@Z:PROC ; kdu_params::generate_marker_segments
EXTRN	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z:PROC	; kdu_params::get
EXTRN	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z:PROC	; kdu_params::get
EXTRN	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z:PROC	; kdu_params::get
EXTRN	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@HH_N@Z:PROC ; kdu_params::textualize_attributes
EXTRN	?finalize_all@kdu_params@@QAEXH_N@Z:PROC	; kdu_params::finalize_all
EXTRN	?transpose_decomp@cod_params@@SAHH@Z:PROC	; cod_params::transpose_decomp
EXTRN	?expand_decomp_bands@cod_params@@SAHHQAF@Z:PROC	; cod_params::expand_decomp_bands
EXTRN	?init@kdu_kernels@@QAEXHPBUkdu_kernel_step_info@@PBM_N22@Z:PROC ; kdu_kernels::init
EXTRN	?get_impulse_response@kdu_kernels@@QAEPAMW4kdu_kernel_type@@AAHPAH2@Z:PROC ; kdu_kernels::get_impulse_response
EXTRN	?get_energy_gain@kdu_kernels@@QAENHHQA_N@Z:PROC	; kdu_kernels::get_energy_gain
EXTRN	?get_bibo_gain@kdu_kernels@@QAENHHQA_N@Z:PROC	; kdu_kernels::get_bibo_gain
EXTRN	?get_bibo_gains@kdu_kernels@@QAEPANHHQA_NAAN1@Z:PROC ; kdu_kernels::get_bibo_gains
EXTRN	?clear@kdu_kernels@@AAEXXZ:PROC			; kdu_kernels::clear
EXTRN	?reset@kdu_kernels@@AAEXXZ:PROC			; kdu_kernels::reset
EXTRN	?print_marker_code@@YAXGAAVkdu_message@@@Z:PROC	; print_marker_code
EXTRN	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ:PROC ; kd_buf_server::get
EXTRN	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z:PROC ; kd_buf_server::release
EXTRN	?attach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z:PROC ; kd_buf_server::attach_thread_buf_server
EXTRN	?detach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z:PROC ; kd_buf_server::detach_thread_buf_server
EXTRN	?read@kd_input@@QAEHPAEH@Z:PROC			; kd_input::read
EXTRN	?read@kd_input@@QAEHAAPAUkd_code_buffer@@AAEPAVkd_buf_server@@H@Z:PROC ; kd_input::read
EXTRN	?ignore@kd_input@@UAE_J_J@Z:PROC		; kd_input::ignore
EXTRN	?process_unexpected_marker@kd_input@@AAEXE@Z:PROC ; kd_input::process_unexpected_marker
EXTRN	??_Ekd_input@@UAEPAXI@Z:PROC			; kd_input::`vector deleting destructor'
EXTRN	?set_tileheader_scope@kd_compressed_input@@QAE_NHH@Z:PROC ; kd_compressed_input::set_tileheader_scope
EXTRN	?seek@kd_compressed_input@@QAEX_J@Z:PROC	; kd_compressed_input::seek
EXTRN	??1kd_pph_input@@UAE@XZ:PROC			; kd_pph_input::~kd_pph_input
EXTRN	?load_buf@kd_pph_input@@MAE_NXZ:PROC		; kd_pph_input::load_buf
EXTRN	??_Ekd_pph_input@@UAEPAXI@Z:PROC		; kd_pph_input::`vector deleting destructor'
EXTRN	?read@kd_marker@@QAE_N_N0@Z:PROC		; kd_marker::read
EXTRN	??1kd_pp_markers@@QAE@XZ:PROC			; kd_pp_markers::~kd_pp_markers
EXTRN	?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z:PROC ; kd_pp_markers::add_marker
EXTRN	?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z:PROC ; kd_pp_markers::transfer_tpart
EXTRN	?ignore_tpart@kd_pp_markers@@QAEXXZ:PROC	; kd_pp_markers::ignore_tpart
EXTRN	?add_tpart_length@kd_tlm_generator@@QAEXH_J@Z:PROC ; kd_tlm_generator::add_tpart_length
EXTRN	?add_tpart@kd_tpart_pointer_server@@QAEXPAUkd_tile_ref@@_J@Z:PROC ; kd_tpart_pointer_server::add_tpart
EXTRN	?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z:PROC ; kd_precinct_pointer_server::add_plt_marker
EXTRN	?start_tpart_body@kd_precinct_pointer_server@@QAEX_JIPAVkdu_params@@1_N2@Z:PROC ; kd_precinct_pointer_server::start_tpart_body
EXTRN	?init@kd_packet_sequencer@@QAEXXZ:PROC		; kd_packet_sequencer::init
EXTRN	?save_state@kd_packet_sequencer@@QAEXXZ:PROC	; kd_packet_sequencer::save_state
EXTRN	?restore_state@kd_packet_sequencer@@QAEXXZ:PROC	; kd_packet_sequencer::restore_state
EXTRN	?next_in_sequence@kd_packet_sequencer@@QAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z:PROC ; kd_packet_sequencer::next_in_sequence
EXTRN	?init@kd_reslength_checker@@QAE_NPAVcod_params@@@Z:PROC ; kd_reslength_checker::init
EXTRN	?notify_tile_status@kd_global_rescomp@@QAEXUkdu_dims@@_N@Z:PROC ; kd_global_rescomp::notify_tile_status
EXTRN	?add_ready_precinct@kd_global_rescomp@@QAEXPAUkd_precinct@@@Z:PROC ; kd_global_rescomp::add_ready_precinct
EXTRN	?close_ready_precinct@kd_global_rescomp@@QAEXPAUkd_precinct@@@Z:PROC ; kd_global_rescomp::close_ready_precinct
EXTRN	?analyze_sensitivity@kd_mct_block@@QAEXHMAAH0_N@Z:PROC ; kd_mct_block::analyze_sensitivity
EXTRN	?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z:PROC ; kd_mct_stage::create_stages
EXTRN	?apply_output_restrictions@kd_mct_stage@@QAEXPAUkd_output_comp_info@@HPBH@Z:PROC ; kd_mct_stage::apply_output_restrictions
EXTRN	?create_tile@kd_codestream@@QAEPAUkd_tile@@Ukdu_coords@@@Z:PROC ; kd_codestream::create_tile
EXTRN	?trim_compressed_data@kd_codestream@@QAEXXZ:PROC ; kd_codestream::trim_compressed_data
EXTRN	?unload_tiles_to_cache_threshold@kd_codestream@@QAEXXZ:PROC ; kd_codestream::unload_tiles_to_cache_threshold
EXTRN	?parse_packet_header@kd_block@@QAEHAAVkd_header_in@@PAVkd_buf_server@@H@Z:PROC ; kd_block::parse_packet_header
EXTRN	?retrieve_data@kd_block@@QAEXPAUkdu_block@@HH_N@Z:PROC ; kd_block::retrieve_data
EXTRN	?store_data@kd_block@@QAEXPAUkdu_block@@PAVkd_buf_server@@@Z:PROC ; kd_block::store_data
EXTRN	?store_data@kd_block@@QAEXPAUkdu_block@@PAVkd_thread_buf_server@@@Z:PROC ; kd_block::store_data
EXTRN	?trim_data@kd_block@@QAE_NGPAVkd_buf_server@@@Z:PROC ; kd_block::trim_data
EXTRN	?start_packet@kd_block@@QAEHHG@Z:PROC		; kd_block::start_packet
EXTRN	?write_packet_header@kd_block@@QAEXAAVkd_header_out@@H_N@Z:PROC ; kd_block::write_packet_header
EXTRN	?write_body_bytes@kd_block@@QAEXPAVkdu_output@@@Z:PROC ; kd_block::write_body_bytes
EXTRN	?build_tree@kd_block@@SAPAV1@Ukdu_coords@@AAPAE@Z:PROC ; kd_block::build_tree
EXTRN	?reset_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z:PROC ; kd_block::reset_output_tree
EXTRN	?save_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z:PROC ; kd_block::save_output_tree
EXTRN	?restore_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z:PROC ; kd_block::restore_output_tree
EXTRN	?reconcile_stats@kd_thread_env@@QAEXXZ:PROC	; kd_thread_env::reconcile_stats
EXTRN	?flush@kd_thread_env@@QAEX_N@Z:PROC		; kd_thread_env::flush
EXTRN	?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z:PROC ; kd_create_dwt_description
EXTRN	??_Ekd_dummy_target@@UAEPAXI@Z:PROC		; kd_dummy_target::`vector deleting destructor'
EXTRN	@__security_check_cookie@4:PROC
EXTRN	__CxxThrowException@8:PROC
EXTRN	___CxxFrameHandler3:PROC
EXTRN	__allmul:PROC
EXTRN	__allshr:PROC
EXTRN	__dtol3:PROC
EXTRN	__ftol2_sse:PROC
EXTRN	__libm_sse2_sqrt_precise:PROC
EXTRN	__ltod3:PROC
EXTRN	_floor:PROC
EXTRN	_memset:PROC
EXTRN	??_7type_info@@6B@:QWORD			; type_info::`vftable'
EXTRN	___security_cookie:DWORD
EXTRN	__fltused:DWORD
;	COMDAT ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA
_BSS	SEGMENT
?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA DQ 01H DUP (?) ; `__local_stdio_printf_options'::`2'::_OptionsStorage
_BSS	ENDS
;	COMDAT __xmm@3fe051d7e177e3e53fff731d2e0e3046
CONST	SEGMENT
__xmm@3fe051d7e177e3e53fff731d2e0e3046 DB 'F0', 0eH, '.', 01dH, 's', 0ffH
	DB	'?', 0e5H, 0e3H, 'w', 0e1H, 0d7H, 'Q', 0e0H, '?'
CONST	ENDS
;	COMDAT __xmm@3fbe516a0eeb824c0000000000000000
CONST	SEGMENT
__xmm@3fbe516a0eeb824c0000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 'L', 082H, 0ebH, 0eH, 'jQ', 0beH, '?'
CONST	ENDS
;	COMDAT __real@41d0000000000000
CONST	SEGMENT
__real@41d0000000000000 DQ 041d0000000000000r	; 1.07374e+09
CONST	ENDS
;	COMDAT __real@40091eafee6fb4c4
CONST	SEGMENT
__real@40091eafee6fb4c4 DQ 040091eafee6fb4c4r	; 3.13998
CONST	ENDS
;	COMDAT __real@4000000000000000
CONST	SEGMENT
__real@4000000000000000 DQ 04000000000000000r	; 2
CONST	ENDS
;	COMDAT __real@40000000
CONST	SEGMENT
__real@40000000 DD 040000000r			; 2
CONST	ENDS
;	COMDAT __real@3ff0000000000000
CONST	SEGMENT
__real@3ff0000000000000 DQ 03ff0000000000000r	; 1
CONST	ENDS
;	COMDAT __real@3fe2000000000000
CONST	SEGMENT
__real@3fe2000000000000 DQ 03fe2000000000000r	; 0.5625
CONST	ENDS
;	COMDAT __real@3fe0000000000000
CONST	SEGMENT
__real@3fe0000000000000 DQ 03fe0000000000000r	; 0.5
CONST	ENDS
;	COMDAT __real@3fb0000000000000
CONST	SEGMENT
__real@3fb0000000000000 DQ 03fb0000000000000r	; 0.0625
CONST	ENDS
;	COMDAT __real@3f800000
CONST	SEGMENT
__real@3f800000 DD 03f800000r			; 1
CONST	ENDS
;	COMDAT __real@3f1a36e2eb1c432d
CONST	SEGMENT
__real@3f1a36e2eb1c432d DQ 03f1a36e2eb1c432dr	; 0.0001
CONST	ENDS
;	COMDAT __real@0000000000000000
CONST	SEGMENT
__real@0000000000000000 DQ 00000000000000000r	; 0
CONST	ENDS
;	COMDAT __real@00000000
CONST	SEGMENT
__real@00000000 DD 000000000r			; 0
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_dummy_target@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_dummy_target@@8 DD FLAT:??_R0?AVkd_dummy_target@@@8 ; kd_dummy_target::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_dummy_target@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_dummy_target@@8
rdata$r	SEGMENT
??_R2kd_dummy_target@@8 DD FLAT:??_R1A@?0A@EA@kd_dummy_target@@8 ; kd_dummy_target::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kdu_output@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_dummy_target@@8
rdata$r	SEGMENT
??_R3kd_dummy_target@@8 DD 00H				; kd_dummy_target::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kd_dummy_target@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_dummy_target@@@8
data$r	SEGMENT
??_R0?AVkd_dummy_target@@@8 DD FLAT:??_7type_info@@6B@	; kd_dummy_target `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_dummy_target@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_dummy_target@@6B@
rdata$r	SEGMENT
??_R4kd_dummy_target@@6B@ DD 00H			; kd_dummy_target::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_dummy_target@@@8
	DD	FLAT:??_R3kd_dummy_target@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_pph_input@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_pph_input@@8 DD FLAT:??_R0?AVkd_pph_input@@@8 ; kd_pph_input::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_pph_input@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_pph_input@@8
rdata$r	SEGMENT
??_R2kd_pph_input@@8 DD FLAT:??_R1A@?0A@EA@kd_pph_input@@8 ; kd_pph_input::`RTTI Base Class Array'
	DD	FLAT:??_R1A@?0A@EA@kd_input@@8
rdata$r	ENDS
;	COMDAT ??_R3kd_pph_input@@8
rdata$r	SEGMENT
??_R3kd_pph_input@@8 DD 00H				; kd_pph_input::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	FLAT:??_R2kd_pph_input@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_pph_input@@@8
data$r	SEGMENT
??_R0?AVkd_pph_input@@@8 DD FLAT:??_7type_info@@6B@	; kd_pph_input `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_pph_input@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_pph_input@@6B@
rdata$r	SEGMENT
??_R4kd_pph_input@@6B@ DD 00H				; kd_pph_input::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_pph_input@@@8
	DD	FLAT:??_R3kd_pph_input@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kd_input@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kd_input@@8 DD FLAT:??_R0?AVkd_input@@@8	; kd_input::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kd_input@@8
rdata$r	ENDS
;	COMDAT ??_R2kd_input@@8
rdata$r	SEGMENT
??_R2kd_input@@8 DD FLAT:??_R1A@?0A@EA@kd_input@@8	; kd_input::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kd_input@@8
rdata$r	SEGMENT
??_R3kd_input@@8 DD 00H					; kd_input::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kd_input@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkd_input@@@8
data$r	SEGMENT
??_R0?AVkd_input@@@8 DD FLAT:??_7type_info@@6B@		; kd_input `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkd_input@@', 00H
data$r	ENDS
;	COMDAT ??_R4kd_input@@6B@
rdata$r	SEGMENT
??_R4kd_input@@6B@ DD 00H				; kd_input::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkd_input@@@8
	DD	FLAT:??_R3kd_input@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@kdu_output@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@kdu_output@@8 DD FLAT:??_R0?AVkdu_output@@@8 ; kdu_output::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	FLAT:??_R3kdu_output@@8
rdata$r	ENDS
;	COMDAT ??_R2kdu_output@@8
rdata$r	SEGMENT
??_R2kdu_output@@8 DD FLAT:??_R1A@?0A@EA@kdu_output@@8	; kdu_output::`RTTI Base Class Array'
rdata$r	ENDS
;	COMDAT ??_R3kdu_output@@8
rdata$r	SEGMENT
??_R3kdu_output@@8 DD 00H				; kdu_output::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	FLAT:??_R2kdu_output@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVkdu_output@@@8
data$r	SEGMENT
??_R0?AVkdu_output@@@8 DD FLAT:??_7type_info@@6B@	; kdu_output `RTTI Type Descriptor'
	DD	00H
	DB	'.?AVkdu_output@@', 00H
data$r	ENDS
;	COMDAT ??_R4kdu_output@@6B@
rdata$r	SEGMENT
??_R4kdu_output@@6B@ DD 00H				; kdu_output::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	FLAT:??_R0?AVkdu_output@@@8
	DD	FLAT:??_R3kdu_output@@8
rdata$r	ENDS
;	COMDAT ??_C@_0FI@JEJCBJLM@Heap?5exhausted?4?5?5Unable?5to?5alloc@
CONST	SEGMENT
??_C@_0FI@JEJCBJLM@Heap?5exhausted?4?5?5Unable?5to?5alloc@ DB 'Heap exhau'
	DB	'sted.  Unable to allocate sufficient memory for code-block st'
	DB	'ate information.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_7kd_dummy_target@@6B@
CONST	SEGMENT
??_7kd_dummy_target@@6B@ DD FLAT:??_R4kd_dummy_target@@6B@ ; kd_dummy_target::`vftable'
	DD	FLAT:??_Ekd_dummy_target@@UAEPAXI@Z
	DD	FLAT:?flush_buf@kd_dummy_target@@MAEXXZ
CONST	ENDS
;	COMDAT ??_C@_0IN@CECCKADH@You?5may?5not?5currently?5flush?5comp@
CONST	SEGMENT
??_C@_0IN@CECCKADH@You?5may?5not?5currently?5flush?5comp@ DB 'You may not'
	DB	' currently flush compressed code-stream data without completi'
	DB	'ng the compression of all code-blocks in all precincts of all'
	DB	' tiles.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BEO@PKHFIGLM@Encountered?5a?5corrupted?5packet?5w@
CONST	SEGMENT
??_C@_0BEO@PKHFIGLM@Encountered?5a?5corrupted?5packet?5w@ DB 'Encountered'
	DB	' a corrupted packet while using packet length information to '
	DB	'access the compressed data source in a random access fashion.'
	DB	'  To process corrupted code-streams in an error resilient man'
	DB	'ner, you must disable seeking on the compressed data source ('
	DB	'i.e., force sequential access) as well as enabling the resili'
	DB	'ent parsing mode.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BIAHNBHE@Packet?5body?5terminated?5with?5an?5F@
CONST	SEGMENT
??_C@_0CD@BIAHNBHE@Packet?5body?5terminated?5with?5an?5F@ DB 'Packet body'
	DB	' terminated with an FF!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FO@KDIMGOKP@?0?5found?5while?5reading?5packet?5bod@
CONST	SEGMENT
??_C@_0FO@KDIMGOKP@?0?5found?5while?5reading?5packet?5bod@ DB ', found wh'
	DB	'ile reading packet body.  Try re-opening the image with the r'
	DB	'esilient mode enabled.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_09LNCLJGMF@?5instead?4?$AA@
CONST	SEGMENT
??_C@_09LNCLJGMF@?5instead?4?$AA@ DB ' instead.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DN@IEKEFHF@Expected?5to?5find?5EPH?5marker?5foll@
CONST	SEGMENT
??_C@_0DN@IEKEFHF@Expected?5to?5find?5EPH?5marker?5foll@ DB 'Expected to '
	DB	'find EPH marker following packet header.  Found ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@NALIOIEH@?0?5found?5while?5reading?5packet?5hea@
CONST	SEGMENT
??_C@_0GA@NALIOIEH@?0?5found?5while?5reading?5packet?5hea@ DB ', found wh'
	DB	'ile reading packet header.  Try re-opening the image with the'
	DB	' resilient mode enabled.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@OOKLLMMG@Illegal?5marker?5code?0?5?$AA@
CONST	SEGMENT
??_C@_0BG@OOKLLMMG@Illegal?5marker?5code?0?5?$AA@ DB 'Illegal marker code'
	DB	', ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BAA@PKDCKLHJ@Illegal?5number?5of?5missing?5MSB?8s?5@
CONST	SEGMENT
??_C@_0BAA@PKDCKLHJ@Illegal?5number?5of?5missing?5MSB?8s?5@ DB 'Illegal n'
	DB	'umber of missing MSB''s signalled in corrupted tag tree.  The'
	DB	' value may not exceed 74 in any practical code-stream or any '
	DB	'legal code-stream which is consistent with profile 0 or profi'
	DB	'le 1.  Try re-opening the image with the resilient mode enabl'
	DB	'ed.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0CBL@LGBHIIBA@Illegal?5inclusion?5tag?5tree?5encou@
CONST	SEGMENT
??_C@_0CBL@LGBHIIBA@Illegal?5inclusion?5tag?5tree?5encou@ DB 'Illegal inc'
	DB	'lusion tag tree encountered while decoding a packet header.  '
	DB	'This problem can arise if empty packets are used (i.e., packe'
	DB	'ts whose first header bit is 0) and the value coded by the in'
	DB	'clusion tag tree in a subsequent packet is not exactly equal '
	DB	'to the index of the quality layer in which each code-block ma'
	DB	'kes its first contribution.  Such an error may arise from a m'
	DB	'is-interpretation of the standard.  The problem may also occu'
	DB	'r as a result of a corrupted code-stream.  Try re-opening the'
	DB	' image with the resilient mode enabled.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BDO@LLBNLAKJ@Packet?5header?5contains?5a?5represe@
CONST	SEGMENT
??_C@_0BDO@LLBNLAKJ@Packet?5header?5contains?5a?5represe@ DB 'Packet head'
	DB	'er contains a representation which is not strictly illegal, b'
	DB	'ut unreasonably large so that it exceeds the dynamic range av'
	DB	'ailable for our internal representation!  The problem is most'
	DB	' likely due to a corrupt or incorrectly constructed code-stre'
	DB	'am.  Try re-opening the image with the resilient mode enabled'
	DB	'.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_R0G@8
data$r	SEGMENT
??_R0G@8 DD	FLAT:??_7type_info@@6B@			; unsigned short `RTTI Type Descriptor'
	DD	00H
	DB	'.G', 00H
data$r	ENDS
;	COMDAT ??_C@_0FB@NMDJGOOL@Exhausted?5PPM?1PPT?5marker?5segment@
CONST	SEGMENT
??_C@_0FB@NMDJGOOL@Exhausted?5PPM?1PPT?5marker?5segment@ DB 'Exhausted PP'
	DB	'M/PPT marker segment data while attempting to parse a packet '
	DB	'header!', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HMCGKOMP@?7Illegal?5marker?5code?5is?5?$AA@
CONST	SEGMENT
??_C@_0BJ@HMCGKOMP@?7Illegal?5marker?5code?5is?5?$AA@ DB 09H, 'Illegal ma'
	DB	'rker code is ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@LOABHKKD@Illegal?5marker?5code?5found?5while?5@
CONST	SEGMENT
??_C@_0FD@LOABHKKD@Illegal?5marker?5code?5found?5while?5@ DB 'Illegal mar'
	DB	'ker code found while attempting to read a packet from the cod'
	DB	'e-stream!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0EO@IEHAKBJH@Use?5the?5resilient?5option?5if?5you?5@
CONST	SEGMENT
??_C@_0EO@IEHAKBJH@Use?5the?5resilient?5option?5if?5you?5@ DB 'Use the re'
	DB	'silient option if you would like to try to recover from this '
	DB	'error.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_02MIICKFIN@?4?6?$AA@
CONST	SEGMENT
??_C@_02MIICKFIN@?4?6?$AA@ DB '.', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@BNNPLEHB@?0?5but?5expected?5?$AA@
CONST	SEGMENT
??_C@_0BA@BNNPLEHB@?0?5but?5expected?5?$AA@ DB ', but expected ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@NMKGFPMC@?7Found?5sequence?5number?5?$AA@
CONST	SEGMENT
??_C@_0BI@NMKGFPMC@?7Found?5sequence?5number?5?$AA@ DB 09H, 'Found sequen'
	DB	'ce number ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0FK@HALGFJID@Out?9of?9sequence?5SOP?5marker?5found@
CONST	SEGMENT
??_C@_0FK@HALGFJID@Out?9of?9sequence?5SOP?5marker?5found@ DB 'Out-of-sequ'
	DB	'ence SOP marker found while attempting to read a packet from '
	DB	'the code-stream!', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@CJMFIANH@Attempting?5to?5open?5the?5same?5code@
CONST	SEGMENT
??_C@_0ED@CJMFIANH@Attempting?5to?5open?5the?5same?5code@ DB 'Attempting '
	DB	'to open the same code-block more than once for writing!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0NN@MFAEJGKE@You?5are?5permitted?5to?5open?5each?5c@
CONST	SEGMENT
??_C@_0NN@MFAEJGKE@You?5are?5permitted?5to?5open?5each?5c@ DB 'You are pe'
	DB	'rmitted to open each code-block only once from an open tile b'
	DB	'efore closing that tile.  If the codestream object is marked '
	DB	'as persistent, you may re-open code-blocks only after re-open'
	DB	'ing their containing tiles.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0MG@MIKKMPNN@The?5precinct?5you?5are?5trying?5to?5a@
CONST	SEGMENT
??_C@_0MG@MIKKMPNN@The?5precinct?5you?5are?5trying?5to?5a@ DB 'The precin'
	DB	'ct you are trying to access via `kdu_resolution::get_precinct'
	DB	'_packets'' is no longer available, probably because you alrea'
	DB	'dy fully accessed its visible contents, causing it to be recy'
	DB	'cled.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0LI@BAKNOCIL@Calls?5to?5?$GAkdu_resolution?3?3open_p@
CONST	SEGMENT
??_C@_0LI@BAKNOCIL@Calls?5to?5?$GAkdu_resolution?3?3open_p@ DB 'Calls to '
	DB	'`kdu_resolution::open_precinct'' are permitted only with inte'
	DB	'rchange codestream objects (i.e., those which have neither a '
	DB	'compressed data source nor a compressed data target).', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07MIOINIMK@Cdecomp?$AA@
CONST	SEGMENT
??_C@_07MIOINIMK@Cdecomp?$AA@ DB 'Cdecomp', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BCL@NDBOHLBO@Attempting?5to?5access?5a?5resolutio@
CONST	SEGMENT
??_C@_0BCL@NDBOHLBO@Attempting?5to?5access?5a?5resolutio@ DB 'Attempting '
	DB	'to access a resolution level within some tile-component, whil'
	DB	'e the codestream is in a geometrically flipped viewing condit'
	DB	'ion, where a packet wavelet transform has been found to be in'
	DB	'compatible with flipping.  This condition can be identified b'
	DB	'y calling `kdu_codestream::can_flip'' first.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0NP@CFEPKMLA@Attempting?5to?5access?5a?5non?9exist@
CONST	SEGMENT
??_C@_0NP@CFEPKMLA@Attempting?5to?5access?5a?5non?9exist@ DB 'Attempting '
	DB	'to access a non-existent resolution level within some tile-co'
	DB	'mponent.  Problem almost certainly caused by trying to discar'
	DB	'd more resolution levels than the number of DWT levels used t'
	DB	'o compress a tile-component.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@
CONST	SEGMENT
??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@ DB 'Mtriang_coeffs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
CONST	SEGMENT
??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@ DB 'Mmatrix_coeffs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@DIALIICI@Mvector_coeffs?$AA@
CONST	SEGMENT
??_C@_0P@DIALIICI@Mvector_coeffs?$AA@ DB 'Mvector_coeffs', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0OJ@JNMDPNHM@Length?5of?5current?5tile?9part?5exce@
CONST	SEGMENT
??_C@_0OJ@JNMDPNHM@Length?5of?5current?5tile?9part?5exce@ DB 'Length of c'
	DB	'urrent tile-part exceeds the maximum value which can be repre'
	DB	'sented by the 32-bit length field in the SOT marker!  You wil'
	DB	'l have to split the code-stream into smaller tile-parts -- se'
	DB	'e the "ORGtparts" parameter attribute.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0NP@BHJNFIFJ@Cannot?5satisfy?5the?5request?5to?5ge@
CONST	SEGMENT
??_C@_0NP@BHJNFIFJ@Cannot?5satisfy?5the?5request?5to?5ge@ DB 'Cannot sati'
	DB	'sfy the request to generate PLT marker segments!  There are s'
	DB	'o many packets in one tile-part that it is beyond the capacit'
	DB	'y of the maximum 256 marker segments to represent length info'
	DB	'rmation for all tile-parts!!', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0KI@NPIDLLIG@Attempting?5to?5generate?5tile?9part@
CONST	SEGMENT
??_C@_0KI@NPIDLLIG@Attempting?5to?5generate?5tile?9part@ DB 'Attempting t'
	DB	'o generate tile-part data without first determining packet le'
	DB	'ngths.  This may be a consequence of incomplete simulation of'
	DB	' the packet construction process.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0MP@KJDJEMOL@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0MP@KJDJEMOL@Profile?5violation?5detected?5?$CIcode@ DB 'Profile vi'
	DB	'olation detected (code-stream is technically illegal).  In a '
	DB	'Profile-0 code-stream, all first tile-parts of all tiles must'
	DB	' appear first, in exactly the same order as their respective '
	DB	'tile numbers.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0GI@GJEHPDEO@?4?5?5The?5maximum?5number?5of?5tile?9pa@
CONST	SEGMENT
??_C@_0GI@GJEHPDEO@?4?5?5The?5maximum?5number?5of?5tile?9pa@ DB '.  The m'
	DB	'aximum number of tile-parts per tile has been fixed by the `O'
	DB	'RGgen_tlm'' parameter attribute to ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PEIPJIAP@?4?5?5No?5tile?5may?5have?5more?5than?525@
CONST	SEGMENT
??_C@_0CJ@PEIPJIAP@?4?5?5No?5tile?5may?5have?5more?5than?525@ DB '.  No t'
	DB	'ile may have more than 255 parts.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KPHEGGEJ@Too?5many?5tile?9parts?5for?5tile?5?$AA@
CONST	SEGMENT
??_C@_0BO@KPHEGGEJ@Too?5many?5tile?9parts?5for?5tile?5?$AA@ DB 'Too many '
	DB	'tile-parts for tile ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DE@HNLKCMOC@Use?5of?5both?5PPM?5and?5PPT?5marker?5s@
CONST	SEGMENT
??_C@_0DE@HNLKCMOC@Use?5of?5both?5PPM?5and?5PPT?5marker?5s@ DB 'Use of bo'
	DB	'th PPM and PPT marker segments is illegal!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JC@HCNJDFHD@Found?5non?9marker?5code?5while?5look@
CONST	SEGMENT
??_C@_0JC@HCNJDFHD@Found?5non?9marker?5code?5while?5look@ DB 'Found non-m'
	DB	'arker code while looking for SOD marker to terminate a tile-p'
	DB	'art header.  Chances are that a marker segment length field i'
	DB	's incorrect!', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0KL@FMHHAPCD@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0KL@FMHHAPCD@Profile?5violation?5detected?5?$CIcode@ DB 'Profile vi'
	DB	'olation detected (code-stream is technically illegal).  PPT m'
	DB	'arker segments may not appear within a Profile-0 code-stream.'
	DB	'  You should set "Sprofile" to 1 or 2.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_03LFCEPJHK@POC?$AA@
CONST	SEGMENT
??_C@_03LFCEPJHK@POC?$AA@ DB 'POC', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0FD@MEKGJNMP@?5is?5identified?5by?5different?5non?9@
CONST	SEGMENT
??_C@_0FD@MEKGJNMP@?5is?5identified?5by?5different?5non?9@ DB ' is identi'
	DB	'fied by different non-zero values in different SOT markers fo'
	DB	'r the tile!', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CK@JIECJLAN@The?5number?5of?5tile?9parts?5for?5til@
CONST	SEGMENT
??_C@_0CK@JIECJLAN@The?5number?5of?5tile?9parts?5for?5til@ DB 'The number'
	DB	' of tile-parts for tile number ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@LBOIHLHG@?5in?5code?9stream?$CB?$AA@
CONST	SEGMENT
??_C@_0BB@LBOIHLHG@?5in?5code?9stream?$CB?$AA@ DB ' in code-stream!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@BFBKABHP@Missing?5or?5out?9of?9sequence?5tile?9@
CONST	SEGMENT
??_C@_0DH@BFBKABHP@Missing?5or?5out?9of?9sequence?5tile?9@ DB 'Missing or'
	DB	' out-of-sequence tile-parts for tile number ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0IL@OEKPKFDK@Corrupt?5SOT?5marker?5segment?5found@
CONST	SEGMENT
??_C@_0IL@OEKPKFDK@Corrupt?5SOT?5marker?5segment?5found@ DB 'Corrupt SOT '
	DB	'marker segment found in codestream: tile-number lies outside '
	DB	'the range of available tiles derived from the SIZ marker segm'
	DB	'ent.', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@BKLJKNEJ@?7Expected?5SOT?5marker?5and?5got?5?$AA@
CONST	SEGMENT
??_C@_0BO@BKLJKNEJ@?7Expected?5SOT?5marker?5and?5got?5?$AA@ DB 09H, 'Expe'
	DB	'cted SOT marker and got ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@KHMENMGB@Invalid?5marker?5code?5found?5in?5cod@
CONST	SEGMENT
??_C@_0CL@KHMENMGB@Invalid?5marker?5code?5found?5in?5cod@ DB 'Invalid mar'
	DB	'ker code found in code-stream!', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0HP@MELIFPKI@Found?5non?9marker?5code?5while?5pars@
CONST	SEGMENT
??_C@_0HP@MELIFPKI@Found?5non?9marker?5code?5while?5pars@ DB 'Found non-m'
	DB	'arker code while parsing tile header marker segments.  Chance'
	DB	's are that a marker segment length field is incorrect!', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@CBFAGHCH@You?5cannot?5use?5PPM?5or?5PPT?5marker@
CONST	SEGMENT
??_C@_0GH@CBFAGHCH@You?5cannot?5use?5PPM?5or?5PPT?5marker@ DB 'You cannot'
	DB	' use PPM or PPT marker segments (packed packet headers) with '
	DB	'cached compressed data sources.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@CKMBKEOA@You?5must?5close?5a?5tile?5before?5you@
CONST	SEGMENT
??_C@_0DB@CKMBKEOA@You?5must?5close?5a?5tile?5before?5you@ DB 'You must c'
	DB	'lose a tile before you can re-open it.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07HDMBGKJA@QCD?3RGN?$AA@
CONST	SEGMENT
??_C@_07HDMBGKJA@QCD?3RGN?$AA@ DB 'QCD:RGN', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@GCDNIPCG@Illegal?5colour?5transform?5specifi@
CONST	SEGMENT
??_C@_0GC@GCDNIPCG@Illegal?5colour?5transform?5specifi@ DB 'Illegal colou'
	DB	'r transform specified when image has insufficient or incompat'
	DB	'ible colour components.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0KN@HAEBDHLJ@Precinct?5partition?5dimensions?5to@
CONST	SEGMENT
??_C@_0KN@HAEBDHLJ@Precinct?5partition?5dimensions?5to@ DB 'Precinct part'
	DB	'ition dimensions too small!  Must not be so small that the in'
	DB	'duced code-block partition becomes smaller than 1 sample wide'
	DB	' or 1 sample high within any subband.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@GLALLHKC@Cband_weights?$AA@
CONST	SEGMENT
??_C@_0O@GLALLHKC@Cband_weights?$AA@ DB 'Cband_weights', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0JM@NAEKEAHJ@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0JM@NAEKEAHJ@Profile?5violation?5detected?5?$CIcode@ DB 'Profile vi'
	DB	'olation detected (code-stream is technically illegal).  The "'
	DB	'Rshift" attribute may not exceed 37, except in Profile-2 (the'
	DB	' unrestricted profile).', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06LDAKCIBF@Rshift?$AA@
CONST	SEGMENT
??_C@_06LDAKCIBF@Rshift?$AA@ DB 'Rshift', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07MDGMFIIN@Rweight?$AA@
CONST	SEGMENT
??_C@_07MDGMFIIN@Rweight?$AA@ DB 'Rweight', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06BGIMBACE@Qguard?$AA@
CONST	SEGMENT
??_C@_06BGIMBACE@Qguard?$AA@ DB 'Qguard', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@
CONST	SEGMENT
??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@ DB 'Qabs_ranges', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@HICBBPMC@Clev_weights?$AA@
CONST	SEGMENT
??_C@_0N@HICBBPMC@Clev_weights?$AA@ DB 'Clev_weights', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0MJ@MHJOJOLI@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0MJ@MHJOJOLI@Profile?5violation?5detected?5?$CIcode@ DB 'Profile vi'
	DB	'olation detected (code-stream is technically illegal).  Profi'
	DB	'le-0 code-streams may have multiple precincts only in those t'
	DB	'ile-component resolutions whose dimensions are greater than 1'
	DB	'28x128.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBP@FFHCNMHP@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0BBP@FFHCNMHP@Profile?5violation?5detected?5?$CIcode@ DB 'Profile v'
	DB	'iolation detected (code-stream is technically illegal).  Prof'
	DB	'ile-0 and Profile-1 code-streams must have sufficient DWT lev'
	DB	'els to permit extraction of a low resolution image which is n'
	DB	'o larger than 128x128.   Try setting a larger value for "Clev'
	DB	'els" or else set "Sprofile" to 2.', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BBK@KIFKIPEK@Tile?9component?9resolution?5encoun@
CONST	SEGMENT
??_C@_0BBK@KIFKIPEK@Tile?9component?9resolution?5encoun@ DB 'Tile-compone'
	DB	'nt-resolution encountered in the codestream contains way too '
	DB	'many precincts!!!  The value calculated from codestream param'
	DB	'eters exceeds (2^30) which means that even the storage requir'
	DB	'ed to keep a status pointer for each precinct will exceed the'
	DB	' memory on most machines.', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@KGBLICHL@Cprecincts?$AA@
CONST	SEGMENT
??_C@_0L@KGBLICHL@Cprecincts?$AA@ DB 'Cprecincts', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0PN@ECKJOGL@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0PN@ECKJOGL@Profile?5violation?5detected?5?$CIcode@ DB 'Profile vio'
	DB	'lation detected (code-stream is technically illegal).  Part-1'
	DB	' code-streams must have their coding origin (anchor point) se'
	DB	't to 0.  A non-zero coding origin is legal only in JPEG2000 P'
	DB	'art 2; set `Sprofile=PART2'' to avoid this warning message.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0KN@KMCHIBHI@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0KN@KMCHIBHI@Profile?5violation?5detected?5?$CIcode@ DB 'Profile vi'
	DB	'olation detected (code-stream is technically illegal).  Profi'
	DB	'le-1 code-streams may not have code-block dimensions larger t'
	DB	'han 64.  You should set "Sprofile" to 2.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0MC@OOKHAIOM@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0MC@OOKHAIOM@Profile?5violation?5detected?5?$CIcode@ DB 'Profile vi'
	DB	'olation detected (code-stream is technically illegal).  Profi'
	DB	'le-0 code-streams may not use the BYPASS, RESET or CAUSAL blo'
	DB	'ck coder mode switches.  You should set "Sprofile" to 1 or 2.'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0ML@FMBEAHIM@Profile?5violation?5detected?5?$CIcode@
CONST	SEGMENT
??_C@_0ML@FMBEAHIM@Profile?5violation?5detected?5?$CIcode@ DB 'Profile vi'
	DB	'olation detected (code-stream is technically illegal).  Profi'
	DB	'le-0 code-streams must have nominally square code-block dimen'
	DB	'sions, measuring 32x32 or 64x64.  You should set "Sprofile" t'
	DB	'o 1 or 2.', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
CONST	SEGMENT
??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@ DB 'Kakadu Core Warning'
	DB	':', 0aH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07HDHNGJDI@Cweight?$AA@
CONST	SEGMENT
??_C@_07HDHNGJDI@Cweight?$AA@ DB 'Cweight', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KGEEGGHK@Rlevels?$AA@
CONST	SEGMENT
??_C@_07KGEEGGHK@Rlevels?$AA@ DB 'Rlevels', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BHA@JBHJNMJO@Tile?9components?5which?5are?5compre@
CONST	SEGMENT
??_C@_0BHA@JBHJNMJO@Tile?9components?5which?5are?5compre@ DB 'Tile-compon'
	DB	'ents which are compressed using the irreversible processing p'
	DB	'ath must have quantization parameters specified in the QCD/QC'
	DB	'C marker segments, either explicitly, or through implicit der'
	DB	'ivation from the quantization parameters for the LL subband, '
	DB	'as explained in the JPEG2000 standard, ISO/IEC 15444-1.  The '
	DB	'present set of code-stream parameters is not legal.', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
CONST	SEGMENT
??_C@_0L@ELEFPJIC@Qabs_steps?$AA@ DB 'Qabs_steps', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08CCOBJCLJ@Qderived?$AA@
CONST	SEGMENT
??_C@_08CCOBJCLJ@Qderived?$AA@ DB 'Qderived', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_04HAOFMIPN@Catk?$AA@
CONST	SEGMENT
??_C@_04HAOFMIPN@Catk?$AA@ DB 'Catk', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06EGDCPANH@Cmodes?$AA@
CONST	SEGMENT
??_C@_06EGDCPANH@Cmodes?$AA@ DB 'Cmodes', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HAGFJFNL@Cblk?$AA@
CONST	SEGMENT
??_C@_04HAGFJFNL@Cblk?$AA@ DB 'Cblk', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@
CONST	SEGMENT
??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@ DB 'Cuse_precincts', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_08IDCJHBJK@Ckernels?$AA@
CONST	SEGMENT
??_C@_08IDCJHBJK@Ckernels?$AA@ DB 'Ckernels', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@ODOOFFGJ@Creversible?$AA@
CONST	SEGMENT
??_C@_0M@ODOOFFGJ@Creversible?$AA@ DB 'Creversible', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BGFFFHMP@Clevels?$AA@
CONST	SEGMENT
??_C@_07BGFFFHMP@Clevels?$AA@ DB 'Clevels', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DMGGEJHL@ORGgen_plt?$AA@
CONST	SEGMENT
??_C@_0L@DMGGEJHL@ORGgen_plt?$AA@ DB 'ORGgen_plt', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09CNLDEMAK@ORGtparts?$AA@
CONST	SEGMENT
??_C@_09CNLDEMAK@ORGtparts?$AA@ DB 'ORGtparts', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@HKNEBDCB@Creslengths?$AA@
CONST	SEGMENT
??_C@_0M@HKNEBDCB@Creslengths?$AA@ DB 'Creslengths', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_07BJCMAMHC@Clayers?$AA@
CONST	SEGMENT
??_C@_07BJCMAMHC@Clayers?$AA@ DB 'Clayers', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
CONST	SEGMENT
??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@ DB 'Calign_blk_last', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_04DEPIIIHA@Cycc?$AA@
CONST	SEGMENT
??_C@_04DEPIIIHA@Cycc?$AA@ DB 'Cycc', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_08NAIOMJOM@Cuse_eph?$AA@
CONST	SEGMENT
??_C@_08NAIOMJOM@Cuse_eph?$AA@ DB 'Cuse_eph', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_08DAJNLNLL@Cuse_sop?$AA@
CONST	SEGMENT
??_C@_08DAJNLNLL@Cuse_sop?$AA@ DB 'Cuse_sop', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_03MNMMELJE@ORG?$AA@
CONST	SEGMENT
??_C@_03MNMMELJE@ORG?$AA@ DB 'ORG', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03KEJABOAE@RGN?$AA@
CONST	SEGMENT
??_C@_03KEJABOAE@RGN?$AA@ DB 'RGN', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03ELMDPBLM@QCD?$AA@
CONST	SEGMENT
??_C@_03ELMDPBLM@QCD?$AA@ DB 'QCD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03LIMJJHMM@COD?$AA@
CONST	SEGMENT
??_C@_03LIMJJHMM@COD?$AA@ DB 'COD', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NDKNKOCB@?3?6?$AA@
CONST	SEGMENT
??_C@_02NDKNKOCB@?3?6?$AA@ DB ':', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@MCFNCJCD@?6?$DO?$DO?5New?5attributes?5for?5tile?5?$AA@
CONST	SEGMENT
??_C@_0BN@MCFNCJCD@?6?$DO?$DO?5New?5attributes?5for?5tile?5?$AA@ DB 0aH, '>'
	DB	'> New attributes for tile ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GG@KMAHIAKO@Coding?5partitions?5?$CInamely?0?5code?9@
CONST	SEGMENT
??_C@_0GG@KMAHIAKO@Coding?5partitions?5?$CInamely?0?5code?9@ DB 'Coding p'
	DB	'artitions (namely, code-block and precinct partitions) must h'
	DB	'ave exact power-of-2 dimensions!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GL@JBAAPDCE@Coding?5partitions?5?$CIcode?9blocks?5a@
CONST	SEGMENT
??_C@_0GL@JBAAPDCE@Coding?5partitions?5?$CIcode?9blocks?5a@ DB 'Coding pa'
	DB	'rtitions (code-blocks and precinct partitions) must have orig'
	DB	'in coordinates equal to 1 or 0 only!', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
CONST	SEGMENT
??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@ DB 'Kakadu Core Error:', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT __CT??_R0PAVkd_header_in@@@84
xdata$x	SEGMENT
__CT??_R0PAVkd_header_in@@@84 DD 01H
	DD	FLAT:??_R0PAVkd_header_in@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAVkd_header_in@@@8
data$r	SEGMENT
??_R0PAVkd_header_in@@@8 DD FLAT:??_7type_info@@6B@	; kd_header_in * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAVkd_header_in@@', 00H
data$r	ENDS
;	COMDAT __CTA2PAVkd_header_in@@
xdata$x	SEGMENT
__CTA2PAVkd_header_in@@ DD 02H
	DD	FLAT:__CT??_R0PAVkd_header_in@@@84
	DD	FLAT:__CT??_R0PAX@84
xdata$x	ENDS
;	COMDAT __TI2PAVkd_header_in@@
xdata$x	SEGMENT
__TI2PAVkd_header_in@@ DD 00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2PAVkd_header_in@@
xdata$x	ENDS
;	COMDAT ??_7kd_pph_input@@6B@
CONST	SEGMENT
??_7kd_pph_input@@6B@ DD FLAT:??_R4kd_pph_input@@6B@	; kd_pph_input::`vftable'
	DD	FLAT:??_Ekd_pph_input@@UAEPAXI@Z
	DD	FLAT:?ignore@kd_input@@UAE_J_J@Z
	DD	FLAT:?load_buf@kd_pph_input@@MAE_NXZ
CONST	ENDS
;	COMDAT ??_7kd_input@@6B@
CONST	SEGMENT
??_7kd_input@@6B@ DD FLAT:??_R4kd_input@@6B@		; kd_input::`vftable'
	DD	FLAT:??_Ekd_input@@UAEPAXI@Z
	DD	FLAT:?ignore@kd_input@@UAE_J_J@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT __CT??_R0H@84
xdata$x	SEGMENT
__CT??_R0H@84 DD 01H
	DD	FLAT:??_R0H@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0H@8
data$r	SEGMENT
??_R0H@8 DD	FLAT:??_7type_info@@6B@			; int `RTTI Type Descriptor'
	DD	00H
	DB	'.H', 00H
data$r	ENDS
;	COMDAT __CTA1H
xdata$x	SEGMENT
__CTA1H	DD	01H
	DD	FLAT:__CT??_R0H@84
xdata$x	ENDS
;	COMDAT __TI1H
xdata$x	SEGMENT
__TI1H	DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA1H
xdata$x	ENDS
;	COMDAT ??_7kdu_output@@6B@
CONST	SEGMENT
??_7kdu_output@@6B@ DD FLAT:??_R4kdu_output@@6B@	; kdu_output::`vftable'
	DD	FLAT:??_Ekdu_output@@UAEPAXI@Z
	DD	FLAT:__purecall
CONST	ENDS
;	COMDAT __CT??_R0PAX@84
xdata$x	SEGMENT
__CT??_R0PAX@84 DD 01H
	DD	FLAT:??_R0PAX@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAX@8
data$r	SEGMENT
??_R0PAX@8 DD	FLAT:??_7type_info@@6B@			; void * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAX', 00H
data$r	ENDS
;	COMDAT __CT??_R0PAE@84
xdata$x	SEGMENT
__CT??_R0PAE@84 DD 01H
	DD	FLAT:??_R0PAE@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	04H
	DD	00H
xdata$x	ENDS
;	COMDAT ??_R0PAE@8
data$r	SEGMENT
??_R0PAE@8 DD	FLAT:??_7type_info@@6B@			; unsigned char * `RTTI Type Descriptor'
	DD	00H
	DB	'.PAE', 00H
data$r	ENDS
;	COMDAT __CTA2PAE
xdata$x	SEGMENT
__CTA2PAE DD	02H
	DD	FLAT:__CT??_R0PAE@84
	DD	FLAT:__CT??_R0PAX@84
xdata$x	ENDS
;	COMDAT __TI2PAE
xdata$x	SEGMENT
__TI2PAE DD	00H
	DD	00H
	DD	00H
	DD	FLAT:__CTA2PAE
xdata$x	ENDS
;	COMDAT ??_C@_02DPKJAMEF@?$CFd?$AA@
CONST	SEGMENT
??_C@_02DPKJAMEF@?$CFd?$AA@ DB '%d', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_02NJNOFBBI@?$CFx?$AA@
CONST	SEGMENT
??_C@_02NJNOFBBI@?$CFx?$AA@ DB '%x', 00H		; `string'
CONST	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?check_coding_partition@@YAXUkdu_dims@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?check_coding_partition@@YAXUkdu_dims@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?check_coding_partition@@YAXUkdu_dims@@@Z$1
__ehfuncinfo$?check_coding_partition@@YAXUkdu_dims@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?check_coding_partition@@YAXUkdu_dims@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?augment_free_list@kd_precinct_size_class@@AAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?augment_free_list@kd_precinct_size_class@@AAEXXZ$0
__ehfuncinfo$?augment_free_list@kd_precinct_size_class@@AAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?augment_free_list@kd_precinct_size_class@@AAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?handle_corrupt_packet@kd_precinct@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?handle_corrupt_packet@kd_precinct@@AAE_NXZ$0
__ehfuncinfo$?handle_corrupt_packet@kd_precinct@@AAE_NXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?handle_corrupt_packet@kd_precinct@@AAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__catchsym$?read_packet@kd_precinct@@AAE_NXZ$17 DD 00H
	DD	FLAT:??_R0G@8
	DD	0ffffffb8H
	DD	FLAT:__catch$?read_packet@kd_precinct@@AAE_NXZ$3
__catchsym$?read_packet@kd_precinct@@AAE_NXZ$16 DD 00H
	DD	FLAT:??_R0PAVkd_header_in@@@8
	DD	00H
	DD	FLAT:__catch$?read_packet@kd_precinct@@AAE_NXZ$0
	DD	00H
	DD	FLAT:??_R0G@8
	DD	0ffffffbcH
	DD	FLAT:__catch$?read_packet@kd_precinct@@AAE_NXZ$1
__ehfuncinfo$?read_packet@kd_precinct@@AAE_NXZ DD 019930522H
	DD	0fH
	DD	FLAT:__unwindtable$?read_packet@kd_precinct@@AAE_NXZ
	DD	02H
	DD	FLAT:__tryblocktable$?read_packet@kd_precinct@@AAE_NXZ
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__tryblocktable$?read_packet@kd_precinct@@AAE_NXZ DD 02H
	DD	02H
	DD	08H
	DD	02H
	DD	FLAT:__catchsym$?read_packet@kd_precinct@@AAE_NXZ$16
	DD	0bH
	DD	0bH
	DD	0dH
	DD	01H
	DD	FLAT:__catchsym$?read_packet@kd_precinct@@AAE_NXZ$17
__unwindtable$?read_packet@kd_precinct@@AAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$6
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	03H
	DD	FLAT:__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$7
	DD	03H
	DD	FLAT:__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$8
	DD	03H
	DD	FLAT:__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$9
	DD	03H
	DD	FLAT:__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$10
	DD	03H
	DD	FLAT:__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$11
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$12
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$13
	DD	0ffffffffH
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	0cH
	DD	FLAT:__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$15
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?simulate_packet@kd_precinct@@QAE_JAA_JHG_N1_J1@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?simulate_packet@kd_precinct@@QAE_JAA_JHG_N1_J1@Z$0
__ehfuncinfo$?simulate_packet@kd_precinct@@QAE_JAA_JHG_N1_J1@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?simulate_packet@kd_precinct@@QAE_JAA_JHG_N1_J1@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_Ekd_resolution@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1kd_resolution@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1kd_resolution@@QAE@XZ$0
	DD	00H
	DD	00H
__ehfuncinfo$??1kd_resolution@@QAE@XZ DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??1kd_resolution@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Ekd_precinct_ref@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Ekd_precinct_ref@@QAEPAXI@Z$0
__ehfuncinfo$??_Ekd_precinct_ref@@QAEPAXI@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??_Ekd_precinct_ref@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1kd_precinct_ref@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_Ekd_tile_comp@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1kd_tile_comp@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1kd_tile_comp@@QAE@XZ$0
__ehfuncinfo$??1kd_tile_comp@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1kd_tile_comp@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?generate_tile_part@kd_tile@@QAE_JHQAG@Z DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$?generate_tile_part@kd_tile@@QAE_JHQAG@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?generate_tile_part@kd_tile@@QAE_JHQAG@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?generate_tile_part@kd_tile@@QAE_JHQAG@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?generate_tile_part@kd_tile@@QAE_JHQAG@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?generate_tile_part@kd_tile@@QAE_JHQAG@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?generate_tile_part@kd_tile@@QAE_JHQAG@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?generate_tile_part@kd_tile@@QAE_JHQAG@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?generate_tile_part@kd_tile@@QAE_JHQAG@Z$5
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?read_tile_part_header@kd_tile@@QAE_NXZ DD 019930522H
	DD	09H
	DD	FLAT:__unwindtable$?read_tile_part_header@kd_tile@@QAE_NXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?read_tile_part_header@kd_tile@@QAE_NXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$8
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$9
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?open@kd_tile@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open@kd_tile@@QAEXXZ$0
__ehfuncinfo$?open@kd_tile@@QAEXXZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?open@kd_tile@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?reinitialize@kd_tile@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?reinitialize@kd_tile@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?reinitialize@kd_tile@@QAEXXZ$1
	DD	01H
	DD	FLAT:__unwindfunclet$?reinitialize@kd_tile@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?reinitialize@kd_tile@@QAEXXZ$3
__ehfuncinfo$?reinitialize@kd_tile@@QAEXXZ DD 019930522H
	DD	04H
	DD	FLAT:__unwindtable$?reinitialize@kd_tile@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z DD 019930522H
	DD	0dH
	DD	FLAT:__unwindtable$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$7
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$8
	DD	01H
	DD	FLAT:__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$9
	DD	02H
	DD	FLAT:__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$10
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$11
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$2
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$4
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$5
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$6
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$?initialize@kd_tile@@QAEXXZ DD 019930522H
	DD	012H
	DD	FLAT:__unwindtable$?initialize@kd_tile@@QAEXXZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
__unwindtable$?initialize@kd_tile@@QAEXXZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$2
	DD	02H
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$3
	DD	02H
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$4
	DD	02H
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$5
	DD	02H
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$6
	DD	02H
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$7
	DD	02H
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$8
	DD	02H
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$9
	DD	02H
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$10
	DD	02H
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$11
	DD	02H
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$12
	DD	02H
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$13
	DD	02H
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$14
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$17
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$15
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?initialize@kd_tile@@QAEXXZ$16
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1kd_tile@@QAE@XZ DD 019930522H
	DD	06H
	DD	FLAT:__unwindtable$??1kd_tile@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
__unwindtable$??1kd_tile@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1kd_tile@@QAE@XZ$1
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1kd_tile@@QAE@XZ$3
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1kd_tile@@QAE@XZ$4
	DD	02H
	DD	FLAT:__unwindfunclet$??1kd_tile@@QAE@XZ$5
	DD	03H
	DD	FLAT:__unwindfunclet$??1kd_tile@@QAE@XZ$6
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$??1kd_tile@@QAE@XZ$7
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??_Gkd_mct_stage@@QAEPAXI@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??_Gkd_mct_stage@@QAEPAXI@Z$0
	DD	00H
	DD	FLAT:__unwindfunclet$??_Gkd_mct_stage@@QAEPAXI@Z$1
__ehfuncinfo$??_Gkd_mct_stage@@QAEPAXI@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$??_Gkd_mct_stage@@QAEPAXI@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1kd_mct_stage@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1kd_mct_stage@@QAE@XZ$0
__ehfuncinfo$??1kd_mct_stage@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1kd_mct_stage@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_Ekd_mct_block@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$??1kd_mct_block@@QAE@XZ DD 0ffffffffH
	DD	FLAT:__unwindfunclet$??1kd_mct_block@@QAE@XZ$0
__ehfuncinfo$??1kd_mct_block@@QAE@XZ DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$??1kd_mct_block@@QAE@XZ
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_Ekd_mct_ss_model@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??_Ekd_reslength_checker@@QAEPAXI@Z DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1kd_precinct_pointer_server@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?get_packets@kdu_precinct@@QAE_NHHAAH0PAVkdu_output@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?get_packets@kdu_precinct@@QAE_NHHAAH0PAVkdu_output@@@Z$0
__ehfuncinfo$?get_packets@kdu_precinct@@QAE_NHHAAH0PAVkdu_output@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?get_packets@kdu_precinct@@QAE_NHHAAH0PAVkdu_output@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?open_block@kdu_precinct@@QAEPAUkdu_block@@HUkdu_coords@@PAVkdu_thread_env@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open_block@kdu_precinct@@QAEPAUkdu_block@@HUkdu_coords@@PAVkdu_thread_env@@@Z$0
__ehfuncinfo$?open_block@kdu_precinct@@QAEPAUkdu_block@@HUkdu_coords@@PAVkdu_thread_env@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?open_block@kdu_precinct@@QAEPAUkdu_block@@HUkdu_coords@@PAVkdu_thread_env@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z$1
__ehfuncinfo$?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?get_precinct_packets@kdu_resolution@@QAEHUkdu_coords@@PAVkdu_thread_env@@_N@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?get_precinct_packets@kdu_resolution@@QAEHUkdu_coords@@PAVkdu_thread_env@@_N@Z$0
__ehfuncinfo$?get_precinct_packets@kdu_resolution@@QAEHUkdu_coords@@PAVkdu_thread_env@@_N@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?get_precinct_packets@kdu_resolution@@QAEHUkdu_coords@@PAVkdu_thread_env@@_N@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?open_precinct@kdu_resolution@@QAE?AVkdu_precinct@@Ukdu_coords@@@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?open_precinct@kdu_resolution@@QAE?AVkdu_precinct@@Ukdu_coords@@@Z$0
__ehfuncinfo$?open_precinct@kdu_resolution@@QAE?AVkdu_precinct@@Ukdu_coords@@@Z DD 019930522H
	DD	01H
	DD	FLAT:__unwindtable$?open_precinct@kdu_resolution@@QAE?AVkdu_precinct@@Ukdu_coords@@@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__unwindtable$?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@H@Z DD 0ffffffffH
	DD	FLAT:__unwindfunclet$?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@H@Z$0
	DD	0ffffffffH
	DD	FLAT:__unwindfunclet$?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@H@Z$1
__ehfuncinfo$?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@H@Z DD 019930522H
	DD	02H
	DD	FLAT:__unwindtable$?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@H@Z
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	01H
xdata$x	ENDS
;	COMDAT xdata$x
xdata$x	SEGMENT
__ehfuncinfo$??1kdu_kernels@@QAE@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	2 DUP(00H)
	DD	2 DUP(00H)
	DD	00H
	DD	05H
xdata$x	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ??_Gkd_dummy_target@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_dummy_target@@UAEPAXI@Z PROC			; kd_dummy_target::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 132  :     virtual ~kdu_output() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kdu_output@@6B@
	je	SHORT $LN10@scalar
	push	524					; 0000020cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN10@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_dummy_target@@UAEPAXI@Z ENDP			; kd_dummy_target::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ??1kd_dummy_target@@UAE@XZ
_TEXT	SEGMENT
??1kd_dummy_target@@UAE@XZ PROC				; kd_dummy_target::~kd_dummy_target, COMDAT
; _this$ = ecx

; 132  :     virtual ~kdu_output() { return; }

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_output@@6B@
	ret	0
??1kd_dummy_target@@UAE@XZ ENDP				; kd_dummy_target::~kd_dummy_target
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ??0kd_dummy_target@@QAE@XZ
_TEXT	SEGMENT
_this$ = -4						; size = 4
??0kd_dummy_target@@QAE@XZ PROC				; kd_dummy_target::kd_dummy_target, COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	ecx

; 131  :       { next_buf = buffer; end_buf = buffer+KDU_OBUF_SIZE; }

	lea	edx, DWORD PTR [ecx+516]
	mov	DWORD PTR _this$[ebp], ecx
	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+520], edx
	mov	DWORD PTR [edx], eax
	mov	eax, ecx
	mov	DWORD PTR [ecx], OFFSET ??_7kd_dummy_target@@6B@
	mov	esp, ebp
	pop	ebp
	ret	0
??0kd_dummy_target@@QAE@XZ ENDP				; kd_dummy_target::kd_dummy_target
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?flush_buf@kd_dummy_target@@MAEXXZ
_TEXT	SEGMENT
?flush_buf@kd_dummy_target@@MAEXXZ PROC			; kd_dummy_target::flush_buf, COMDAT
; _this$ = ecx

; 6252 :       virtual void flush_buf() { next_buf = buffer; }

	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+516], eax
	ret	0
?flush_buf@kd_dummy_target@@MAEXXZ ENDP			; kd_dummy_target::flush_buf
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?desequence_packets_until_tile_inactive@@YAXPAUkd_tile@@PAUkd_codestream@@@Z
_TEXT	SEGMENT
_p_idx$ = -8						; size = 8
_active$ = 8						; size = 4
_res$ = 12						; size = 4
_codestream$ = 12					; size = 4
?desequence_packets_until_tile_inactive@@YAXPAUkd_tile@@PAUkd_codestream@@@Z PROC ; desequence_packets_until_tile_inactive, COMDAT

; 462  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx

; 466  :   while ((active == codestream->active_tile) && // In case destroyed

	mov	ebx, DWORD PTR _codestream$[ebp]
	push	edi
	mov	edi, DWORD PTR _active$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _p_idx$[ebp], 0
	mov	DWORD PTR _p_idx$[ebp+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 466  :   while ((active == codestream->active_tile) && // In case destroyed

	cmp	edi, DWORD PTR [ebx+364]
	jne	$LN28@desequence
	push	esi
	npad	7
$LL2@desequence:
	mov	ecx, DWORD PTR [edi+52]
	lea	eax, DWORD PTR _p_idx$[ebp]
	push	eax
	lea	eax, DWORD PTR _res$[ebp]
	push	eax
	call	?next_in_sequence@kd_packet_sequencer@@QAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_sequence
	mov	edx, eax
	test	edx, edx
	je	SHORT $LN37@desequence
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4661 :   register kdu_long state_val = state;

	mov	ecx, DWORD PTR [edx]

; 4662 :   return ((state_val != 0) &&

	mov	eax, ecx
	mov	esi, DWORD PTR [edx+4]
	or	eax, esi
	je	SHORT $LN12@desequence
	mov	eax, ecx
	and	eax, 1
	or	eax, 0
	jne	SHORT $LN4@desequence
	test	BYTE PTR [ecx+8], 4
	jne	SHORT $LN4@desequence
$LN12@desequence:

; 4663 :           ((state_val & 1) ||
; 4664 :            (((kd_precinct *) _kdu_long_to_addr(state_val))->flags &
; 4665 :             KD_PFLAG_DESEQUENCED)));
; 4666 : }
; 4667 : 
; 4668 : inline void
; 4669 :   kd_precinct_ref::clear()
; 4670 : {
; 4671 :   if (state && !(state & 1))
; 4672 :     {
; 4673 :       kd_precinct *precinct = (kd_precinct *) _kdu_long_to_addr(state);
; 4674 :       precinct->ref = NULL; // Satisfy the test in `kd_precinct::closing'
; 4675 :       precinct->closing();
; 4676 :       precinct->size_class->release(precinct);
; 4677 :     }
; 4678 :   state = 0;
; 4679 : }
; 4680 : 
; 4681 : inline void
; 4682 :   kd_precinct_ref::close_and_reset()
; 4683 : {
; 4684 :   if (state & 1)
; 4685 :     {
; 4686 :       if (state != 3)
; 4687 :         state &= ~((kdu_long) 2);
; 4688 :     }
; 4689 :   else if (state != 0)
; 4690 :     {
; 4691 :       kd_precinct *prec = (kd_precinct *) _kdu_long_to_addr(state);
; 4692 :       if ((prec->flags & KD_PFLAG_PARSED)||(prec->num_packets_read > 0))
; 4693 :         {
; 4694 :           close();
; 4695 :           state &= ~((kdu_long) 2);
; 4696 :         }
; 4697 :     }
; 4698 : }
; 4699 : 
; 4700 : inline void
; 4701 :   kd_precinct_ref::release()
; 4702 : {
; 4703 :   kd_precinct *precinct = (kd_precinct *) _kdu_long_to_addr(state);
; 4704 :   assert((state != 0) && !(state & 1));
; 4705 :   if (precinct->flags & KD_PFLAG_INACTIVE)
; 4706 :     return; // Already on the inactive list.
; 4707 :   precinct->flags |= KD_PFLAG_RELEASED;
; 4708 :     // precinct->released = true; // In case not already set.
; 4709 :   if ((precinct->flags & KD_PFLAG_ADDRESSABLE) &&
; 4710 :       (!precinct->resolution->codestream->cached) &&
; 4711 :       ((precinct->num_packets_read == 0) ||
; 4712 :        (precinct->num_packets_read == precinct->next_layer_idx)))
; 4713 :     precinct->size_class->move_to_inactive_list(precinct);
; 4714 :   else
; 4715 :     close();
; 4716 : }
; 4717 : 
; 4718 : inline kd_precinct *
; 4719 :   kd_precinct_ref::open(kd_resolution *res, kdu_coords pos_idx,
; 4720 :                         bool need_activate)
; 4721 : {
; 4722 :   if (state == 3)

	cmp	ecx, 3
	jne	SHORT $LN15@desequence
	test	esi, esi
	je	SHORT $LN14@desequence
$LN15@desequence:

; 4723 :     return NULL; // Precinct is not currently loaded
; 4724 :   if ((state == 0) || (state & 1))

	mov	eax, ecx
	or	eax, esi
	je	SHORT $LN17@desequence
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN17@desequence

; 4726 :   kd_precinct *result = (kd_precinct *) _kdu_long_to_addr(state);

	mov	esi, DWORD PTR [edx]

; 4727 :   if (result->flags & KD_PFLAG_INACTIVE)

	test	BYTE PTR [esi+8], 32			; 00000020H
	je	SHORT $LN14@desequence

; 4728 :     { // Must be on the inactive list
; 4729 :       result->size_class->withdraw_from_inactive_list(result);

	mov	ecx, DWORD PTR [esi+52]
	push	esi
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list

; 4730 :       result->activate();

	mov	ecx, esi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate

; 4731 :     }
; 4732 :   else if (need_activate && (result->flags & KD_PFLAG_RELEASED))
; 4733 :     result->activate();
; 4734 :   return result;

	jmp	SHORT $LN14@desequence
$LN17@desequence:

; 4725 :     return instantiate_precinct(res,pos_idx);

	push	DWORD PTR _p_idx$[ebp+4]
	mov	ecx, edx
	push	DWORD PTR _p_idx$[ebp]
	push	DWORD PTR _res$[ebp]
	call	?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z ; kd_precinct_ref::instantiate_precinct
	mov	esi, eax
$LN14@desequence:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 468  :     if (!(pref->is_desequenced() ||

	mov	ecx, esi
	call	?desequence_packet@kd_precinct@@QAE_NXZ	; kd_precinct::desequence_packet
	test	al, al
	je	SHORT $LN37@desequence
$LN4@desequence:

; 466  :   while ((active == codestream->active_tile) && // In case destroyed

	cmp	edi, DWORD PTR [ebx+364]
	je	$LL2@desequence
$LN37@desequence:
	pop	esi

; 469  :           pref->open(res,p_idx,false)->desequence_packet()))
; 470  :       break;
; 471  :   if (active == codestream->active_tile)

	cmp	edi, DWORD PTR [ebx+364]
	jne	SHORT $LN28@desequence

; 472  :     {
; 473  :       codestream->active_tile = NULL;

	mov	DWORD PTR [ebx+364], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2743 :         if ((!codestream->persistent) ||

	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax+337], 0
	je	SHORT $LN28@desequence
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN23@desequence
	cmp	BYTE PTR [eax+338], 0
	je	SHORT $LN28@desequence
$LN23@desequence:

; 2744 :             ((codestream->tpart_ptr_server==NULL) && !codestream->cached))
; 2745 :           { assert(!is_unloadable); return; }
; 2746 :         if (is_open || (this==codestream->active_tile))

	cmp	BYTE PTR [edi+229], 0
	jne	SHORT $LN27@desequence
	cmp	edi, DWORD PTR [eax+364]
	je	SHORT $LN27@desequence

; 2750 :           }
; 2751 :         else
; 2752 :           { // Should be on the unloadable list
; 2753 :             if (!is_unloadable)

	cmp	BYTE PTR [edi+230], 0
	jne	SHORT $LN28@desequence

; 2754 :               add_to_unloadable_list();

	mov	ecx, edi
	call	?add_to_unloadable_list@kd_tile@@AAEXXZ	; kd_tile::add_to_unloadable_list
	pop	edi
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 476  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN27@desequence:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2748 :             if (is_unloadable)

	cmp	BYTE PTR [edi+230], 0
	je	SHORT $LN28@desequence

; 2749 :               withdraw_from_unloadable_list();

	mov	ecx, edi
	call	?withdraw_from_unloadable_list@kd_tile@@AAEXXZ ; kd_tile::withdraw_from_unloadable_list
$LN28@desequence:
	pop	edi
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 476  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?desequence_packets_until_tile_inactive@@YAXPAUkd_tile@@PAUkd_codestream@@@Z ENDP ; desequence_packets_until_tile_inactive
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?compare_sop_num@@YAHHH@Z
_TEXT	SEGMENT
_sop_num$ = 8						; size = 4
_packet_num$ = 12					; size = 4
?compare_sop_num@@YAHHH@Z PROC				; compare_sop_num, COMDAT

; 436  : {

	push	ebp
	mov	ebp, esp

; 437  :   assert((sop_num >= 0) && (sop_num < (1<<16)));
; 438  :   int diff = sop_num - packet_num;

	mov	eax, DWORD PTR _sop_num$[ebp]
	sub	eax, DWORD PTR _packet_num$[ebp]

; 439  : 
; 440  :   if ((diff & 0x0000FFFF) == 0)

	movzx	ecx, ax
	test	ecx, ecx
	jne	SHORT $LN2@compare_so

; 441  :     return 0;

	xor	eax, eax

; 446  : }

	pop	ebp
	ret	0
$LN2@compare_so:

; 442  :   if ((diff > 0) || ((diff & 0x0000FFFF) <= (1<<15)))

	test	eax, eax
	jg	SHORT $LN4@compare_so
	cmp	ecx, 32768				; 00008000H
	jle	SHORT $LN4@compare_so

; 443  :     return diff; // `sop_num' deemed to be greater than `packet_num'.
; 444  :   else
; 445  :     return diff-(1<<16); // `sop_num' deemed to be less than `packet_num'.

	add	eax, -65536				; ffff0000H
$LN4@compare_so:

; 446  : }

	pop	ebp
	ret	0
?compare_sop_num@@YAHHH@Z ENDP				; compare_sop_num
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?create_child_node@@YAPAUkd_leaf_node@@PAUkd_node@@HH0AAHPAUkd_subband@@1HHH_N3HQA_NH4AAVkdu_kernels@@@Z
_TEXT	SEGMENT
$T1 = -48						; size = 16
_lval$2 = -40						; size = 8
_num_hor_extra_stages$1$ = -32				; size = 4
_num_vert_extra_stages$1$ = -28				; size = 4
_min$1$ = -24						; size = 4
_vert_bibo_gains$1$ = -24				; size = 4
_branch_y$1$ = -20					; size = 4
_hor_bibo_gains$1$ = -20				; size = 4
_hval$3 = -16						; size = 8
_branch_x$1$ = -12					; size = 4
_next_branch_mask$1$ = -8				; size = 4
_result$1$ = -4						; size = 4
_parent$ = 8						; size = 4
_child_idx$ = 12					; size = 4
_min$2$ = 16						; size = 4
tv800 = 16						; size = 4
tv778 = 16						; size = 4
_branch_mask$ = 16					; size = 4
_primary_vert_depth$1$ = 19				; size = 1
_intermediate_nodes$ = 20				; size = 4
_next_inode_idx$ = 24					; size = 4
_subbands$ = 28						; size = 4
_next_band_idx$ = 32					; size = 4
_decomp_val$ = 36					; size = 4
_sub_level$ = 40					; size = 4
_orientation$ = 44					; size = 4
_hor_high$ = 48						; size = 1
_vert_high$ = 52					; size = 1
_num_hor_extra_stages$ = 56				; size = 4
_hor_extra_stage_high$ = 60				; size = 4
_num_vert_extra_stages$ = 64				; size = 4
_vert_extra_stage_high$ = 68				; size = 4
_kernels$ = 72						; size = 4
?create_child_node@@YAPAUkd_leaf_node@@PAUkd_node@@HH0AAHPAUkd_subband@@1HHH_N3HQA_NH4AAVkdu_kernels@@@Z PROC ; create_child_node, COMDAT

; 269  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 48					; 00000030H

; 270  :   assert((sub_level >= 1) && (sub_level <= 3));
; 271  :   int next_branch_mask = decomp_val & 3;

	mov	eax, DWORD PTR _decomp_val$[ebp]

; 272  :   decomp_val >>= 2;
; 273  :   if (sub_level == 2)

	xor	ecx, ecx
	mov	edx, eax
	sar	eax, 2
	and	edx, 3
	cmp	DWORD PTR _sub_level$[ebp], 2
	push	ebx
	push	esi
	cmove	eax, ecx
	mov	DWORD PTR _next_branch_mask$1$[ebp], edx
	push	edi

; 274  :     decomp_val = 0; // No more decomposition beyond our own children, if any
; 275  : 
; 276  :   kd_leaf_node *result=NULL;
; 277  :   kd_node *inode=NULL;

	xor	edi, edi
	mov	DWORD PTR _decomp_val$[ebp], eax

; 278  :   if (next_branch_mask == 0)

	test	edx, edx
	jne	SHORT $LN12@create_chi

; 279  :     result = &(subbands[next_band_idx++]);

	mov	ecx, DWORD PTR _next_band_idx$[ebp]
	mov	eax, DWORD PTR [ecx]
	imul	ebx, eax, 132
	add	ebx, DWORD PTR _subbands$[ebp]
	mov	DWORD PTR _result$1$[ebp], ebx

; 280  :   else

	jmp	SHORT $LN63@create_chi
$LN12@create_chi:

; 281  :     result = inode = &(intermediate_nodes[next_inode_idx++]);

	mov	ecx, DWORD PTR _next_inode_idx$[ebp]
	mov	eax, DWORD PTR [ecx]
	imul	edi, eax, 104
	add	edi, DWORD PTR _intermediate_nodes$[ebp]
	mov	ebx, edi
	mov	DWORD PTR _result$1$[ebp], edi
$LN63@create_chi:

; 282  : 
; 283  :   result->parent = parent;

	mov	esi, DWORD PTR _parent$[ebp]
	inc	eax

; 284  :   if (branch_mask & 1)

	test	BYTE PTR _branch_mask$[ebp], 1
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _child_idx$[ebp]
	mov	DWORD PTR [ebx], esi
	je	SHORT $LN14@create_chi

; 285  :     {
; 286  :       result->branch_x = (kdu_byte)(child_idx & 1);
; 287  :       assert(num_hor_extra_stages < 3);
; 288  :       hor_extra_stage_high[num_hor_extra_stages++] =

	mov	esi, DWORD PTR _num_hor_extra_stages$[ebp]
	mov	al, cl
	mov	edx, DWORD PTR _hor_extra_stage_high$[ebp]
	and	al, 1
	mov	BYTE PTR [ebx+40], al
	setne	al
	mov	BYTE PTR [esi+edx], al
	mov	eax, esi

; 289  :         (result->branch_x)?true:false;
; 290  :       if (result->branch_x)

	mov	edx, DWORD PTR _next_branch_mask$1$[ebp]
	inc	eax
	cmp	BYTE PTR [ebx+40], 0
	mov	esi, DWORD PTR _parent$[ebp]
	mov	DWORD PTR _num_hor_extra_stages$1$[ebp], eax
	je	SHORT $LN15@create_chi

; 291  :         {
; 292  :           if (hor_high)

	cmp	BYTE PTR _hor_high$[ebp], 0
	je	SHORT $LN17@create_chi

; 293  :             result->resolution->can_flip = false;

	mov	eax, DWORD PTR [ebx+4]
	mov	BYTE PTR [eax+173], 0
$LN17@create_chi:

; 294  :           hor_high = true;

	mov	BYTE PTR _hor_high$[ebp], 1

; 295  :         }
; 296  :     }
; 297  :   else

	jmp	SHORT $LN15@create_chi
$LN14@create_chi:

; 298  :     {
; 299  :       result->branch_x = 2;

	mov	eax, DWORD PTR _num_hor_extra_stages$[ebp]
	mov	BYTE PTR [ebx+40], 2
	mov	DWORD PTR _num_hor_extra_stages$1$[ebp], eax
$LN15@create_chi:

; 300  :       assert(!(child_idx & 1));
; 301  :     }
; 302  :   if (branch_mask & 2)

	test	BYTE PTR _branch_mask$[ebp], 2
	je	SHORT $LN18@create_chi

; 303  :     {
; 304  :       result->branch_y = (kdu_byte)((child_idx>>1) & 1);
; 305  :       assert(num_vert_extra_stages < 3);
; 306  :       vert_extra_stage_high[num_vert_extra_stages++] =

	mov	esi, DWORD PTR _vert_extra_stage_high$[ebp]
	sar	ecx, 1
	and	cl, 1
	mov	BYTE PTR [ebx+41], cl
	mov	ecx, DWORD PTR _num_vert_extra_stages$[ebp]
	setne	al
	mov	BYTE PTR [ecx+esi], al
	inc	ecx

; 307  :         (result->branch_y)?true:false;
; 308  :       if (result->branch_y)

	cmp	BYTE PTR [ebx+41], 0
	mov	esi, DWORD PTR _parent$[ebp]
	mov	DWORD PTR _num_vert_extra_stages$1$[ebp], ecx
	je	SHORT $LN19@create_chi

; 309  :         {
; 310  :           if (vert_high)

	cmp	BYTE PTR _vert_high$[ebp], 0
	je	SHORT $LN21@create_chi

; 311  :             result->resolution->can_flip = false;

	mov	eax, DWORD PTR [ebx+4]
	mov	BYTE PTR [eax+173], 0
$LN21@create_chi:

; 312  :           vert_high = true;

	mov	BYTE PTR _vert_high$[ebp], 1

; 313  :         }
; 314  :     }
; 315  :   else

	jmp	SHORT $LN19@create_chi
$LN18@create_chi:

; 316  :     {
; 317  :       result->branch_y = 2;

	mov	eax, DWORD PTR _num_vert_extra_stages$[ebp]
	mov	BYTE PTR [ebx+41], 2
	mov	DWORD PTR _num_vert_extra_stages$1$[ebp], eax
$LN19@create_chi:

; 318  :       assert(!(child_idx & 2));
; 319  :     }
; 320  : 
; 321  :   // Do the BIBO gain stuff here
; 322  :   if (inode != NULL)

	test	edi, edi
	je	$LN6@create_chi

; 323  :     {
; 324  :       assert(next_branch_mask != 0);
; 325  :       inode->num_hor_steps = (kdu_byte)

	test	dl, 1
	je	SHORT $LN28@create_chi
	mov	eax, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+76]
	jmp	SHORT $LN64@create_chi
$LN28@create_chi:
	xor	eax, eax
$LN64@create_chi:
	mov	DWORD PTR tv800[ebp], eax
	mov	BYTE PTR [edi+92], al

; 326  :         ((next_branch_mask & 1)?
; 327  :          (result->resolution->tile_comp->kernel_num_steps):0);
; 328  :       inode->num_vert_steps = (kdu_byte)

	test	dl, 2
	je	SHORT $LN30@create_chi
	mov	eax, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+76]
	mov	eax, DWORD PTR tv800[ebp]
	jmp	SHORT $LN31@create_chi
$LN30@create_chi:
	xor	ecx, ecx
$LN31@create_chi:
	mov	BYTE PTR [edi+93], cl

; 329  :         ((next_branch_mask & 2)?
; 330  :          (result->resolution->tile_comp->kernel_num_steps):0);
; 331  :       inode->bibo_gains =

	mov	edx, 4
	movzx	ecx, cl
	movzx	eax, al
	add	eax, 2
	add	eax, ecx
	xor	ecx, ecx
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, eax
	add	esp, 4

; 332  :         new float[inode->num_hor_steps+inode->num_vert_steps+2];
; 333  :       float *hor_bibo_gains = inode->bibo_gains;
; 334  :       float *vert_bibo_gains = inode->bibo_gains + (1+inode->num_hor_steps);

	movzx	eax, BYTE PTR [edi+92]
	inc	eax
	mov	DWORD PTR [edi+100], edx

; 335  :       hor_bibo_gains[0] =

	movzx	ecx, BYTE PTR [esi+92]
	and	ecx, 254				; 000000feH
	mov	DWORD PTR _hor_bibo_gains$1$[ebp], edx
	lea	eax, DWORD PTR [edx+eax*4]
	mov	DWORD PTR _vert_bibo_gains$1$[ebp], eax
	mov	eax, DWORD PTR [esi+100]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR [edx], eax

; 336  :         parent->bibo_gains[parent->num_hor_steps & 254];
; 337  :       vert_bibo_gains[0] =

	movzx	ecx, BYTE PTR [esi+93]
	movzx	eax, BYTE PTR [esi+92]
	and	ecx, 254				; 000000feH
	add	ecx, eax
	mov	eax, DWORD PTR [esi+100]
	mov	eax, DWORD PTR [eax+ecx*4+4]
	mov	ecx, DWORD PTR _vert_bibo_gains$1$[ebp]
	mov	DWORD PTR [ecx], eax

; 338  :         parent->bibo_gains[(1+parent->num_hor_steps) +
; 339  :                            (parent->num_vert_steps & 254)];
; 340  : 
; 341  :       double lval, hval, *gains;
; 342  :       kdu_byte primary_hor_depth = parent->resolution->hor_depth;
; 343  :       kdu_byte primary_vert_depth = parent->resolution->vert_depth;
; 344  :       if (inode->num_hor_steps > 0)

	cmp	BYTE PTR [edi+92], 0
	mov	eax, DWORD PTR [esi+4]
	mov	cl, BYTE PTR [eax+14]
	mov	al, BYTE PTR [eax+15]
	mov	BYTE PTR _primary_vert_depth$1$[ebp], al
	jbe	SHORT $LN3@create_chi

; 345  :         {
; 346  :           gains = kernels.get_bibo_gains(primary_hor_depth,

	lea	eax, DWORD PTR _hval$3[ebp]
	push	eax
	lea	eax, DWORD PTR _lval$2[ebp]
	push	eax
	push	DWORD PTR _hor_extra_stage_high$[ebp]
	movzx	eax, cl
	push	DWORD PTR _num_hor_extra_stages$1$[ebp]
	mov	ecx, DWORD PTR _kernels$[ebp]
	push	eax
	call	?get_bibo_gains@kdu_kernels@@QAEPANHHQA_NAAN1@Z ; kdu_kernels::get_bibo_gains

; 347  :                                          num_hor_extra_stages,
; 348  :                                          hor_extra_stage_high,lval,hval);
; 349  :           for (kdu_byte n=0; n < inode->num_hor_steps; n++)

	xor	dl, dl
	cmp	BYTE PTR [edi+92], dl
	jbe	SHORT $LN62@create_chi
	mov	ebx, DWORD PTR _hor_bibo_gains$1$[ebp]
	npad	4
$LL4@create_chi:

; 350  :             hor_bibo_gains[n+1] = (float) gains[n];

	movzx	ecx, dl
	inc	dl
	movsd	xmm0, QWORD PTR [eax+ecx*8]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [ebx+ecx*4+4], xmm0
	cmp	dl, BYTE PTR [edi+92]
	jb	SHORT $LL4@create_chi
	mov	ebx, DWORD PTR _result$1$[ebp]
$LN62@create_chi:
	mov	al, BYTE PTR _primary_vert_depth$1$[ebp]
$LN3@create_chi:

; 351  :         }
; 352  :       if (inode->num_vert_steps > 0)

	cmp	BYTE PTR [edi+93], 0
	jbe	SHORT $LN6@create_chi

; 353  :         {
; 354  :           gains = kernels.get_bibo_gains(primary_vert_depth,

	lea	ecx, DWORD PTR _hval$3[ebp]
	movzx	eax, al
	push	ecx
	lea	ecx, DWORD PTR _lval$2[ebp]
	push	ecx
	push	DWORD PTR _vert_extra_stage_high$[ebp]
	mov	ecx, DWORD PTR _kernels$[ebp]
	push	DWORD PTR _num_vert_extra_stages$1$[ebp]
	push	eax
	call	?get_bibo_gains@kdu_kernels@@QAEPANHHQA_NAAN1@Z ; kdu_kernels::get_bibo_gains

; 355  :                                          num_vert_extra_stages,
; 356  :                                          vert_extra_stage_high,lval,hval);
; 357  :           for (kdu_byte n=0; n < inode->num_vert_steps; n++)

	xor	dl, dl
	cmp	BYTE PTR [edi+93], dl
	jbe	SHORT $LN6@create_chi
	mov	esi, DWORD PTR _vert_bibo_gains$1$[ebp]
	npad	7
$LL7@create_chi:

; 358  :             vert_bibo_gains[n+1] = (float) gains[n];

	movzx	ecx, dl
	inc	dl
	movsd	xmm0, QWORD PTR [eax+ecx*8]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [esi+ecx*4+4], xmm0
	cmp	dl, BYTE PTR [edi+93]
	jb	SHORT $LL7@create_chi
	mov	esi, DWORD PTR _parent$[ebp]
$LN6@create_chi:

; 364  :   result->dims =

	movups	xmm1, XMMWORD PTR [esi+8]
	movzx	eax, BYTE PTR [ebx+41]
	mov	DWORD PTR _branch_y$1$[ebp], eax
	movzx	eax, BYTE PTR [ebx+40]

; 122  :   kdu_coords min = parent_dims.pos;

	movaps	xmm0, xmm1
	psrldq	xmm0, 4
	movd	ecx, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	movaps	xmm0, xmm1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 364  :   result->dims =

	mov	DWORD PTR _branch_x$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	psrldq	xmm0, 12				; 0000000cH
	movd	eax, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 122  :   kdu_coords min = parent_dims.pos;

	movd	DWORD PTR _min$2$[ebp], xmm1
	mov	DWORD PTR _min$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	ecx, eax
	psrldq	xmm1, 8
	movd	eax, xmm1
	add	eax, DWORD PTR _min$2$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 125  :   if ((branch_x & ~1) == 0)

	test	DWORD PTR _branch_x$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN33@create_chi

; 126  :     { // Parent node is split horizontally
; 127  :       min.x -= (branch_x)?high_support_max:low_support_max;
; 128  :       lim.x -= (branch_x)?high_support_min:low_support_min;
; 129  :       min.x = (min.x + 1 - branch_x) >> 1;

	mov	ebx, DWORD PTR _min$1$[ebp]
	sub	ebx, DWORD PTR _branch_x$1$[ebp]

; 130  :       lim.x = (lim.x + 1 - branch_x) >> 1;

	sub	ecx, DWORD PTR _branch_x$1$[ebp]
	inc	ebx
	sar	ebx, 1
	inc	ecx
	mov	DWORD PTR _min$1$[ebp], ebx
	sar	ecx, 1
$LN33@create_chi:

; 131  :     }
; 132  : 
; 133  :   if ((branch_y & ~1) == 0)

	test	DWORD PTR _branch_y$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN34@create_chi

; 134  :     { // Parent node is split vertically
; 135  :       min.y -= (branch_y)?high_support_max:low_support_max;
; 136  :       lim.y -= (branch_y)?high_support_min:low_support_min;
; 137  :       min.y = (min.y + 1 - branch_y) >> 1;

	mov	esi, DWORD PTR _min$2$[ebp]
	sub	esi, DWORD PTR _branch_y$1$[ebp]

; 138  :       lim.y = (lim.y + 1 - branch_y) >> 1;

	sub	eax, DWORD PTR _branch_y$1$[ebp]
	inc	esi
	sar	esi, 1
	inc	eax
	mov	DWORD PTR _min$2$[ebp], esi
	mov	esi, DWORD PTR _parent$[ebp]
	sar	eax, 1
$LN34@create_chi:

; 142  :   result.pos = min;

	mov	ebx, DWORD PTR _min$2$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	eax, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 142  :   result.pos = min;

	mov	edx, DWORD PTR _min$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ecx, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 142  :   result.pos = min;

	mov	DWORD PTR $T1[ebp], ebx

; 364  :   result->dims =

	mov	ebx, DWORD PTR _result$1$[ebp]

; 142  :   result.pos = min;

	mov	DWORD PTR $T1[ebp+4], edx

; 365  :     get_child_dims(parent->dims,result->branch_x,result->branch_y);
; 366  : 
; 367  :   if (next_branch_mask == 0)

	mov	edx, DWORD PTR _next_branch_mask$1$[ebp]

; 143  :   result.size = lim-min;

	mov	DWORD PTR $T1[ebp+8], eax
	mov	DWORD PTR $T1[ebp+12], ecx

; 364  :   result->dims =

	movups	xmm0, XMMWORD PTR $T1[ebp]
	movups	XMMWORD PTR [ebx+8], xmm0

; 365  :     get_child_dims(parent->dims,result->branch_x,result->branch_y);
; 366  : 
; 367  :   if (next_branch_mask == 0)

	test	edx, edx
	jne	SHORT $LN25@create_chi

; 368  :     { // This is a leaf node; check the subband descriptor
; 369  :       assert(result->is_leaf);
; 370  :       kd_subband *band = (kd_subband *) result;
; 371  :       band->orientation = (kdu_byte) orientation;

	mov	cl, BYTE PTR _orientation$[ebp]

; 372  : #ifdef _DEBUG
; 373  :       kdu_int16 descriptor = band->descriptor;
; 374  :       int hor_count = descriptor & 3;
; 375  :       int vert_count = (descriptor >> 8) & 3;
; 376  :       kd_leaf_node *scan;
; 377  :       for (scan=result; scan != &(scan->resolution->node); scan=scan->parent)
; 378  :         {
; 379  :           if ((scan->branch_x > 1) == 0)
; 380  :             { // Branch is decomposed horizontally
; 381  :               hor_count -= (scan->branch_x & ~1)?0:1;
; 382  :               assert(((descriptor>>(2+hor_count))&1) == (int)scan->branch_x);
; 383  :             }
; 384  :           if ((scan->branch_y > 1) == 0)
; 385  :             { // Branch is decomposed vertically
; 386  :               vert_count -= (scan->branch_y & ~1)?0:1;
; 387  :               assert(((descriptor>>(10+vert_count))&1) == (int)scan->branch_y);
; 388  :             }
; 389  :         }
; 390  :       assert((hor_count == 0) && (vert_count == 0));
; 391  : #endif // _DEBUG
; 392  : 
; 393  :       parent->num_descendant_nodes++;
; 394  :       parent->num_descendant_leaves++;
; 395  :       return result; // No more children

	mov	eax, ebx
	mov	BYTE PTR [ebx+46], cl
	inc	WORD PTR [esi+94]
	inc	WORD PTR [esi+96]
	pop	edi
	pop	esi
	pop	ebx

; 417  : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN25@create_chi:
	mov	ebx, DWORD PTR _decomp_val$[ebp]

; 396  :     }
; 397  : 
; 398  :   int b;
; 399  :   for (b=0; b < 4; b++)

	lea	ecx, DWORD PTR [edi+76]
	xor	esi, esi
	mov	DWORD PTR tv778[ebp], ecx
	npad	1
$LL10@create_chi:

; 400  :     if (b == (b & next_branch_mask))

	mov	eax, esi
	and	eax, edx
	cmp	esi, eax
	jne	SHORT $LN8@create_chi

; 401  :       {
; 402  :         inode->children[b] =

	push	DWORD PTR _kernels$[ebp]
	mov	eax, DWORD PTR _sub_level$[ebp]
	push	DWORD PTR _vert_extra_stage_high$[ebp]
	inc	eax
	push	DWORD PTR _num_vert_extra_stages$1$[ebp]
	push	DWORD PTR _hor_extra_stage_high$[ebp]
	push	DWORD PTR _num_hor_extra_stages$1$[ebp]
	push	DWORD PTR _vert_high$[ebp]
	push	DWORD PTR _hor_high$[ebp]
	push	DWORD PTR _orientation$[ebp]
	push	eax
	mov	eax, ebx
	and	eax, 3
	push	eax
	push	DWORD PTR _next_band_idx$[ebp]
	push	DWORD PTR _subbands$[ebp]
	push	DWORD PTR _next_inode_idx$[ebp]
	push	DWORD PTR _intermediate_nodes$[ebp]
	push	edx
	push	esi
	push	edi
	call	?create_child_node@@YAPAUkd_leaf_node@@PAUkd_node@@HH0AAHPAUkd_subband@@1HHH_N3HQA_NH4AAVkdu_kernels@@@Z ; create_child_node
	mov	ecx, DWORD PTR tv778[ebp]
	add	esp, 68					; 00000044H
	mov	edx, DWORD PTR _next_branch_mask$1$[ebp]

; 403  :           create_child_node(inode,b,next_branch_mask,
; 404  :                             intermediate_nodes,next_inode_idx,
; 405  :                             subbands,next_band_idx,(decomp_val & 3),
; 406  :                             sub_level+1,orientation,hor_high,vert_high,
; 407  :                             num_hor_extra_stages,hor_extra_stage_high,
; 408  :                             num_vert_extra_stages,vert_extra_stage_high,
; 409  :                             kernels);
; 410  :         decomp_val >>= 2;

	sar	ebx, 2
	mov	DWORD PTR [ecx], eax
$LN8@create_chi:

; 396  :     }
; 397  : 
; 398  :   int b;
; 399  :   for (b=0; b < 4; b++)

	inc	esi
	add	ecx, 4
	mov	DWORD PTR tv778[ebp], ecx
	cmp	esi, 4
	jl	SHORT $LL10@create_chi

; 411  :       }
; 412  : 
; 413  :   parent->num_descendant_leaves += inode->num_descendant_leaves;

	mov	ecx, DWORD PTR _parent$[ebp]
	movzx	eax, WORD PTR [edi+96]
	add	WORD PTR [ecx+96], ax

; 414  :   parent->num_descendant_nodes += inode->num_descendant_nodes + 1;

	movzx	eax, WORD PTR [edi+94]
	pop	edi
	inc	ax
	add	WORD PTR [ecx+94], ax

; 415  : 
; 416  :   return result;

	mov	eax, DWORD PTR _result$1$[ebp]
	pop	esi
	pop	ebx

; 417  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?create_child_node@@YAPAUkd_leaf_node@@PAUkd_node@@HH0AAHPAUkd_subband@@1HHH_N3HQA_NH4AAVkdu_kernels@@@Z ENDP ; create_child_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?check_coding_partition@@YAXUkdu_dims@@@Z
_TEXT	SEGMENT
_e$2 = -52						; size = 20
_e$3 = -32						; size = 20
__$EHRec$ = -12						; size = 12
_partition$ = 8						; size = 16
?check_coding_partition@@YAXUkdu_dims@@@Z PROC		; check_coding_partition, COMDAT

; 197  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?check_coding_partition@@YAXUkdu_dims@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax

; 198  :   if ((partition.pos.x != (partition.pos.x & 1)) ||

	mov	eax, DWORD PTR _partition$[ebp+4]
	and	eax, 1
	cmp	DWORD PTR _partition$[ebp+4], eax
	jne	SHORT $LN3@check_codi
	mov	eax, DWORD PTR _partition$[ebp]
	and	eax, 1
	cmp	DWORD PTR _partition$[ebp], eax
	je	SHORT $LN2@check_codi
$LN3@check_codi:

; 200  :     { KDU_ERROR(e,0); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0GL@JBAAPDCE@Coding?5partitions?5?$CIcode?9blocks?5a@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 200  :     { KDU_ERROR(e,0); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 203  :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@check_codi:

; 204  :   if (!(is_power_2(partition.size.x) && is_power_2(partition.size.y)))

	push	DWORD PTR _partition$[ebp+12]
	call	?is_power_2@@YA_NH@Z			; is_power_2
	add	esp, 4
	test	al, al
	je	SHORT $LN5@check_codi
	push	DWORD PTR _partition$[ebp+8]
	call	?is_power_2@@YA_NH@Z			; is_power_2
	add	esp, 4
	test	al, al
	jne	SHORT $LN4@check_codi
$LN5@check_codi:

; 205  :     { KDU_ERROR(e,1); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0GG@KMAHIAKO@Coding?5partitions?5?$CInamely?0?5code?9@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 205  :     { KDU_ERROR(e,1); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 208  :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN4@check_codi:

; 209  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?check_coding_partition@@YAXUkdu_dims@@@Z$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?check_coding_partition@@YAXUkdu_dims@@@Z$1:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?check_coding_partition@@YAXUkdu_dims@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-44]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?check_coding_partition@@YAXUkdu_dims@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?check_coding_partition@@YAXUkdu_dims@@@Z ENDP		; check_coding_partition
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?is_power_2@@YA_NH@Z
_TEXT	SEGMENT
_val$ = 8						; size = 4
?is_power_2@@YA_NH@Z PROC				; is_power_2, COMDAT

; 182  : {

	push	ebp
	mov	ebp, esp

; 183  :   for (; val > 1; val >>= 1)

	mov	eax, DWORD PTR _val$[ebp]
	cmp	eax, 1
	jle	SHORT $LN3@is_power_2
	npad	5
$LL4@is_power_2:

; 184  :     if (val & 1)

	test	al, 1
	jne	SHORT $LN8@is_power_2

; 183  :   for (; val > 1; val >>= 1)

	sar	eax, 1
	cmp	eax, 1
	jg	SHORT $LL4@is_power_2
$LN3@is_power_2:

; 186  :     return (val==1);

	xor	ecx, ecx
	cmp	eax, 1
	sete	al

; 187  : }

	pop	ebp
	ret	0
$LN8@is_power_2:

; 185  :       return false;

	xor	al, al

; 187  : }

	pop	ebp
	ret	0
?is_power_2@@YA_NH@Z ENDP				; is_power_2
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_partition_indices@@YA?AUkdu_dims@@U1@0@Z
_TEXT	SEGMENT
_lim$4$ = -8						; size = 4
_min$2$ = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_partition$ = 12					; size = 16
_region$ = 28						; size = 16
?get_partition_indices@@YA?AUkdu_dims@@U1@0@Z PROC	; get_partition_indices, COMDAT

; 159  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	ecx, DWORD PTR _region$[ebp+4]
	sub	ecx, DWORD PTR _partition$[ebp+4]

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	eax, DWORD PTR _region$[ebp+8]
	push	ebx
	mov	ebx, DWORD PTR _region$[ebp+12]
	push	esi

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	esi, DWORD PTR _region$[ebp]

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	ebx, ecx

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	esi, DWORD PTR _partition$[ebp]
	push	edi

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	eax, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 199  :   if (num < 0)

	or	edi, -1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	DWORD PTR _lim$4$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 199  :   if (num < 0)

	test	ecx, ecx
	jns	SHORT $LN14@get_partit

; 200  :     return -(1+((-num-1)/den));

	mov	eax, edi
	sub	eax, ecx
	mov	ecx, DWORD PTR _partition$[ebp+12]
	cdq
	idiv	ecx
	mov	edx, edi
	sub	edx, eax
	mov	DWORD PTR _min$2$[ebp], edx
	jmp	SHORT $LN15@get_partit
$LN14@get_partit:

; 201  :   else
; 202  :     return num/den;

	mov	eax, ecx
	mov	ecx, DWORD PTR _partition$[ebp+12]
	cdq
	idiv	ecx
	mov	DWORD PTR _min$2$[ebp], eax
$LN15@get_partit:

; 179  :   if (num <= 0)

	test	ebx, ebx
	jg	SHORT $LN18@get_partit

; 180  :     return -((-num)/den);

	mov	eax, ebx
	cdq
	idiv	ecx
	mov	ebx, eax
	jmp	SHORT $LN19@get_partit
$LN18@get_partit:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ebx-1]
	cdq
	idiv	ecx
	lea	ebx, DWORD PTR [eax+1]
$LN19@get_partit:

; 200  :     return -(1+((-num-1)/den));

	mov	ecx, DWORD PTR _partition$[ebp+8]
	test	esi, esi
	jns	SHORT $LN22@get_partit
	mov	eax, edi
	sub	eax, esi
	cdq
	idiv	ecx
	sub	edi, eax
	jmp	SHORT $LN23@get_partit
$LN22@get_partit:

; 201  :   else
; 202  :     return num/den;

	mov	eax, esi
	cdq
	idiv	ecx
	mov	edi, eax
$LN23@get_partit:

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _lim$4$[ebp]
	test	eax, eax
	jg	SHORT $LN26@get_partit

; 180  :     return -((-num)/den);

	cdq
	idiv	ecx
	mov	ecx, eax
	jmp	SHORT $LN27@get_partit
$LN26@get_partit:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	ecx
	lea	ecx, DWORD PTR [eax+1]
$LN27@get_partit:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 166  :   if (region.size.x == 0) lim.x = min.x;

	cmp	DWORD PTR _region$[ebp+12], 0
	mov	edx, DWORD PTR _min$2$[ebp]
	cmove	ebx, edx

; 167  :   if (region.size.y == 0) lim.y = min.y;

	cmp	DWORD PTR _region$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 167  :   if (region.size.y == 0) lim.y = min.y;

	cmove	ecx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [eax+8], 0

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ebx, edx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [eax+12], 0

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ecx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 170  :   indices.pos = min;

	mov	DWORD PTR [eax], edi
	pop	edi
	pop	esi

; 171  :   indices.size = lim-min;

	mov	DWORD PTR [eax+12], ebx
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax+8], ecx
	pop	ebx

; 172  : 
; 173  :   return indices;
; 174  : }

	mov	esp, ebp
	pop	ebp
	ret	0
?get_partition_indices@@YA?AUkdu_dims@@U1@0@Z ENDP	; get_partition_indices
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_child_dims@@YA?AUkdu_dims@@U1@HHHHHH@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_parent_dims$ = 12					; size = 16
_branch_x$ = 28						; size = 4
_branch_y$ = 32						; size = 4
_low_support_min$ = 36					; size = 4
_low_support_max$ = 40					; size = 4
_high_support_min$ = 44					; size = 4
_high_support_max$ = 48					; size = 4
?get_child_dims@@YA?AUkdu_dims@@U1@HHHHHH@Z PROC	; get_child_dims, COMDAT

; 121  : {

	push	ebp
	mov	ebp, esp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	ecx, DWORD PTR _parent_dims$[ebp+12]
	mov	edx, DWORD PTR _parent_dims$[ebp+8]
	push	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 125  :   if ((branch_x & ~1) == 0)

	mov	ebx, DWORD PTR _branch_x$[ebp]
	push	esi
	mov	esi, DWORD PTR _parent_dims$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	edx, esi
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 122  :   kdu_coords min = parent_dims.pos;

	mov	edi, DWORD PTR _parent_dims$[ebp+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	ecx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 125  :   if ((branch_x & ~1) == 0)

	test	ebx, -2					; fffffffeH
	jne	SHORT $LN2@get_child_

; 126  :     { // Parent node is split horizontally
; 127  :       min.x -= (branch_x)?high_support_max:low_support_max;

	mov	eax, DWORD PTR _low_support_max$[ebp]
	test	ebx, ebx
	cmovne	eax, DWORD PTR _high_support_max$[ebp]

; 128  :       lim.x -= (branch_x)?high_support_min:low_support_min;
; 129  :       min.x = (min.x + 1 - branch_x) >> 1;

	sub	edi, eax
	mov	eax, DWORD PTR _low_support_min$[ebp]
	sub	edi, ebx
	inc	edi
	sar	edi, 1
	test	ebx, ebx
	cmovne	eax, DWORD PTR _high_support_min$[ebp]

; 130  :       lim.x = (lim.x + 1 - branch_x) >> 1;

	sub	ecx, eax
	sub	ecx, ebx
	inc	ecx
	sar	ecx, 1
$LN2@get_child_:

; 131  :     }
; 132  : 
; 133  :   if ((branch_y & ~1) == 0)

	mov	eax, DWORD PTR _branch_y$[ebp]
	test	eax, -2					; fffffffeH
	jne	SHORT $LN3@get_child_

; 134  :     { // Parent node is split vertically
; 135  :       min.y -= (branch_y)?high_support_max:low_support_max;

	mov	ebx, DWORD PTR _low_support_max$[ebp]
	test	eax, eax
	cmovne	ebx, DWORD PTR _high_support_max$[ebp]

; 136  :       lim.y -= (branch_y)?high_support_min:low_support_min;
; 137  :       min.y = (min.y + 1 - branch_y) >> 1;

	sub	esi, ebx
	mov	ebx, DWORD PTR _low_support_min$[ebp]
	sub	esi, eax
	inc	esi
	sar	esi, 1
	test	eax, eax
	cmovne	ebx, DWORD PTR _high_support_min$[ebp]

; 138  :       lim.y = (lim.y + 1 - branch_y) >> 1;

	sub	edx, ebx
	sub	edx, eax
	inc	edx
	sar	edx, 1
$LN3@get_child_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 224  :     kdu_coords plus(const kdu_coords &rhs)
; 225  :       { /* [SYNOPSIS] Same as `operator+', but more suitable for
; 226  :                       some language bindings. */
; 227  :            return (*this)+rhs;
; 228  :       }
; 229  :     kdu_coords operator-(const kdu_coords &rhs)
; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ecx, edi
	sub	edx, esi

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [eax], 0
	mov	DWORD PTR [eax+4], 0
	mov	DWORD PTR [eax+8], 0
	mov	DWORD PTR [eax+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 142  :   result.pos = min;

	mov	DWORD PTR [eax+4], edi
	pop	edi
	mov	DWORD PTR [eax], esi
	pop	esi

; 143  :   result.size = lim-min;

	mov	DWORD PTR [eax+8], edx
	mov	DWORD PTR [eax+12], ecx
	pop	ebx

; 144  :   return result;
; 145  : }

	pop	ebp
	ret	0
?get_child_dims@@YA?AUkdu_dims@@U1@HHHHHH@Z ENDP	; get_child_dims
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?update_stats@kd_thread_env@@QAEXPAUkdu_block@@PAUkd_codestream@@@Z
_TEXT	SEGMENT
_blk$ = 8						; size = 4
_cs$ = 12						; size = 4
?update_stats@kd_thread_env@@QAEXPAUkdu_block@@PAUkd_codestream@@@Z PROC ; kd_thread_env::update_stats, COMDAT
; _this$ = ecx

; 4578 :       { /* Called during encoding after each code-block of data has been

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 4579 :            generated, whenever coding statistics are being kept by the
; 4580 :            relevant codestream.  This function updates the internal coding
; 4581 :            statistics record managed by the `stats' member, which is
; 4582 :            reconciled against the underlying codestream only at appropriate
; 4583 :            intervals, so as to minimize thread blocking conditions. */
; 4584 :         if ((stats_codestream != cs) && (stats_codestream != NULL))

	mov	edi, DWORD PTR _cs$[ebp]
	mov	eax, DWORD PTR [esi+33128]
	cmp	eax, edi
	je	SHORT $LN2@update_sta
	test	eax, eax
	je	SHORT $LN2@update_sta

; 4585 :           {
; 4586 :             reconcile_stats();

	call	?reconcile_stats@kd_thread_env@@QAEXXZ	; kd_thread_env::reconcile_stats

; 4587 :             stats_codestream = cs;

	mov	DWORD PTR [esi+33128], edi
$LN2@update_sta:

; 4588 :           }
; 4589 :         stats.update_stats(blk);

	push	DWORD PTR _blk$[ebp]
	lea	ecx, DWORD PTR [esi+296]
	call	?update_stats@kd_compressed_stats@@QAE_NPAUkdu_block@@@Z ; kd_compressed_stats::update_stats
	pop	edi
	pop	esi

; 4590 :       }

	pop	ebp
	ret	8
?update_stats@kd_thread_env@@QAEXPAUkdu_block@@PAUkd_codestream@@@Z ENDP ; kd_thread_env::update_stats
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_block_state@kd_thread_env@@QAEPAUkd_thread_block_state@@PAUkd_codestream@@PAUkd_precinct@@PAVkd_block@@@Z
_TEXT	SEGMENT
_cs$ = 8						; size = 4
_precinct$ = 12						; size = 4
_block$ = 16						; size = 4
?get_block_state@kd_thread_env@@QAEPAUkd_thread_block_state@@PAUkd_codestream@@PAUkd_precinct@@PAVkd_block@@@Z PROC ; kd_thread_env::get_block_state, COMDAT
; _this$ = ecx

; 4563 :       {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 4564 :         if (num_outstanding_blocks == KD_THREAD_MAX_OUTSTANDING_BLOCKS)

	cmp	DWORD PTR [esi+33168], 8
	jne	SHORT $LN5@get_block_

; 4565 :           flush(true);

	push	1
	call	?flush@kd_thread_env@@QAEX_N@Z		; kd_thread_env::flush
$LN5@get_block_:

; 4566 :         kd_thread_block_state *scan=outstanding_blocks;

	lea	eax, DWORD PTR [esi+33172]

; 4567 :         for (int n=0; n < KD_THREAD_MAX_OUTSTANDING_BLOCKS; n++, scan++)

	xor	ecx, ecx
	npad	2
$LL4@get_block_:

; 4568 :           if (scan->target_precinct == NULL)

	cmp	DWORD PTR [eax+24], 0
	je	SHORT $LN9@get_block_

; 4567 :         for (int n=0; n < KD_THREAD_MAX_OUTSTANDING_BLOCKS; n++, scan++)

	inc	ecx
	add	eax, 32					; 00000020H
	cmp	ecx, 8
	jl	SHORT $LL4@get_block_

; 4573 :               return scan;
; 4574 :             }
; 4575 :         return NULL; // Should not be possible!!

	xor	eax, eax
	pop	esi

; 4576 :       }

	pop	ebp
	ret	12					; 0000000cH
$LN9@get_block_:

; 4569 :             {
; 4570 :               num_outstanding_blocks++;

	inc	DWORD PTR [esi+33168]

; 4571 :               scan->target_precinct=precinct;  scan->target_block=block;

	mov	ecx, DWORD PTR _precinct$[ebp]
	mov	DWORD PTR [eax+24], ecx
	mov	ecx, DWORD PTR _block$[ebp]
	mov	DWORD PTR [eax+28], ecx

; 4572 :               owner->have_outstanding_blocks = true;

	mov	ecx, DWORD PTR [esi+128]
	pop	esi
	mov	BYTE PTR [ecx+44], 1

; 4576 :       }

	pop	ebp
	ret	12					; 0000000cH
?get_block_state@kd_thread_env@@QAEPAUkd_thread_block_state@@PAUkd_codestream@@PAUkd_precinct@@PAVkd_block@@@Z ENDP ; kd_thread_env::get_block_state
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get@kd_precinct_server@@QAEPAUkd_precinct@@HH@Z
_TEXT	SEGMENT
_this$1$ = -8						; size = 4
_scan$1$ = -4						; size = 4
_max_blocks$ = 8					; size = 4
$T1 = 12						; size = 4
_num_subbands$ = 12					; size = 4
?get@kd_precinct_server@@QAEPAUkd_precinct@@HH@Z PROC	; kd_precinct_server::get, COMDAT
; _this$ = ecx

; 6441 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 8
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 6442 :   kd_precinct_size_class *scan;
; 6443 :   for (scan=size_classes; scan != NULL; scan=scan->next)

	mov	edi, DWORD PTR _num_subbands$[ebp]
	mov	esi, DWORD PTR [ebx]
	mov	DWORD PTR _this$1$[ebp], ebx
	mov	DWORD PTR _scan$1$[ebp], esi
	test	esi, esi
	je	SHORT $LN34@get
	mov	eax, DWORD PTR _max_blocks$[ebp]
	npad	3
$LL4@get:

; 6444 :     if ((scan->max_blocks == max_blocks) &&

	cmp	DWORD PTR [esi+8], eax
	jne	SHORT $LN2@get
	cmp	DWORD PTR [esi+12], edi
	je	$LN26@get
$LN2@get:

; 6442 :   kd_precinct_size_class *scan;
; 6443 :   for (scan=size_classes; scan != NULL; scan=scan->next)

	mov	esi, DWORD PTR [esi+36]
	mov	DWORD PTR _scan$1$[ebp], esi
	test	esi, esi
	jne	SHORT $LL4@get
$LN34@get:

; 6449 :       scan =

	push	40					; 00000028H
	call	??2@YAPAXI@Z				; operator new
	mov	esi, eax
	mov	DWORD PTR _scan$1$[ebp], eax
	add	esp, 4
	mov	DWORD PTR $T1[ebp], esi
	test	esi, esi
	je	SHORT $LN10@get
	mov	eax, DWORD PTR [ebx+24]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4411 :         this->max_blocks = max_blocks;

	mov	ecx, DWORD PTR _max_blocks$[ebp]

; 4412 :         this->num_subbands = num_subbands;
; 4413 :         this->server = server;  this->buf_server = buf_server;

	mov	DWORD PTR [esi+4], eax

; 4414 :         total_precincts = 0; free_list = NULL; next = NULL;
; 4415 :         alloc_bytes = (int) sizeof(kd_precinct);
; 4416 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4417 :         alloc_bytes += num_subbands * (int) sizeof(kd_precinct_band);

	lea	eax, DWORD PTR [edi+edi*2]
	mov	DWORD PTR [esi+8], ecx
	lea	ecx, DWORD PTR [eax*8+56]

; 4418 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4419 :         alloc_bytes += 4 + max_blocks * (int) sizeof(kd_block);

	mov	eax, DWORD PTR _max_blocks$[ebp]
	mov	edx, ecx
	neg	edx
	mov	DWORD PTR [esi+12], edi
	and	edx, 7
	mov	DWORD PTR [esi], ebx
	add	edx, ecx
	mov	DWORD PTR [esi+24], 0
	lea	eax, DWORD PTR [eax+eax*2]
	mov	DWORD PTR [esi+28], 0
	lea	eax, DWORD PTR [eax*8+4]
	mov	DWORD PTR [esi+32], 0
	add	eax, edx
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+16], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6449 :       scan =

	jmp	SHORT $LN11@get
$LN10@get:
	xor	esi, esi
	mov	DWORD PTR _scan$1$[ebp], esi
$LN11@get:

; 6450 :         new kd_precinct_size_class(max_blocks,num_subbands,this,buf_server);
; 6451 :       scan->next = size_classes; size_classes = scan;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi+36], eax
	mov	DWORD PTR [ebx], esi
$LN26@get:

; 6452 :     }
; 6453 : 
; 6454 :   kd_precinct *tmp;
; 6455 :   while (((tmp = inactive_head) != NULL) &&

	mov	ebx, DWORD PTR [ebx+16]
	test	ebx, ebx
	je	SHORT $LN17@get
	mov	esi, DWORD PTR _this$1$[ebp]
	npad	8
$LL5@get:
	mov	edi, DWORD PTR [esi+24]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 289  :       { return (cache_threshold_bytes <

	push	0
	push	232					; 000000e8H
	push	DWORD PTR [edi+20]
	push	DWORD PTR [edi+16]
	call	__allmul
	add	eax, DWORD PTR [edi+32]
	adc	edx, DWORD PTR [edi+36]
	cmp	DWORD PTR [edi+52], edx
	jg	SHORT $LN40@get
	jl	SHORT $LN36@get
	cmp	DWORD PTR [edi+48], eax
	jae	SHORT $LN40@get
$LN36@get:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6460 :       tmp->ref->close();

	mov	ecx, DWORD PTR [ebx+4]
	call	?close@kd_precinct_ref@@QAEXXZ		; kd_precinct_ref::close
	mov	ebx, DWORD PTR [esi+16]
	test	ebx, ebx
	jne	SHORT $LL5@get
$LN40@get:
	mov	esi, DWORD PTR _scan$1$[ebp]
$LN17@get:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4429 :         if (free_list == NULL)

	cmp	DWORD PTR [esi+32], 0
	jne	SHORT $LN20@get

; 4430 :           augment_free_list();

	mov	ecx, esi
	call	?augment_free_list@kd_precinct_size_class@@AAEXXZ ; kd_precinct_size_class::augment_free_list
$LN20@get:

; 4431 :         kd_precinct *result = free_list; free_list = free_list->next;

	mov	edi, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [edi+44]
	mov	DWORD PTR [esi+32], ecx

; 4432 :         result->next = result->prev = NULL;

	mov	DWORD PTR [edi+48], 0
	mov	DWORD PTR [edi+44], 0

; 4433 :         buf_server->augment_structure_bytes(alloc_bytes);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+16]
	cdq

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	add	DWORD PTR [ecx+32], eax

; 281  :         if (structure_bytes > peak_structure_bytes)

	mov	eax, DWORD PTR [ecx+32]
	adc	DWORD PTR [ecx+36], edx
	mov	edx, DWORD PTR [ecx+36]
	cmp	edx, DWORD PTR [ecx+44]
	jl	SHORT $LN39@get
	jg	SHORT $LN37@get
	cmp	eax, DWORD PTR [ecx+40]
	jbe	SHORT $LN39@get
$LN37@get:

; 282  :           peak_structure_bytes = structure_bytes;

	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+44], edx
$LN39@get:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6462 :   return scan->get();

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebx

; 6463 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?get@kd_precinct_server@@QAEPAUkd_precinct@@HH@Z ENDP	; kd_precinct_server::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?augment_free_list@kd_precinct_size_class@@AAEXXZ
_TEXT	SEGMENT
_e$2 = -32						; size = 20
__$EHRec$ = -12						; size = 12
?augment_free_list@kd_precinct_size_class@@AAEXXZ PROC	; kd_precinct_size_class::augment_free_list, COMDAT
; _this$ = ecx

; 6372 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?augment_free_list@kd_precinct_size_class@@AAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 6373 :   kd_precinct *elt = (kd_precinct *) malloc((size_t) alloc_bytes);

	push	DWORD PTR [esi+16]
	call	DWORD PTR __imp__malloc
	mov	edi, eax
	add	esp, 4

; 6374 :   if (elt == NULL)

	test	edi, edi
	jne	SHORT $LN2@augment_fr

; 6375 :     { KDU_ERROR(e,39); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0FI@JEJCBJLM@Heap?5exhausted?4?5?5Unable?5to?5alloc@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6375 :     { KDU_ERROR(e,39); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6378 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@augment_fr:

; 6379 :   elt->size_class = this;

	mov	DWORD PTR [edi+52], esi

; 6380 :   elt->next = free_list;

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [edi+44], eax

; 6381 :   free_list = elt;
; 6382 :   this->total_precincts++;

	add	DWORD PTR [esi+24], 1

; 6383 :   server->total_allocated_bytes += (kdu_long) alloc_bytes;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+16]
	adc	DWORD PTR [esi+28], 0
	cdq
	mov	DWORD PTR [esi+32], edi
	add	DWORD PTR [ecx+8], eax
	adc	DWORD PTR [ecx+12], edx

; 6384 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?augment_free_list@kd_precinct_size_class@@AAEXXZ$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?augment_free_list@kd_precinct_size_class@@AAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-32]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?augment_free_list@kd_precinct_size_class@@AAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?augment_free_list@kd_precinct_size_class@@AAEXXZ ENDP	; kd_precinct_size_class::augment_free_list
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z
_TEXT	SEGMENT
_precinct$ = 8						; size = 4
?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z PROC ; kd_precinct_size_class::withdraw_from_inactive_list, COMDAT
; _this$ = ecx

; 6409 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 6410 :   assert(precinct->flags & KD_PFLAG_INACTIVE);
; 6411 :   if (precinct->prev == NULL)

	mov	esi, DWORD PTR _precinct$[ebp]
	push	edi
	mov	edi, ecx
	mov	edx, DWORD PTR [esi+48]

; 6412 :     {
; 6413 :       assert(precinct == server->inactive_head);
; 6414 :       server->inactive_head = precinct->next;

	mov	eax, DWORD PTR [esi+44]
	test	edx, edx
	jne	SHORT $LN2@withdraw_f
	mov	edx, DWORD PTR [edi]
	mov	DWORD PTR [edx+16], eax

; 6415 :     }
; 6416 :   else

	jmp	SHORT $LN3@withdraw_f
$LN2@withdraw_f:

; 6417 :     precinct->prev->next = precinct->next;

	mov	DWORD PTR [edx+44], eax
$LN3@withdraw_f:

; 6418 :   if (precinct->next == NULL)

	mov	ecx, DWORD PTR [esi+44]

; 6419 :     {
; 6420 :       assert(precinct == server->inactive_tail);
; 6421 :       server->inactive_tail = precinct->prev;

	mov	eax, DWORD PTR [esi+48]
	test	ecx, ecx
	jne	SHORT $LN4@withdraw_f
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR [ecx+20], eax

; 6422 :     }
; 6423 :   else

	jmp	SHORT $LN5@withdraw_f
$LN4@withdraw_f:

; 6424 :     precinct->next->prev = precinct->prev;

	mov	DWORD PTR [ecx+48], eax
$LN5@withdraw_f:

; 6425 :   precinct->flags &= ~KD_PFLAG_INACTIVE;

	and	DWORD PTR [esi+8], -33			; ffffffdfH
	pop	edi

; 6426 :     // precinct->inactive = false;
; 6427 :   precinct->prev = precinct->next = NULL;

	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	pop	esi

; 6428 : }

	pop	ebp
	ret	4
?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ENDP ; kd_precinct_size_class::withdraw_from_inactive_list
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?move_to_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z
_TEXT	SEGMENT
_precinct$ = 8						; size = 4
?move_to_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z PROC ; kd_precinct_size_class::move_to_inactive_list, COMDAT
; _this$ = ecx

; 6392 : {

	push	ebp
	mov	ebp, esp

; 6393 :   assert((precinct->prev == NULL) && (precinct->next == NULL) &&
; 6394 :          !(precinct->flags & KD_PFLAG_INACTIVE));
; 6395 :   precinct->flags |= KD_PFLAG_INACTIVE;

	mov	edx, DWORD PTR _precinct$[ebp]
	or	DWORD PTR [edx+8], 32			; 00000020H

; 6396 :     // precinct->inactive = true;
; 6397 :   if ((precinct->prev = server->inactive_tail) == NULL)

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+20]
	test	eax, eax
	mov	DWORD PTR [edx+48], eax

; 6398 :     server->inactive_head = server->inactive_tail = precinct;

	mov	eax, DWORD PTR [ecx]
	jne	SHORT $LN2@move_to_in
	mov	DWORD PTR [eax+20], edx
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [eax+16], edx

; 6401 : }

	pop	ebp
	ret	4
$LN2@move_to_in:

; 6399 :   else
; 6400 :     server->inactive_tail = server->inactive_tail->next = precinct;

	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [eax+44], edx
	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [eax+20], edx

; 6401 : }

	pop	ebp
	ret	4
?move_to_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ENDP ; kd_precinct_size_class::move_to_inactive_list
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?release@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z
_TEXT	SEGMENT
_precinct$ = 8						; size = 4
?release@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z PROC ; kd_precinct_size_class::release, COMDAT
; _this$ = ecx

; 4437 :       {

	push	ebp
	mov	ebp, esp
	push	esi

; 4438 :         if (precinct->flags & KD_PFLAG_INACTIVE)

	mov	esi, DWORD PTR _precinct$[ebp]
	push	edi
	mov	edi, ecx
	test	BYTE PTR [esi+8], 32			; 00000020H
	je	SHORT $LN2@release

; 4439 :           withdraw_from_inactive_list(precinct);

	push	esi
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list
$LN2@release:

; 4440 :         precinct->next = free_list;

	mov	eax, DWORD PTR [edi+32]
	mov	DWORD PTR [esi+44], eax

; 4441 :         free_list = precinct;
; 4442 :         buf_server->augment_structure_bytes(-alloc_bytes);

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [edi+32], esi
	neg	eax
	cdq

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	add	DWORD PTR [ecx+32], eax

; 281  :         if (structure_bytes > peak_structure_bytes)

	mov	eax, DWORD PTR [ecx+32]
	adc	DWORD PTR [ecx+36], edx
	mov	edx, DWORD PTR [ecx+36]
	pop	edi
	pop	esi
	cmp	edx, DWORD PTR [ecx+44]
	jl	SHORT $LN5@release
	jg	SHORT $LN7@release
	cmp	eax, DWORD PTR [ecx+40]
	jbe	SHORT $LN5@release
$LN7@release:

; 282  :           peak_structure_bytes = structure_bytes;

	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+44], edx
$LN5@release:

; 4443 :       }

	pop	ebp
	ret	4
?release@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ENDP ; kd_precinct_size_class::release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get@kd_precinct_size_class@@QAEPAUkd_precinct@@XZ
_TEXT	SEGMENT
?get@kd_precinct_size_class@@QAEPAUkd_precinct@@XZ PROC	; kd_precinct_size_class::get, COMDAT
; _this$ = ecx

; 4428 :       {

	push	esi
	mov	esi, ecx
	push	edi

; 4429 :         if (free_list == NULL)

	cmp	DWORD PTR [esi+32], 0
	jne	SHORT $LN2@get

; 4430 :           augment_free_list();

	call	?augment_free_list@kd_precinct_size_class@@AAEXXZ ; kd_precinct_size_class::augment_free_list
$LN2@get:

; 4431 :         kd_precinct *result = free_list; free_list = free_list->next;

	mov	edi, DWORD PTR [esi+32]
	mov	eax, DWORD PTR [edi+44]
	mov	DWORD PTR [esi+32], eax

; 4432 :         result->next = result->prev = NULL;

	mov	DWORD PTR [edi+48], 0
	mov	DWORD PTR [edi+44], 0

; 4433 :         buf_server->augment_structure_bytes(alloc_bytes);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+16]
	cdq

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	add	DWORD PTR [ecx+32], eax

; 281  :         if (structure_bytes > peak_structure_bytes)

	mov	eax, DWORD PTR [ecx+32]
	adc	DWORD PTR [ecx+36], edx
	mov	edx, DWORD PTR [ecx+36]
	cmp	edx, DWORD PTR [ecx+44]
	jl	SHORT $LN9@get
	jg	SHORT $LN7@get
	cmp	eax, DWORD PTR [ecx+40]
	jbe	SHORT $LN9@get
$LN7@get:

; 282  :           peak_structure_bytes = structure_bytes;

	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+44], edx
$LN9@get:

; 4434 :         return result;

	mov	eax, edi
	pop	edi
	pop	esi

; 4435 :       }

	ret	0
?get@kd_precinct_size_class@@QAEPAUkd_precinct@@XZ ENDP	; kd_precinct_size_class::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_precinct_size_class@@QAE@HHPAVkd_precinct_server@@PAVkd_buf_server@@@Z
_TEXT	SEGMENT
_max_blocks$ = 8					; size = 4
_num_subbands$ = 12					; size = 4
_server$ = 16						; size = 4
_buf_server$ = 20					; size = 4
??0kd_precinct_size_class@@QAE@HHPAVkd_precinct_server@@PAVkd_buf_server@@@Z PROC ; kd_precinct_size_class::kd_precinct_size_class, COMDAT
; _this$ = ecx

; 4407 :     kd_precinct_size_class(int max_blocks, int num_subbands,

	push	ebp
	mov	ebp, esp

; 4408 :                            kd_precinct_server *server,
; 4409 :                            kd_buf_server *buf_server)
; 4410 :       {
; 4411 :         this->max_blocks = max_blocks;
; 4412 :         this->num_subbands = num_subbands;

	mov	edx, DWORD PTR _num_subbands$[ebp]

; 4413 :         this->server = server;  this->buf_server = buf_server;

	mov	eax, DWORD PTR _server$[ebp]
	push	esi
	mov	esi, DWORD PTR _max_blocks$[ebp]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR _buf_server$[ebp]
	mov	DWORD PTR [edi+4], eax

; 4414 :         total_precincts = 0; free_list = NULL; next = NULL;
; 4415 :         alloc_bytes = (int) sizeof(kd_precinct);
; 4416 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4417 :         alloc_bytes += num_subbands * (int) sizeof(kd_precinct_band);

	lea	eax, DWORD PTR [edx+edx*2]
	lea	ecx, DWORD PTR [eax*8+56]
	mov	DWORD PTR [edi+12], edx

; 4418 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary

	mov	edx, ecx
	mov	DWORD PTR [edi+8], esi
	neg	edx
	mov	DWORD PTR [edi+24], 0
	and	edx, 7
	mov	DWORD PTR [edi+28], 0

; 4419 :         alloc_bytes += 4 + max_blocks * (int) sizeof(kd_block);

	lea	eax, DWORD PTR [esi+esi*2]
	mov	DWORD PTR [edi+32], 0
	lea	eax, DWORD PTR [eax*8+4]
	mov	DWORD PTR [edi+36], 0
	add	edx, ecx
	add	eax, edx
	mov	DWORD PTR [edi+16], eax

; 4420 :       }

	mov	eax, edi
	pop	edi
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??0kd_precinct_size_class@@QAE@HHPAVkd_precinct_server@@PAVkd_buf_server@@@Z ENDP ; kd_precinct_size_class::kd_precinct_size_class
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?handle_corrupt_packet@kd_precinct@@AAE_NXZ
_TEXT	SEGMENT
_e$2 = -36						; size = 20
_this$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?handle_corrupt_packet@kd_precinct@@AAE_NXZ PROC	; kd_precinct::handle_corrupt_packet, COMDAT
; _this$ = ecx

; 5756 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?handle_corrupt_packet@kd_precinct@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 24					; 00000018H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$1$[ebp], ecx

; 5757 :   if (flags & KD_PFLAG_ADDRESSABLE)

	test	BYTE PTR [ecx+8], 8
	je	SHORT $LN8@handle_cor

; 5758 :     { KDU_ERROR(e,36); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BEO@PKHFIGLM@Encountered?5a?5corrupted?5packet?5w@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5758 :     { KDU_ERROR(e,36); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5765 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _this$1$[ebp]
$LN8@handle_cor:

; 5766 : 
; 5767 :   kd_tile *tile = resolution->tile_comp->tile;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax+4]

; 5768 :   kd_codestream *codestream = tile->codestream;

	mov	edi, DWORD PTR [esi]

; 5769 :   bool expect_large_gap = !codestream->expect_ubiquitous_sops;

	cmp	BYTE PTR [edi+333], 0
	sete	bh

; 5774 : 
; 5775 :   flags |= KD_PFLAG_CORRUPTED;

	or	DWORD PTR [ecx+8], 2
$LN74@handle_cor:

; 5770 :       // It is reasonable to expect large (unbounded) gaps between valid
; 5771 :       // SOP marker sequence numbers if SOP markers are not known to be
; 5772 :       // in front of every packet.
; 5773 :   bool confirm_large_gap = expect_large_gap;

	mov	bl, bh
	npad	1
$LL4@handle_cor:

; 5776 :     // corrupted = true;
; 5777 :   do { // Read up to next valid SOP marker, if this has not already been done.
; 5778 :       if (!tile->skipping_to_sop)

	cmp	BYTE PTR [esi+256], 0
	jne	SHORT $LN9@handle_cor
	npad	7
$LL7@handle_cor:

; 5779 :         { // Need to read next SOP marker.
; 5780 :           do {
; 5781 :               if (!codestream->marker->read(true,true))

	mov	ecx, DWORD PTR [edi+16]
	push	1
	push	1
	call	?read@kd_marker@@QAE_N_N0@Z		; kd_marker::read
	test	al, al
	je	$LN58@handle_cor

; 5786 :                 }
; 5787 :               if (codestream->marker->get_code() == KDU_SOT)

	mov	eax, DWORD PTR [edi+16]
	mov	ecx, 65424				; 0000ff90H
	movzx	eax, WORD PTR [eax+8]
	cmp	ax, cx
	je	$LN60@handle_cor

; 5792 :                 }
; 5793 :             } while (codestream->marker->get_code() != KDU_SOP);

	mov	ecx, 65425				; 0000ff91H
	cmp	ax, cx
	jne	SHORT $LL7@handle_cor

; 5794 :           tile->next_sop_sequence_num = codestream->marker->get_bytes()[0];

	mov	eax, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [eax+20]
	movzx	ecx, BYTE PTR [eax]

; 5795 :           tile->next_sop_sequence_num<<=8;

	shl	ecx, 8
	mov	DWORD PTR [esi+260], ecx

; 5796 :           tile->next_sop_sequence_num += codestream->marker->get_bytes()[1];

	mov	eax, DWORD PTR [edi+16]
	mov	eax, DWORD PTR [eax+20]
	movzx	eax, BYTE PTR [eax+1]
	add	eax, ecx

; 5797 :           tile->skipping_to_sop = true;

	mov	BYTE PTR [esi+256], 1
	mov	DWORD PTR [esi+260], eax
$LN9@handle_cor:

; 438  :   int diff = sop_num - packet_num;

	mov	ecx, DWORD PTR [esi+260]
	mov	eax, ecx
	sub	eax, DWORD PTR [esi+252]

; 439  : 
; 440  :   if ((diff & 0x0000FFFF) == 0)

	movzx	edx, ax
	test	edx, edx
	je	$LN66@handle_cor

; 441  :     return 0;
; 442  :   if ((diff > 0) || ((diff & 0x0000FFFF) <= (1<<15)))

	test	eax, eax
	jg	SHORT $LN42@handle_cor
	cmp	edx, 32768				; 00008000H

; 444  :   else
; 445  :     return diff-(1<<16); // `sop_num' deemed to be less than `packet_num'.

	lea	edx, DWORD PTR [eax-65536]
	jg	SHORT $LN41@handle_cor
$LN42@handle_cor:

; 443  :     return diff; // `sop_num' deemed to be greater than `packet_num'.

	mov	edx, eax
$LN41@handle_cor:

; 5798 :         }
; 5799 :       assert(tile->skipping_to_sop);
; 5800 :       if (compare_sop_num(tile->next_sop_sequence_num,
; 5801 :                           tile->next_input_packet_num) <= 0)

	test	edx, edx
	jle	$LN66@handle_cor

; 439  : 
; 440  :   if ((diff & 0x0000FFFF) == 0)

	movzx	edx, ax
	test	edx, edx
	je	SHORT $LN14@handle_cor

; 441  :     return 0;
; 442  :   if ((diff > 0) || ((diff & 0x0000FFFF) <= (1<<15)))

	test	eax, eax
	jg	SHORT $LN47@handle_cor
	cmp	edx, 32768				; 00008000H
	jle	SHORT $LN47@handle_cor

; 444  :   else
; 445  :     return diff-(1<<16); // `sop_num' deemed to be less than `packet_num'.

	add	eax, -65536				; ffff0000H
$LN47@handle_cor:

; 5807 :                                 tile->next_input_packet_num) > 3) &&

	cmp	eax, 3
	jle	SHORT $LN14@handle_cor
	test	bl, bl
	jne	SHORT $LN14@handle_cor

; 5808 :                !confirm_large_gap)
; 5809 :         { // Unwilling to skip so many packets without confirmation that
; 5810 :           // the SOP sequence number itself has not been corrupted.
; 5811 :           tile->skipping_to_sop = false; // Skip another one to make sure.

	mov	BYTE PTR [esi+256], bl

; 5812 :           confirm_large_gap = true;

	mov	bl, 1

; 5813 :         }
; 5814 :       else if (compare_sop_num(tile->next_sop_sequence_num,

	jmp	$LL4@handle_cor
$LN14@handle_cor:

; 5815 :                                (int)(tile->total_precincts*tile->num_layers))
; 5816 :                                >= 0)

	mov	eax, DWORD PTR [esi+144]
	imul	eax, DWORD PTR [esi+132]

; 438  :   int diff = sop_num - packet_num;

	sub	ecx, eax

; 439  : 
; 440  :   if ((diff & 0x0000FFFF) == 0)

	movzx	eax, cx
	test	eax, eax
	je	SHORT $LN66@handle_cor

; 441  :     return 0;
; 442  :   if ((diff > 0) || ((diff & 0x0000FFFF) <= (1<<15)))

	test	ecx, ecx
	jg	SHORT $LN72@handle_cor
	cmp	eax, 32768				; 00008000H
	jle	SHORT $LN53@handle_cor

; 444  :   else
; 445  :     return diff-(1<<16); // `sop_num' deemed to be less than `packet_num'.

	add	ecx, -65536				; ffff0000H
$LN53@handle_cor:

; 5815 :                                (int)(tile->total_precincts*tile->num_layers))
; 5816 :                                >= 0)

	test	ecx, ecx
$LN72@handle_cor:
	jns	SHORT $LN66@handle_cor

; 5817 :         { // Assume that the SOP marker itself has a corrupt sequence number
; 5818 :           tile->skipping_to_sop = false; // Force hunt for another SOP marker.
; 5819 :           confirm_large_gap = expect_large_gap;
; 5820 :         }
; 5821 :     } while (!tile->skipping_to_sop);

	cmp	BYTE PTR [esi+256], 0
	je	$LL7@handle_cor

; 5822 : 
; 5823 :   // Update state to indicate a transferred packet.
; 5824 :   assert(num_packets_read < tile->num_layers);
; 5825 :   num_packets_read++;

	mov	eax, DWORD PTR _this$1$[ebp]
	inc	DWORD PTR [eax+20]

; 5826 :   return true;

	mov	al, 1

; 5827 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN66@handle_cor:

; 5802 :         { // If equal, the SOP marker must be for a previously corrupt precinct
; 5803 :           tile->skipping_to_sop = false; // Force hunt for another SOP marker.

	mov	BYTE PTR [esi+256], 0

; 5804 :           confirm_large_gap = expect_large_gap;
; 5805 :         }
; 5806 :       else if ((compare_sop_num(tile->next_sop_sequence_num,

	jmp	$LN74@handle_cor
$LN60@handle_cor:

; 5788 :                 { // We have encountered the end of the current tile-part.
; 5789 :                   codestream->active_tile = NULL;

	mov	DWORD PTR [edi+364], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2743 :         if ((!codestream->persistent) ||

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+337], 0
	je	SHORT $LN29@handle_cor
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN24@handle_cor
	cmp	BYTE PTR [eax+338], 0
	je	SHORT $LN29@handle_cor
$LN24@handle_cor:

; 2744 :             ((codestream->tpart_ptr_server==NULL) && !codestream->cached))
; 2745 :           { assert(!is_unloadable); return; }
; 2746 :         if (is_open || (this==codestream->active_tile))

	cmp	BYTE PTR [esi+229], 0
	jne	SHORT $LN28@handle_cor
	cmp	esi, DWORD PTR [eax+364]
	je	SHORT $LN28@handle_cor

; 2750 :           }
; 2751 :         else
; 2752 :           { // Should be on the unloadable list
; 2753 :             if (!is_unloadable)

	cmp	BYTE PTR [esi+230], 0
	jne	SHORT $LN29@handle_cor

; 2754 :               add_to_unloadable_list();

	mov	ecx, esi
	call	?add_to_unloadable_list@kd_tile@@AAEXXZ	; kd_tile::add_to_unloadable_list
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5791 :                   return false;

	xor	al, al

; 5827 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN28@handle_cor:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2748 :             if (is_unloadable)

	cmp	BYTE PTR [esi+230], 0
	je	SHORT $LN29@handle_cor

; 2749 :               withdraw_from_unloadable_list();

	mov	ecx, esi
	call	?withdraw_from_unloadable_list@kd_tile@@AAEXXZ ; kd_tile::withdraw_from_unloadable_list
$LN29@handle_cor:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5791 :                   return false;

	xor	al, al

; 5827 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN58@handle_cor:

; 5782 :                 { // Must have exhausted the code-stream.
; 5783 :                   assert(codestream->in->failed());
; 5784 :                   tile->finished_reading();

	mov	ecx, esi
	call	?finished_reading@kd_tile@@QAE_NXZ	; kd_tile::finished_reading

; 5785 :                   return false;

	xor	al, al

; 5827 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?handle_corrupt_packet@kd_precinct@@AAE_NXZ$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?handle_corrupt_packet@kd_precinct@@AAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-40]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?handle_corrupt_packet@kd_precinct@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?handle_corrupt_packet@kd_precinct@@AAE_NXZ ENDP	; kd_precinct::handle_corrupt_packet
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?read_packet@kd_precinct@@AAE_NXZ
_TEXT	SEGMENT
_e$2 = -136						; size = 20
_e$3 = -116						; size = 20
_e$4 = -116						; size = 20
_e$5 = -116						; size = 20
_e$6 = -116						; size = 20
_e$7 = -116						; size = 20
_e$8 = -116						; size = 20
_e$9 = -116						; size = 20
_e$10 = -116						; size = 20
_e$11 = -116						; size = 20
_e$12 = -116						; size = 20
_header$ = -96						; size = 16
_body_bytes$ = -80					; size = 8
_code$13 = -72						; size = 2
_code$14 = -68						; size = 2
_pband$1$ = -64						; size = 4
tv1373 = -64						; size = 4
_addr$1$ = -60						; size = 4
_b$1$ = -56						; size = 4
_pband$1$ = -56						; size = 4
tv1238 = -56						; size = 4
_buf_server$1$ = -52					; size = 4
_b$1$ = -52						; size = 4
_m$1$ = -48						; size = 4
_m$1$ = -48						; size = 4
_comp$ = -44						; size = 4
_codestream$ = -40					; size = 4
_n$1$ = -36						; size = 4
_seek_marker$ = -36					; size = 1
_header_source$ = -36					; size = 4
_header_bytes$ = -32					; size = 4
_this$ = -28						; size = 4
_tile$ = -24						; size = 4
_use_sop$1$ = -19					; size = 1
$T15 = -19						; size = 1
$T16 = -19						; size = 1
_byte$17 = -18						; size = 1
_use_eph$ = -18						; size = 1
_tpart_ends$1$ = -17					; size = 1
_suspend$ = -17						; size = 1
__$EHRec$ = -16						; size = 16
?read_packet@kd_precinct@@AAE_NXZ PROC			; kd_precinct::read_packet, COMDAT
; _this$ = ecx

; 5435 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read_packet@kd_precinct@@AAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR __$EHRec$[ebp], esp
	mov	esi, ecx
	mov	DWORD PTR _this$[ebp], esi

; 5436 :   if (num_packets_read < 0)

	cmp	DWORD PTR [esi+20], 0
	jl	$LN38@read_packe

; 5437 :     {
; 5438 :       assert(flags & KD_PFLAG_ADDRESSABLE);
; 5439 :       return false; // Saves excessive processing for addressable precincts
; 5440 :                     // with missing packets
; 5441 :     }
; 5442 : 
; 5443 :   kd_codestream *codestream = resolution->codestream;

	mov	eax, DWORD PTR [esi]

; 5444 :   kd_tile_comp *comp = resolution->tile_comp;
; 5445 :   kd_tile *tile = comp->tile;
; 5446 :   assert(num_packets_read < tile->num_layers);
; 5447 :   assert((flags & KD_PFLAG_ADDRESSABLE) || (tile == codestream->active_tile));
; 5448 : 
; 5449 :   bool use_sop = resolution->tile_comp->tile->use_sop;
; 5450 :   bool use_eph = resolution->tile_comp->tile->use_eph;
; 5451 :   bool tpart_ends = false;

	xor	dh, dh
	mov	BYTE PTR _tpart_ends$1$[ebp], dh
	mov	ebx, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _comp$[ebp], eax
	mov	DWORD PTR _codestream$[ebp], ebx
	mov	edi, DWORD PTR [eax+4]
	mov	eax, edi
	mov	DWORD PTR _tile$[ebp], edi
	mov	cl, BYTE PTR [eax+224]
	mov	al, BYTE PTR [eax+225]
	mov	BYTE PTR _use_sop$1$[ebp], cl
	mov	BYTE PTR _use_eph$[ebp], al

; 5452 :   bool seek_marker =
; 5453 :     use_sop && codestream->expect_ubiquitous_sops && codestream->resilient;

	test	cl, cl
	je	SHORT $LN86@read_packe
	cmp	BYTE PTR [ebx+333], dh
	je	SHORT $LN86@read_packe
	mov	BYTE PTR _seek_marker$[ebp], 1
	cmp	BYTE PTR [ebx+332], dh
	jne	SHORT $LN87@read_packe
$LN86@read_packe:
	mov	BYTE PTR _seek_marker$[ebp], 0
$LN87@read_packe:

; 5454 :   int header_bytes = 0;
; 5455 :   
; 5456 :   if ((flags & KD_PFLAG_CORRUPTED) ||

	test	BYTE PTR [esi+8], 2
	mov	DWORD PTR _header_bytes$[ebp], 0
	jne	$LN24@read_packe
	mov	dl, BYTE PTR [edi+256]
	test	dl, dl
	je	SHORT $LN210@read_packe

; 438  :   int diff = sop_num - packet_num;

	mov	eax, DWORD PTR [edi+260]
	sub	eax, DWORD PTR [edi+252]

; 439  : 
; 440  :   if ((diff & 0x0000FFFF) == 0)

	movzx	ecx, ax
	test	ecx, ecx
	je	SHORT $LN23@read_packe

; 441  :     return 0;
; 442  :   if ((diff > 0) || ((diff & 0x0000FFFF) <= (1<<15)))

	test	eax, eax
	jg	$LN24@read_packe
	cmp	ecx, 32768				; 00008000H
	jle	SHORT $LN120@read_packe

; 443  :     return diff; // `sop_num' deemed to be greater than `packet_num'.
; 444  :   else
; 445  :     return diff-(1<<16); // `sop_num' deemed to be less than `packet_num'.

	add	eax, -65536				; ffff0000H
$LN120@read_packe:

; 5454 :   int header_bytes = 0;
; 5455 :   
; 5456 :   if ((flags & KD_PFLAG_CORRUPTED) ||

	test	eax, eax
	jne	$LN24@read_packe
$LN23@read_packe:

; 5461 :   if (tile->skipping_to_sop)

	test	dl, dl
	je	SHORT $LN210@read_packe

; 5462 :     { // We have already read the SOP marker for this packet.
; 5463 :       assert(compare_sop_num(tile->next_sop_sequence_num,
; 5464 :                              tile->next_input_packet_num) == 0);
; 5465 :       tile->skipping_to_sop = false;

	mov	BYTE PTR [edi+256], 0

; 5466 :       header_bytes += 6; // Count the SOP marker

	mov	DWORD PTR _header_bytes$[ebp], 6

; 5467 :     }
; 5468 :   else

	jmp	SHORT $LN3@read_packe
$LN210@read_packe:

; 5469 :     while (codestream->marker->read(true,seek_marker))

	mov	edi, DWORD PTR _seek_marker$[ebp]
	mov	ecx, DWORD PTR [ebx+16]
	push	edi
	push	1
	call	?read@kd_marker@@QAE_N_N0@Z		; kd_marker::read
	test	al, al
	je	SHORT $LN241@read_packe
	mov	DWORD PTR tv1238[ebp], 65424		; 0000ff90H
	npad	6
$LL2@read_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	mov	edx, DWORD PTR [ebx+16]
	movzx	ecx, WORD PTR [edx+8]
	mov	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5471 :         if (codestream->marker->get_code() == KDU_SOT)

	cmp	ax, WORD PTR tv1238[ebp]
	je	$LN217@read_packe

; 5473 :         else if (use_sop &&

	cmp	BYTE PTR _use_sop$1$[ebp], 0
	je	SHORT $LN29@read_packe
	mov	ecx, 65425				; 0000ff91H
	cmp	ax, cx
	je	SHORT $LN218@read_packe
$LN29@read_packe:

; 5502 :                         return handle_corrupt_packet();
; 5503 :                       }
; 5504 :                   }
; 5505 :               }
; 5506 :             break;
; 5507 :           }
; 5508 :         else if (!seek_marker) // If `seek_marker' is true we will loop back

	cmp	BYTE PTR _seek_marker$[ebp], 0
	je	$LN219@read_packe

; 5469 :     while (codestream->marker->read(true,seek_marker))

	push	edi
	push	1
	mov	ecx, edx
	call	?read@kd_marker@@QAE_N_N0@Z		; kd_marker::read
	test	al, al
	jne	SHORT $LL2@read_packe
$LN241@read_packe:
	mov	edi, DWORD PTR _tile$[ebp]
$LN246@read_packe:
	mov	dh, BYTE PTR _tpart_ends$1$[ebp]
$LN3@read_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 528  :         return exhausted;

	mov	ecx, DWORD PTR [ebx+4]
	mov	al, BYTE PTR [ecx+533]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5523 :   if (codestream->in->failed())

	test	al, al
	je	$LN37@read_packe

; 5524 :     {
; 5525 :       tile->finished_reading();

	mov	ecx, edi
	call	?finished_reading@kd_tile@@QAE_NXZ	; kd_tile::finished_reading

; 5526 :       if ((num_packets_read == 0) && (flags & KD_PFLAG_ADDRESSABLE))

	cmp	DWORD PTR [esi+20], 0
	jne	SHORT $LN38@read_packe
	test	BYTE PTR [esi+8], 8
	je	SHORT $LN38@read_packe

; 5527 :         num_packets_read = -1; // Saves coming back here time and time again

	mov	DWORD PTR [esi+20], -1
$LN38@read_packe:

; 5528 :                    // for addressable precincts with all packets missing
; 5529 :       return false;

	xor	al, al

; 5748 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN218@read_packe:

; 5474 :                  (codestream->marker->get_code() == KDU_SOP))
; 5475 :           { // Found the required SOP segment
; 5476 :             if (!(flags & KD_PFLAG_ADDRESSABLE))

	test	BYTE PTR [esi+8], 8
	jne	SHORT $LN241@read_packe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 888  :     kdu_byte *get_bytes() { return buf; }

	mov	eax, DWORD PTR [edx+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5483 :                                     tile->next_input_packet_num) != 0)

	mov	edx, DWORD PTR _tile$[ebp]
	mov	DWORD PTR _header_bytes$[ebp], 6
	movzx	edi, BYTE PTR [eax+1]
	movzx	eax, BYTE PTR [eax]
	push	DWORD PTR [edx+252]
	shl	eax, 8
	add	edi, eax
	push	edi
	call	?compare_sop_num@@YAHHH@Z		; compare_sop_num
	add	esp, 8
	test	eax, eax
	je	$LN240@read_packe

; 5484 :                   {
; 5485 :                     if (!codestream->resilient)

	cmp	BYTE PTR [ebx+332], 0
	jne	$LN33@read_packe

; 5486 :                       { KDU_ERROR(e,25);

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$12[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	OFFSET ??_C@_0FK@HALGFJID@Out?9of?9sequence?5SOP?5marker?5found@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5486 :                       { KDU_ERROR(e,25);

	mov	DWORD PTR __$EHRec$[ebp+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	OFFSET ??_C@_0BI@NMKGFPMC@?7Found?5sequence?5number?5?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5494 :                           << ".\n";

	push	edi
	lea	ecx, DWORD PTR _e$12[ebp]
	call	??6kdu_message@@QAEAAV0@H@Z		; kdu_message::operator<<
	mov	esi, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0BA@BNNPLEHB@?0?5but?5expected?5?$AA@
	mov	ecx, esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5494 :                           << ".\n";

	mov	edi, DWORD PTR _tile$[ebp]
	mov	ecx, esi
	movzx	eax, WORD PTR [edi+252]
	push	eax
	call	??6kdu_message@@QAEAAV0@H@Z		; kdu_message::operator<<
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_02MIICKFIN@?4?6?$AA@
	mov	ecx, eax
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]
	mov	eax, DWORD PTR _e$12[ebp]
	lea	ecx, DWORD PTR _e$12[ebp]
	push	OFFSET ??_C@_0EO@IEHAKBJH@Use?5the?5resilient?5option?5if?5you?5@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5497 :                       }

	lea	ecx, DWORD PTR _e$12[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error

; 5498 :                     else

	mov	esi, DWORD PTR _this$[ebp]
	jmp	$LN246@read_packe
$LN33@read_packe:

; 5499 :                       {
; 5500 :                         tile->skipping_to_sop = true;

	mov	BYTE PTR [edx+256], 1

; 5501 :                         tile->next_sop_sequence_num = sequence_num;

	mov	DWORD PTR [edx+260], edi
$LN24@read_packe:

; 5457 :       (tile->skipping_to_sop &&
; 5458 :        (compare_sop_num(tile->next_sop_sequence_num,
; 5459 :                         tile->next_input_packet_num) != 0)))
; 5460 :     return handle_corrupt_packet();

	mov	ecx, esi
$LN253@read_packe:
	call	?handle_corrupt_packet@kd_precinct@@AAE_NXZ ; kd_precinct::handle_corrupt_packet

; 5748 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN219@read_packe:

; 5509 :           { 
; 5510 :             if (!codestream->resilient)

	cmp	BYTE PTR [ebx+332], 0
	jne	SHORT $LN24@read_packe

; 5511 :               { KDU_ERROR(e,26);

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$11[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_0FD@LOABHKKD@Illegal?5marker?5code?5found?5while?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5511 :               { KDU_ERROR(e,26);

	mov	DWORD PTR __$EHRec$[ebp+12], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_0BJ@HMCGKOMP@?7Illegal?5marker?5code?5is?5?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5515 :                 codestream->marker->print_current_code(e); e << ".\n";

	mov	eax, DWORD PTR [ebx+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 851  :         print_marker_code(this->code,out);

	lea	ecx, DWORD PTR _e$11[ebp]
	push	ecx
	movzx	eax, WORD PTR [eax+8]
	push	eax
	call	?print_marker_code@@YAXGAAVkdu_message@@@Z ; print_marker_code
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 851  :         print_marker_code(this->code,out);

	add	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_02MIICKFIN@?4?6?$AA@
	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$11[ebp]
	lea	ecx, DWORD PTR _e$11[ebp]
	push	OFFSET ??_C@_0EO@IEHAKBJH@Use?5the?5resilient?5option?5if?5you?5@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5518 :               }

	lea	ecx, DWORD PTR _e$11[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error

; 5519 :             return handle_corrupt_packet();

	jmp	$LN24@read_packe
$LN217@read_packe:
	mov	edi, DWORD PTR _tile$[ebp]

; 5472 :           { tpart_ends = true; break; }

	mov	dh, 1
	jmp	$LN3@read_packe
$LN240@read_packe:
	mov	dh, BYTE PTR _tpart_ends$1$[ebp]
	mov	edi, DWORD PTR _tile$[ebp]
	jmp	$LN3@read_packe
$LN37@read_packe:

; 5530 :     }
; 5531 : 
; 5532 :   if (tpart_ends)

	test	dh, dh
	je	SHORT $LN39@read_packe

; 5533 :     {
; 5534 :       codestream->active_tile = NULL;
; 5535 :       tile->adjust_unloadability();

	mov	ecx, edi
	mov	DWORD PTR [ebx+364], 0
	call	?adjust_unloadability@kd_tile@@QAEXXZ	; kd_tile::adjust_unloadability

; 5536 :       return false;

	xor	al, al

; 5748 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@read_packe:

; 5537 :     }
; 5538 : 
; 5539 :   // Now read the packet header.
; 5540 :   bool suspend = codestream->simulate_parsing_while_counting_bytes &&

	cmp	BYTE PTR [ebx+336], 0
	je	SHORT $LN89@read_packe
	mov	eax, DWORD PTR [esi+20]
	cmp	eax, DWORD PTR [esi+12]
	jge	SHORT $LN88@read_packe
	test	BYTE PTR [esi+8], 64			; 00000040H
	jne	SHORT $LN89@read_packe
$LN88@read_packe:

; 5541 :     ((num_packets_read >= required_layers) || !(flags & KD_PFLAG_RELEVANT));
; 5542 :   if (suspend)
; 5543 :     codestream->in->set_suspend(true);

	push	1
	mov	BYTE PTR _suspend$[ebp], 1
	call	?set_suspend@kd_compressed_input@@QAEX_N@Z ; kd_compressed_input::set_suspend
	jmp	SHORT $LN40@read_packe
$LN89@read_packe:

; 5537 :     }
; 5538 : 
; 5539 :   // Now read the packet header.
; 5540 :   bool suspend = codestream->simulate_parsing_while_counting_bytes &&

	mov	BYTE PTR _suspend$[ebp], 0
$LN40@read_packe:

; 5544 : 
; 5545 :   kd_input *header_source = tile->packed_headers;

	mov	edi, DWORD PTR [edi+48]
	mov	DWORD PTR _header_source$[ebp], edi

; 5546 :   if (header_source == NULL)

	test	edi, edi
	jne	SHORT $LN41@read_packe

; 5547 :     header_source = codestream->in;

	mov	edi, DWORD PTR [ebx+4]
	mov	DWORD PTR _header_source$[ebp], edi
$LN41@read_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3498 :       { this->source = source; bits_left=0; byte=0; header_bytes=0; }

	mov	DWORD PTR _header$[ebp], edi
	xorps	xmm0, xmm0
	mov	DWORD PTR _header$[ebp+8], 0
	mov	BYTE PTR _header$[ebp+4], 0
	mov	DWORD PTR _header$[ebp+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5550 :   if (codestream->resilient)

	cmp	BYTE PTR [ebx+332], 0
	movlpd	QWORD PTR _body_bytes$[ebp], xmm0
	je	SHORT $LN42@read_packe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 505  :         this->reject_all = reject_all; throw_markers = true; have_FF = false;

	mov	WORD PTR [edi+535], 0

; 506  :       }

	jmp	SHORT $LN248@read_packe
$LN42@read_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5552 :   else if (codestream->fussy)

	cmp	BYTE PTR [ebx+334], 0
	je	SHORT $LN44@read_packe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 505  :         this->reject_all = reject_all; throw_markers = true; have_FF = false;

	mov	WORD PTR [edi+535], 256			; 00000100H
$LN248@read_packe:
	mov	BYTE PTR [edi+534], 1
$LN44@read_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5555 :       if (header.get_bit() != 0)

	lea	ecx, DWORD PTR _header$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], 2
	call	?get_bit@kd_header_in@@QAEHXZ		; kd_header_in::get_bit
	test	eax, eax
	je	SHORT $LN5@read_packe

; 5556 :         for (int b=0; b < resolution->num_subbands; b++)

	mov	edx, DWORD PTR _this$[ebp]
	xor	esi, esi
$LN250@read_packe:
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _b$1$[ebp], esi
	movzx	eax, BYTE PTR [eax+174]
	cmp	esi, eax
	jge	SHORT $LN242@read_packe

; 5557 :           {
; 5558 :             kd_precinct_band *pband = subbands + b;

	mov	eax, DWORD PTR [edx+40]
	lea	ecx, DWORD PTR [esi+esi*2]

; 5559 :             kd_block *block = pband->blocks;

	mov	edi, DWORD PTR [eax+ecx*8+20]
	lea	ecx, DWORD PTR [eax+ecx*8]

; 5560 :             for (int m=pband->block_indices.size.y; m > 0; m--)

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _pband$1$[ebp], ecx
$LN249@read_packe:
	mov	DWORD PTR _m$1$[ebp], eax
	test	eax, eax
	jle	SHORT $LN4@read_packe

; 5561 :               for (int n=pband->block_indices.size.x; n > 0; n--, block++)

	mov	esi, DWORD PTR [ecx+16]
$LL12@read_packe:
	test	esi, esi
	jle	SHORT $LN7@read_packe

; 5562 :                 body_bytes +=

	push	DWORD PTR [edx+20]
	lea	eax, DWORD PTR _header$[ebp]
	mov	ecx, edi
	push	DWORD PTR [ebx+24]
	push	eax
	call	?parse_packet_header@kd_block@@QAEHAAVkd_header_in@@PAVkd_buf_server@@H@Z ; kd_block::parse_packet_header
	cdq
	add	DWORD PTR _body_bytes$[ebp], eax
	adc	DWORD PTR _body_bytes$[ebp+4], edx
	dec	esi
	mov	edx, DWORD PTR _this$[ebp]
	add	edi, 24					; 00000018H
	jmp	SHORT $LL12@read_packe
$LN7@read_packe:

; 5560 :             for (int m=pband->block_indices.size.y; m > 0; m--)

	mov	eax, DWORD PTR _m$1$[ebp]
	mov	ecx, DWORD PTR _pband$1$[ebp]
	dec	eax
	jmp	SHORT $LN249@read_packe
$LN4@read_packe:

; 5556 :         for (int b=0; b < resolution->num_subbands; b++)

	mov	esi, DWORD PTR _b$1$[ebp]
	inc	esi
	jmp	SHORT $LN250@read_packe
$LN242@read_packe:
	mov	edi, DWORD PTR _header_source$[ebp]
$LN5@read_packe:

; 5563 :                   block->parse_packet_header(header,codestream->buf_server,
; 5564 :                                              num_packets_read);
; 5565 :           }
; 5566 :       header_bytes += header.finish(); // Clears any terminal FF

	lea	ecx, DWORD PTR _header$[ebp]
	call	?finish@kd_header_in@@QAEHXZ		; kd_header_in::finish
	add	DWORD PTR _header_bytes$[ebp], eax
	jmp	$LN251@read_packe
__catch$?read_packet@kd_precinct@@AAE_NXZ$0:

; 5567 :     }
; 5568 :   catch (kd_header_in *)
; 5569 :     { // Insufficient header bytes in source.
; 5570 :       if (header_source == tile->packed_headers)

	mov	esi, DWORD PTR _tile$[ebp]
	mov	eax, DWORD PTR _header_source$[ebp]
	cmp	eax, DWORD PTR [esi+48]
	jne	SHORT $LN47@read_packe

; 5573 :           KDU_ERROR(e,27); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$10[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_0FB@NMDJGOOL@Exhausted?5PPM?1PPT?5marker?5segment@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5573 :           KDU_ERROR(e,27); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5576 :         }

	lea	ecx, DWORD PTR _e$10[ebp]
	mov	BYTE PTR __$EHRec$[ebp+12], 3
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN47@read_packe:

; 5577 :       assert(codestream->in->failed());
; 5578 :       tile->finished_reading();

	mov	ecx, esi
	call	?finished_reading@kd_tile@@QAE_NXZ	; kd_tile::finished_reading

; 5579 :       if ((num_packets_read == 0) && (flags & KD_PFLAG_ADDRESSABLE))

	mov	eax, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [eax+20], 0
	jne	SHORT $LN48@read_packe
	test	BYTE PTR [eax+8], 8
	je	SHORT $LN48@read_packe

; 5580 :         num_packets_read = -1; // Saves coming back here again for addressable

	mov	DWORD PTR [eax+20], -1
$LN48@read_packe:

; 5581 :                                // precincts with all packets missing
; 5582 :       if (suspend)

	cmp	BYTE PTR _suspend$[ebp], 0
	je	SHORT $LN49@read_packe

; 5583 :         codestream->in->set_suspend(false);

	mov	ecx, DWORD PTR _codestream$[ebp]
	push	0
	mov	ecx, DWORD PTR [ecx+4]
	call	?set_suspend@kd_compressed_input@@QAEX_N@Z ; kd_compressed_input::set_suspend
$LN49@read_packe:

; 5584 :       return false;

	mov	eax, $LN38@read_packe
	ret	0
__catch$?read_packet@kd_precinct@@AAE_NXZ$1:

; 5585 :     }
; 5586 :   catch (kdu_uint16 code)
; 5587 :     {
; 5588 :       if (codestream->resilient && (header_source == codestream->in))

	mov	eax, DWORD PTR _codestream$[ebp]
	cmp	BYTE PTR [eax+332], 0
	je	SHORT $LN50@read_packe
	mov	ecx, DWORD PTR [eax+4]
	cmp	DWORD PTR _header_source$[ebp], ecx
	jne	SHORT $LN50@read_packe

; 5589 :         { // Assume that all exceptions arise as a result of corruption.
; 5590 :           if (suspend)

	cmp	BYTE PTR _suspend$[ebp], 0
	je	SHORT $LN52@read_packe

; 5591 :             codestream->in->set_suspend(false);

	push	0
	call	?set_suspend@kd_compressed_input@@QAEX_N@Z ; kd_compressed_input::set_suspend
$LN52@read_packe:

; 5592 :           return handle_corrupt_packet();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?handle_corrupt_packet@kd_precinct@@AAE_NXZ ; kd_precinct::handle_corrupt_packet
	mov	BYTE PTR $T16[ebp], al
	mov	eax, $LN110@read_packe
	ret	0
$LN110@read_packe:
	mov	al, BYTE PTR $T16[ebp]

; 5748 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN50@read_packe:

; 5593 :         }
; 5594 :       else if (code == KDU_EXCEPTION_PRECISION)

	mov	esi, DWORD PTR _code$14[ebp]

; 5595 :         { KDU_ERROR(e,28); e <<

	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
	cmp	si, 13					; 0000000dH
	jne	SHORT $LN53@read_packe
	mov	BYTE PTR __$EHRec$[ebp+12], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0BDO@LLBNLAKJ@Packet?5header?5contains?5a?5represe@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5602 :         }

	jmp	SHORT $LN252@read_packe
$LN53@read_packe:

; 5603 :       else if (code == KDU_EXCEPTION_ILLEGAL_LAYER)

	cmp	si, 21					; 00000015H
	jne	SHORT $LN55@read_packe

; 5604 :         { KDU_ERROR(e,29); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0CBL@LGBHIIBA@Illegal?5inclusion?5tag?5tree?5encou@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5615 :         }

	jmp	SHORT $LN252@read_packe
$LN55@read_packe:

; 5616 :       else if (code == KDU_EXCEPTION_ILLEGAL_MISSING_MSBS)

	cmp	si, 74					; 0000004aH
	jne	SHORT $LN57@read_packe

; 5617 :         { KDU_ERROR(e,30); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0BAA@PKDCKLHJ@Illegal?5number?5of?5missing?5MSB?8s?5@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5624 :       else

	jmp	SHORT $LN252@read_packe
$LN57@read_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$6[ebp]
	lea	ecx, DWORD PTR _e$6[ebp]
	push	OFFSET ??_C@_0BG@OOKLLMMG@Illegal?5marker?5code?0?5?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5625 :         { KDU_ERROR(e,31); e << KDU_TXT("Illegal marker code, ");

	mov	BYTE PTR __$EHRec$[ebp+12], 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5626 :           print_marker_code(code,e); e <<

	lea	eax, DWORD PTR _e$6[ebp]
	push	eax
	push	esi
	call	?print_marker_code@@YAXGAAVkdu_message@@@Z ; print_marker_code
	add	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0GA@NALIOIEH@?0?5found?5while?5reading?5packet?5hea@
$LN252@read_packe:
	mov	eax, DWORD PTR _e$6[ebp]
	lea	ecx, DWORD PTR _e$6[ebp]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5629 :         }

	lea	ecx, DWORD PTR _e$6[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error

; 5630 :     }

	mov	eax, $LN112@read_packe
	ret	0
$LN112@read_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
	mov	ebx, DWORD PTR _codestream$[ebp]
	mov	edi, DWORD PTR _header_source$[ebp]
$LN251@read_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5631 :   if (!header_source->disable_marker_throwing())

	mov	ecx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	?disable_marker_throwing@kd_input@@QAE_NXZ ; kd_input::disable_marker_throwing
	cmp	BYTE PTR _use_eph$[ebp], 0
	je	$LN60@read_packe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5632 :     {
; 5633 :       assert(0); // If this happens, `header.finish()' did not execute properly
; 5634 :     }
; 5635 : 
; 5636 :   // Next, read any required EPH marker.
; 5637 : 
; 5638 :   if (use_eph)
; 5639 :     {
; 5640 :       kdu_byte byte;
; 5641 :       kdu_uint16 code;
; 5642 : 
; 5643 :       code = 0;
; 5644 :       if (header_source->get(byte))

	lea	eax, DWORD PTR _byte$17[ebp]
	mov	ecx, edi
	push	eax
	xor	esi, esi
	call	?get@kd_input@@QAE_NAAE@Z		; kd_input::get
	test	al, al
	je	SHORT $LN61@read_packe

; 5645 :         code = byte;

	movzx	esi, BYTE PTR _byte$17[ebp]
$LN61@read_packe:

; 5646 :       if (header_source->get(byte))

	lea	eax, DWORD PTR _byte$17[ebp]
	mov	ecx, edi
	push	eax
	call	?get@kd_input@@QAE_NAAE@Z		; kd_input::get
	test	al, al
	je	SHORT $LN62@read_packe

; 5647 :         code = (code<<8) + byte;

	movzx	eax, BYTE PTR _byte$17[ebp]
	shl	esi, 8
	add	si, ax
	movzx	esi, si
$LN62@read_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 528  :         return exhausted;

	mov	al, BYTE PTR [edi+533]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5648 :       if (header_source->failed())

	test	al, al
	je	SHORT $LN63@read_packe

; 5649 :         {
; 5650 :           if (header_source == tile->packed_headers)

	mov	esi, DWORD PTR _tile$[ebp]
	cmp	edi, DWORD PTR [esi+48]
	jne	SHORT $LN64@read_packe

; 5653 :               KDU_ERROR(e,32); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0FB@NMDJGOOL@Exhausted?5PPM?1PPT?5marker?5segment@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5653 :               KDU_ERROR(e,32); e <<

	mov	DWORD PTR __$EHRec$[ebp+12], 9
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5656 :             }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN64@read_packe:

; 5657 :           assert(codestream->in->failed());
; 5658 :           tile->finished_reading();

	mov	ecx, esi
	call	?finished_reading@kd_tile@@QAE_NXZ	; kd_tile::finished_reading

; 5659 :           if ((num_packets_read == 0) && (flags & KD_PFLAG_ADDRESSABLE))

	mov	ecx, DWORD PTR _this$[ebp]
	cmp	DWORD PTR [ecx+20], 0
	jne	SHORT $LN65@read_packe
	test	BYTE PTR [ecx+8], 8
	je	SHORT $LN65@read_packe

; 5660 :             num_packets_read = -1; // Saves coming back here again for

	mov	DWORD PTR [ecx+20], -1
$LN65@read_packe:

; 5661 :                       // addressable precincts with all packets missing
; 5662 :           if (suspend)

	cmp	BYTE PTR _suspend$[ebp], 0
	je	$LN38@read_packe

; 5663 :             codestream->in->set_suspend(false);

	mov	ecx, DWORD PTR [ebx+4]
	push	0
	call	?set_suspend@kd_compressed_input@@QAEX_N@Z ; kd_compressed_input::set_suspend

; 5664 :           return false;

	xor	al, al

; 5748 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN63@read_packe:

; 5665 :         }
; 5666 :       if (code != KDU_EPH)

	mov	eax, 65426				; 0000ff92H
	cmp	si, ax
	je	SHORT $LN69@read_packe

; 5667 :         {
; 5668 :           if (codestream->resilient && (header_source == codestream->in))

	cmp	BYTE PTR [ebx+332], 0
	je	SHORT $LN68@read_packe
	mov	ecx, DWORD PTR [ebx+4]
	cmp	edi, ecx
	jne	SHORT $LN68@read_packe

; 5669 :             { // Missing EPH is a clear indicator of corruption.
; 5670 :               if (suspend)

	cmp	BYTE PTR _suspend$[ebp], 0
	je	SHORT $LN70@read_packe

; 5671 :                 codestream->in->set_suspend(false);

	push	0
	call	?set_suspend@kd_compressed_input@@QAEX_N@Z ; kd_compressed_input::set_suspend
$LN70@read_packe:

; 5672 :               return handle_corrupt_packet();

	mov	ecx, DWORD PTR _this$[ebp]
	jmp	$LN253@read_packe
$LN68@read_packe:

; 5675 :             { KDU_ERROR(e,33); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$4[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
	push	OFFSET ??_C@_0DN@IEKEFHF@Expected?5to?5find?5EPH?5marker?5foll@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5675 :             { KDU_ERROR(e,33); e <<

	mov	DWORD PTR __$EHRec$[ebp+12], 10		; 0000000aH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5678 :               print_marker_code(code,e);

	lea	eax, DWORD PTR _e$4[ebp]
	push	eax
	push	esi
	call	?print_marker_code@@YAXGAAVkdu_message@@@Z ; print_marker_code
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$4[ebp]
	lea	ecx, DWORD PTR _e$4[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5678 :               print_marker_code(code,e);

	add	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_09LNCLJGMF@?5instead?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5680 :             }

	lea	ecx, DWORD PTR _e$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN69@read_packe:

; 5681 :         }
; 5682 :       header_bytes += 2; // Count the EPH marker

	add	DWORD PTR _header_bytes$[ebp], 2
$LN60@read_packe:

; 5683 :     }
; 5684 : 
; 5685 :   // Finally, read the body bytes.
; 5686 : 
; 5687 :   if (body_bytes > 0)

	mov	esi, DWORD PTR _body_bytes$[ebp+4]
	test	esi, esi
	jl	$LN238@read_packe
	jg	SHORT $LN236@read_packe
	mov	edi, DWORD PTR _body_bytes$[ebp]
	test	edi, edi
	je	$LN115@read_packe
$LN236@read_packe:

; 5688 :     {
; 5689 :       if (codestream->resilient)

	cmp	BYTE PTR [ebx+332], 0
	je	SHORT $LN72@read_packe

; 5690 :         codestream->in->enable_marker_throwing();

	mov	eax, DWORD PTR [ebx+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 505  :         this->reject_all = reject_all; throw_markers = true; have_FF = false;

	mov	WORD PTR [eax+535], 0

; 506  :       }

	jmp	SHORT $LN254@read_packe
$LN72@read_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5691 :       else if (codestream->fussy)

	cmp	BYTE PTR [ebx+334], 0
	je	SHORT $LN74@read_packe

; 5692 :         codestream->in->enable_marker_throwing(true);

	mov	eax, DWORD PTR [ebx+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 505  :         this->reject_all = reject_all; throw_markers = true; have_FF = false;

	mov	WORD PTR [eax+535], 256			; 00000100H
$LN254@read_packe:
	mov	BYTE PTR [eax+534], 1
$LN74@read_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5693 :       try {

	mov	DWORD PTR __$EHRec$[ebp+12], 11		; 0000000bH

; 5694 :           for (int b=0; b < resolution->num_subbands; b++)

	xor	edi, edi
$LN257@read_packe:
	mov	edx, DWORD PTR _this$[ebp]
	mov	DWORD PTR _b$1$[ebp], edi
	mov	eax, DWORD PTR [edx]
	movzx	eax, BYTE PTR [eax+174]
	cmp	edi, eax
	jge	$LN14@read_packe

; 5695 :             {
; 5696 :               kd_precinct_band *pband = subbands + b;

	mov	eax, DWORD PTR [edx+40]
	lea	ecx, DWORD PTR [edi+edi*2]

; 5697 :               kd_block *block = pband->blocks;

	mov	esi, DWORD PTR [eax+ecx*8+20]
	lea	ecx, DWORD PTR [eax+ecx*8]

; 5698 :               for (int m=pband->block_indices.size.y; m > 0; m--)

	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _pband$1$[ebp], ecx
$LN256@read_packe:
	mov	DWORD PTR _m$1$[ebp], eax
	test	eax, eax
	jle	$LN13@read_packe

; 5699 :                 for (int n=pband->block_indices.size.x; n > 0; n--, block++)

	mov	edi, DWORD PTR [ecx+16]
$LN255@read_packe:
	mov	DWORD PTR _n$1$[ebp], edi
	test	edi, edi
	jle	$LN16@read_packe

; 5700 :                   block->read_body_bytes(codestream->in,

	mov	eax, DWORD PTR [ebx+24]
	mov	dl, BYTE PTR [ebx+339]
	mov	ecx, DWORD PTR [ebx+4]
	mov	DWORD PTR _buf_server$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3644 :         if (this->temp_length > 0)

	movzx	eax, WORD PTR [esi+18]
	test	ax, ax
	je	$LN19@read_packe

; 3645 :           {
; 3646 :             if (num_passes == 255)

	cmp	BYTE PTR [esi+10], 255			; 000000ffH
	jne	SHORT $LN185@read_packe

; 3647 :               { // Read and discard the code-bytes.
; 3648 :                 assert(first_buf == NULL);  source->ignore(this->temp_length);

	mov	edi, DWORD PTR [ecx]
	cdq
	push	edx
	push	eax
	call	DWORD PTR [edi+4]
	mov	edi, DWORD PTR _n$1$[ebp]

; 3659 :             this->temp_length = 0;

	xor	eax, eax
	mov	WORD PTR [esi+18], ax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5699 :                 for (int n=pband->block_indices.size.x; n > 0; n--, block++)

	dec	edi
	add	esi, 24					; 00000018H
	jmp	SHORT $LN255@read_packe
$LN185@read_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3650 :             else if (in_memory_source)

	test	dl, dl
	je	$LN187@read_packe

; 579  :         if (throw_markers)

	cmp	BYTE PTR [ecx+534], 0

; 3651 :               {
; 3652 :                 kdu_byte *addr;
; 3653 :                 this->num_bytes += source->pseudo_read(addr,this->temp_length);

	mov	edx, eax

; 555  :           }
; 556  :       }
; 557  :     void putback(kdu_uint16 code)
; 558  :       { /* This function is designed to improve the readability of code
; 559  :            which puts marker codes back to the input object from which they
; 560  :            were read. */
; 561  :         assert(!exhausted);
; 562  :         assert(!throw_markers);
; 563  :         first_unread-=2;
; 564  :         if (!fully_buffered)
; 565  :           {
; 566  :             assert(first_unread >= buffer);
; 567  :             first_unread[0] = (kdu_byte)(code>>8);
; 568  :             first_unread[1] = (kdu_byte) code;
; 569  :           }
; 570  :       }
; 571  :     int pseudo_read(kdu_byte * &addr, int count)
; 572  :       { /* This function should be called only for `fully_buffered' sources.
; 573  :            It behaves like `read', except that it does not actually read
; 574  :            any bytes.  Instead, it puts the address of the block of data
; 575  :            that would have been read into the variable referenced by the
; 576  :            `addr' argument. */
; 577  :         assert(fully_buffered);
; 578  :         addr = first_unread;

	mov	edi, DWORD PTR [ecx+524]
	mov	DWORD PTR _addr$1$[ebp], edi

; 579  :         if (throw_markers)

	je	SHORT $LN191@read_packe

; 580  :           return read(addr,count); // Slower path, looks for markers

	push	edx
	push	edi
	call	?read@kd_input@@QAEHPAEH@Z		; kd_input::read
	mov	edx, eax
	jmp	SHORT $LN190@read_packe
$LN191@read_packe:

; 581  :         first_unread += count;
; 582  :         if (first_unread > first_unwritten)

	mov	eax, DWORD PTR [ecx+528]
	add	edi, edx
	mov	DWORD PTR [ecx+524], edi
	cmp	edi, eax
	jbe	SHORT $LN192@read_packe

; 583  :           {
; 584  :             count -= (int)(first_unread - first_unwritten);

	sub	eax, edi

; 585  :             first_unread = first_unwritten; exhausted = true;

	mov	BYTE PTR [ecx+533], 1
	add	edx, eax
	mov	eax, DWORD PTR [ecx+528]
	mov	DWORD PTR [ecx+524], eax
$LN192@read_packe:
	mov	edi, DWORD PTR _addr$1$[ebp]
$LN190@read_packe:

; 3660 :           }
; 3661 :       }
; 3662 :     void retrieve_data(kdu_block *block, int max_layers, int discard_passes,
; 3663 :                        bool in_memory_source);
; 3664 :       /* Retrieves compressed code-bytes, number of coding passes and codeword
; 3665 :          segment lengths from the current code-block and stores them in the
; 3666 :          `block' object.  All fields which are common for compression and
; 3667 :          decompression have already been filled out by the caller.  The
; 3668 :          byte buffer is allocated so as to be large enough to allow a
; 3669 :          2 byte marker code to be appended to the compressed data,
; 3670 :          if desired -- see declaration of "kdu_subband::open_block".
; 3671 :             The `max_layers' argument identifies the maximum number of
; 3672 :          quality layers for which code-block contributions are to be
; 3673 :          retrieved.
; 3674 :             The `discard_passes' argument indicates the number of additional
; 3675 :          coding passes to be removed, if any.
; 3676 :             If `in_memory_source' is true, the layer code bytes are not
; 3677 :          stored in the `kd_code_buffer' list embedded inside `block'.  Instead,
; 3678 :          the `kd_code_buffer' list stores only the header information for
; 3679 :          each layer, along with the address of the code bytes, which reside
; 3680 :          in the memory block managed by an in-memory compressed data source
; 3681 :          (one which offers the `KDU_SOURCE_CAP_IN_MEMORY') capability.  In
; 3682 :          this case, we retrieve the address and then perform a simple memory
; 3683 :          block copy operation to efficiently retrieve the code bytes for
; 3684 :          each layer. */
; 3685 :     void store_data(kdu_block *block, kd_buf_server *buf_server);
; 3686 :       /* Stores compressed code-bytes, pass length and pass slope information
; 3687 :          from the `block' object into the current code-block.  This function
; 3688 :          is invoked by "kdu_subband::close_block" when the containing
; 3689 :          codestream object was not constructed for input.  Also reflects
; 3690 :          the `msbs_w' value into higher nodes in the tag tree. */
; 3691 :     void store_data(kdu_block *block, kd_thread_buf_server *thread_buf_server);
; 3692 :       /* Same as the above function, but uses `kd_thread_buf_server::get'
; 3693 :          rather than `kd_buf_server::get' to get new code buffers.  This
; 3694 :          version is used to save code-block state in multi-threaded
; 3695 :          environments so as to minimize cache coherency bottlenecks and the
; 3696 :          need to lock shared resources. */
; 3697 :     void transfer_data(kd_block &src)
; 3698 :       { /* Like `store_data', but gets results from another block.  Exploits
; 3699 :            the layout of the object to copy only whole pointers or whole
; 3700 :            32-bit words, even where these represent multiple fields. */
; 3701 :         current_buf = first_buf = src.first_buf;
; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);
; 3703 :         src.current_buf = src.first_buf = NULL;
; 3704 :       }
; 3705 :     bool trim_data(kdu_uint16 slope_threshold, kd_buf_server *buf_server);
; 3706 :       /* This function serves two purposes: it helps reduce the amount of
; 3707 :          compressed data which must be buffered in memory while compressing
; 3708 :          an image; and it allows individual block contributions to be
; 3709 :          discarded during packet construction in order to tightly fit the
; 3710 :          generated bit-rate to the target compressed bit-rate.
; 3711 :             The function sets all coding pass slopes which are less than or
; 3712 :          equal to the supplied slope threshold to 0 and then discards all
; 3713 :          code bytes which could not possibly be included in the final
; 3714 :          code-stream, as a result of this modification.
; 3715 :             If anything was discarded, the function returns true.  Otherwise,
; 3716 :          it returns false. */
; 3717 :     int start_packet(int layer_idx, kdu_uint16 slope_threshold);
; 3718 :       /* Call this function only during rate allocation or packet generation.
; 3719 :          Before the first call to this function, you must reset the tag tree
; 3720 :          (see the "reset_output_tree" member function).  If you are calling
; 3721 :          the function multiple times with the same layer for rate allocation
; 3722 :          purposes, you must use "save_output_tree" and "restore_output_tree"
; 3723 :          as described below.
; 3724 :             The function leaves behind information about the number of new
; 3725 :          coding passes and the number of new code bytes which would be
; 3726 :          contributed by this code-block if the supplied threshold were actually
; 3727 :          used.  The final contributing coding pass must have a non-zero
; 3728 :          distortion-length slope which is strictly greater than the slope
; 3729 :          threshold.  It also updates the tag tree structure to reflect any
; 3730 :          new knowledge about the first layer to which this code-block would
; 3731 :          contribute.  This information is picked up by "write_packet_header".
; 3732 :             The function's return value is the total number of new code-bytes
; 3733 :          contributed by the block.  This allows the PCRD-opt algorithm to
; 3734 :          determine roughly the right slope threshold before committing to the
; 3735 :          work of simulating packet header generation. */
; 3736 :     void write_packet_header(kd_header_out &head, int layer_idx,
; 3737 :                              bool simulate);
; 3738 :       /* Call this function only after a `start_packet' call.  It writes
; 3739 :          (or simulates the writing of) packet header information corresponding
; 3740 :          to the code-block inclusion information set up by `start_packet'.
; 3741 :          If `simulate' is true, some internal state adjustments are delayed
; 3742 :          until the next call to "save_output_tree", so multiple calls to
; 3743 :          "start_packet" and "write_packet_header" may be issued with the same
; 3744 :          layer index to determine an optimal slope threshold.  Otherwise,
; 3745 :          if `simulate' is false, the internal state information is fully
; 3746 :          updated and the "save_output_tree" and "restore_output_tree" functions
; 3747 :          need not and should not be called. */
; 3748 :     void write_body_bytes(kdu_output *dest);
; 3749 :       /* This function should be called after a non-simulated
; 3750 :          "write_packet_header" call to output the newly included body bytes.
; 3751 :          The actual number of bytes to be written was left behind by
; 3752 :          the preceding "start_packet" call in the `temp_length' field. */
; 3753 :   // --------------------------------------------------------------------------
; 3754 :   public: // Static functions used to operate on tag-trees built from kd_block
; 3755 :     static kd_block *build_tree(kdu_coords size, kdu_byte * &mem_block);
; 3756 :       /* Builds a full tag tree returning a pointer to the upper left hand
; 3757 :          corner leaf node.  Apart from the `up_down' navigation pointers,
; 3758 :          all fields are initialized to 0.  This is appropriate for tag tree
; 3759 :          decoding, but encoders will need to call "reset_output_tree" and
; 3760 :          use "start_packet" to install appropriate node values.
; 3761 :             The tag tree is not allocated from the heap.  Instead, it is
; 3762 :          allocated from an existing memory block, identified by the `mem_block'
; 3763 :          argument.  This memory block is assumed to be large enough to hold
; 3764 :          the array of `kd_block' structures.  Upon return, the `mem_block'
; 3765 :          value is advanced by an amount equal to the size of the tag tree
; 3766 :          array. */
; 3767 :     static void reset_output_tree(kd_block *tree, kdu_coords size);
; 3768 :       /* Call this function immediately before simulating or actually
; 3769 :          generating any packet data for the relevant code-blocks.  Once
; 3770 :          the PCRD-opt algorithm has completed, you should call this function
; 3771 :          a second time to prepare for actual packet output.  The function
; 3772 :          initializes the threshold state variables, `layer_w_bar' and
; 3773 :          `msbs_w_bar' to 0, and the value state variables, `layer_w' and
; 3774 :          `msbs_w' to their maximum representable values.  The succession of
; 3775 :          "start_packet" calls will update the value variables `layer_w'
; 3776 :          and `msbs_w' in such a way that the tag tree coding process runs
; 3777 :          correctly in each subsequent call to "write_packet_header". */
; 3778 :     static void save_output_tree(kd_block *tree, kdu_coords size);
; 3779 :       /* Call this only during rate allocation, before moving on to a new
; 3780 :          layer.  The function saves the current state (`msbs_wbar' and
; 3781 :          `layer_wbar') of each node in the tag tree.  For leaf nodes, it also
; 3782 :          commits the number of new coding passes found in the last call to
; 3783 :          "start_packet". */
; 3784 :     static void restore_output_tree(kd_block *tree, kdu_coords size);
; 3785 :       /* Call this during rate allocation before supplying a new slope
; 3786 :          threshold for the same layer index, in a new "start_packet" call.
; 3787 :          The function restores the `msbs_w_bar' and `layer_w_bar' values
; 3788 :          previously saved by "save_output_tree". */
; 3789 :   // --------------------------------------------------------------------------
; 3790 :   public: // State identification functions
; 3791 :     void set_discard()
; 3792 :       { /* Use this function only with input-oriented operations.  It informs
; 3793 :            the object that none of the code-blocks associated with this
; 3794 :            block will ever be accessed, so that it is free to skip over them
; 3795 :            when reading a packet.  This can save a lot of memory if you have
; 3796 :            a defined region of interest for decompression. */
; 3797 :         num_passes = 255;
; 3798 :       }
; 3799 :     bool empty()
; 3800 :       { // Returns true if the block has no code-bytes yet.
; 3801 :         return first_buf == NULL;
; 3802 :       }
; 3803 :     void set_modes(int modes)
; 3804 :       {
; 3805 :         assert(modes == (modes & 0xFF));
; 3806 :         this->modes = (kdu_byte) modes;
; 3807 :       }
; 3808 :   // --------------------------------------------------------------------------
; 3809 :   private: // Convenience functions for transferring data to/from code buffers.
; 3810 :     void start_buffering(kd_buf_server *buf_server) // Call before `put_byte'
; 3811 :       { assert(first_buf == NULL);
; 3812 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3813 :     void start_buffering(kd_thread_buf_server *buf_server)
; 3814 :       { assert(first_buf == NULL);
; 3815 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3816 :     void put_byte(kdu_byte val, kd_buf_server *buf_server)
; 3817 :       {
; 3818 :         assert(current_buf != NULL);
; 3819 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3820 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3821 :         current_buf->buf[buf_pos++] = val;
; 3822 :       }
; 3823 :     void put_word(int val, kd_buf_server *buf_server)
; 3824 :       {
; 3825 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3826 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))
; 3827 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3828 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;
; 3829 :         buf_pos += 2;
; 3830 :       }
; 3831 :     void put_address(kdu_byte *addr, kd_buf_server *buf_server)
; 3832 :       {
; 3833 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer

	mov	al, BYTE PTR [esi+8]

; 3651 :               {
; 3652 :                 kdu_byte *addr;
; 3653 :                 this->num_bytes += source->pseudo_read(addr,this->temp_length);

	add	WORD PTR [esi+14], dx

; 3660 :           }
; 3661 :       }
; 3662 :     void retrieve_data(kdu_block *block, int max_layers, int discard_passes,
; 3663 :                        bool in_memory_source);
; 3664 :       /* Retrieves compressed code-bytes, number of coding passes and codeword
; 3665 :          segment lengths from the current code-block and stores them in the
; 3666 :          `block' object.  All fields which are common for compression and
; 3667 :          decompression have already been filled out by the caller.  The
; 3668 :          byte buffer is allocated so as to be large enough to allow a
; 3669 :          2 byte marker code to be appended to the compressed data,
; 3670 :          if desired -- see declaration of "kdu_subband::open_block".
; 3671 :             The `max_layers' argument identifies the maximum number of
; 3672 :          quality layers for which code-block contributions are to be
; 3673 :          retrieved.
; 3674 :             The `discard_passes' argument indicates the number of additional
; 3675 :          coding passes to be removed, if any.
; 3676 :             If `in_memory_source' is true, the layer code bytes are not
; 3677 :          stored in the `kd_code_buffer' list embedded inside `block'.  Instead,
; 3678 :          the `kd_code_buffer' list stores only the header information for
; 3679 :          each layer, along with the address of the code bytes, which reside
; 3680 :          in the memory block managed by an in-memory compressed data source
; 3681 :          (one which offers the `KDU_SOURCE_CAP_IN_MEMORY') capability.  In
; 3682 :          this case, we retrieve the address and then perform a simple memory
; 3683 :          block copy operation to efficiently retrieve the code bytes for
; 3684 :          each layer. */
; 3685 :     void store_data(kdu_block *block, kd_buf_server *buf_server);
; 3686 :       /* Stores compressed code-bytes, pass length and pass slope information
; 3687 :          from the `block' object into the current code-block.  This function
; 3688 :          is invoked by "kdu_subband::close_block" when the containing
; 3689 :          codestream object was not constructed for input.  Also reflects
; 3690 :          the `msbs_w' value into higher nodes in the tag tree. */
; 3691 :     void store_data(kdu_block *block, kd_thread_buf_server *thread_buf_server);
; 3692 :       /* Same as the above function, but uses `kd_thread_buf_server::get'
; 3693 :          rather than `kd_buf_server::get' to get new code buffers.  This
; 3694 :          version is used to save code-block state in multi-threaded
; 3695 :          environments so as to minimize cache coherency bottlenecks and the
; 3696 :          need to lock shared resources. */
; 3697 :     void transfer_data(kd_block &src)
; 3698 :       { /* Like `store_data', but gets results from another block.  Exploits
; 3699 :            the layout of the object to copy only whole pointers or whole
; 3700 :            32-bit words, even where these represent multiple fields. */
; 3701 :         current_buf = first_buf = src.first_buf;
; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);
; 3703 :         src.current_buf = src.first_buf = NULL;
; 3704 :       }
; 3705 :     bool trim_data(kdu_uint16 slope_threshold, kd_buf_server *buf_server);
; 3706 :       /* This function serves two purposes: it helps reduce the amount of
; 3707 :          compressed data which must be buffered in memory while compressing
; 3708 :          an image; and it allows individual block contributions to be
; 3709 :          discarded during packet construction in order to tightly fit the
; 3710 :          generated bit-rate to the target compressed bit-rate.
; 3711 :             The function sets all coding pass slopes which are less than or
; 3712 :          equal to the supplied slope threshold to 0 and then discards all
; 3713 :          code bytes which could not possibly be included in the final
; 3714 :          code-stream, as a result of this modification.
; 3715 :             If anything was discarded, the function returns true.  Otherwise,
; 3716 :          it returns false. */
; 3717 :     int start_packet(int layer_idx, kdu_uint16 slope_threshold);
; 3718 :       /* Call this function only during rate allocation or packet generation.
; 3719 :          Before the first call to this function, you must reset the tag tree
; 3720 :          (see the "reset_output_tree" member function).  If you are calling
; 3721 :          the function multiple times with the same layer for rate allocation
; 3722 :          purposes, you must use "save_output_tree" and "restore_output_tree"
; 3723 :          as described below.
; 3724 :             The function leaves behind information about the number of new
; 3725 :          coding passes and the number of new code bytes which would be
; 3726 :          contributed by this code-block if the supplied threshold were actually
; 3727 :          used.  The final contributing coding pass must have a non-zero
; 3728 :          distortion-length slope which is strictly greater than the slope
; 3729 :          threshold.  It also updates the tag tree structure to reflect any
; 3730 :          new knowledge about the first layer to which this code-block would
; 3731 :          contribute.  This information is picked up by "write_packet_header".
; 3732 :             The function's return value is the total number of new code-bytes
; 3733 :          contributed by the block.  This allows the PCRD-opt algorithm to
; 3734 :          determine roughly the right slope threshold before committing to the
; 3735 :          work of simulating packet header generation. */
; 3736 :     void write_packet_header(kd_header_out &head, int layer_idx,
; 3737 :                              bool simulate);
; 3738 :       /* Call this function only after a `start_packet' call.  It writes
; 3739 :          (or simulates the writing of) packet header information corresponding
; 3740 :          to the code-block inclusion information set up by `start_packet'.
; 3741 :          If `simulate' is true, some internal state adjustments are delayed
; 3742 :          until the next call to "save_output_tree", so multiple calls to
; 3743 :          "start_packet" and "write_packet_header" may be issued with the same
; 3744 :          layer index to determine an optimal slope threshold.  Otherwise,
; 3745 :          if `simulate' is false, the internal state information is fully
; 3746 :          updated and the "save_output_tree" and "restore_output_tree" functions
; 3747 :          need not and should not be called. */
; 3748 :     void write_body_bytes(kdu_output *dest);
; 3749 :       /* This function should be called after a non-simulated
; 3750 :          "write_packet_header" call to output the newly included body bytes.
; 3751 :          The actual number of bytes to be written was left behind by
; 3752 :          the preceding "start_packet" call in the `temp_length' field. */
; 3753 :   // --------------------------------------------------------------------------
; 3754 :   public: // Static functions used to operate on tag-trees built from kd_block
; 3755 :     static kd_block *build_tree(kdu_coords size, kdu_byte * &mem_block);
; 3756 :       /* Builds a full tag tree returning a pointer to the upper left hand
; 3757 :          corner leaf node.  Apart from the `up_down' navigation pointers,
; 3758 :          all fields are initialized to 0.  This is appropriate for tag tree
; 3759 :          decoding, but encoders will need to call "reset_output_tree" and
; 3760 :          use "start_packet" to install appropriate node values.
; 3761 :             The tag tree is not allocated from the heap.  Instead, it is
; 3762 :          allocated from an existing memory block, identified by the `mem_block'
; 3763 :          argument.  This memory block is assumed to be large enough to hold
; 3764 :          the array of `kd_block' structures.  Upon return, the `mem_block'
; 3765 :          value is advanced by an amount equal to the size of the tag tree
; 3766 :          array. */
; 3767 :     static void reset_output_tree(kd_block *tree, kdu_coords size);
; 3768 :       /* Call this function immediately before simulating or actually
; 3769 :          generating any packet data for the relevant code-blocks.  Once
; 3770 :          the PCRD-opt algorithm has completed, you should call this function
; 3771 :          a second time to prepare for actual packet output.  The function
; 3772 :          initializes the threshold state variables, `layer_w_bar' and
; 3773 :          `msbs_w_bar' to 0, and the value state variables, `layer_w' and
; 3774 :          `msbs_w' to their maximum representable values.  The succession of
; 3775 :          "start_packet" calls will update the value variables `layer_w'
; 3776 :          and `msbs_w' in such a way that the tag tree coding process runs
; 3777 :          correctly in each subsequent call to "write_packet_header". */
; 3778 :     static void save_output_tree(kd_block *tree, kdu_coords size);
; 3779 :       /* Call this only during rate allocation, before moving on to a new
; 3780 :          layer.  The function saves the current state (`msbs_wbar' and
; 3781 :          `layer_wbar') of each node in the tag tree.  For leaf nodes, it also
; 3782 :          commits the number of new coding passes found in the last call to
; 3783 :          "start_packet". */
; 3784 :     static void restore_output_tree(kd_block *tree, kdu_coords size);
; 3785 :       /* Call this during rate allocation before supplying a new slope
; 3786 :          threshold for the same layer index, in a new "start_packet" call.
; 3787 :          The function restores the `msbs_w_bar' and `layer_w_bar' values
; 3788 :          previously saved by "save_output_tree". */
; 3789 :   // --------------------------------------------------------------------------
; 3790 :   public: // State identification functions
; 3791 :     void set_discard()
; 3792 :       { /* Use this function only with input-oriented operations.  It informs
; 3793 :            the object that none of the code-blocks associated with this
; 3794 :            block will ever be accessed, so that it is free to skip over them
; 3795 :            when reading a packet.  This can save a lot of memory if you have
; 3796 :            a defined region of interest for decompression. */
; 3797 :         num_passes = 255;
; 3798 :       }
; 3799 :     bool empty()
; 3800 :       { // Returns true if the block has no code-bytes yet.
; 3801 :         return first_buf == NULL;
; 3802 :       }
; 3803 :     void set_modes(int modes)
; 3804 :       {
; 3805 :         assert(modes == (modes & 0xFF));
; 3806 :         this->modes = (kdu_byte) modes;
; 3807 :       }
; 3808 :   // --------------------------------------------------------------------------
; 3809 :   private: // Convenience functions for transferring data to/from code buffers.
; 3810 :     void start_buffering(kd_buf_server *buf_server) // Call before `put_byte'
; 3811 :       { assert(first_buf == NULL);
; 3812 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3813 :     void start_buffering(kd_thread_buf_server *buf_server)
; 3814 :       { assert(first_buf == NULL);
; 3815 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3816 :     void put_byte(kdu_byte val, kd_buf_server *buf_server)
; 3817 :       {
; 3818 :         assert(current_buf != NULL);
; 3819 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3820 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3821 :         current_buf->buf[buf_pos++] = val;
; 3822 :       }
; 3823 :     void put_word(int val, kd_buf_server *buf_server)
; 3824 :       {
; 3825 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3826 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))
; 3827 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3828 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;
; 3829 :         buf_pos += 2;
; 3830 :       }
; 3831 :     void put_address(kdu_byte *addr, kd_buf_server *buf_server)
; 3832 :       {
; 3833 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer

	neg	al
	and	al, 3
	add	BYTE PTR [esi+8], al

; 3834 :         if (buf_pos > (KD_CODE_BUFFER_LEN-KDU_POINTER_BYTES))

	cmp	BYTE PTR [esi+8], 54			; 00000036H
	jbe	SHORT $LN195@read_packe

; 3835 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }

	mov	ecx, DWORD PTR _buf_server$1$[ebp]
	mov	BYTE PTR [esi+8], 0
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	ecx, eax
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax], ecx
	mov	DWORD PTR [esi+4], ecx
$LN195@read_packe:

; 3836 : 
; 3837 :         ((kdu_byte **)(current_buf->buf+buf_pos))[0] = addr;

	movzx	ecx, BYTE PTR [esi+8]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [eax+ecx+6], edi

; 3659 :             this->temp_length = 0;

	xor	eax, eax
	mov	edi, DWORD PTR _n$1$[ebp]

; 3838 :         buf_pos += KDU_POINTER_BYTES;

	add	BYTE PTR [esi+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5699 :                 for (int n=pband->block_indices.size.x; n > 0; n--, block++)

	dec	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3659 :             this->temp_length = 0;

	mov	WORD PTR [esi+18], ax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5699 :                 for (int n=pband->block_indices.size.x; n > 0; n--, block++)

	add	esi, 24					; 00000018H
	jmp	$LN255@read_packe
$LN187@read_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3657 :               this->num_bytes +=

	push	eax
	push	DWORD PTR _buf_server$1$[ebp]
	lea	eax, DWORD PTR [esi+8]
	push	eax
	lea	eax, DWORD PTR [esi+4]
	push	eax
	call	?read@kd_input@@QAEHAAPAUkd_code_buffer@@AAEPAVkd_buf_server@@H@Z ; kd_input::read
	add	WORD PTR [esi+14], ax

; 3659 :             this->temp_length = 0;

	xor	eax, eax
	mov	WORD PTR [esi+18], ax
$LN19@read_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5699 :                 for (int n=pband->block_indices.size.x; n > 0; n--, block++)

	dec	edi
	add	esi, 24					; 00000018H
	jmp	$LN255@read_packe
__catch$?read_packet@kd_precinct@@AAE_NXZ$3:

; 5701 :                                          codestream->buf_server,
; 5702 :                                          codestream->in_memory_source);
; 5703 :             }
; 5704 :         }
; 5705 :       catch (kdu_uint16 code)
; 5706 :         {
; 5707 :           if (codestream->resilient)

	mov	ecx, DWORD PTR _codestream$[ebp]
	cmp	BYTE PTR [ecx+332], 0
	je	SHORT $LN76@read_packe

; 5708 :             { // We have run into the next SOP or SOT marker.
; 5709 :               if (suspend)

	cmp	BYTE PTR _suspend$[ebp], 0
	je	SHORT $LN78@read_packe

; 5710 :                 codestream->in->set_suspend(false);

	mov	ecx, DWORD PTR [ecx+4]
	push	0
	call	?set_suspend@kd_compressed_input@@QAEX_N@Z ; kd_compressed_input::set_suspend
$LN78@read_packe:

; 5711 :               return handle_corrupt_packet();

	mov	ecx, DWORD PTR _this$[ebp]
	call	?handle_corrupt_packet@kd_precinct@@AAE_NXZ ; kd_precinct::handle_corrupt_packet
	mov	BYTE PTR $T15[ebp], al
	mov	eax, $LN110@read_packe
	ret	0
$LN76@read_packe:

; 5714 :             { KDU_ERROR(e,34); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0BG@OOKLLMMG@Illegal?5marker?5code?0?5?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5714 :             { KDU_ERROR(e,34); e <<

	mov	BYTE PTR __$EHRec$[ebp+12], 13		; 0000000dH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5716 :               print_marker_code(code,e); e <<

	lea	eax, DWORD PTR _e$3[ebp]
	push	eax
	push	DWORD PTR _code$13[ebp]
	call	?print_marker_code@@YAXGAAVkdu_message@@@Z ; print_marker_code
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5716 :               print_marker_code(code,e); e <<

	add	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0FO@KDIMGOKP@?0?5found?5while?5reading?5packet?5bod@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5719 :             }

	lea	ecx, DWORD PTR _e$3[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error

; 5720 :         }

	mov	eax, $LN116@read_packe
	ret	0
$LN116@read_packe:
	mov	ebx, DWORD PTR _codestream$[ebp]
$LN14@read_packe:
	mov	esi, DWORD PTR _body_bytes$[ebp+4]
	mov	DWORD PTR __$EHRec$[ebp+12], -1
$LN238@read_packe:
	mov	edi, DWORD PTR _body_bytes$[ebp]
$LN115@read_packe:

; 5722 :   if (!codestream->in->disable_marker_throwing())

	mov	eax, DWORD PTR [ebx+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 514  :         if (!throw_markers) return true;

	cmp	BYTE PTR [eax+534], 0
	je	$LN81@read_packe

; 515  :         throw_markers = false; // Must not touch `reject_all' here.
; 516  :         if (exhausted) have_FF = false;

	cmp	BYTE PTR [eax+533], 0
	mov	BYTE PTR [eax+534], 0
	je	SHORT $LN203@read_packe
	mov	BYTE PTR [eax+535], 0
$LN203@read_packe:

; 517  :         return !have_FF;

	cmp	BYTE PTR [eax+535], 0
	sete	al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5722 :   if (!codestream->in->disable_marker_throwing())

	test	al, al
	jne	$LN81@read_packe

; 5723 :     {
; 5724 :       if (codestream->resilient)

	cmp	BYTE PTR [ebx+332], al
	je	SHORT $LN80@read_packe

; 5725 :         { // We probably just ran into the 1'st byte of the next SOP/SOT marker
; 5726 :           codestream->in->putback((kdu_byte) 0xFF);

	mov	eax, DWORD PTR [ebx+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 550  :         first_unread--;

	dec	DWORD PTR [eax+524]

; 551  :         if (!fully_buffered)

	cmp	BYTE PTR [eax+532], 0
	mov	ecx, DWORD PTR [eax+524]
	jne	SHORT $LN206@read_packe

; 552  :           {
; 553  :             assert(first_unread >= buffer);
; 554  :             *first_unread = byte;

	mov	BYTE PTR [ecx], 255			; 000000ffH
$LN206@read_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5727 :           if (suspend)

	cmp	BYTE PTR _suspend$[ebp], 0
	je	$LN70@read_packe

; 5728 :             codestream->in->set_suspend(false);

	mov	ecx, DWORD PTR [ebx+4]
	push	0
	call	?set_suspend@kd_compressed_input@@QAEX_N@Z ; kd_compressed_input::set_suspend

; 5729 :           return handle_corrupt_packet();

	mov	ecx, DWORD PTR _this$[ebp]
	jmp	$LN253@read_packe
$LN16@read_packe:

; 5698 :               for (int m=pband->block_indices.size.y; m > 0; m--)

	mov	eax, DWORD PTR _m$1$[ebp]
	mov	ecx, DWORD PTR _pband$1$[ebp]
	dec	eax
	jmp	$LN256@read_packe
$LN13@read_packe:

; 5694 :           for (int b=0; b < resolution->num_subbands; b++)

	mov	edi, DWORD PTR _b$1$[ebp]
	inc	edi
	jmp	$LN257@read_packe
$LN80@read_packe:

; 5732 :         { KDU_ERROR(e,35); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0CD@BIAHNBHE@Packet?5body?5terminated?5with?5an?5F@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5732 :         { KDU_ERROR(e,35); e <<

	mov	DWORD PTR __$EHRec$[ebp+12], 14		; 0000000eH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5734 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN81@read_packe:

; 5735 :     }
; 5736 :   
; 5737 :   if ((!(flags & KD_PFLAG_PARSED)) && (comp->layer_stats != NULL))

	mov	edx, DWORD PTR _this$[ebp]
	test	DWORD PTR [edx+8], 256			; 00000100H
	jne	SHORT $LN83@read_packe
	mov	eax, DWORD PTR _comp$[ebp]
	mov	eax, DWORD PTR [eax+148]
	mov	DWORD PTR tv1373[ebp], eax
	test	eax, eax
	je	SHORT $LN83@read_packe

; 5738 :     { // Accumulate packet length information in layer statistics
; 5739 :       int entry_idx = (resolution->res_level * tile->num_layers +
; 5740 :                        num_packets_read) << 1;

	mov	eax, DWORD PTR [edx]
	movzx	ecx, BYTE PTR [eax+12]
	mov	eax, DWORD PTR _tile$[ebp]
	imul	ecx, DWORD PTR [eax+132]

; 5741 :       comp->layer_stats[entry_idx]++;

	mov	eax, DWORD PTR tv1373[ebp]
	add	ecx, DWORD PTR [edx+20]
	add	ecx, ecx
	lea	edx, DWORD PTR [ecx*8]
	add	DWORD PTR [edx+eax], 1
	adc	DWORD PTR [edx+eax+4], 0

; 5742 :       comp->layer_stats[entry_idx+1] += body_bytes+header_bytes;

	mov	eax, DWORD PTR _comp$[ebp]
	mov	ecx, DWORD PTR [eax+148]
	mov	eax, DWORD PTR _header_bytes$[ebp]
	add	ecx, edx
	cdq
	add	eax, edi
	adc	edx, esi
	add	DWORD PTR [ecx+8], eax
	adc	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR _this$[ebp]
$LN83@read_packe:

; 5743 :     }
; 5744 :   num_packets_read++;

	inc	DWORD PTR [edx+20]

; 5745 :   if (suspend)

	cmp	BYTE PTR _suspend$[ebp], 0
	je	SHORT $LN84@read_packe

; 5746 :     codestream->in->set_suspend(false);

	mov	ecx, DWORD PTR [ebx+4]
	push	0
	call	?set_suspend@kd_compressed_input@@QAEX_N@Z ; kd_compressed_input::set_suspend
$LN84@read_packe:

; 5747 :   return true;

	mov	al, 1

; 5748 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp+4]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$5:
	lea	ecx, DWORD PTR _e$12[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$6:
	lea	ecx, DWORD PTR _e$11[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$7:
	lea	ecx, DWORD PTR _e$10[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$8:
	lea	ecx, DWORD PTR _e$9[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$9:
	lea	ecx, DWORD PTR _e$8[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$10:
	lea	ecx, DWORD PTR _e$7[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$11:
	lea	ecx, DWORD PTR _e$6[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$12:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$13:
	lea	ecx, DWORD PTR _e$4[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$14:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_packet@kd_precinct@@AAE_NXZ$15:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?read_packet@kd_precinct@@AAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-140]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read_packet@kd_precinct@@AAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?read_packet@kd_precinct@@AAE_NXZ ENDP			; kd_precinct::read_packet
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?write_packet@kd_precinct@@QAE_JG_N@Z
_TEXT	SEGMENT
_head$ = -52						; size = 16
_this$1$ = -36						; size = 4
_tile$1$ = -32						; size = 4
_num_blocks$3$ = -28					; size = 4
_out$1$ = -28						; size = 4
_check_bytes$ = -24					; size = 8
_pband$1$ = -20						; size = 4
tv784 = -20						; size = 4
tv781 = -20						; size = 4
_pband$1$ = -16						; size = 4
tv783 = -16						; size = 4
_b$1$ = -12						; size = 4
_check_bytes$2$ = -8					; size = 4
_check_bytes$1$ = -4					; size = 4
_word$1$ = 8						; size = 4
_b$2$ = 8						; size = 4
_threshold$ = 8						; size = 2
tv779 = 8						; size = 4
_byte$1$ = 11						; size = 1
_b$3$ = 12						; size = 4
_empty_packet$ = 12					; size = 1
?write_packet@kd_precinct@@QAE_JG_N@Z PROC		; kd_precinct::write_packet, COMDAT
; _this$ = ecx

; 5970 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 52					; 00000034H

; 5971 :   int b, n, num_blocks;
; 5972 :   kdu_long check_bytes = 0;
; 5973 :   kd_tile *tile = resolution->tile_comp->tile;
; 5974 :   kdu_output *out = resolution->codestream->out;
; 5975 : 
; 5976 :   if (!empty_packet)

	cmp	BYTE PTR _empty_packet$[ebp], 0
	xorps	xmm0, xmm0
	push	ebx
	mov	ebx, ecx
	movlpd	QWORD PTR _check_bytes$[ebp], xmm0
	push	esi
	push	edi
	mov	DWORD PTR _this$1$[ebp], ebx
	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _tile$1$[ebp], eax
	mov	eax, DWORD PTR [ecx]
	mov	esi, DWORD PTR [eax+8]
	mov	DWORD PTR _out$1$[ebp], esi
	jne	$LN122@write_pack

; 5977 :     { // Start the packet.
; 5978 :       for (b=0; b < resolution->num_subbands; b++)

	xor	edx, edx
	mov	DWORD PTR _b$1$[ebp], edx
	cmp	BYTE PTR [ecx+174], dl
	jbe	$LN121@write_pack
	mov	eax, DWORD PTR _check_bytes$[ebp+4]
	xor	ecx, ecx
	mov	DWORD PTR _check_bytes$2$[ebp], eax
	mov	eax, DWORD PTR _check_bytes$[ebp]
	mov	DWORD PTR tv783[ebp], ecx
	mov	DWORD PTR _check_bytes$1$[ebp], eax
$LL4@write_pack:

; 5979 :         {
; 5980 :           kd_precinct_band *pband = subbands + b;

	mov	edi, DWORD PTR [ebx+40]
	add	edi, ecx

; 5981 :           if (next_layer_idx == 0)

	cmp	DWORD PTR [ebx+16], 0
	jne	SHORT $LN21@write_pack

; 5982 :             kd_block::reset_output_tree(pband->blocks,

	push	DWORD PTR [edi+16]
	push	DWORD PTR [edi+12]
	push	DWORD PTR [edi+20]
	call	?reset_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z ; kd_block::reset_output_tree
	mov	ecx, DWORD PTR tv783[ebp]
	add	esp, 12					; 0000000cH
	mov	edx, DWORD PTR _b$1$[ebp]
$LN21@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	esi, DWORD PTR [edi+16]
	imul	esi, DWORD PTR [edi+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5985 :           for (n=0; n < num_blocks; n++)

	test	esi, esi
	jle	SHORT $LN2@write_pack

; 5983 :                                         pband->block_indices.size);
; 5984 :           num_blocks = (int) pband->block_indices.area();

	xor	eax, eax
	mov	DWORD PTR tv784[ebp], eax
$LL7@write_pack:

; 5986 :             check_bytes +=

	push	DWORD PTR _threshold$[ebp]
	mov	ecx, DWORD PTR [edi+20]
	push	DWORD PTR [ebx+16]
	add	ecx, eax
	call	?start_packet@kd_block@@QAEHHG@Z	; kd_block::start_packet
	cdq
	add	DWORD PTR _check_bytes$1$[ebp], eax
	mov	eax, DWORD PTR tv784[ebp]
	adc	DWORD PTR _check_bytes$2$[ebp], edx
	add	eax, 24					; 00000018H
	mov	DWORD PTR tv784[ebp], eax
	sub	esi, 1
	jne	SHORT $LL7@write_pack
	mov	ecx, DWORD PTR tv783[ebp]
	mov	edx, DWORD PTR _b$1$[ebp]
$LN2@write_pack:

; 5977 :     { // Start the packet.
; 5978 :       for (b=0; b < resolution->num_subbands; b++)

	mov	eax, DWORD PTR [ebx]
	inc	edx
	add	ecx, 24					; 00000018H
	mov	DWORD PTR _b$1$[ebp], edx
	mov	DWORD PTR tv783[ebp], ecx
	movzx	eax, BYTE PTR [eax+174]
	cmp	edx, eax
	jl	SHORT $LL4@write_pack
	mov	esi, DWORD PTR _out$1$[ebp]
	mov	edi, DWORD PTR _check_bytes$2$[ebp]
	jmp	SHORT $LN3@write_pack
$LN121@write_pack:
	mov	edi, DWORD PTR _check_bytes$[ebp+4]
	mov	eax, DWORD PTR _check_bytes$[ebp]
	mov	DWORD PTR _check_bytes$2$[ebp], edi
	mov	DWORD PTR _check_bytes$1$[ebp], eax
$LN3@write_pack:

; 5987 :             pband->blocks[n].start_packet(next_layer_idx,threshold);
; 5988 :         }
; 5989 :       if (resolution->tile_comp->tile->use_sop)

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+224], 0
	je	$LN22@write_pack
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN34@write_pack

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN34@write_pack:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN37@write_pack

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN37@write_pack:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 145			; 00000091H
	mov	eax, DWORD PTR [esi+516]
	inc	eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5991 :           check_bytes += out->put(KDU_SOP);

	add	DWORD PTR _check_bytes$1$[ebp], 2
	mov	DWORD PTR [esi+516], eax
	adc	edi, 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN42@write_pack

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN42@write_pack:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 0
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN45@write_pack

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN45@write_pack:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5993 :           check_bytes += out->put((kdu_uint16)

	mov	ecx, DWORD PTR _tile$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], 4
	mov	eax, DWORD PTR [esi+516]
	inc	eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5992 :           check_bytes += out->put((kdu_uint16) 4);

	add	DWORD PTR _check_bytes$1$[ebp], 2
	mov	DWORD PTR [esi+516], eax

; 5993 :           check_bytes += out->put((kdu_uint16)

	movzx	ecx, WORD PTR [ecx+248]
	adc	edi, 0
	mov	DWORD PTR _word$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN50@write_pack

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _word$1$[ebp]
$LN50@write_pack:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 144  :         return 1;
; 145  :       }
; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN53@write_pack

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN53@write_pack:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	ecx, DWORD PTR _word$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5993 :           check_bytes += out->put((kdu_uint16)

	add	DWORD PTR _check_bytes$1$[ebp], 2
	adc	edi, 0
	mov	DWORD PTR _check_bytes$2$[ebp], edi
	jmp	SHORT $LN22@write_pack
$LN122@write_pack:
	mov	eax, DWORD PTR _check_bytes$[ebp+4]
	mov	DWORD PTR _check_bytes$2$[ebp], eax
	mov	eax, DWORD PTR _check_bytes$[ebp]
	mov	DWORD PTR _check_bytes$1$[ebp], eax
$LN22@write_pack:

; 5999 :   if (empty_packet)

	cmp	BYTE PTR _empty_packet$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }

	mov	edi, esi
	mov	DWORD PTR _head$[ebp+8], 0
	mov	DWORD PTR _head$[ebp+12], edi

; 3567 :         bits_left--;

	mov	DWORD PTR _head$[ebp+4], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5999 :   if (empty_packet)

	je	SHORT $LN65@write_pack
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3566 :         byte += byte + bit;

	xor	dl, dl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6001 :   else

	jmp	$LN119@write_pack
$LN65@write_pack:

; 6004 :       for (b=0; b < resolution->num_subbands; b++)

	mov	eax, DWORD PTR [ebx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3566 :         byte += byte + bit;

	mov	dl, 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6004 :       for (b=0; b < resolution->num_subbands; b++)

	xor	ecx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3566 :         byte += byte + bit;

	mov	BYTE PTR _head$[ebp], dl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6004 :       for (b=0; b < resolution->num_subbands; b++)

	mov	DWORD PTR _b$2$[ebp], ecx
	cmp	BYTE PTR [eax+174], cl
	jbe	SHORT $LN119@write_pack
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3566 :         byte += byte + bit;

	xor	edx, edx
	mov	DWORD PTR tv781[ebp], edx
$LL10@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6006 :           kd_precinct_band *pband = subbands + b;

	mov	eax, DWORD PTR [ebx+40]
	add	eax, edx
	mov	DWORD PTR _pband$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	esi, DWORD PTR [eax+16]
	imul	esi, DWORD PTR [eax+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6008 :           for (n=0; n < num_blocks; n++)

	test	esi, esi
	jle	SHORT $LN8@write_pack

; 6006 :           kd_precinct_band *pband = subbands + b;

	xor	edi, edi
$LL13@write_pack:

; 6009 :             pband->blocks[n].write_packet_header(head,next_layer_idx,false);

	push	0
	push	DWORD PTR [ebx+16]
	lea	ecx, DWORD PTR _head$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [eax+20]
	add	ecx, edi
	call	?write_packet_header@kd_block@@QAEXAAVkd_header_out@@H_N@Z ; kd_block::write_packet_header
	mov	eax, DWORD PTR _pband$1$[ebp]
	add	edi, 24					; 00000018H
	sub	esi, 1
	jne	SHORT $LL13@write_pack
	mov	ecx, DWORD PTR _b$2$[ebp]
	mov	edx, DWORD PTR tv781[ebp]
$LN8@write_pack:

; 6004 :       for (b=0; b < resolution->num_subbands; b++)

	mov	eax, DWORD PTR [ebx]
	inc	ecx
	add	edx, 24					; 00000018H
	mov	DWORD PTR _b$2$[ebp], ecx
	mov	DWORD PTR tv781[ebp], edx
	movzx	eax, BYTE PTR [eax+174]
	cmp	ecx, eax
	jl	SHORT $LL10@write_pack
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3576 :         if (bits_left < 8)

	cmp	DWORD PTR _head$[ebp+4], 8
	mov	esi, DWORD PTR _out$1$[ebp]
	jge	SHORT $LN76@write_pack
	mov	edi, DWORD PTR _head$[ebp+12]
	mov	dl, BYTE PTR _head$[ebp]
$LN119@write_pack:

; 3577 :           {
; 3578 :             byte <<= bits_left;

	mov	cl, BYTE PTR _head$[ebp+4]
	shl	dl, cl
	mov	BYTE PTR _byte$1$[ebp], dl
	mov	BYTE PTR _head$[ebp], dl

; 3579 :             if (out != NULL)

	test	edi, edi
	je	SHORT $LN75@write_pack
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN80@write_pack

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
	mov	dl, BYTE PTR _byte$1$[ebp]
$LN80@write_pack:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
	mov	BYTE PTR [eax], dl
	inc	DWORD PTR [edi+516]
	mov	edi, DWORD PTR _head$[ebp+12]
	mov	dl, BYTE PTR _head$[ebp]
$LN75@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3581 :             completed_bytes++;

	inc	DWORD PTR _head$[ebp+8]

; 3582 :             if (byte == 0xFF)

	cmp	dl, 255					; 000000ffH
	jne	SHORT $LN76@write_pack

; 3583 :               { // Need the stuffing byte.
; 3584 :                 if (out != NULL)

	test	edi, edi
	je	SHORT $LN77@write_pack
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN83@write_pack

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
$LN83@write_pack:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
	mov	BYTE PTR [eax], 0
	inc	DWORD PTR [edi+516]
$LN77@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3586 :                 completed_bytes++;

	inc	DWORD PTR _head$[ebp+8]
$LN76@write_pack:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6012 :   check_bytes += head.finish();

	mov	eax, DWORD PTR _head$[ebp+8]
	mov	ecx, DWORD PTR _check_bytes$1$[ebp]
	mov	edi, DWORD PTR _check_bytes$2$[ebp]
	cdq
	add	ecx, eax

; 6013 :   if (resolution->tile_comp->tile->use_eph)

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR _check_bytes$1$[ebp], ecx
	adc	edi, edx
	mov	DWORD PTR _check_bytes$2$[ebp], edi
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+225], 0
	je	SHORT $LN25@write_pack
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN88@write_pack

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _check_bytes$1$[ebp]
$LN88@write_pack:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN91@write_pack

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _check_bytes$1$[ebp]
$LN91@write_pack:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 146			; 00000092H
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6014 :     check_bytes += out->put(KDU_EPH);

	add	ecx, 2
	mov	DWORD PTR _check_bytes$1$[ebp], ecx
	adc	edi, 0
	mov	DWORD PTR _check_bytes$2$[ebp], edi
$LN25@write_pack:

; 6015 :   if (!empty_packet)

	cmp	BYTE PTR _empty_packet$[ebp], 0
	jne	SHORT $LN15@write_pack

; 6016 :     for (b=0; b < resolution->num_subbands; b++)

	mov	eax, DWORD PTR [ebx]
	xor	edx, edx
	mov	DWORD PTR _b$3$[ebp], edx
	cmp	BYTE PTR [eax+174], dl
	jbe	SHORT $LN15@write_pack
	xor	edi, edi
	mov	DWORD PTR tv779[ebp], edi
	npad	7
$LL16@write_pack:

; 6017 :       {
; 6018 :         kd_precinct_band *pband = subbands + b;

	mov	ecx, DWORD PTR [ebx+40]
	add	ecx, edi
	mov	DWORD PTR _pband$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [ecx+16]
	imul	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR _num_blocks$3$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6020 :         for (n=0; n < num_blocks; n++)

	test	eax, eax
	jle	SHORT $LN14@write_pack

; 6017 :       {
; 6018 :         kd_precinct_band *pband = subbands + b;

	xor	edi, edi
	mov	ebx, eax
	npad	6
$LL19@write_pack:

; 6021 :           pband->blocks[n].write_body_bytes(out);

	mov	ecx, DWORD PTR [ecx+20]
	push	esi
	add	ecx, edi
	call	?write_body_bytes@kd_block@@QAEXPAVkdu_output@@@Z ; kd_block::write_body_bytes
	mov	ecx, DWORD PTR _pband$1$[ebp]
	add	edi, 24					; 00000018H
	sub	ebx, 1
	jne	SHORT $LL19@write_pack
	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	edx, DWORD PTR _b$3$[ebp]
	mov	edi, DWORD PTR tv779[ebp]
$LN14@write_pack:

; 6016 :     for (b=0; b < resolution->num_subbands; b++)

	mov	eax, DWORD PTR [ebx]
	inc	edx
	add	edi, 24					; 00000018H
	mov	DWORD PTR _b$3$[ebp], edx
	mov	DWORD PTR tv779[ebp], edi
	movzx	eax, BYTE PTR [eax+174]
	cmp	edx, eax
	jl	SHORT $LL16@write_pack
	mov	edi, DWORD PTR _check_bytes$2$[ebp]
$LN15@write_pack:

; 6022 :       }
; 6023 : 
; 6024 :   assert(check_bytes == packet_bytes[next_layer_idx]); // Simulation correct?
; 6025 :   next_layer_idx++;
; 6026 :   tile->sequenced_relevant_packets++;

	mov	eax, DWORD PTR _tile$1$[ebp]
	inc	DWORD PTR [ebx+16]
	inc	DWORD PTR [eax+248]

; 6027 :   if (next_layer_idx == tile->num_layers)

	mov	ecx, DWORD PTR [ebx+16]
	cmp	ecx, DWORD PTR [eax+132]
	jne	SHORT $LN120@write_pack

; 6028 :     resolution->rescomp->close_ready_precinct(this);

	mov	ecx, DWORD PTR [ebx]
	push	ebx
	mov	ecx, DWORD PTR [ecx+8]
	call	?close_ready_precinct@kd_global_rescomp@@QAEXPAUkd_precinct@@@Z ; kd_global_rescomp::close_ready_precinct
$LN120@write_pack:

; 6029 :   return check_bytes;

	mov	eax, DWORD PTR _check_bytes$1$[ebp]
	mov	edx, edi
	pop	edi
	pop	esi
	pop	ebx

; 6030 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?write_packet@kd_precinct@@QAE_JG_N@Z ENDP		; kd_precinct::write_packet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?simulate_packet@kd_precinct@@QAE_JAA_JHG_N1_J1@Z
_TEXT	SEGMENT
_e$2 = -92						; size = 20
_head$3 = -72						; size = 16
_body_bytes$ = -56					; size = 8
tv799 = -48						; size = 4
_tile$1$ = -44						; size = 4
_buf_server$1$ = -40					; size = 4
_b$2$ = -36						; size = 4
tv773 = -36						; size = 4
_last_trimmed_block$1$ = -32				; size = 4
_b$1$ = -32						; size = 4
_last_trimmed_subband$1$ = -28				; size = 4
_b$1$ = -24						; size = 4
tv771 = -24						; size = 4
_this$1$ = -20						; size = 4
_body_bytes$2$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_header_bytes$ = 8					; size = 4
_layer_idx$ = 12					; size = 4
_slope_threshold$ = 16					; size = 2
_finalize_layer$ = 20					; size = 1
_last_layer$ = 24					; size = 1
_max_bytes$ = 28					; size = 8
_body_bytes$1$ = 36					; size = 4
tv777 = 36						; size = 4
_trim_to_limit$ = 36					; size = 1
?simulate_packet@kd_precinct@@QAE_JAA_JHG_N1_J1@Z PROC	; kd_precinct::simulate_packet, COMDAT
; _this$ = ecx

; 5838 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?simulate_packet@kd_precinct@@QAE_JAA_JHG_N1_J1@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx

; 5839 :   kd_tile *tile = resolution->tile_comp->tile;
; 5840 :   assert(required_layers == tile->num_layers);
; 5841 :   kd_buf_server *buf_server = resolution->codestream->buf_server;
; 5842 :   assert(layer_idx < required_layers);
; 5843 :   if (this->num_outstanding_blocks != 0)

	cmp	DWORD PTR [ebx+24], 0
	mov	edx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR _tile$1$[ebp], edi
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR _buf_server$1$[ebp], eax
	je	SHORT $LN31@simulate_p

; 5844 :     { KDU_ERROR_DEV(e,37); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0IN@CECCKADH@You?5may?5not?5currently?5flush?5comp@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5844 :     { KDU_ERROR_DEV(e,37); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5847 :         "of all code-blocks in all precincts of all tiles."); }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN31@simulate_p:

; 5848 :   if (packet_bytes == NULL)

	cmp	DWORD PTR [ebx+32], 0
	jne	SHORT $LN32@simulate_p

; 5849 :     {
; 5850 :       assert(layer_idx == 0);
; 5851 :       packet_bytes = new kdu_long[required_layers];

	mov	eax, DWORD PTR [ebx+12]
	xor	ecx, ecx
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR [ebx+32], eax
$LN32@simulate_p:

; 5852 :     }
; 5853 :   if (layer_idx == 0)

	mov	edx, DWORD PTR _layer_idx$[ebp]
	test	edx, edx
	jne	SHORT $LN3@simulate_p

; 5854 :     { // Assign each packet the smallest legal empty packet size by default.
; 5855 :       for (int n=0; n < required_layers; n++)

	xor	esi, esi
	cmp	DWORD PTR [ebx+12], esi
	jle	SHORT $LN3@simulate_p
	npad	6
$LL4@simulate_p:

; 5856 :         packet_bytes[n] = (tile->use_eph)?3:1;

	mov	ecx, DWORD PTR [ebx+32]
	xor	eax, eax
	cmp	BYTE PTR [edi+225], al
	setne	al
	lea	eax, DWORD PTR [eax*2+1]
	cdq
	mov	DWORD PTR [ecx+esi*8], eax
	mov	DWORD PTR [ecx+esi*8+4], edx
	inc	esi
	cmp	esi, DWORD PTR [ebx+12]
	jl	SHORT $LL4@simulate_p
	mov	edx, DWORD PTR _layer_idx$[ebp]
$LN3@simulate_p:

; 5857 :     }
; 5858 :   packet_bytes[layer_idx] = 0; // Mark packet so we can catch any failure later
; 5859 : 
; 5860 :   if (trim_to_limit)

	cmp	BYTE PTR _trim_to_limit$[ebp], 0
	lea	ecx, DWORD PTR [edx*8]
	mov	eax, DWORD PTR [ebx+32]
	mov	DWORD PTR tv799[ebp], ecx
	mov	DWORD PTR [ecx+eax], 0
	mov	DWORD PTR [ecx+eax+4], 0
	je	SHORT $LN6@simulate_p

; 5861 :     { /* To make the code below work efficiently, we need to first trim away
; 5862 :          all coding passes which have slopes <= `slope_threshold'.  This
; 5863 :          only leaves coding passes which have slopes equal to `slope_threshold'
; 5864 :          to consider for further discarding. */
; 5865 :       assert(last_layer && finalize_layer);
; 5866 :       for (int b=0; b < resolution->num_subbands; b++)

	mov	eax, DWORD PTR [ebx]
	xor	ecx, ecx
	mov	DWORD PTR _b$1$[ebp], ecx
	cmp	BYTE PTR [eax+174], cl
	jbe	SHORT $LN6@simulate_p
	xor	eax, eax
	mov	DWORD PTR tv777[ebp], eax
	npad	4
$LL7@simulate_p:

; 5867 :         {
; 5868 :           kd_precinct_band *pband = subbands + b;

	mov	ebx, DWORD PTR [ebx+40]
	add	ebx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	edi, DWORD PTR [ebx+16]
	imul	edi, DWORD PTR [ebx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5870 :           for (int n=0; n < num_blocks; n++)

	test	edi, edi
	jle	SHORT $LN5@simulate_p

; 5867 :         {
; 5868 :           kd_precinct_band *pband = subbands + b;

	xor	esi, esi
$LL10@simulate_p:

; 5871 :             pband->blocks[n].trim_data(slope_threshold,buf_server);

	push	DWORD PTR _buf_server$1$[ebp]
	mov	ecx, DWORD PTR [ebx+20]
	push	DWORD PTR _slope_threshold$[ebp]
	add	ecx, esi
	call	?trim_data@kd_block@@QAE_NGPAVkd_buf_server@@@Z ; kd_block::trim_data
	add	esi, 24					; 00000018H
	sub	edi, 1
	jne	SHORT $LL10@simulate_p
	mov	ecx, DWORD PTR _b$1$[ebp]
	mov	eax, DWORD PTR tv777[ebp]
$LN5@simulate_p:

; 5861 :     { /* To make the code below work efficiently, we need to first trim away
; 5862 :          all coding passes which have slopes <= `slope_threshold'.  This
; 5863 :          only leaves coding passes which have slopes equal to `slope_threshold'
; 5864 :          to consider for further discarding. */
; 5865 :       assert(last_layer && finalize_layer);
; 5866 :       for (int b=0; b < resolution->num_subbands; b++)

	mov	ebx, DWORD PTR _this$1$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR tv777[ebp], eax
	inc	ecx
	mov	DWORD PTR _b$1$[ebp], ecx
	mov	eax, DWORD PTR [ebx]
	movzx	eax, BYTE PTR [eax+174]
	cmp	ecx, eax
	mov	eax, DWORD PTR tv777[ebp]
	jl	SHORT $LL7@simulate_p
	mov	edx, DWORD PTR _layer_idx$[ebp]
$LN6@simulate_p:

; 5872 :         }
; 5873 :     }
; 5874 : 
; 5875 :   int last_trimmed_subband = resolution->num_subbands;

	mov	eax, DWORD PTR [ebx]

; 5876 :   int last_trimmed_block = 0;

	mov	DWORD PTR _last_trimmed_block$1$[ebp], 0
	movzx	eax, BYTE PTR [eax+174]
	mov	DWORD PTR _last_trimmed_subband$1$[ebp], eax
$LL13@simulate_p:

; 5877 :   kdu_long body_bytes;
; 5878 : 
; 5879 :   do { // Iterates only if we are trimming blocks to meet a `max_bytes' target
; 5880 :       body_bytes = 0;
; 5881 :       header_bytes = 1; // Minimum possible header size.

	mov	edi, DWORD PTR _header_bytes$[ebp]
	xorps	xmm0, xmm0

; 5882 :       if (tile->use_sop)

	mov	eax, DWORD PTR _tile$1$[ebp]
	movlpd	QWORD PTR _body_bytes$[ebp], xmm0
	mov	DWORD PTR [edi], 1
	mov	DWORD PTR [edi+4], 0
	cmp	BYTE PTR [eax+224], 0
	je	SHORT $LN35@simulate_p

; 5883 :         header_bytes += 6;

	mov	DWORD PTR [edi], 7
	mov	DWORD PTR [edi+4], 0
$LN35@simulate_p:

; 5884 :       if (tile->use_eph)

	cmp	BYTE PTR [eax+225], 0
	je	SHORT $LN36@simulate_p

; 5885 :         header_bytes += 2;

	add	DWORD PTR [edi], 2
	adc	DWORD PTR [edi+4], 0
$LN36@simulate_p:

; 5886 :       // Run the packet start functions for this packet
; 5887 :       int b;
; 5888 :       for (b=0; b < resolution->num_subbands; b++)

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR _b$1$[ebp], 0
	cmp	BYTE PTR [eax+174], 0
	mov	eax, DWORD PTR _body_bytes$[ebp+4]
	mov	DWORD PTR _body_bytes$2$[ebp], eax
	mov	eax, DWORD PTR _body_bytes$[ebp]
	mov	DWORD PTR _body_bytes$1$[ebp], eax
	jbe	$LN15@simulate_p
	xor	ecx, ecx
	mov	DWORD PTR tv773[ebp], ecx
	jmp	SHORT $LN16@simulate_p
	npad	3
$LL133@simulate_p:
	mov	edx, DWORD PTR _layer_idx$[ebp]
$LN16@simulate_p:

; 5889 :         {
; 5890 :           kd_precinct_band *pband = subbands + b;

	mov	esi, DWORD PTR [ebx+40]
	add	esi, ecx

; 5891 :           if (layer_idx == 0)
; 5892 :             kd_block::reset_output_tree(pband->blocks,

	push	DWORD PTR [esi+16]
	push	DWORD PTR [esi+12]
	push	DWORD PTR [esi+20]
	test	edx, edx
	jne	SHORT $LN37@simulate_p
	call	?reset_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z ; kd_block::reset_output_tree

; 5893 :                                         pband->block_indices.size);
; 5894 :           else

	jmp	SHORT $LN135@simulate_p
$LN37@simulate_p:

; 5895 :             kd_block::restore_output_tree(pband->blocks,

	call	?restore_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z ; kd_block::restore_output_tree
$LN135@simulate_p:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	edi, DWORD PTR [esi+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5895 :             kd_block::restore_output_tree(pband->blocks,

	add	esp, 12					; 0000000cH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	imul	edi, DWORD PTR [esi+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5898 :           for (int n=0; n < num_blocks; n++)

	test	edi, edi
	jle	SHORT $LN131@simulate_p

; 5896 :                                           pband->block_indices.size);
; 5897 :           int num_blocks = (int) pband->block_indices.area();

	xor	ebx, ebx
$LL19@simulate_p:

; 5899 :             body_bytes +=

	push	DWORD PTR _slope_threshold$[ebp]
	mov	ecx, DWORD PTR [esi+20]
	push	DWORD PTR _layer_idx$[ebp]
	add	ecx, ebx
	call	?start_packet@kd_block@@QAEHHG@Z	; kd_block::start_packet
	mov	ecx, DWORD PTR _body_bytes$1$[ebp]
	cdq
	add	ecx, eax
	mov	eax, DWORD PTR _body_bytes$2$[ebp]
	mov	DWORD PTR _body_bytes$1$[ebp], ecx
	adc	eax, edx
	add	ebx, 24					; 00000018H
	mov	DWORD PTR _body_bytes$2$[ebp], eax
	sub	edi, 1
	jne	SHORT $LL19@simulate_p
	mov	ebx, DWORD PTR _this$1$[ebp]
	jmp	SHORT $LN18@simulate_p
$LN131@simulate_p:
	mov	eax, DWORD PTR _body_bytes$2$[ebp]
	mov	ecx, DWORD PTR _body_bytes$1$[ebp]
$LN18@simulate_p:

; 5900 :               pband->blocks[n].start_packet(layer_idx,slope_threshold);
; 5901 :           if ((body_bytes+header_bytes) > max_bytes)

	mov	edi, DWORD PTR _header_bytes$[ebp]
	add	ecx, DWORD PTR [edi]
	adc	eax, DWORD PTR [edi+4]
	cmp	eax, DWORD PTR _max_bytes$[ebp+4]
	jl	SHORT $LN14@simulate_p
	jg	SHORT $LN124@simulate_p
	cmp	ecx, DWORD PTR _max_bytes$[ebp]
	jbe	SHORT $LN14@simulate_p
$LN124@simulate_p:

; 5902 :             {
; 5903 :               if (!finalize_layer)

	cmp	BYTE PTR _finalize_layer$[ebp], 0
	je	$LN91@simulate_p
$LN14@simulate_p:

; 5886 :       // Run the packet start functions for this packet
; 5887 :       int b;
; 5888 :       for (b=0; b < resolution->num_subbands; b++)

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR _b$1$[ebp]
	mov	ecx, DWORD PTR tv773[ebp]
	inc	edx
	add	ecx, 24					; 00000018H
	mov	DWORD PTR _b$1$[ebp], edx
	movzx	eax, BYTE PTR [eax+174]
	mov	DWORD PTR tv773[ebp], ecx
	cmp	edx, eax
	jl	$LL133@simulate_p
$LN15@simulate_p:

; 5913 :       for (b=0; b < resolution->num_subbands; b++)

	mov	eax, DWORD PTR _this$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }

	xor	esi, esi

; 3558 :     void put_bit(int bit)
; 3559 :       { // Output a header bit
; 3560 :         assert(bit == (bit & 1));
; 3561 :         if (bits_left == 0)
; 3562 :           { if (out != NULL) out->put(byte);
; 3563 :             completed_bytes++;
; 3564 :             bits_left = (byte==0xFF)?7:8;
; 3565 :             byte = 0; }
; 3566 :         byte += byte + bit;

	mov	bl, 1

; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }

	mov	DWORD PTR _head$3[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5913 :       for (b=0; b < resolution->num_subbands; b++)

	xor	ecx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }

	mov	DWORD PTR _head$3[ebp+12], esi

; 3558 :     void put_bit(int bit)
; 3559 :       { // Output a header bit
; 3560 :         assert(bit == (bit & 1));
; 3561 :         if (bits_left == 0)
; 3562 :           { if (out != NULL) out->put(byte);
; 3563 :             completed_bytes++;
; 3564 :             bits_left = (byte==0xFF)?7:8;
; 3565 :             byte = 0; }
; 3566 :         byte += byte + bit;

	mov	BYTE PTR _head$3[ebp], bl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5913 :       for (b=0; b < resolution->num_subbands; b++)

	mov	eax, DWORD PTR [eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3567 :         bits_left--;

	mov	DWORD PTR _head$3[ebp+4], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5913 :       for (b=0; b < resolution->num_subbands; b++)

	mov	DWORD PTR _b$2$[ebp], ecx
	cmp	BYTE PTR [eax+174], cl
	jbe	SHORT $LN123@simulate_p
	mov	ebx, DWORD PTR _this$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }

	xor	eax, eax
	mov	DWORD PTR tv771[ebp], eax
$LL22@simulate_p:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5915 :           kd_precinct_band *pband = subbands + b;

	mov	ebx, DWORD PTR [ebx+40]
	add	ebx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	edi, DWORD PTR [ebx+16]
	imul	edi, DWORD PTR [ebx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5917 :           for (int n=0; n < num_blocks; n++)

	test	edi, edi
	jle	SHORT $LN20@simulate_p

; 5915 :           kd_precinct_band *pband = subbands + b;

	xor	esi, esi
$LL25@simulate_p:

; 5918 :             pband->blocks[n].write_packet_header(head,layer_idx,true);

	mov	ecx, DWORD PTR [ebx+20]
	lea	eax, DWORD PTR _head$3[ebp]
	push	1
	push	DWORD PTR _layer_idx$[ebp]
	add	ecx, esi
	push	eax
	call	?write_packet_header@kd_block@@QAEXAAVkd_header_out@@H_N@Z ; kd_block::write_packet_header
	add	esi, 24					; 00000018H
	sub	edi, 1
	jne	SHORT $LL25@simulate_p
	mov	ecx, DWORD PTR _b$2$[ebp]
	mov	eax, DWORD PTR tv771[ebp]
$LN20@simulate_p:

; 5913 :       for (b=0; b < resolution->num_subbands; b++)

	mov	ebx, DWORD PTR _this$1$[ebp]
	add	eax, 24					; 00000018H
	mov	DWORD PTR tv771[ebp], eax
	inc	ecx
	mov	DWORD PTR _b$2$[ebp], ecx
	mov	eax, DWORD PTR [ebx]
	movzx	eax, BYTE PTR [eax+174]
	cmp	ecx, eax
	mov	eax, DWORD PTR tv771[ebp]
	jl	SHORT $LL22@simulate_p
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3576 :         if (bits_left < 8)

	cmp	DWORD PTR _head$3[ebp+4], 8
	jge	SHORT $LN69@simulate_p
	mov	esi, DWORD PTR _head$3[ebp+12]
	mov	bl, BYTE PTR _head$3[ebp]
$LN123@simulate_p:

; 3577 :           {
; 3578 :             byte <<= bits_left;

	mov	cl, BYTE PTR _head$3[ebp+4]
	shl	bl, cl
	mov	BYTE PTR _head$3[ebp], bl

; 3579 :             if (out != NULL)

	test	esi, esi
	je	SHORT $LN68@simulate_p
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN73@simulate_p

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN73@simulate_p:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
	mov	esi, DWORD PTR _head$3[ebp+12]
	mov	bl, BYTE PTR _head$3[ebp]
$LN68@simulate_p:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3581 :             completed_bytes++;

	inc	DWORD PTR _head$3[ebp+8]

; 3582 :             if (byte == 0xFF)

	cmp	bl, 255					; 000000ffH
	jne	SHORT $LN130@simulate_p

; 3583 :               { // Need the stuffing byte.
; 3584 :                 if (out != NULL)

	test	esi, esi
	je	SHORT $LN70@simulate_p
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN76@simulate_p

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN76@simulate_p:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 0
	inc	DWORD PTR [esi+516]
$LN70@simulate_p:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3586 :                 completed_bytes++;

	inc	DWORD PTR _head$3[ebp+8]
$LN130@simulate_p:
	mov	ebx, DWORD PTR _this$1$[ebp]
$LN69@simulate_p:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5920 :       header_bytes += head.finish() - 1; // Already counted the 1'st byte above

	mov	esi, DWORD PTR _header_bytes$[ebp]
	mov	eax, DWORD PTR _head$3[ebp+8]

; 5921 : 
; 5922 :       if ((body_bytes+header_bytes) > max_bytes)

	mov	edi, DWORD PTR _body_bytes$1$[ebp]
	dec	eax
	cdq
	mov	ecx, edi
	add	DWORD PTR [esi], eax
	adc	DWORD PTR [esi+4], edx
	add	ecx, DWORD PTR [esi]
	mov	edx, DWORD PTR _header_bytes$[ebp]
	mov	esi, DWORD PTR _body_bytes$2$[ebp]
	mov	eax, esi
	adc	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _max_bytes$[ebp+4]
	jl	SHORT $LN42@simulate_p
	jg	SHORT $LN125@simulate_p
	cmp	ecx, DWORD PTR _max_bytes$[ebp]
	jbe	SHORT $LN42@simulate_p
$LN125@simulate_p:

; 5923 :         {
; 5924 :           if (!finalize_layer)

	cmp	BYTE PTR _finalize_layer$[ebp], 0
	je	$LN93@simulate_p

; 5926 :           assert(trim_to_limit);
; 5927 : 
; 5928 :           // If we get here, we need to trim away some code-block contributions
; 5929 : 
; 5930 :           bool something_discarded = false;

	mov	edx, DWORD PTR _last_trimmed_subband$1$[ebp]
	xor	cl, cl
	mov	edi, DWORD PTR _last_trimmed_block$1$[ebp]
	lea	esi, DWORD PTR [edx+edx*2]
	shl	esi, 3
$LL26@simulate_p:

; 5932 :             {
; 5933 :               kd_precinct_band *pband = subbands + last_trimmed_subband;

	mov	eax, DWORD PTR [ebx+40]
	add	eax, esi

; 5934 :               if (last_trimmed_block == 0)

	test	edi, edi
	jne	SHORT $LN45@simulate_p
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	edi, DWORD PTR [eax-8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5936 :                   last_trimmed_subband--; pband--;

	dec	edx
	sub	esi, 24					; 00000018H
	mov	DWORD PTR _last_trimmed_subband$1$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	imul	edi, DWORD PTR [eax-12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5940 :                   continue; // In case precinct-band contains no code-blocks

	jmp	SHORT $LN101@simulate_p
$LN45@simulate_p:

; 5941 :                 }
; 5942 :               last_trimmed_block--;
; 5943 :               kd_block *block = pband->blocks + last_trimmed_block;

	mov	eax, DWORD PTR [eax+20]
	dec	edi

; 5944 :               something_discarded =

	push	DWORD PTR _buf_server$1$[ebp]
	lea	ecx, DWORD PTR [edi+edi*2]
	lea	ecx, DWORD PTR [eax+ecx*8]
	mov	eax, DWORD PTR _slope_threshold$[ebp]
	inc	eax
	push	eax
	call	?trim_data@kd_block@@QAE_NGPAVkd_buf_server@@@Z ; kd_block::trim_data
	mov	edx, DWORD PTR _last_trimmed_subband$1$[ebp]
	mov	cl, al
$LN101@simulate_p:

; 5931 :           while (!something_discarded)

	test	cl, cl
	je	SHORT $LL26@simulate_p
	mov	DWORD PTR _last_trimmed_block$1$[ebp], edi

; 5945 :                 block->trim_data(slope_threshold+1,buf_server);
; 5946 :             }
; 5947 :         }
; 5948 :       else if (finalize_layer)

	jmp	SHORT $LN137@simulate_p
$LN42@simulate_p:
	cmp	BYTE PTR _finalize_layer$[ebp], 0
	je	SHORT $LN11@simulate_p

; 5949 :         { // Save the state information in preparation for output.
; 5950 :           for (b=0; b < resolution->num_subbands; b++)

	mov	eax, DWORD PTR [ebx]
	xor	edi, edi
	cmp	BYTE PTR [eax+174], 0
	jbe	SHORT $LN132@simulate_p
	xor	esi, esi
$LL30@simulate_p:

; 5951 :             {
; 5952 :               kd_precinct_band *pband = subbands + b;

	mov	eax, DWORD PTR [ebx+40]

; 5953 :               kd_block::save_output_tree(pband->blocks,

	push	DWORD PTR [eax+esi+16]
	push	DWORD PTR [eax+esi+12]
	push	DWORD PTR [eax+esi+20]
	call	?save_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z ; kd_block::save_output_tree
	mov	eax, DWORD PTR [ebx]
	lea	esi, DWORD PTR [esi+24]
	inc	edi
	add	esp, 12					; 0000000cH
	movzx	eax, BYTE PTR [eax+174]
	cmp	edi, eax
	jl	SHORT $LL30@simulate_p
$LN137@simulate_p:
	mov	edx, DWORD PTR _header_bytes$[ebp]
	mov	esi, DWORD PTR _body_bytes$2$[ebp]
$LN132@simulate_p:
	mov	edi, DWORD PTR _body_bytes$1$[ebp]
$LN11@simulate_p:

; 5954 :                                          pband->block_indices.size);
; 5955 :             }
; 5956 :         }
; 5957 :     } while ((body_bytes+header_bytes) > max_bytes);

	mov	ecx, edi
	mov	eax, esi
	add	ecx, DWORD PTR [edx]
	adc	eax, DWORD PTR [edx+4]
	cmp	eax, DWORD PTR _max_bytes$[ebp+4]
	jl	SHORT $LN92@simulate_p
	jg	SHORT $LN126@simulate_p
	cmp	ecx, DWORD PTR _max_bytes$[ebp]
	jbe	SHORT $LN92@simulate_p
$LN126@simulate_p:
	mov	edx, DWORD PTR _layer_idx$[ebp]
	jmp	$LL13@simulate_p
$LN91@simulate_p:

; 5904 :                 return body_bytes+header_bytes;

	mov	eax, DWORD PTR _body_bytes$1$[ebp]
	add	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR _body_bytes$2$[ebp]
	adc	edx, DWORD PTR [edi+4]

; 5962 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN93@simulate_p:

; 5925 :             return body_bytes+header_bytes;

	add	edi, DWORD PTR [edx]
	adc	esi, DWORD PTR [edx+4]
	jmp	SHORT $LN136@simulate_p
$LN92@simulate_p:

; 5958 : 
; 5959 :   // Record packet length information.
; 5960 :   packet_bytes[layer_idx] = body_bytes + header_bytes;

	mov	eax, DWORD PTR _header_bytes$[ebp]
	mov	edx, edi
	mov	ecx, esi
	add	edx, DWORD PTR [eax]
	adc	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ebx+32]
	mov	ebx, DWORD PTR tv799[ebp]
	mov	DWORD PTR [ebx+eax], edx
	mov	DWORD PTR [ebx+eax+4], ecx

; 5961 :   return body_bytes + header_bytes;

	mov	eax, DWORD PTR _header_bytes$[ebp]
	add	edi, DWORD PTR [eax]
	adc	esi, DWORD PTR [eax+4]
$LN136@simulate_p:
	mov	edx, esi
	mov	eax, edi

; 5962 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?simulate_packet@kd_precinct@@QAE_JAA_JHG_N1_J1@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?simulate_packet@kd_precinct@@QAE_JAA_JHG_N1_J1@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-96]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?simulate_packet@kd_precinct@@QAE_JAA_JHG_N1_J1@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?simulate_packet@kd_precinct@@QAE_JAA_JHG_N1_J1@Z ENDP	; kd_precinct::simulate_packet
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?load_required_packets@kd_precinct@@QAEXXZ
_TEXT	SEGMENT
?load_required_packets@kd_precinct@@QAEXXZ PROC		; kd_precinct::load_required_packets, COMDAT
; _this$ = ecx

; 4226 :       {

	push	esi
	mov	esi, ecx

; 4227 :         if ((!(flags & KD_PFLAG_ADDRESSABLE)) ||
; 4228 :             (unique_address == 0) || (num_packets_read != 0))

	test	BYTE PTR [esi+8], 8
	je	SHORT $LN12@load_requi
	mov	edx, DWORD PTR [esi+32]
	mov	eax, edx
	mov	ecx, DWORD PTR [esi+36]
	or	eax, ecx
	je	SHORT $LN12@load_requi
	cmp	DWORD PTR [esi+20], 0
	jne	SHORT $LN12@load_requi

; 4229 :           return;
; 4230 :         assert((flags & KD_PFLAG_DESEQUENCED) &&
; 4231 :                (next_layer_idx >= required_layers));
; 4232 :         resolution->codestream->in->seek(unique_address);

	mov	eax, DWORD PTR [esi]
	push	ecx
	push	edx
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	call	?seek@kd_compressed_input@@QAEX_J@Z	; kd_compressed_input::seek

; 4233 :         while (num_packets_read < required_layers)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, DWORD PTR [esi+12]
	jge	SHORT $LN12@load_requi
$LL2@load_requi:

; 4234 :           if (!read_packet())

	mov	ecx, esi
	call	?read_packet@kd_precinct@@AAE_NXZ	; kd_precinct::read_packet
	test	al, al
	je	SHORT $LN12@load_requi

; 4233 :         while (num_packets_read < required_layers)

	mov	eax, DWORD PTR [esi+20]
	cmp	eax, DWORD PTR [esi+12]
	jl	SHORT $LL2@load_requi
$LN12@load_requi:
	pop	esi

; 4235 :             break;
; 4236 :       }

	ret	0
?load_required_packets@kd_precinct@@QAEXXZ ENDP		; kd_precinct::load_required_packets
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?desequence_packet@kd_precinct@@QAE_NXZ
_TEXT	SEGMENT
?desequence_packet@kd_precinct@@QAE_NXZ PROC		; kd_precinct::desequence_packet, COMDAT
; _this$ = ecx

; 4202 :       {

	push	esi
	mov	esi, ecx
	push	edi

; 4203 :         kd_tile *tile = resolution->tile_comp->tile;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+4]
	mov	edi, DWORD PTR [eax+4]

; 4204 :         assert(!(flags & (KD_PFLAG_DESEQUENCED | KD_PFLAG_ADDRESSABLE)));
; 4205 :         if (!read_packet()) return false;

	call	?read_packet@kd_precinct@@AAE_NXZ	; kd_precinct::read_packet
	test	al, al
	jne	SHORT $LN2@desequence
	pop	edi
	pop	esi

; 4218 :       }

	ret	0
$LN2@desequence:

; 4206 :         next_layer_idx++;

	inc	DWORD PTR [esi+16]
	mov	ecx, DWORD PTR [esi+16]

; 4207 :         if (next_layer_idx == tile->num_layers)

	cmp	ecx, DWORD PTR [edi+132]
	jne	SHORT $LN10@desequence

; 4176 :         if (flags & KD_PFLAG_DESEQUENCED)

	mov	eax, DWORD PTR [esi+8]
	test	al, 4
	jne	SHORT $LN10@desequence

; 4177 :           return;
; 4178 :         flags |= KD_PFLAG_DESEQUENCED;

	or	eax, 4
	mov	DWORD PTR [esi+8], eax

; 4179 :           // desequenced = true;
; 4180 :         if (next_layer_idx == 0)

	test	ecx, ecx
	jne	SHORT $LN9@desequence

; 4181 :           {
; 4182 :             flags |= KD_PFLAG_ADDRESSABLE;

	or	eax, 8

; 4183 :               // addressable = true;
; 4184 :             unique_address = 0;

	mov	DWORD PTR [esi+32], ecx
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+36], ecx
$LN9@desequence:

; 4185 :           }
; 4186 :         if (num_outstanding_blocks == 0)

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN10@desequence

; 4187 :           release();

	mov	ecx, esi
	call	?release@kd_precinct@@QAEXXZ		; kd_precinct::release
$LN10@desequence:

; 4208 :           finished_desequencing();
; 4209 :         tile->next_input_packet_num++;

	inc	DWORD PTR [edi+252]

; 4210 :         if ((flags & KD_PFLAG_RELEVANT) &&

	test	BYTE PTR [esi+8], 64			; 00000040H
	je	SHORT $LN5@desequence
	mov	eax, DWORD PTR [esi+16]
	cmp	eax, DWORD PTR [edi+140]
	jg	SHORT $LN5@desequence

; 4211 :             (next_layer_idx <= tile->max_relevant_layers))
; 4212 :           {
; 4213 :             tile->sequenced_relevant_packets++;

	inc	DWORD PTR [edi+248]

; 4214 :             if (tile->sequenced_relevant_packets==tile->max_relevant_packets)

	mov	eax, DWORD PTR [edi+248]
	cdq
	cmp	eax, DWORD PTR [edi+152]
	jne	SHORT $LN5@desequence
	cmp	edx, DWORD PTR [edi+156]
	jne	SHORT $LN5@desequence

; 4215 :               tile->finished_reading();

	mov	ecx, edi
	call	?finished_reading@kd_tile@@QAE_NXZ	; kd_tile::finished_reading
$LN5@desequence:

; 4216 :           }
; 4217 :         return true;

	pop	edi
	mov	al, 1
	pop	esi

; 4218 :       }

	ret	0
?desequence_packet@kd_precinct@@QAE_NXZ ENDP		; kd_precinct::desequence_packet
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?finished_desequencing@kd_precinct@@QAEXXZ
_TEXT	SEGMENT
?finished_desequencing@kd_precinct@@QAEXXZ PROC		; kd_precinct::finished_desequencing, COMDAT
; _this$ = ecx

; 4176 :         if (flags & KD_PFLAG_DESEQUENCED)

	mov	eax, DWORD PTR [ecx+8]
	test	al, 4
	jne	SHORT $LN4@finished_d

; 4177 :           return;
; 4178 :         flags |= KD_PFLAG_DESEQUENCED;

	or	eax, 4

; 4179 :           // desequenced = true;
; 4180 :         if (next_layer_idx == 0)

	cmp	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+8], eax
	jne	SHORT $LN3@finished_d

; 4181 :           {
; 4182 :             flags |= KD_PFLAG_ADDRESSABLE;

	or	eax, 8

; 4183 :               // addressable = true;
; 4184 :             unique_address = 0;

	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+36], 0
$LN3@finished_d:

; 4185 :           }
; 4186 :         if (num_outstanding_blocks == 0)

	cmp	DWORD PTR [ecx+24], 0
	je	?release@kd_precinct@@QAEXXZ		; kd_precinct::release
$LN4@finished_d:

; 4187 :           release();
; 4188 :       }

	ret	0
?finished_desequencing@kd_precinct@@QAEXXZ ENDP		; kd_precinct::finished_desequencing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?release@kd_precinct@@QAEXXZ
_TEXT	SEGMENT
?release@kd_precinct@@QAEXXZ PROC			; kd_precinct::release, COMDAT
; _this$ = ecx

; 4149 :         assert(resolution->codestream->in != NULL);
; 4150 :         num_outstanding_blocks = 0;
; 4151 :         flags |= KD_PFLAG_RELEASED;

	or	DWORD PTR [ecx+8], 16			; 00000010H
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [ecx+24], 0

; 4152 :           // released = true;
; 4153 :         if ((flags & KD_PFLAG_ADDRESSABLE) ||

	test	al, 8
	jne	SHORT $LN3@release
	test	al, 4
	je	SHORT $LN8@release
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	cmp	BYTE PTR [eax+337], 0
	jne	SHORT $LN8@release
$LN3@release:

; 4154 :             ((flags & KD_PFLAG_DESEQUENCED) &&
; 4155 :                 // if (addressable ||
; 4156 :                 //     (desequenced &&
; 4157 :              !resolution->codestream->persistent))
; 4158 :           ref->release(); // May unload us from memory!

	mov	edx, DWORD PTR [ecx+4]

; 4160 :     void finished_desequencing()
; 4161 :       /* Called once we can be sure that no more packets will be available
; 4162 :          for this precinct.  In practice, the function is called when the
; 4163 :          last packet has been desequenced or when the containing tile has
; 4164 :          been completely read.  If no packets at all have been desequenced for
; 4165 :          the precinct when this function is called (must have been invoked
; 4166 :          from within `kd_tile::finished_reading'), the precinct is marked
; 4167 :          as addressable, with an address of 0.  This is because it is safe
; 4168 :          to unload such a precinct and then reload it again regardless of
; 4169 :          the services offered by the compressed data source -- there is no
; 4170 :          data actually available from the compressed source for the
; 4171 :          precinct anyway, so reloading is a no-op.
; 4172 :             It should be noted that this function may unload the precinct
; 4173 :          from memory if it is determined that all code-blocks in the
; 4174 :          region of interest (there may be none) have already been consumed. */
; 4175 :       {
; 4176 :         if (flags & KD_PFLAG_DESEQUENCED)
; 4177 :           return;
; 4178 :         flags |= KD_PFLAG_DESEQUENCED;
; 4179 :           // desequenced = true;
; 4180 :         if (next_layer_idx == 0)
; 4181 :           {
; 4182 :             flags |= KD_PFLAG_ADDRESSABLE;
; 4183 :               // addressable = true;
; 4184 :             unique_address = 0;
; 4185 :           }
; 4186 :         if (num_outstanding_blocks == 0)
; 4187 :           release();
; 4188 :       }
; 4189 :     bool desequence_packet()
; 4190 :       /* This function should be called when a non-NULL `kd_precinct_ref'
; 4191 :          pointer is returned by `kd_packet_sequencer::next_in_sequence' and
; 4192 :          its `kd_precinct_ref::is_sequenced' function returns false.
; 4193 :          The function invokes `read_packet' and, if successful, increments
; 4194 :          the precinct's `next_layer_idx' field and the containing tile's
; 4195 :          `num_sequenced_packets' field.
; 4196 :             The function returns false if `read_packet' returns false,
; 4197 :          in which case, more tile-parts must be read (if there are any) to
; 4198 :          recover the information required to desequence the packet.
; 4199 :             Before returning true, the function checks to see whether all
; 4200 :          packets for the tile have been sequenced.  If so, the tile's
; 4201 :          `finished_reading' function is called. */
; 4202 :       {
; 4203 :         kd_tile *tile = resolution->tile_comp->tile;
; 4204 :         assert(!(flags & (KD_PFLAG_DESEQUENCED | KD_PFLAG_ADDRESSABLE)));
; 4205 :         if (!read_packet()) return false;
; 4206 :         next_layer_idx++;
; 4207 :         if (next_layer_idx == tile->num_layers)
; 4208 :           finished_desequencing();
; 4209 :         tile->next_input_packet_num++;
; 4210 :         if ((flags & KD_PFLAG_RELEVANT) &&
; 4211 :             (next_layer_idx <= tile->max_relevant_layers))
; 4212 :           {
; 4213 :             tile->sequenced_relevant_packets++;
; 4214 :             if (tile->sequenced_relevant_packets==tile->max_relevant_packets)
; 4215 :               tile->finished_reading();
; 4216 :           }
; 4217 :         return true;
; 4218 :       }
; 4219 :     void load_required_packets()
; 4220 :       /* If the precinct is addressable, this function uses its
; 4221 :          `unique_address' to position the compressed data source at the
; 4222 :          beginning of the precinct's first packet; it then loads all required
; 4223 :          packets from the compressed source.  Otherwise, the function does
; 4224 :          nothing at all -- reading is presumed to have occurred during packet
; 4225 :          desequencing. */
; 4226 :       {
; 4227 :         if ((!(flags & KD_PFLAG_ADDRESSABLE)) ||
; 4228 :             (unique_address == 0) || (num_packets_read != 0))
; 4229 :           return;
; 4230 :         assert((flags & KD_PFLAG_DESEQUENCED) &&
; 4231 :                (next_layer_idx >= required_layers));
; 4232 :         resolution->codestream->in->seek(unique_address);
; 4233 :         while (num_packets_read < required_layers)
; 4234 :           if (!read_packet())
; 4235 :             break;
; 4236 :       }
; 4237 :     kdu_long simulate_packet(kdu_long &header_bytes,
; 4238 :                              int layer_idx, kdu_uint16 slope_threshold,
; 4239 :                              bool finalize_layer, bool last_layer,
; 4240 :                              kdu_long max_bytes=KDU_LONG_HUGE,
; 4241 :                              bool trim_to_limit=false);
; 4242 :       /* Implements the functionality of `kd_codestream::simulate_output'
; 4243 :          for a single precinct.  Note that the total number of packet bytes
; 4244 :          is left behind in the internal `layer_bytes' array.  This allows the
; 4245 :          determination of tile-part length fields later on when we come to
; 4246 :          construct the code-stream.  The function returns this total number
; 4247 :          of bytes.  It also returns the number of packet header bytes via
; 4248 :          `header_bytes' (the function return value includes the cost of these
; 4249 :          header bytes).
; 4250 :             If the `max_bytes' limit is exceeded, the function may return
; 4251 :          prematurely, without having completed the simulation.  This is
; 4252 :          unacceptable when finalizing a layer, so you must be sure that
; 4253 :          `max_bytes' is sufficient in that case.
; 4254 :             If `trim_to_limit' is true, `finalize_layer' and `last_layer'
; 4255 :          must also both be true.  The function then trims away all coding
; 4256 :          passes from the precinct's code-blocks which are associated with
; 4257 :          slope values of `slope_threshold'+1 or less, until the limit
; 4258 :          associated with `max_bytes' is satisfied.  This functionality is
; 4259 :          used to implement the `sloppy_bytes' capabilities advertised by the
; 4260 :          `kd_codestream::simulate_output' function. */
; 4261 :     kdu_long write_packet(kdu_uint16 slope_threshold, bool empty_packet=false);
; 4262 :       /* Writes out the next packet for this precinct, using the supplied
; 4263 :          distortion-length slope threshold.  Increments the `next_layer_idx'
; 4264 :          field as well as the containing tile's `num_sequenced_packets'
; 4265 :          field when done.  If `empty_packet' is true, an empty packet should
; 4266 :          be issued, having a length of 1 byte, plus the length of any required
; 4267 :          EPH marker (no SOP marker will be attached to empty packets).  The
; 4268 :          function returns the total number of bytes output for the packet. */
; 4269 :   private: // Member functions
; 4270 :     bool read_packet();
; 4271 :       /* Reads a new layer of this precinct sequentially from the
; 4272 :          compressed data source, incrementing the `num_packets_read' member.
; 4273 :          Note that packet reading may be interleaved with acesses to the
; 4274 :          precinct's code-blocks for various reasons.  For example, we
; 4275 :          may initially open a tile with only a limited number of required
; 4276 :          layers, using its code-block data to decompress an approximate
; 4277 :          representation of the image.  We may then find that the additional
; 4278 :          packets need to be loaded in order to advance to other precincts
; 4279 :          in the code-stream.
; 4280 :             The function returns false if an SOT marker (or an EOC marker) is
; 4281 :          encountered.  Note that when an SOT marker is encountered, its
; 4282 :          segment is fully read into the codestream marker service and the
; 4283 :          precinct's tile must be active (otherwise an error message will be
; 4284 :          generated).  Before returning false in this way, the function sets
; 4285 :          the `active_tile' pointer in the codestream object to NULL.  The
; 4286 :          caller may determine the cause of failure by invoking the codestream
; 4287 :          marker service's `get_code' function, which will return one of SOT,
; 4288 :          EOC or 0, where 0 occurs only if the code-stream has been
; 4289 :          exhausted. */
; 4290 :     bool handle_corrupt_packet();
; 4291 :       /* This function implements alternate processing for the `read_packet'
; 4292 :          function in the event that a packet is found to be corrupt.  It is
; 4293 :          called whenever packet corruption is detected, including when the
; 4294 :          precinct is known to have had previously corrupt packets. The function
; 4295 :          manipulates the containing tile's `skipping_to_sop' and
; 4296 :          `next_sop_sequence_num' fields, advancing to the next SOP or SOT
; 4297 :          marker if necessary (the function may be called after detecting an
; 4298 :          SOP marker already, whose sequence number is not as expected).  If
; 4299 :          an SOT marker is encountered, the function renders the current tile
; 4300 :          inactive and returns false (this is the behaviour expected of
; 4301 :          `read_packet').  Otherwise, it updates the precinct and tile state to
; 4302 :          identify the packet as having been read. */
; 4303 :   public: // Public Links and Identification
; 4304 :     kd_resolution *resolution;
; 4305 :     kd_precinct_ref *ref; // Element of `resolution->precinct_refs' array
; 4306 : 
; 4307 :   public: // Mode flags used for decompression and/or interchange
; 4308 :     int flags; // The following flags are defined.
; 4309 :        // KD_PFLAG_GENERATING -- after 1'st call to `kd_precinct::get_packets'
; 4310 :        // KD_PFLAG_CORRUPTED -- if error occurred during packet reading
; 4311 :        // KD_PFLAG_DESEQUENCED -- if all packets have been desequenced
; 4312 :        // KD_PFLAG_ADDRESSABLE -- if seekable, cached or used for interchange
; 4313 :        // KD_PFLAG_RELEASED -- if `activate' must be called to revive state
; 4314 :        // KD_PFLAG_INACTIVE -- if resides on `kd_precict_server's inactive list
; 4315 :        // KD_PFLAG_RELEVANT -- always true if codestream is for non-persistent
; 4316 :        //     input; otherwise, true only if precinct belongs to the relevant
; 4317 :        //     set of precincts of a relevant tile-component-resolution
; 4318 :        // KD_PFLAG_SIGNIFICANT -- if any code-block bytes have been generated
; 4319 :        //     by `kdu_precinct::size_packets' or `kdu_precinct::get_packets'
; 4320 :        // KD_PFLAG_PARSED -- if the precinct was parsed previously and then
; 4321 :        //     unloaded; prevents multiple accumulation of packet length stats
; 4322 :   public: // State variables
; 4323 :     int required_layers; /* Actual number of layers for output codestream;
; 4324 :                 max apparent layers for input or interchange codestream. */
; 4325 :     int next_layer_idx; // Next layer to be sequenced or generated.
; 4326 :     union { // First field used for input; second interchange; third for output
; 4327 :         int num_packets_read; // Incremented when packets read or interchanged
; 4328 :         int cumulative_bytes; // Size of all packets generated so far.
; 4329 :         int saved_next_layer_idx; // Used by "kd_packet_sequencer::save_state"
; 4330 :       };
; 4331 : 
; 4332 :   public: // Activation state variables
; 4333 :     int num_outstanding_blocks; // See notes below.
; 4334 :     union { // First field used only in reading; second only in writing.
; 4335 :         kdu_long unique_address; // See below
; 4336 :         kdu_long *packet_bytes; // Lengths generated during simulated output
; 4337 :       };
; 4338 :   public: // code-block containers
; 4339 :     kd_precinct_band *subbands; // In practice, this member points into the
; 4340 :        // same block of memory which is allocated to hold the precinct so
; 4341 :        // as to encourage memory locality and allow for manipulation of all
; 4342 :        // aspects of a precinct, including all of its code-blocks, via a
; 4343 :        // single heap block.  Note that the number of entries in this array
; 4344 :        // is given by `resolution->num_subbands'.
; 4345 : 
; 4346 :   public: // See below for an explanation of these links
; 4347 :     kd_precinct *next; // Next in free, inactive or generated list
; 4348 :     kd_precinct *prev; // Previous in inactive or generated list
; 4349 :     kd_precinct_size_class *size_class; // For correctly releasing storage
; 4350 :   };
; 4351 :   /* Notes:
; 4352 :         `unique_address' is valid if and only if the precinct is marked as
; 4353 :      addressable, meaning that the precinct has a unique address from which it
; 4354 :      may be loaded (for input codestream objects) or identified (for
; 4355 :      interchange codestream objects).  If addressable, the `unique_address'
; 4356 :      will be 0 if and only if the precinct is known to be empty, meaning that
; 4357 :      reloading the precinct does not require any actual data transfers from a
; 4358 :      compressed data source.
; 4359 :         Except as described above, when used with seekable compressed data
; 4360 :      sources, the `unique_address' member holds a positive quantity which
; 4361 :      identifies an offset into the code-stream at which the precinct's
; 4362 :      packets may be found.  In the case of cached sources (those advertising
; 4363 :      the KDU_SOURCE_CAP_CACHED capability) or codestream objects created for
; 4364 :      interchange (no compressed data source or target), the `unique_address'
; 4365 :      will be negative and -(1+`unique_address') is the precinct's unique
; 4366 :      identifier, as passed to the `kdu_compressed_source::set_precinct_scope'
; 4367 :      function, or returned by the `kdu_precinct::get_unique_id' function.
; 4368 :         The `num_outstanding_blocks' member is used to monitor the number of
; 4369 :      code-blocks from the application's region of interest which have still
; 4370 :      to be consumed (input codestreams) or the number of code-blocks which
; 4371 :      have still to be written in order to complete the precinct (output
; 4372 :      and interchange codestreams).
; 4373 :         The `next' and `prev' links may be used to manage the precinct's
; 4374 :      location in one of three different lists.  The first list is the
; 4375 :      singly-linked free list maintained by `kd_precinct_size_class', from
; 4376 :      which the `kd_precinct_server' object re-issues previously released
; 4377 :      resources.
; 4378 :         The second list on which this structure may find itself is the
; 4379 :      doubly-linked list of currently inactive precincts, which is managed by
; 4380 :      the `kd_precinct_server' object.  Precincts which find themselves on this
; 4381 :      list have been released, but their resources have not yet been recycled.
; 4382 :      They may be successfully re-activated, if their resources have not been
; 4383 :      re-issued to another precinct.  Precincts on this list may be identified
; 4384 :      by the `inactive' flag.  Every inactive precinct necessarily also has
; 4385 :      its `released' member set to true, but the converse is not necessarily
; 4386 :      true.  This is because precincts which have been partially parsed
; 4387 :      in a context for which they were not directly relevant, will be marked
; 4388 :      as released, even though they are not inactive.
; 4389 :         The third list on which this structure may find itself is the
; 4390 :      doubly-linked list of generated precincts managed by the
; 4391 :      `kd_global_rescomp' structure.  This list contains all precincts
; 4392 :      from a given resolution of a given image component, across all tiles,
; 4393 :      which have been fully generated, but not yet flushed out to the
; 4394 :      code-stream.   The list is used to manage incremental rate allocation
; 4395 :      when processing large images.  Elements on this list have not yet
; 4396 :      been closed. */
; 4397 : 
; 4398 : /*****************************************************************************/
; 4399 : /*                         kd_precinct_size_class                            */
; 4400 : /*****************************************************************************/
; 4401 : 
; 4402 :   /* For an explanation of the role played by precinct size classes, see
; 4403 :      the discussion appearing below the declaration of `kd_precinct_server'. */
; 4404 : 
; 4405 : class kd_precinct_size_class {
; 4406 :   public: // Member functions
; 4407 :     kd_precinct_size_class(int max_blocks, int num_subbands,
; 4408 :                            kd_precinct_server *server,
; 4409 :                            kd_buf_server *buf_server)
; 4410 :       {
; 4411 :         this->max_blocks = max_blocks;
; 4412 :         this->num_subbands = num_subbands;
; 4413 :         this->server = server;  this->buf_server = buf_server;
; 4414 :         total_precincts = 0; free_list = NULL; next = NULL;
; 4415 :         alloc_bytes = (int) sizeof(kd_precinct);
; 4416 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4417 :         alloc_bytes += num_subbands * (int) sizeof(kd_precinct_band);
; 4418 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4419 :         alloc_bytes += 4 + max_blocks * (int) sizeof(kd_block);
; 4420 :       }
; 4421 :     ~kd_precinct_size_class()
; 4422 :       { kd_precinct *tmp;
; 4423 :         while ((tmp=free_list) != NULL)
; 4424 :           { free_list = tmp->next; free(tmp); total_precincts--; }
; 4425 :         assert(total_precincts == 0);
; 4426 :       }
; 4427 :     kd_precinct *get()
; 4428 :       {
; 4429 :         if (free_list == NULL)
; 4430 :           augment_free_list();
; 4431 :         kd_precinct *result = free_list; free_list = free_list->next;
; 4432 :         result->next = result->prev = NULL;
; 4433 :         buf_server->augment_structure_bytes(alloc_bytes);
; 4434 :         return result;
; 4435 :       }
; 4436 :     void release(kd_precinct *precinct)
; 4437 :       {
; 4438 :         if (precinct->flags & KD_PFLAG_INACTIVE)
; 4439 :           withdraw_from_inactive_list(precinct);
; 4440 :         precinct->next = free_list;
; 4441 :         free_list = precinct;
; 4442 :         buf_server->augment_structure_bytes(-alloc_bytes);
; 4443 :       }
; 4444 :     void move_to_inactive_list(kd_precinct *precinct);
; 4445 :     void withdraw_from_inactive_list(kd_precinct *precinct);
; 4446 :       /* Used to move precincts onto or off the inactive list maintained
; 4447 :          by the `kd_precinct_server' object to which the present object
; 4448 :          belongs. */
; 4449 :   private: // Helper function
; 4450 :     void augment_free_list();
; 4451 :   private: // Data
; 4452 :     friend class kd_precinct_server;
; 4453 :     kd_precinct_server *server;
; 4454 :     kd_buf_server *buf_server;
; 4455 :     int max_blocks;
; 4456 :     int num_subbands;
; 4457 :     int alloc_bytes; // Num bytes to allocate per precinct.
; 4458 :     kdu_long total_precincts; // Number of precincts allocated with this size
; 4459 :     kd_precinct *free_list; // List of precincts which have been released
; 4460 :     kd_precinct_size_class *next; // Next size class
; 4461 :   };
; 4462 : 
; 4463 : /*****************************************************************************/
; 4464 : /*                           kd_precinct_server                              */
; 4465 : /*****************************************************************************/
; 4466 : 
; 4467 : class kd_precinct_server {
; 4468 :   public: // Member functions
; 4469 :     kd_precinct_server(kd_buf_server *buf_server)
; 4470 :       { size_classes = NULL; total_allocated_bytes = 0;
; 4471 :         inactive_head = inactive_tail = NULL; this->buf_server = buf_server; }
; 4472 :     ~kd_precinct_server()
; 4473 :       {
; 4474 :         kd_precinct_size_class *tmp;
; 4475 :         while ((tmp=size_classes) != NULL)
; 4476 :           { size_classes = tmp->next; delete tmp; }
; 4477 :       }
; 4478 :     kd_precinct *get(int max_blocks, int num_subbands);
; 4479 :     kdu_long get_total_allocated_bytes()
; 4480 :       { return total_allocated_bytes; }
; 4481 :   private: // Data
; 4482 :     friend class kd_precinct_size_class;
; 4483 :     kd_precinct_size_class *size_classes; // List of different size classes.
; 4484 :     kdu_long total_allocated_bytes;
; 4485 :     kd_precinct *inactive_head, *inactive_tail;
; 4486 :     kd_buf_server *buf_server; // Used to manage cacheing, as described below
; 4487 :   };
; 4488 :   /* Notes:
; 4489 :         This object is used to serve up empty precincts and to recycle their
; 4490 :      storage when they are no longer required.  Precinct memory blocks are
; 4491 :      organized into size classes, based on the maximum number of code-blocks
; 4492 :      and precinct-bands in the precinct, where these quantities are consistent
; 4493 :      for all precincts associated with any given `kd_resolution' object.  In
; 4494 :      many cases, it can happen that all precincts from the entire image have
; 4495 :      exactly the same size class.  This maximizes the potential for recycling
; 4496 :      precinct storage, since precincts may only be allocated from and
; 4497 :      recycled back to their own size class.  The reason for this dependence on
; 4498 :      size classes is that the block of memory associated with each precinct
; 4499 :      is large enough to accommodate all `max_blocks' code-blocks which might
; 4500 :      be required to populate the `kd_precinct_band::blocks' arrays and all
; 4501 :      precinct-bands which are required to populate the `kd_precinct::subbands'
; 4502 :      array.  This gets us out of having to maintain separate mechanisms
; 4503 :      to serve up code-block storage as a recyclable resource.  It also helps
; 4504 :      with memory localization.
; 4505 :         The object also manages a cacheing service for precincts and their
; 4506 :      data.  When precincts are released using `kd_precinct_ref::release',
; 4507 :      they are appended to a list of inactive precincts headed by
; 4508 :      `inactive_head' and concluded by `inactive_tail'.  The list is doubly
; 4509 :      linked via the `kd_precinct::next' and `kd_precinct::prev' members.  When
; 4510 :      a previously released precinct is opened using `kd_precinct_ref::open',
; 4511 :      it is removed from this list and its `kd_precinct::activate' function is
; 4512 :      called.  Note that the KD_PFLAG_RELEASED flag is not a reliable
; 4513 :      indicator of whether or not a precinct is on the inactive list, since
; 4514 :      precincts which have been released using `kd_precinct::release', but
; 4515 :      have not yet been completely desequenced (all packets have not yet been
; 4516 :      parsed from or located in the code-stream), will also have this flag
; 4517 :      set, but will not be on an inactive list.  The KD_PFLAG_INACTIVE
; 4518 :      flag should be used to determine whether or not a precinct is on the
; 4519 :      inactive list.
; 4520 :         When `kd_precinct_server::get' function is called, it queries the
; 4521 :      codestream object's `kd_buf_server' service to determine whether or not
; 4522 :      a cache threshold has been exceeded.  If so, it closes down precincts
; 4523 :      on the inactive list until the `kd_buf_server' object reports that
; 4524 :      sufficient resources are in hand. */
; 4525 : 
; 4526 : /*****************************************************************************/
; 4527 : /*                          kd_thread_block_state                            */
; 4528 : /*****************************************************************************/
; 4529 : 
; 4530 : struct kd_thread_block_state {
; 4531 :     kd_block block;
; 4532 :     kd_precinct *target_precinct;
; 4533 :     kd_block *target_block; // see below
; 4534 :   };
; 4535 :   /* An array of these structures is used to maintain information about
; 4536 :      processed code-blocks in thread-local storage, reflecting this information
; 4537 :      only every so often to the `kdu_codestream' machinery, so as to minimize
; 4538 :      thread blocking and cache coherency management overhead.  Each object of
; 4539 :      this class represents a single code-block, identified via the
; 4540 :      `target_precinct' and `target_block' members.
; 4541 :         If `target_precinct' is NULL, the record is empty.  Non-empty records
; 4542 :      may appear anywhere within the `outstanding_blocks' array in
; 4543 :      `kd_thread_env'. */
; 4544 : 
; 4545 : /*****************************************************************************/
; 4546 : /*                              kd_thread_env                                */
; 4547 : /*****************************************************************************/
; 4548 : 
; 4549 : #define KD_THREAD_MAX_OUTSTANDING_BLOCKS 8
; 4550 : 
; 4551 : class kd_thread_env {
; 4552 :   public: // Member functions
; 4553 :     kd_thread_env(kdu_thread_env *owner)
; 4554 :       {
; 4555 :         this->owner=owner;  buf_server.init(this);
; 4556 :         num_outstanding_blocks=0;  stats_codestream = NULL;
; 4557 :         memset(outstanding_blocks,0,
; 4558 :                sizeof(kd_thread_block_state)*KD_THREAD_MAX_OUTSTANDING_BLOCKS);
; 4559 :       }
; 4560 :     kd_thread_block_state *get_block_state(kd_codestream *cs,
; 4561 :                                            kd_precinct *precinct,
; 4562 :                                            kd_block *block)
; 4563 :       {
; 4564 :         if (num_outstanding_blocks == KD_THREAD_MAX_OUTSTANDING_BLOCKS)
; 4565 :           flush(true);
; 4566 :         kd_thread_block_state *scan=outstanding_blocks;
; 4567 :         for (int n=0; n < KD_THREAD_MAX_OUTSTANDING_BLOCKS; n++, scan++)
; 4568 :           if (scan->target_precinct == NULL)
; 4569 :             {
; 4570 :               num_outstanding_blocks++;
; 4571 :               scan->target_precinct=precinct;  scan->target_block=block;
; 4572 :               owner->have_outstanding_blocks = true;
; 4573 :               return scan;
; 4574 :             }
; 4575 :         return NULL; // Should not be possible!!
; 4576 :       }
; 4577 :     void update_stats(kdu_block *blk, kd_codestream *cs)
; 4578 :       { /* Called during encoding after each code-block of data has been
; 4579 :            generated, whenever coding statistics are being kept by the
; 4580 :            relevant codestream.  This function updates the internal coding
; 4581 :            statistics record managed by the `stats' member, which is
; 4582 :            reconciled against the underlying codestream only at appropriate
; 4583 :            intervals, so as to minimize thread blocking conditions. */
; 4584 :         if ((stats_codestream != cs) && (stats_codestream != NULL))
; 4585 :           {
; 4586 :             reconcile_stats();
; 4587 :             stats_codestream = cs;
; 4588 :           }
; 4589 :         stats.update_stats(blk);
; 4590 :       }
; 4591 :     void reconcile_stats();
; 4592 :       /* This function is used to reconcile the temporary information in
; 4593 :          the `stats' member with the coding statistics manager in the
; 4594 :          `kd_codestream' object referenced by the `stats_codestream' member.
; 4595 :          After reconciliation, the `stats' member will be empty and the
; 4596 :          `stats_codestream' member is reset to NULL so that we are free to
; 4597 :          accumulate statistics for a different codestream in the future.
; 4598 :          This function is invoked from `flush' and also if a call to
; 4599 :          `update_stats' specifies a different codestream to that for which
; 4600 :          coding statistics are currently being recorded in the `stats'
; 4601 :          member. */
; 4602 :     void flush(bool force_flush);
; 4603 :       /* Clears the `outstanding_blocks' queue and reconciles any outstanding
; 4604 :          `stats' information.  This function should not be called while
; 4605 :          holding any lock, since it typically needs to acquire its own lock or
; 4606 :          locks.
; 4607 :             If `force_flush' is false, the function may return without
; 4608 :          flushing anything, if it finds that the necessary mutex is already
; 4609 :          held by another thread.  This helps to keep threads alive for as long
; 4610 :          as possible.  A thread will typically try to flush its block queue
; 4611 :          each time it is augmented, once it starts getting close to full.
; 4612 :          A forced flush is required only once the queue becomes completely
; 4613 :          full -- this is performed automatically from within
; 4614 :          `get_block_state'. */
; 4615 :     void discard_all();
; 4616 :       /* This function is called from `kdu_thread_env::do_sync' or
; 4617 :          `kdu_thread_env::on_finished' if an exception has been handled
; 4618 :          by any thread in the working group.  It discards all processed
; 4619 :          code-blocks, returning any associated storage to the internal
; 4620 :          queue, being careful to do so in such a way as to avoid throwing
; 4621 :          further exceptions while acquiring locks. */
; 4622 :   private: // Padding
; 4623 :     kdu_byte _leadin[KDU_MAX_L2_CACHE_LINE];
; 4624 :   public: // Links
; 4625 :     kdu_thread_env *owner;
; 4626 :   public: // Public resources
; 4627 :     kdu_block block; // Thread-local code-block storage
; 4628 :     kd_compressed_stats stats; // Used to temporarily record statistics
; 4629 :     kd_codestream *stats_codestream; // Codestream to which statistics belong
; 4630 :     kd_thread_buf_server buf_server;
; 4631 :     int num_outstanding_blocks;
; 4632 :   private: // Private resources
; 4633 :     kd_thread_block_state outstanding_blocks[KD_THREAD_MAX_OUTSTANDING_BLOCKS];
; 4634 :   private: // Padding
; 4635 :     kdu_byte _trailer[KDU_MAX_L2_CACHE_LINE];
; 4636 :   };
; 4637 : 
; 4638 : 
; 4639 : /* ========================================================================= */
; 4640 : /*         Inlined Member Functions Delayed to Satisfy Dependencies          */
; 4641 : /* ========================================================================= */
; 4642 : 
; 4643 : inline void
; 4644 :   kd_thread_buf_server::set_codestream_buf_server(kd_buf_server *buf_server)
; 4645 : {
; 4646 :   if (buf_server != this->ultimate_buf_server)
; 4647 :     {
; 4648 :       env->owner->acquire_lock(KD_THREADLOCK_GENERAL);
; 4649 :       if (ultimate_buf_server != NULL)
; 4650 :         ultimate_buf_server->detach_thread_buf_server(this);
; 4651 :       if (buf_server != NULL)
; 4652 :         buf_server->attach_thread_buf_server(this);
; 4653 :       assert(buf_server == ultimate_buf_server);
; 4654 :       env->owner->release_lock(KD_THREADLOCK_GENERAL);
; 4655 :     }
; 4656 : }
; 4657 : 
; 4658 : inline bool
; 4659 :   kd_precinct_ref::is_desequenced()
; 4660 : {
; 4661 :   register kdu_long state_val = state;
; 4662 :   return ((state_val != 0) &&
; 4663 :           ((state_val & 1) ||
; 4664 :            (((kd_precinct *) _kdu_long_to_addr(state_val))->flags &
; 4665 :             KD_PFLAG_DESEQUENCED)));
; 4666 : }
; 4667 : 
; 4668 : inline void
; 4669 :   kd_precinct_ref::clear()
; 4670 : {
; 4671 :   if (state && !(state & 1))
; 4672 :     {
; 4673 :       kd_precinct *precinct = (kd_precinct *) _kdu_long_to_addr(state);
; 4674 :       precinct->ref = NULL; // Satisfy the test in `kd_precinct::closing'
; 4675 :       precinct->closing();
; 4676 :       precinct->size_class->release(precinct);
; 4677 :     }
; 4678 :   state = 0;
; 4679 : }
; 4680 : 
; 4681 : inline void
; 4682 :   kd_precinct_ref::close_and_reset()
; 4683 : {
; 4684 :   if (state & 1)
; 4685 :     {
; 4686 :       if (state != 3)
; 4687 :         state &= ~((kdu_long) 2);
; 4688 :     }
; 4689 :   else if (state != 0)
; 4690 :     {
; 4691 :       kd_precinct *prec = (kd_precinct *) _kdu_long_to_addr(state);
; 4692 :       if ((prec->flags & KD_PFLAG_PARSED)||(prec->num_packets_read > 0))
; 4693 :         {
; 4694 :           close();
; 4695 :           state &= ~((kdu_long) 2);
; 4696 :         }
; 4697 :     }
; 4698 : }
; 4699 : 
; 4700 : inline void
; 4701 :   kd_precinct_ref::release()
; 4702 : {
; 4703 :   kd_precinct *precinct = (kd_precinct *) _kdu_long_to_addr(state);

	mov	ecx, DWORD PTR [edx]

; 4704 :   assert((state != 0) && !(state & 1));
; 4705 :   if (precinct->flags & KD_PFLAG_INACTIVE)

	mov	eax, DWORD PTR [ecx+8]
	test	al, 32					; 00000020H
	jne	SHORT $LN8@release

; 4706 :     return; // Already on the inactive list.
; 4707 :   precinct->flags |= KD_PFLAG_RELEASED;

	or	eax, 16					; 00000010H
	mov	DWORD PTR [ecx+8], eax

; 4708 :     // precinct->released = true; // In case not already set.
; 4709 :   if ((precinct->flags & KD_PFLAG_ADDRESSABLE) &&
; 4710 :       (!precinct->resolution->codestream->cached) &&

	test	al, 8
	je	SHORT $LN7@release
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	cmp	BYTE PTR [eax+338], 0
	jne	SHORT $LN7@release
	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN9@release
	cmp	eax, DWORD PTR [ecx+16]
	jne	SHORT $LN7@release
$LN9@release:

; 4711 :       ((precinct->num_packets_read == 0) ||
; 4712 :        (precinct->num_packets_read == precinct->next_layer_idx)))
; 4713 :     precinct->size_class->move_to_inactive_list(precinct);

	push	ecx
	mov	ecx, DWORD PTR [ecx+52]
	call	?move_to_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::move_to_inactive_list
$LN8@release:

; 4159 :       }

	ret	0
$LN7@release:

; 4714 :   else
; 4715 :     close();

	mov	ecx, edx
	jmp	?close@kd_precinct_ref@@QAEXXZ		; kd_precinct_ref::close
?release@kd_precinct@@QAEXXZ ENDP			; kd_precinct::release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?closing@kd_precinct@@QAEXXZ
_TEXT	SEGMENT
_this$1$ = -24						; size = 4
_pb$1$ = -20						; size = 4
_buf_server$1$ = -16					; size = 4
_b$1$ = -12						; size = 4
_num_blocks$1$ = -8					; size = 4
tv305 = -4						; size = 4
?closing@kd_precinct@@QAEXXZ PROC			; kd_precinct::closing, COMDAT
; _this$ = ecx

; 5357 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	esi
	mov	esi, ecx
	push	edi

; 5361 :   for (int b=0; b < resolution->num_subbands; b++)

	xor	edi, edi
	mov	DWORD PTR _this$1$[ebp], esi
	mov	DWORD PTR _b$1$[ebp], edi
	mov	edx, DWORD PTR [esi]
	cmp	BYTE PTR [edx+174], 0
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+24]
	mov	DWORD PTR _buf_server$1$[ebp], eax
	jbe	$LN3@closing

; 5358 :   assert(ref == NULL); // Safety check to ensure that this function is called
; 5359 :                        // only from within `kd_precinct_ref::close'.
; 5360 :   kd_buf_server *buf_server = resolution->codestream->buf_server;

	xor	eax, eax
	mov	DWORD PTR tv305[ebp], eax
	push	ebx
	npad	1
$LL4@closing:

; 5362 :     {
; 5363 :       kd_precinct_band *pb = subbands+b;

	mov	ecx, DWORD PTR [esi+40]
	add	ecx, eax
	mov	DWORD PTR _pb$1$[ebp], ecx

; 5364 :       if (pb->blocks != NULL)

	cmp	DWORD PTR [ecx+20], 0
	je	SHORT $LN2@closing
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	ebx, DWORD PTR [ecx+16]
	imul	ebx, DWORD PTR [ecx+12]
	mov	DWORD PTR _num_blocks$1$[ebp], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5367 :           for (int n=0; n < num_blocks; n++)

	test	ebx, ebx
	jle	SHORT $LN6@closing

; 5365 :         {
; 5366 :           int num_blocks = (int) pb->block_indices.area();

	xor	edi, edi
	npad	2
$LL7@closing:

; 5368 :             pb->blocks[n].cleanup(buf_server);

	mov	esi, DWORD PTR [ecx+20]
	add	esi, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3609 :         while ((current_buf=first_buf) != NULL)

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
	test	eax, eax
	je	SHORT $LN15@closing
	mov	ebx, DWORD PTR _buf_server$1$[ebp]
$LL14@closing:

; 3610 :           { first_buf=current_buf->next;  buf_server->release(current_buf); }

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, ebx
	push	DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
	call	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ; kd_buf_server::release
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
	test	eax, eax
	jne	SHORT $LL14@closing
	mov	ebx, DWORD PTR _num_blocks$1$[ebp]
	mov	ecx, DWORD PTR _pb$1$[ebp]
$LN15@closing:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5367 :           for (int n=0; n < num_blocks; n++)

	add	edi, 24					; 00000018H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3797 :         num_passes = 255;

	mov	BYTE PTR [esi+10], 255			; 000000ffH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5367 :           for (int n=0; n < num_blocks; n++)

	sub	ebx, 1
	mov	DWORD PTR _num_blocks$1$[ebp], ebx
	jne	SHORT $LL7@closing
	mov	esi, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR tv305[ebp]
	mov	edi, DWORD PTR _b$1$[ebp]
$LN6@closing:

; 5369 :           pb->blocks = NULL; // Note that there is no deletion since the

	mov	DWORD PTR [ecx+20], 0
$LN2@closing:

; 5361 :   for (int b=0; b < resolution->num_subbands; b++)

	add	eax, 24					; 00000018H
	inc	edi
	mov	DWORD PTR tv305[ebp], eax
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _b$1$[ebp], edi
	movzx	eax, BYTE PTR [eax+174]
	cmp	edi, eax
	mov	eax, DWORD PTR tv305[ebp]
	jl	$LL4@closing
	pop	ebx
$LN3@closing:

; 5370 :             // `blocks' array is part of the same memory block as `kd_precicnt'
; 5371 :         }
; 5372 :     }
; 5373 : 
; 5374 :   if ((!(flags & KD_PFLAG_ADDRESSABLE)) && (packet_bytes != NULL))

	test	BYTE PTR [esi+8], 8
	jne	SHORT $LN9@closing
	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN9@closing

; 5375 :     {
; 5376 :       delete[] packet_bytes;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4

; 5377 :       packet_bytes = NULL;

	mov	DWORD PTR [esi+32], 0
$LN9@closing:
	pop	edi
	pop	esi

; 5378 :     }
; 5379 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?closing@kd_precinct@@QAEXXZ ENDP			; kd_precinct::closing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?activate@kd_precinct@@QAEXXZ
_TEXT	SEGMENT
_block_dims$1 = -64					; size = 16
tv573 = -48						; size = 4
_min$1$ = -44						; size = 4
tv570 = -36						; size = 4
_this$1$ = -32						; size = 4
tv562 = -28						; size = 4
tv561 = -24						; size = 4
_b$1$ = -20						; size = 4
_y$1$ = -16						; size = 4
_x$1$ = -12						; size = 4
_block_dims$1$ = -8					; size = 4
_block_dims$5$ = -4					; size = 4
?activate@kd_precinct@@QAEXXZ PROC			; kd_precinct::activate, COMDAT
; _this$ = ecx

; 5387 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx

; 5388 :   kd_tile_comp *comp = resolution->tile_comp;

	mov	ebx, DWORD PTR [ecx]
	mov	DWORD PTR _this$1$[ebp], ecx
	mov	DWORD PTR tv573[ebp], ebx
	mov	edx, DWORD PTR [ebx+4]

; 5389 :   kd_tile *tile = comp->tile;

	mov	eax, DWORD PTR [edx+4]

; 5390 : 
; 5391 :   assert((flags & KD_PFLAG_RELEASED) &&
; 5392 :          (num_outstanding_blocks == 0) && tile->is_open);
; 5393 :   flags &= ~KD_PFLAG_RELEASED;

	and	DWORD PTR [ecx+8], -17			; ffffffefH

; 5394 :     // released = false;
; 5395 :   required_layers = tile->num_apparent_layers;

	mov	eax, DWORD PTR [eax+136]
	mov	DWORD PTR [ecx+12], eax

; 5396 : 
; 5397 :   if ((resolution->res_level > comp->apparent_dwt_levels) || !comp->enabled)

	movzx	eax, BYTE PTR [ebx+12]
	cmp	eax, DWORD PTR [edx+60]
	jg	$LN12@activate
	cmp	BYTE PTR [edx+152], 0
	je	$LN12@activate

; 5398 :     return; // No code-blocks from the precinct lie in the region of interest
; 5399 : 
; 5400 :   for (int b=0; b < resolution->num_subbands; b++)

	cmp	BYTE PTR [ebx+174], 0
	mov	DWORD PTR _b$1$[ebp], 0
	jbe	$LN12@activate

; 5401 :     {
; 5402 :       kd_precinct_band *pb = subbands+b;

	mov	ecx, DWORD PTR [ecx+40]
	push	esi
	xor	esi, esi
	add	ecx, 4
	push	edi
	mov	DWORD PTR tv562[ebp], esi
	mov	DWORD PTR tv561[ebp], ecx
$LL4@activate:

; 5403 :       kd_subband *subband = resolution->subbands+b;

	mov	ebx, DWORD PTR [ebx+184]

; 5404 : 
; 5405 :       // Get location and size of first code-block in the partition which
; 5406 :       // intersects with current precinct-band.
; 5407 :       kdu_dims block_dims = subband->block_partition;
; 5408 :       block_dims.pos.x += block_dims.size.x * pb->block_indices.pos.x;

	mov	eax, DWORD PTR [ecx+4]
	add	ebx, esi
	movups	xmm1, XMMWORD PTR [ebx+68]
	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	movd	edx, xmm0
	movups	XMMWORD PTR _block_dims$1[ebp], xmm1

; 5409 :       block_dims.pos.y += block_dims.size.y * pb->block_indices.pos.y;

	mov	esi, DWORD PTR _block_dims$1[ebp+8]
	mov	edi, DWORD PTR _block_dims$1[ebp]
	imul	eax, edx
	mov	DWORD PTR _block_dims$1$[ebp], edx
	psrldq	xmm1, 4
	movd	edx, xmm1
	add	edx, eax
	mov	eax, DWORD PTR [ecx]
	imul	eax, esi
	mov	DWORD PTR _min$1$[ebp], edx
	add	edi, eax

; 5410 :       kdu_coords min = block_dims.pos; // So we can keep coming back here.
; 5411 :       kd_block *block = pb->blocks;
; 5412 :       int x, y;
; 5413 :       for (y=0, block_dims.pos.y=min.y;

	xor	eax, eax
	mov	DWORD PTR _block_dims$5$[ebp], edi
	mov	DWORD PTR _y$1$[ebp], eax

; 5414 :            y < pb->block_indices.size.y;

	cmp	DWORD PTR [ecx+8], eax
	jle	$LN2@activate
$LL7@activate:

; 5416 :         for (x=0, block_dims.pos.x=min.x;
; 5417 :              x < pb->block_indices.size.x;

	cmp	DWORD PTR [ecx+12], 0
	mov	DWORD PTR _x$1$[ebp], 0
	jle	SHORT $LN5@activate
	npad	2
$LL10@activate:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 370  :         if ((pos.x+size.x) <= rhs.pos.x) return false;

	mov	ecx, DWORD PTR _block_dims$1$[ebp]
	mov	eax, DWORD PTR [ebx+28]
	add	ecx, edx
	mov	DWORD PTR tv570[ebp], ecx
	cmp	ecx, eax
	jle	SHORT $LN8@activate

; 371  :         if ((pos.y+size.y) <= rhs.pos.y) return false;

	mov	ecx, DWORD PTR _block_dims$1[ebp+8]
	mov	esi, DWORD PTR [ebx+24]
	add	ecx, edi
	cmp	ecx, esi
	jle	SHORT $LN42@activate

; 372  :         if (pos.x >= (rhs.pos.x+rhs.size.x)) return false;

	mov	edi, DWORD PTR [ebx+36]
	add	eax, edi
	cmp	edx, eax
	jge	SHORT $LN41@activate

; 373  :         if (pos.y >= (rhs.pos.y+rhs.size.y)) return false;

	mov	ecx, DWORD PTR [ebx+32]
	lea	eax, DWORD PTR [ecx+esi]

; 374  :         if ((size.x <= 0) || (size.y <= 0) ||
; 375  :             (rhs.size.x <= 0) || (rhs.size.y <= 0))

	mov	esi, DWORD PTR _block_dims$1[ebp+8]
	cmp	DWORD PTR _block_dims$5$[ebp], eax
	jge	SHORT $LN37@activate
	cmp	DWORD PTR _block_dims$1$[ebp], 0
	jle	SHORT $LN37@activate
	test	esi, esi
	jle	SHORT $LN37@activate
	test	edi, edi
	jle	SHORT $LN37@activate
	mov	edi, DWORD PTR _block_dims$5$[ebp]
	test	ecx, ecx
	jle	SHORT $LN8@activate
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5420 :             num_outstanding_blocks++;

	mov	eax, DWORD PTR _this$1$[ebp]
	inc	DWORD PTR [eax+24]
	jmp	SHORT $LN8@activate
$LN37@activate:
	mov	edi, DWORD PTR _block_dims$5$[ebp]
	jmp	SHORT $LN8@activate
$LN41@activate:
	mov	edi, DWORD PTR _block_dims$5$[ebp]
$LN42@activate:
	mov	esi, DWORD PTR _block_dims$1[ebp+8]
$LN8@activate:

; 5418 :              x++, block_dims.pos.x += block_dims.size.x, block++)

	mov	eax, DWORD PTR _x$1$[ebp]
	mov	ecx, DWORD PTR tv561[ebp]
	inc	eax
	mov	edx, DWORD PTR tv570[ebp]
	mov	DWORD PTR _x$1$[ebp], eax
	cmp	eax, DWORD PTR [ecx+12]
	jl	SHORT $LL10@activate
	mov	eax, DWORD PTR _y$1$[ebp]
$LN5@activate:

; 5414 :            y < pb->block_indices.size.y;

	mov	edx, DWORD PTR _min$1$[ebp]

; 5415 :            y++, block_dims.pos.y += block_dims.size.y)

	inc	eax
	add	edi, esi
	mov	DWORD PTR _y$1$[ebp], eax
	mov	DWORD PTR _block_dims$5$[ebp], edi
	cmp	eax, DWORD PTR [ecx+8]
	jl	$LL7@activate
$LN2@activate:

; 5398 :     return; // No code-blocks from the precinct lie in the region of interest
; 5399 : 
; 5400 :   for (int b=0; b < resolution->num_subbands; b++)

	mov	ebx, DWORD PTR tv573[ebp]
	add	ecx, 24					; 00000018H
	mov	edx, DWORD PTR _b$1$[ebp]
	mov	esi, DWORD PTR tv562[ebp]
	inc	edx
	add	esi, 132				; 00000084H
	mov	DWORD PTR _b$1$[ebp], edx
	movzx	eax, BYTE PTR [ebx+174]
	mov	DWORD PTR tv561[ebp], ecx
	mov	DWORD PTR tv562[ebp], esi
	cmp	edx, eax
	jl	$LL4@activate
	pop	edi
	pop	esi
$LN12@activate:
	pop	ebx

; 5421 :     }
; 5422 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?activate@kd_precinct@@QAEXXZ ENDP			; kd_precinct::activate
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?initialize@kd_precinct@@QAEXPAUkd_resolution@@Ukdu_coords@@@Z
_TEXT	SEGMENT
$T1 = -104						; size = 16
_prec_dims$2 = -88					; size = 16
$T3 = -88						; size = 16
_block_dims$4 = -72					; size = 16
$T5 = -72						; size = 16
_min$1$ = -56						; size = 4
_mem_block$ = -52					; size = 4
_node$1$ = -48						; size = 4
_comp$1$ = -48						; size = 4
tv1063 = -48						; size = 4
_b$2$ = -44						; size = 4
_this$1$ = -44						; size = 4
_y$2$ = -36						; size = 4
_tile$1$ = -32						; size = 4
tv1066 = -28						; size = 4
tv1062 = -28						; size = 4
_branch_y$1$ = -24					; size = 4
_y$1$ = -24						; size = 4
_block_dims$1$ = -24					; size = 4
_branch_x$1$ = -20					; size = 4
_x$2$ = -20						; size = 4
_codestream$1$ = -16					; size = 4
$T6 = -12						; size = 4
_branch_x$1$ = -12					; size = 4
_block_dims$5$ = -12					; size = 4
_branch_y$1$ = -8					; size = 4
_pb$1$ = -8						; size = 4
_nothing_visible$1$ = -1				; size = 1
_resolution$ = 8					; size = 4
_pos_idx$ = 12						; size = 8
?initialize@kd_precinct@@QAEXPAUkd_resolution@@Ukdu_coords@@@Z PROC ; kd_precinct::initialize, COMDAT
; _this$ = ecx

; 5217 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 104				; 00000068H
	push	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	mov	ebx, DWORD PTR _pos_idx$[ebp]
	push	esi
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5218 :   kd_codestream *codestream = resolution->codestream;

	mov	edi, DWORD PTR _resolution$[ebp]
	mov	esi, ecx
	mov	DWORD PTR _this$1$[ebp], esi

; 5219 :   kd_tile_comp *comp = resolution->tile_comp;

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	add	ebx, DWORD PTR [edi+136]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5218 :   kd_codestream *codestream = resolution->codestream;

	mov	DWORD PTR _codestream$1$[ebp], eax

; 5220 :   kd_tile *tile = comp->tile;

	mov	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR _tile$1$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	mov	edx, DWORD PTR _pos_idx$[ebp+4]
	add	edx, DWORD PTR [edi+140]
	mov	DWORD PTR _pos_idx$[ebp+4], edx
	mov	DWORD PTR _pos_idx$[ebp], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5224 :   this->resolution = resolution;

	mov	DWORD PTR [esi], edi

; 5225 :   ref = NULL; // Value will be set later by `kd_precinct_ref::open'.

	mov	DWORD PTR [esi+4], 0

; 5226 :   flags = KD_PFLAG_RELEVANT;

	mov	DWORD PTR [esi+8], 64			; 00000040H

; 5227 :   // addressable = corrupted = desequenced = released = inactive = false;
; 5228 :   // generating = is_significant = false; is_relevant = true;
; 5229 :   if ((codestream->in != NULL) && (!codestream->persistent) &&

	cmp	DWORD PTR [eax+4], 0
	mov	DWORD PTR _comp$1$[ebp], ecx
	je	SHORT $LN20@initialize
	cmp	BYTE PTR [eax+337], 0
	jne	SHORT $LN20@initialize
	movzx	eax, BYTE PTR [edi+12]
	cmp	eax, DWORD PTR [ecx+60]
	jg	SHORT $LN21@initialize
	cmp	BYTE PTR [ecx+152], 0
	je	SHORT $LN21@initialize
	mov	ecx, DWORD PTR [edi+156]
	cmp	edx, ecx
	jl	SHORT $LN21@initialize
	cmp	ebx, DWORD PTR [edi+152]
	jl	SHORT $LN21@initialize
	mov	eax, DWORD PTR [edi+164]
	add	eax, ecx
	cmp	edx, eax
	jge	SHORT $LN21@initialize
	mov	eax, DWORD PTR [edi+160]
	add	eax, DWORD PTR [edi+152]
	cmp	ebx, eax
	jl	SHORT $LN20@initialize
$LN21@initialize:

; 5230 :       ((resolution->res_level > comp->apparent_dwt_levels) ||
; 5231 :        (!comp->enabled) ||
; 5232 :        (pos_idx.x < resolution->region_indices.pos.x) ||
; 5233 :        (pos_idx.y < resolution->region_indices.pos.y) ||
; 5234 :        (pos_idx.x >= (resolution->region_indices.pos.x +
; 5235 :                       resolution->region_indices.size.x)) ||
; 5236 :        (pos_idx.y >= (resolution->region_indices.pos.y +
; 5237 :                       resolution->region_indices.size.y))))
; 5238 :     flags &= ~KD_PFLAG_RELEVANT;

	mov	DWORD PTR [esi+8], 0
$LN20@initialize:

; 5239 :       // is_relevant = false;
; 5240 : 
; 5241 :   required_layers = tile->num_apparent_layers;

	mov	eax, DWORD PTR _tile$1$[ebp]

; 5242 :   next_layer_idx = num_packets_read = cumulative_bytes = 0;
; 5243 :   num_outstanding_blocks = 0;
; 5244 :   unique_address = 0;
; 5245 :   packet_bytes = NULL; // Create this array if and when we need it.
; 5246 : 
; 5247 :   resolution->node.prec_dims = resolution->precinct_partition;

	lea	ecx, DWORD PTR [edi+76]
	mov	eax, DWORD PTR [eax+136]
	mov	DWORD PTR [esi+12], eax
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+32], 0
	movups	xmm0, XMMWORD PTR [edi+120]
	movups	XMMWORD PTR [ecx], xmm0

; 5248 :   resolution->node.prec_dims.pos.x +=

	mov	eax, DWORD PTR [edi+88]
	imul	eax, edx
	add	DWORD PTR [edi+80], eax

; 5249 :     pos_idx.x * resolution->node.prec_dims.size.x;
; 5250 :   resolution->node.prec_dims.pos.y +=

	mov	eax, DWORD PTR [edi+84]
	imul	eax, ebx
	add	DWORD PTR [ecx], eax

; 5251 :     pos_idx.y * resolution->node.prec_dims.size.y;
; 5252 :   resolution->node.prec_dims &= resolution->node.dims;

	lea	eax, DWORD PTR [edi+24]
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=

; 5253 :   assert((resolution->node.prec_dims.size.x > 0) &&
; 5254 :          (resolution->node.prec_dims.size.y > 0));
; 5255 : 
; 5256 :   bool nothing_visible = // True if current view excludes this resolution
; 5257 :     (codestream->persistent && !tile->is_open) ||
; 5258 :     (resolution->res_level > comp->apparent_dwt_levels) ||

	mov	eax, DWORD PTR _codestream$1$[ebp]
	cmp	BYTE PTR [eax+337], 0
	je	SHORT $LN31@initialize
	mov	eax, DWORD PTR _tile$1$[ebp]
	cmp	BYTE PTR [eax+229], 0
	je	SHORT $LN32@initialize
$LN31@initialize:
	mov	ecx, DWORD PTR _comp$1$[ebp]
	movzx	eax, BYTE PTR [edi+12]
	cmp	eax, DWORD PTR [ecx+60]
	jg	SHORT $LN32@initialize
	cmp	BYTE PTR [ecx+152], 0
	mov	BYTE PTR _nothing_visible$1$[ebp], 0
	jne	SHORT $LN33@initialize
$LN32@initialize:
	mov	BYTE PTR _nothing_visible$1$[ebp], 1
$LN33@initialize:

; 5259 :     (!comp->enabled);
; 5260 :   
; 5261 :   // Initialize the precinct-bands.
; 5262 :   int mem_offset = sizeof(kd_precinct);
; 5263 :   mem_offset += (-mem_offset) & 7; // Align on 8-byte boundary
; 5264 :   kdu_byte *mem_block = ((kdu_byte *) this) + mem_offset;

	lea	edx, DWORD PTR [esi+56]

; 5265 :   subbands = (kd_precinct_band *) mem_block;

	mov	DWORD PTR [esi+40], edx

; 5266 :   mem_offset = resolution->num_subbands * sizeof(kd_precinct_band);

	movzx	eax, BYTE PTR [edi+174]
	lea	ecx, DWORD PTR [eax+eax*2]
	shl	ecx, 3

; 5267 :   mem_offset += (-mem_offset) & 7;

	mov	eax, ecx
	neg	eax
	and	eax, 7

; 5268 :   mem_block += mem_offset;

	add	eax, ecx
	add	edx, eax

; 5269 : 
; 5270 :   int b;
; 5271 :   for (b=0; b < resolution->num_intermediate_nodes; b++)

	cmp	BYTE PTR [edi+175], 0
	mov	DWORD PTR _mem_block$[ebp], edx
	jbe	$LN3@initialize

; 5259 :     (!comp->enabled);
; 5260 :   
; 5261 :   // Initialize the precinct-bands.
; 5262 :   int mem_offset = sizeof(kd_precinct);
; 5263 :   mem_offset += (-mem_offset) & 7; // Align on 8-byte boundary
; 5264 :   kdu_byte *mem_block = ((kdu_byte *) this) + mem_offset;

	xor	ecx, ecx
	xor	esi, esi
	mov	DWORD PTR tv1066[ebp], ecx
	npad	8
$LL4@initialize:

; 5272 :     {
; 5273 :       kd_node *node = resolution->intermediate_nodes + b;

	mov	eax, DWORD PTR [edi+176]
	add	eax, ecx
	mov	DWORD PTR _node$1$[ebp], eax

; 5274 :       node->prec_dims =

	movzx	ecx, BYTE PTR [eax+41]
	mov	DWORD PTR _branch_y$1$[ebp], ecx
	movzx	ecx, BYTE PTR [eax+40]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _branch_x$1$[ebp], ecx
	movups	xmm1, XMMWORD PTR [eax+60]

; 122  :   kdu_coords min = parent_dims.pos;

	movaps	xmm0, xmm1
	movd	edx, xmm1
	psrldq	xmm0, 4
	movd	ebx, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	psrldq	xmm1, 8
	movd	ecx, xmm0
	movd	eax, xmm1
	add	ecx, ebx
	add	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 125  :   if ((branch_x & ~1) == 0)

	test	DWORD PTR _branch_x$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN37@initialize

; 126  :     { // Parent node is split horizontally
; 127  :       min.x -= (branch_x)?high_support_max:low_support_max;
; 128  :       lim.x -= (branch_x)?high_support_min:low_support_min;
; 129  :       min.x = (min.x + 1 - branch_x) >> 1;

	sub	ebx, DWORD PTR _branch_x$1$[ebp]

; 130  :       lim.x = (lim.x + 1 - branch_x) >> 1;

	sub	ecx, DWORD PTR _branch_x$1$[ebp]
	inc	ebx
	inc	ecx
	sar	ebx, 1
	sar	ecx, 1
$LN37@initialize:

; 131  :     }
; 132  : 
; 133  :   if ((branch_y & ~1) == 0)

	test	DWORD PTR _branch_y$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN38@initialize

; 134  :     { // Parent node is split vertically
; 135  :       min.y -= (branch_y)?high_support_max:low_support_max;
; 136  :       lim.y -= (branch_y)?high_support_min:low_support_min;
; 137  :       min.y = (min.y + 1 - branch_y) >> 1;

	sub	edx, DWORD PTR _branch_y$1$[ebp]

; 138  :       lim.y = (lim.y + 1 - branch_y) >> 1;

	sub	eax, DWORD PTR _branch_y$1$[ebp]
	inc	edx
	inc	eax
	sar	edx, 1
	sar	eax, 1
$LN38@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 142  :   result.pos = min;

	mov	DWORD PTR $T5[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ecx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 143  :   result.size = lim-min;

	mov	DWORD PTR $T5[ebp+8], eax

; 5274 :       node->prec_dims =

	mov	eax, DWORD PTR _node$1$[ebp]
	inc	esi

; 143  :   result.size = lim-min;

	mov	DWORD PTR $T5[ebp+12], ecx

; 5269 : 
; 5270 :   int b;
; 5271 :   for (b=0; b < resolution->num_intermediate_nodes; b++)

	mov	ecx, DWORD PTR tv1066[ebp]

; 142  :   result.pos = min;

	mov	DWORD PTR $T5[ebp+4], ebx

; 5269 : 
; 5270 :   int b;
; 5271 :   for (b=0; b < resolution->num_intermediate_nodes; b++)

	add	ecx, 104				; 00000068H

; 5274 :       node->prec_dims =

	movups	xmm0, XMMWORD PTR $T5[ebp]
	mov	DWORD PTR tv1066[ebp], ecx
	movups	XMMWORD PTR [eax+60], xmm0
	movzx	eax, BYTE PTR [edi+175]
	cmp	esi, eax
	jl	$LL4@initialize
	mov	esi, DWORD PTR _this$1$[ebp]
$LN3@initialize:

; 5275 :         get_child_dims(node->parent->prec_dims,node->branch_x,node->branch_y);
; 5276 :     }
; 5277 : 
; 5278 :   for (b=0; b < resolution->num_subbands; b++)

	cmp	BYTE PTR [edi+174], 0
	mov	DWORD PTR _b$2$[ebp], 0
	jbe	$LN6@initialize
	xor	edx, edx
	xor	eax, eax
	mov	DWORD PTR tv1063[ebp], edx
	mov	DWORD PTR tv1062[ebp], eax
	npad	9
$LL7@initialize:

; 5279 :     {
; 5280 :       kd_precinct_band *pb = subbands + b;

	mov	ebx, DWORD PTR [esi+40]

; 5281 :       kd_subband *subband = resolution->subbands + b;

	mov	edi, DWORD PTR [edi+184]
	add	ebx, eax
	add	edi, edx
	mov	DWORD PTR _pb$1$[ebp], ebx

; 5282 :       pb->subband = subband;

	mov	DWORD PTR [ebx], edi

; 5283 :       kdu_dims prec_dims =
; 5284 :         get_child_dims(subband->parent->prec_dims,

	movzx	eax, BYTE PTR [edi+41]
	mov	DWORD PTR _branch_y$1$[ebp], eax
	movzx	eax, BYTE PTR [edi+40]
	mov	DWORD PTR _branch_x$1$[ebp], eax
	mov	eax, DWORD PTR [edi]
	movups	xmm1, XMMWORD PTR [eax+60]

; 122  :   kdu_coords min = parent_dims.pos;

	movaps	xmm0, xmm1
	movd	ecx, xmm1
	psrldq	xmm0, 4
	movd	edx, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	movd	eax, xmm0
	psrldq	xmm1, 8
	add	eax, edx
	mov	DWORD PTR $T6[ebp], eax
	movd	eax, xmm1
	add	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 125  :   if ((branch_x & ~1) == 0)

	test	DWORD PTR _branch_x$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN55@initialize

; 126  :     { // Parent node is split horizontally
; 127  :       min.x -= (branch_x)?high_support_max:low_support_max;
; 128  :       lim.x -= (branch_x)?high_support_min:low_support_min;
; 129  :       min.x = (min.x + 1 - branch_x) >> 1;

	sub	edx, DWORD PTR _branch_x$1$[ebp]

; 130  :       lim.x = (lim.x + 1 - branch_x) >> 1;

	mov	ebx, DWORD PTR $T6[ebp]
	inc	edx
	sub	ebx, DWORD PTR _branch_x$1$[ebp]
	inc	ebx
	sar	edx, 1
	sar	ebx, 1
	mov	DWORD PTR $T6[ebp], ebx
	mov	ebx, DWORD PTR _pb$1$[ebp]
$LN55@initialize:

; 131  :     }
; 132  : 
; 133  :   if ((branch_y & ~1) == 0)

	test	DWORD PTR _branch_y$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN56@initialize

; 134  :     { // Parent node is split vertically
; 135  :       min.y -= (branch_y)?high_support_max:low_support_max;
; 136  :       lim.y -= (branch_y)?high_support_min:low_support_min;
; 137  :       min.y = (min.y + 1 - branch_y) >> 1;

	sub	ecx, DWORD PTR _branch_y$1$[ebp]

; 138  :       lim.y = (lim.y + 1 - branch_y) >> 1;

	sub	eax, DWORD PTR _branch_y$1$[ebp]
	inc	ecx
	inc	eax
	sar	ecx, 1
	sar	eax, 1
$LN56@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	DWORD PTR $T6[ebp], edx
	sub	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 143  :   result.size = lim-min;

	mov	DWORD PTR _prec_dims$2[ebp+8], eax

; 5285 :                        subband->branch_x,subband->branch_y);
; 5286 :       pb->block_indices =

	sub	esp, 16					; 00000010H

; 143  :   result.size = lim-min;

	mov	eax, DWORD PTR $T6[ebp]
	mov	DWORD PTR _prec_dims$2[ebp+12], eax

; 5285 :                        subband->branch_x,subband->branch_y);
; 5286 :       pb->block_indices =

	mov	eax, esp

; 142  :   result.pos = min;

	mov	DWORD PTR _prec_dims$2[ebp], ecx

; 5285 :                        subband->branch_x,subband->branch_y);
; 5286 :       pb->block_indices =

	sub	esp, 16					; 00000010H

; 142  :   result.pos = min;

	mov	DWORD PTR _prec_dims$2[ebp+4], edx

; 5285 :                        subband->branch_x,subband->branch_y);
; 5286 :       pb->block_indices =

	movups	xmm0, XMMWORD PTR _prec_dims$2[ebp]
	movups	XMMWORD PTR [eax], xmm0
	mov	eax, esp
	movups	xmm0, XMMWORD PTR [edi+68]
	movups	XMMWORD PTR [eax], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?get_partition_indices@@YA?AUkdu_dims@@U1@0@Z ; get_partition_indices
	movups	xmm0, XMMWORD PTR [eax]

; 5287 :         get_partition_indices(subband->block_partition,prec_dims);
; 5288 :       pb->blocks = kd_block::build_tree(pb->block_indices.size,mem_block);

	lea	eax, DWORD PTR _mem_block$[ebp]
	push	eax
	movups	XMMWORD PTR [ebx+4], xmm0
	push	DWORD PTR [ebx+16]
	push	DWORD PTR [ebx+12]
	call	?build_tree@kd_block@@SAPAV1@Ukdu_coords@@AAPAE@Z ; kd_block::build_tree

; 5289 : 
; 5290 :       /* Finally, scan through the leaf nodes of the `blocks' array setting
; 5291 :          up the coding modes and determining whether or not each block
; 5292 :          actually belongs to the current region of interest. */
; 5293 : 
; 5294 :       // Get location and size of first code-block in the partition which
; 5295 :       // intersects with current precinct-band.
; 5296 :       kdu_dims block_dims = subband->block_partition;
; 5297 :       block_dims.pos.x += block_dims.size.x * pb->block_indices.pos.x;

	mov	ecx, DWORD PTR [ebx+8]
	add	esp, 48					; 00000030H
	mov	DWORD PTR [ebx+20], eax
	movups	xmm1, XMMWORD PTR [edi+68]
	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	movd	edx, xmm0
	movups	XMMWORD PTR _block_dims$4[ebp], xmm1
	imul	ecx, edx
	mov	DWORD PTR _block_dims$1$[ebp], edx
	psrldq	xmm1, 4
	movd	edx, xmm1
	add	edx, ecx

; 5298 :       block_dims.pos.y += block_dims.size.y * pb->block_indices.pos.y;

	mov	ecx, DWORD PTR [ebx+4]
	imul	ecx, DWORD PTR _block_dims$4[ebp+8]
	mov	DWORD PTR _min$1$[ebp], edx
	mov	edx, DWORD PTR _block_dims$4[ebp]
	add	edx, ecx
	mov	DWORD PTR _block_dims$5$[ebp], edx

; 5299 :       kdu_coords min = block_dims.pos; // So we can keep coming back here.

	mov	ecx, edx

; 5300 :       kd_block *block = pb->blocks;
; 5301 :       int x, y;
; 5302 :       if (codestream->in == NULL) // Used for output or interchange

	mov	edx, DWORD PTR _codestream$1$[ebp]
	cmp	DWORD PTR [edx+4], 0
	jne	SHORT $LN22@initialize

; 5303 :         { // All blocks marked as outstanding; none can be discarded
; 5304 :           for (y=0, block_dims.pos.y=min.y;

	xor	ecx, ecx
	mov	DWORD PTR _y$1$[ebp], ecx

; 5305 :                y < pb->block_indices.size.y;

	cmp	DWORD PTR [ebx+12], ecx
	jle	$LN5@initialize
	mov	edi, DWORD PTR _resolution$[ebp]
	npad	4
$LL10@initialize:

; 5307 :             for (x=0, block_dims.pos.x=min.x;

	xor	edx, edx

; 5308 :                  x < pb->block_indices.size.x;

	cmp	DWORD PTR [ebx+16], edx
	jle	SHORT $LN8@initialize
	npad	9
$LL13@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3806 :         this->modes = (kdu_byte) modes;

	mov	ecx, DWORD PTR [edi+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5309 :                  x++, block_dims.pos.x += block_dims.size.x, block++)

	inc	edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3806 :         this->modes = (kdu_byte) modes;

	mov	cl, BYTE PTR [ecx+140]
	mov	BYTE PTR [eax+17], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5309 :                  x++, block_dims.pos.x += block_dims.size.x, block++)

	add	eax, 24					; 00000018H

; 5310 :               {
; 5311 :                 block->set_modes(resolution->tile_comp->modes);
; 5312 :                 num_outstanding_blocks++;

	inc	DWORD PTR [esi+24]
	cmp	edx, DWORD PTR [ebx+16]
	jl	SHORT $LL13@initialize
	mov	ecx, DWORD PTR _y$1$[ebp]
$LN8@initialize:

; 5306 :                y++, block_dims.pos.y += block_dims.size.y)

	inc	ecx
	mov	DWORD PTR _y$1$[ebp], ecx
	cmp	ecx, DWORD PTR [ebx+12]
	jl	SHORT $LL10@initialize

; 5313 :               }
; 5314 :         }
; 5315 :       else

	jmp	$LN5@initialize
$LN22@initialize:

; 5316 :         { // For input codestreams only (not interchange or output codestreams)
; 5317 :           for (y=0, block_dims.pos.y=min.y;
; 5318 :                y < pb->block_indices.size.y;

	cmp	DWORD PTR [ebx+12], 0
	mov	DWORD PTR _y$2$[ebp], 0
	jle	$LN5@initialize
	npad	6
$LL16@initialize:

; 5320 :             for (x=0, block_dims.pos.x=min.x;
; 5321 :                  x < pb->block_indices.size.x;

	cmp	DWORD PTR [ebx+16], 0
	mov	edx, DWORD PTR _min$1$[ebp]
	mov	DWORD PTR _x$2$[ebp], 0
	jle	$LN14@initialize
$LL19@initialize:

; 5325 :                 if (nothing_visible || !block_dims.intersects(subband->region))

	cmp	BYTE PTR _nothing_visible$1$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3806 :         this->modes = (kdu_byte) modes;

	mov	ecx, DWORD PTR _resolution$[ebp]
	mov	ecx, DWORD PTR [ecx+4]
	mov	cl, BYTE PTR [ecx+140]
	mov	BYTE PTR [eax+17], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5325 :                 if (nothing_visible || !block_dims.intersects(subband->region))

	jne	SHORT $LN26@initialize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 370  :         if ((pos.x+size.x) <= rhs.pos.x) return false;

	mov	ecx, DWORD PTR _block_dims$1$[ebp]
	mov	ebx, DWORD PTR [edi+28]
	add	ecx, edx
	cmp	ecx, ebx
	jle	SHORT $LN118@initialize

; 371  :         if ((pos.y+size.y) <= rhs.pos.y) return false;

	mov	ecx, DWORD PTR _block_dims$5$[ebp]
	add	ecx, DWORD PTR _block_dims$4[ebp+8]
	cmp	ecx, DWORD PTR [edi+24]
	jle	SHORT $LN118@initialize

; 372  :         if (pos.x >= (rhs.pos.x+rhs.size.x)) return false;

	mov	ecx, DWORD PTR [edi+36]
	add	ecx, ebx
	cmp	edx, ecx
	jge	SHORT $LN118@initialize

; 373  :         if (pos.y >= (rhs.pos.y+rhs.size.y)) return false;

	mov	ecx, DWORD PTR [edi+24]
	mov	ebx, DWORD PTR [edi+32]
	add	ecx, ebx
	cmp	DWORD PTR _block_dims$5$[ebp], ecx
	jge	SHORT $LN118@initialize

; 375  :             (rhs.size.x <= 0) || (rhs.size.y <= 0))

	cmp	DWORD PTR _block_dims$1$[ebp], 0
	jle	SHORT $LN118@initialize
	cmp	DWORD PTR _block_dims$4[ebp+8], 0
	jle	SHORT $LN118@initialize
	cmp	DWORD PTR [edi+36], 0
	jle	SHORT $LN118@initialize
	test	ebx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5331 :                   num_outstanding_blocks++;

	mov	ebx, DWORD PTR _pb$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 375  :             (rhs.size.x <= 0) || (rhs.size.y <= 0))

	jle	SHORT $LN26@initialize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5331 :                   num_outstanding_blocks++;

	inc	DWORD PTR [esi+24]
	jmp	SHORT $LN17@initialize
$LN118@initialize:
	mov	ebx, DWORD PTR _pb$1$[ebp]
$LN26@initialize:

; 5326 :                   {
; 5327 :                     if (!codestream->persistent)

	mov	ecx, DWORD PTR _codestream$1$[ebp]
	cmp	BYTE PTR [ecx+337], 0
	jne	SHORT $LN17@initialize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3797 :         num_passes = 255;

	mov	BYTE PTR [eax+10], 255			; 000000ffH
$LN17@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5322 :                  x++, block_dims.pos.x += block_dims.size.x, block++)

	mov	ecx, DWORD PTR _x$2$[ebp]
	add	eax, 24					; 00000018H
	add	edx, DWORD PTR _block_dims$1$[ebp]
	inc	ecx
	mov	DWORD PTR _x$2$[ebp], ecx
	cmp	ecx, DWORD PTR [ebx+16]
	jl	$LL19@initialize
	mov	ecx, DWORD PTR _block_dims$5$[ebp]
$LN14@initialize:

; 5319 :                y++, block_dims.pos.y += block_dims.size.y)

	mov	edx, DWORD PTR _y$2$[ebp]
	add	ecx, DWORD PTR _block_dims$4[ebp+8]
	inc	edx
	mov	DWORD PTR _y$2$[ebp], edx
	mov	DWORD PTR _block_dims$5$[ebp], ecx
	cmp	edx, DWORD PTR [ebx+12]
	jl	$LL16@initialize
$LN5@initialize:

; 5275 :         get_child_dims(node->parent->prec_dims,node->branch_x,node->branch_y);
; 5276 :     }
; 5277 : 
; 5278 :   for (b=0; b < resolution->num_subbands; b++)

	mov	edi, DWORD PTR _resolution$[ebp]
	mov	ecx, DWORD PTR _b$2$[ebp]
	mov	edx, DWORD PTR tv1063[ebp]
	inc	ecx
	add	DWORD PTR tv1062[ebp], 24		; 00000018H
	add	edx, 132				; 00000084H
	movzx	eax, BYTE PTR [edi+174]
	cmp	ecx, eax
	mov	DWORD PTR _b$2$[ebp], ecx
	mov	eax, DWORD PTR tv1062[ebp]
	mov	DWORD PTR tv1063[ebp], edx
	jl	$LL7@initialize
$LN6@initialize:

; 5332 :               }
; 5333 :         }
; 5334 :     }
; 5335 :   if ((num_outstanding_blocks == 0) && (codestream->in != NULL))

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN28@initialize
	mov	eax, DWORD PTR _codestream$1$[ebp]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN28@initialize

; 5336 :     flags |= KD_PFLAG_RELEASED;

	or	DWORD PTR [esi+8], 16			; 00000010H
$LN28@initialize:

; 5337 :       // released = true;
; 5338 :                      // Can only happen when the precinct is opened for parsing
; 5339 :                      // and does not lie within the current region of interest.
; 5340 :                      // For this reason, it will not be automatically released
; 5341 :                      // when the containing tile is closed (the tile may not
; 5342 :                      // be open yet) or correctly activated when the tile is
; 5343 :                      // opened.  By marking it as released here, we ensure that
; 5344 :                      // `kd_precinct_ref::open' calls `kd_precinct::activate'
; 5345 :                      // when the precinct is first opened for actually
; 5346 :                      // retrieving code-block data.
; 5347 :   if (tile->empty_shell)

	mov	eax, DWORD PTR _tile$1$[ebp]
	cmp	BYTE PTR [eax+227], 0
	je	SHORT $LN29@initialize

; 5348 :     num_packets_read = -1; // Prevents any attempt to read compressed data

	mov	DWORD PTR [esi+20], -1
$LN29@initialize:

; 5349 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?initialize@kd_precinct@@QAEXPAUkd_resolution@@Ukdu_coords@@@Z ENDP ; kd_precinct::initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?put_address@kd_block@@AAEXPAEPAVkd_buf_server@@@Z
_TEXT	SEGMENT
_addr$ = 8						; size = 4
_buf_server$ = 12					; size = 4
?put_address@kd_block@@AAEXPAEPAVkd_buf_server@@@Z PROC	; kd_block::put_address, COMDAT
; _this$ = ecx

; 3832 :       {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 3833 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer

	mov	dl, BYTE PTR [esi+8]
	neg	dl
	and	dl, 3
	add	dl, BYTE PTR [esi+8]
	mov	BYTE PTR [esi+8], dl

; 3834 :         if (buf_pos > (KD_CODE_BUFFER_LEN-KDU_POINTER_BYTES))

	cmp	dl, 54					; 00000036H
	jbe	SHORT $LN2@put_addres

; 3835 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }

	mov	ecx, DWORD PTR _buf_server$[ebp]
	mov	BYTE PTR [esi+8], 0
	call	?get@kd_buf_server@@QAEPAUkd_code_buffer@@XZ ; kd_buf_server::get
	mov	ecx, DWORD PTR [esi+4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [esi+4], eax
$LN2@put_addres:

; 3836 : 
; 3837 :         ((kdu_byte **)(current_buf->buf+buf_pos))[0] = addr;

	movzx	edx, BYTE PTR [esi+8]
	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR _addr$[ebp]
	mov	DWORD PTR [ecx+edx+6], eax

; 3838 :         buf_pos += KDU_POINTER_BYTES;

	add	BYTE PTR [esi+8], 4
	pop	esi

; 3839 :       }

	pop	ebp
	ret	8
?put_address@kd_block@@AAEXPAEPAVkd_buf_server@@@Z ENDP	; kd_block::put_address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?set_modes@kd_block@@QAEXH@Z
_TEXT	SEGMENT
_modes$ = 8						; size = 4
?set_modes@kd_block@@QAEXH@Z PROC			; kd_block::set_modes, COMDAT
; _this$ = ecx

; 3804 :       {

	push	ebp
	mov	ebp, esp

; 3805 :         assert(modes == (modes & 0xFF));
; 3806 :         this->modes = (kdu_byte) modes;

	mov	al, BYTE PTR _modes$[ebp]
	mov	BYTE PTR [ecx+17], al

; 3807 :       }

	pop	ebp
	ret	4
?set_modes@kd_block@@QAEXH@Z ENDP			; kd_block::set_modes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?empty@kd_block@@QAE_NXZ
_TEXT	SEGMENT
?empty@kd_block@@QAE_NXZ PROC				; kd_block::empty, COMDAT
; _this$ = ecx

; 3801 :         return first_buf == NULL;

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	sete	al

; 3802 :       }

	ret	0
?empty@kd_block@@QAE_NXZ ENDP				; kd_block::empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?set_discard@kd_block@@QAEXXZ
_TEXT	SEGMENT
?set_discard@kd_block@@QAEXXZ PROC			; kd_block::set_discard, COMDAT
; _this$ = ecx

; 3793 :            the object that none of the code-blocks associated with this
; 3794 :            block will ever be accessed, so that it is free to skip over them
; 3795 :            when reading a packet.  This can save a lot of memory if you have
; 3796 :            a defined region of interest for decompression. */
; 3797 :         num_passes = 255;

	mov	BYTE PTR [ecx+10], 255			; 000000ffH

; 3798 :       }

	ret	0
?set_discard@kd_block@@QAEXXZ ENDP			; kd_block::set_discard
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?read_body_bytes@kd_block@@QAEXPAVkd_input@@PAVkd_buf_server@@_N@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
_buf_server$ = 12					; size = 4
_addr$1 = 16						; size = 4
_in_memory_source$ = 16					; size = 1
?read_body_bytes@kd_block@@QAEXPAVkd_input@@PAVkd_buf_server@@_N@Z PROC ; kd_block::read_body_bytes, COMDAT
; _this$ = ecx

; 3639 :       { /* This function should be called after parsing the header of a

	push	ebp
	mov	ebp, esp
	push	edi
	mov	edi, ecx

; 3640 :            packet.  It reads the code-bytes contributed by the code-block to
; 3641 :            this packet.  If `in_memory_source' is true, only the address of
; 3642 :            the code-bytes is recorded, and then only if the length of the
; 3643 :            code-byte segment is non-zero. */
; 3644 :         if (this->temp_length > 0)

	movzx	eax, WORD PTR [edi+18]
	test	ax, ax
	je	SHORT $LN2@read_body_

; 3645 :           {
; 3646 :             if (num_passes == 255)

	cmp	BYTE PTR [edi+10], 255			; 000000ffH

; 3647 :               { // Read and discard the code-bytes.
; 3648 :                 assert(first_buf == NULL);  source->ignore(this->temp_length);

	mov	ecx, DWORD PTR _source$[ebp]
	jne	SHORT $LN3@read_body_
	push	esi
	mov	esi, DWORD PTR [ecx]
	cdq
	push	edx
	push	eax
	call	DWORD PTR [esi+4]

; 3658 :                 source->read(current_buf,buf_pos,buf_server,this->temp_length);
; 3659 :             this->temp_length = 0;

	xor	eax, eax
	pop	esi
	mov	WORD PTR [edi+18], ax
	pop	edi

; 3660 :           }
; 3661 :       }

	pop	ebp
	ret	12					; 0000000cH
$LN3@read_body_:

; 3649 :               }
; 3650 :             else if (in_memory_source)

	cmp	BYTE PTR _in_memory_source$[ebp], 0

; 3651 :               {
; 3652 :                 kdu_byte *addr;
; 3653 :                 this->num_bytes += source->pseudo_read(addr,this->temp_length);

	push	eax
	je	SHORT $LN5@read_body_
	lea	eax, DWORD PTR _addr$1[ebp]
	push	eax
	call	?pseudo_read@kd_input@@QAEHAAPAEH@Z	; kd_input::pseudo_read

; 3654 :                 put_address(addr,buf_server);

	push	DWORD PTR _buf_server$[ebp]
	add	WORD PTR [edi+14], ax
	mov	ecx, edi
	push	DWORD PTR _addr$1[ebp]
	call	?put_address@kd_block@@AAEXPAEPAVkd_buf_server@@@Z ; kd_block::put_address

; 3658 :                 source->read(current_buf,buf_pos,buf_server,this->temp_length);
; 3659 :             this->temp_length = 0;

	xor	eax, eax
	mov	WORD PTR [edi+18], ax
	pop	edi

; 3660 :           }
; 3661 :       }

	pop	ebp
	ret	12					; 0000000cH
$LN5@read_body_:

; 3655 :               }
; 3656 :             else
; 3657 :               this->num_bytes +=

	push	DWORD PTR _buf_server$[ebp]
	lea	eax, DWORD PTR [edi+8]
	push	eax
	lea	eax, DWORD PTR [edi+4]
	push	eax
	call	?read@kd_input@@QAEHAAPAUkd_code_buffer@@AAEPAVkd_buf_server@@H@Z ; kd_input::read
	add	WORD PTR [edi+14], ax

; 3658 :                 source->read(current_buf,buf_pos,buf_server,this->temp_length);
; 3659 :             this->temp_length = 0;

	xor	eax, eax
	mov	WORD PTR [edi+18], ax
$LN2@read_body_:
	pop	edi

; 3660 :           }
; 3661 :       }

	pop	ebp
	ret	12					; 0000000cH
?read_body_bytes@kd_block@@QAEXPAVkd_input@@PAVkd_buf_server@@_N@Z ENDP ; kd_block::read_body_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?cleanup@kd_block@@QAEXPAVkd_buf_server@@@Z
_TEXT	SEGMENT
_buf_server$ = 8					; size = 4
?cleanup@kd_block@@QAEXPAVkd_buf_server@@@Z PROC	; kd_block::cleanup, COMDAT
; _this$ = ecx

; 3608 :       {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 3609 :         while ((current_buf=first_buf) != NULL)

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
	test	eax, eax
	je	SHORT $LN11@cleanup
	push	edi
	mov	edi, DWORD PTR _buf_server$[ebp]
$LL2@cleanup:

; 3610 :           { first_buf=current_buf->next;  buf_server->release(current_buf); }

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, edi
	push	DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi], eax
	call	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ; kd_buf_server::release
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+4], eax
	test	eax, eax
	jne	SHORT $LL2@cleanup
	pop	edi
$LN11@cleanup:

; 3613 :     kd_code_buffer *cleanup()
; 3614 :       { // As above, but returns the linked list of buffers
; 3615 :         kd_code_buffer *result = first_buf;  first_buf = current_buf = NULL;
; 3616 :         set_discard();
; 3617 :         return result;
; 3618 :       }
; 3619 : 
; 3620 :   // --------------------------------------------------------------------------
; 3621 :   public: // Packet manipulation member functions
; 3622 :     int parse_packet_header(kd_header_in &head, kd_buf_server *buf_server,
; 3623 :                             int layer_idx); // Throws (kdu_uint16 code)
; 3624 :       /* Parses bits in the packet header corresponding to the current
; 3625 :          block for the current layer (this must be the next layer for which
; 3626 :          information has not yet been parsed).  The function returns the
; 3627 :          number of new body bytes contributed by the code-block in this layer
; 3628 :          and also stores this value internally to be used in subsequent calls
; 3629 :          to the `read_body_bytes' member function.
; 3630 :             The `kd_header_in' object may throw an exception if the packet
; 3631 :          data terminates unexpectedly.  Moreover, to assist in locating and
; 3632 :          possibly recovering from errors, the present function may throw a
; 3633 :          16-bit unsigned integer exception code, which is either the value of
; 3634 :          an illegal marker code encountered in the packet header, or one of
; 3635 :          the special exception codes, KDU_EXCEPTION_PRECISION or
; 3636 :          KDU_EXCEPTION_ILLEGAL_LAYER. */
; 3637 :     void read_body_bytes(kd_input *source, kd_buf_server *buf_server,
; 3638 :                          bool in_memory_source)
; 3639 :       { /* This function should be called after parsing the header of a
; 3640 :            packet.  It reads the code-bytes contributed by the code-block to
; 3641 :            this packet.  If `in_memory_source' is true, only the address of
; 3642 :            the code-bytes is recorded, and then only if the length of the
; 3643 :            code-byte segment is non-zero. */
; 3644 :         if (this->temp_length > 0)
; 3645 :           {
; 3646 :             if (num_passes == 255)
; 3647 :               { // Read and discard the code-bytes.
; 3648 :                 assert(first_buf == NULL);  source->ignore(this->temp_length);
; 3649 :               }
; 3650 :             else if (in_memory_source)
; 3651 :               {
; 3652 :                 kdu_byte *addr;
; 3653 :                 this->num_bytes += source->pseudo_read(addr,this->temp_length);
; 3654 :                 put_address(addr,buf_server);
; 3655 :               }
; 3656 :             else
; 3657 :               this->num_bytes +=
; 3658 :                 source->read(current_buf,buf_pos,buf_server,this->temp_length);
; 3659 :             this->temp_length = 0;
; 3660 :           }
; 3661 :       }
; 3662 :     void retrieve_data(kdu_block *block, int max_layers, int discard_passes,
; 3663 :                        bool in_memory_source);
; 3664 :       /* Retrieves compressed code-bytes, number of coding passes and codeword
; 3665 :          segment lengths from the current code-block and stores them in the
; 3666 :          `block' object.  All fields which are common for compression and
; 3667 :          decompression have already been filled out by the caller.  The
; 3668 :          byte buffer is allocated so as to be large enough to allow a
; 3669 :          2 byte marker code to be appended to the compressed data,
; 3670 :          if desired -- see declaration of "kdu_subband::open_block".
; 3671 :             The `max_layers' argument identifies the maximum number of
; 3672 :          quality layers for which code-block contributions are to be
; 3673 :          retrieved.
; 3674 :             The `discard_passes' argument indicates the number of additional
; 3675 :          coding passes to be removed, if any.
; 3676 :             If `in_memory_source' is true, the layer code bytes are not
; 3677 :          stored in the `kd_code_buffer' list embedded inside `block'.  Instead,
; 3678 :          the `kd_code_buffer' list stores only the header information for
; 3679 :          each layer, along with the address of the code bytes, which reside
; 3680 :          in the memory block managed by an in-memory compressed data source
; 3681 :          (one which offers the `KDU_SOURCE_CAP_IN_MEMORY') capability.  In
; 3682 :          this case, we retrieve the address and then perform a simple memory
; 3683 :          block copy operation to efficiently retrieve the code bytes for
; 3684 :          each layer. */
; 3685 :     void store_data(kdu_block *block, kd_buf_server *buf_server);
; 3686 :       /* Stores compressed code-bytes, pass length and pass slope information
; 3687 :          from the `block' object into the current code-block.  This function
; 3688 :          is invoked by "kdu_subband::close_block" when the containing
; 3689 :          codestream object was not constructed for input.  Also reflects
; 3690 :          the `msbs_w' value into higher nodes in the tag tree. */
; 3691 :     void store_data(kdu_block *block, kd_thread_buf_server *thread_buf_server);
; 3692 :       /* Same as the above function, but uses `kd_thread_buf_server::get'
; 3693 :          rather than `kd_buf_server::get' to get new code buffers.  This
; 3694 :          version is used to save code-block state in multi-threaded
; 3695 :          environments so as to minimize cache coherency bottlenecks and the
; 3696 :          need to lock shared resources. */
; 3697 :     void transfer_data(kd_block &src)
; 3698 :       { /* Like `store_data', but gets results from another block.  Exploits
; 3699 :            the layout of the object to copy only whole pointers or whole
; 3700 :            32-bit words, even where these represent multiple fields. */
; 3701 :         current_buf = first_buf = src.first_buf;
; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);
; 3703 :         src.current_buf = src.first_buf = NULL;
; 3704 :       }
; 3705 :     bool trim_data(kdu_uint16 slope_threshold, kd_buf_server *buf_server);
; 3706 :       /* This function serves two purposes: it helps reduce the amount of
; 3707 :          compressed data which must be buffered in memory while compressing
; 3708 :          an image; and it allows individual block contributions to be
; 3709 :          discarded during packet construction in order to tightly fit the
; 3710 :          generated bit-rate to the target compressed bit-rate.
; 3711 :             The function sets all coding pass slopes which are less than or
; 3712 :          equal to the supplied slope threshold to 0 and then discards all
; 3713 :          code bytes which could not possibly be included in the final
; 3714 :          code-stream, as a result of this modification.
; 3715 :             If anything was discarded, the function returns true.  Otherwise,
; 3716 :          it returns false. */
; 3717 :     int start_packet(int layer_idx, kdu_uint16 slope_threshold);
; 3718 :       /* Call this function only during rate allocation or packet generation.
; 3719 :          Before the first call to this function, you must reset the tag tree
; 3720 :          (see the "reset_output_tree" member function).  If you are calling
; 3721 :          the function multiple times with the same layer for rate allocation
; 3722 :          purposes, you must use "save_output_tree" and "restore_output_tree"
; 3723 :          as described below.
; 3724 :             The function leaves behind information about the number of new
; 3725 :          coding passes and the number of new code bytes which would be
; 3726 :          contributed by this code-block if the supplied threshold were actually
; 3727 :          used.  The final contributing coding pass must have a non-zero
; 3728 :          distortion-length slope which is strictly greater than the slope
; 3729 :          threshold.  It also updates the tag tree structure to reflect any
; 3730 :          new knowledge about the first layer to which this code-block would
; 3731 :          contribute.  This information is picked up by "write_packet_header".
; 3732 :             The function's return value is the total number of new code-bytes
; 3733 :          contributed by the block.  This allows the PCRD-opt algorithm to
; 3734 :          determine roughly the right slope threshold before committing to the
; 3735 :          work of simulating packet header generation. */
; 3736 :     void write_packet_header(kd_header_out &head, int layer_idx,
; 3737 :                              bool simulate);
; 3738 :       /* Call this function only after a `start_packet' call.  It writes
; 3739 :          (or simulates the writing of) packet header information corresponding
; 3740 :          to the code-block inclusion information set up by `start_packet'.
; 3741 :          If `simulate' is true, some internal state adjustments are delayed
; 3742 :          until the next call to "save_output_tree", so multiple calls to
; 3743 :          "start_packet" and "write_packet_header" may be issued with the same
; 3744 :          layer index to determine an optimal slope threshold.  Otherwise,
; 3745 :          if `simulate' is false, the internal state information is fully
; 3746 :          updated and the "save_output_tree" and "restore_output_tree" functions
; 3747 :          need not and should not be called. */
; 3748 :     void write_body_bytes(kdu_output *dest);
; 3749 :       /* This function should be called after a non-simulated
; 3750 :          "write_packet_header" call to output the newly included body bytes.
; 3751 :          The actual number of bytes to be written was left behind by
; 3752 :          the preceding "start_packet" call in the `temp_length' field. */
; 3753 :   // --------------------------------------------------------------------------
; 3754 :   public: // Static functions used to operate on tag-trees built from kd_block
; 3755 :     static kd_block *build_tree(kdu_coords size, kdu_byte * &mem_block);
; 3756 :       /* Builds a full tag tree returning a pointer to the upper left hand
; 3757 :          corner leaf node.  Apart from the `up_down' navigation pointers,
; 3758 :          all fields are initialized to 0.  This is appropriate for tag tree
; 3759 :          decoding, but encoders will need to call "reset_output_tree" and
; 3760 :          use "start_packet" to install appropriate node values.
; 3761 :             The tag tree is not allocated from the heap.  Instead, it is
; 3762 :          allocated from an existing memory block, identified by the `mem_block'
; 3763 :          argument.  This memory block is assumed to be large enough to hold
; 3764 :          the array of `kd_block' structures.  Upon return, the `mem_block'
; 3765 :          value is advanced by an amount equal to the size of the tag tree
; 3766 :          array. */
; 3767 :     static void reset_output_tree(kd_block *tree, kdu_coords size);
; 3768 :       /* Call this function immediately before simulating or actually
; 3769 :          generating any packet data for the relevant code-blocks.  Once
; 3770 :          the PCRD-opt algorithm has completed, you should call this function
; 3771 :          a second time to prepare for actual packet output.  The function
; 3772 :          initializes the threshold state variables, `layer_w_bar' and
; 3773 :          `msbs_w_bar' to 0, and the value state variables, `layer_w' and
; 3774 :          `msbs_w' to their maximum representable values.  The succession of
; 3775 :          "start_packet" calls will update the value variables `layer_w'
; 3776 :          and `msbs_w' in such a way that the tag tree coding process runs
; 3777 :          correctly in each subsequent call to "write_packet_header". */
; 3778 :     static void save_output_tree(kd_block *tree, kdu_coords size);
; 3779 :       /* Call this only during rate allocation, before moving on to a new
; 3780 :          layer.  The function saves the current state (`msbs_wbar' and
; 3781 :          `layer_wbar') of each node in the tag tree.  For leaf nodes, it also
; 3782 :          commits the number of new coding passes found in the last call to
; 3783 :          "start_packet". */
; 3784 :     static void restore_output_tree(kd_block *tree, kdu_coords size);
; 3785 :       /* Call this during rate allocation before supplying a new slope
; 3786 :          threshold for the same layer index, in a new "start_packet" call.
; 3787 :          The function restores the `msbs_w_bar' and `layer_w_bar' values
; 3788 :          previously saved by "save_output_tree". */
; 3789 :   // --------------------------------------------------------------------------
; 3790 :   public: // State identification functions
; 3791 :     void set_discard()
; 3792 :       { /* Use this function only with input-oriented operations.  It informs
; 3793 :            the object that none of the code-blocks associated with this
; 3794 :            block will ever be accessed, so that it is free to skip over them
; 3795 :            when reading a packet.  This can save a lot of memory if you have
; 3796 :            a defined region of interest for decompression. */
; 3797 :         num_passes = 255;

	mov	BYTE PTR [esi+10], 255			; 000000ffH
	pop	esi

; 3611 :         set_discard(); // Discard from any packets parsed in the future
; 3612 :       }

	pop	ebp
	ret	4
?cleanup@kd_block@@QAEXPAVkd_buf_server@@@Z ENDP	; kd_block::cleanup
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?finish@kd_header_out@@QAEHXZ
_TEXT	SEGMENT
?finish@kd_header_out@@QAEHXZ PROC			; kd_header_out::finish, COMDAT
; _this$ = ecx

; 3575 :       { // Returns the total number of bytes consumed by the packet header.

	push	esi
	mov	esi, ecx

; 3576 :         if (bits_left < 8)

	cmp	DWORD PTR [esi+4], 8
	jge	SHORT $LN14@finish

; 3577 :           {
; 3578 :             byte <<= bits_left;

	mov	cl, BYTE PTR [esi+4]
	shl	BYTE PTR [esi], cl
	push	ebx
	mov	bl, BYTE PTR [esi]
	push	edi

; 3579 :             if (out != NULL)

	mov	edi, DWORD PTR [esi+12]
	test	edi, edi
	je	SHORT $LN3@finish
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN8@finish

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
$LN8@finish:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [edi+516]
$LN3@finish:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3581 :             completed_bytes++;

	inc	DWORD PTR [esi+8]

; 3582 :             if (byte == 0xFF)

	cmp	BYTE PTR [esi], 255			; 000000ffH
	jne	SHORT $LN13@finish

; 3583 :               { // Need the stuffing byte.
; 3584 :                 if (out != NULL)

	mov	edi, DWORD PTR [esi+12]
	test	edi, edi
	je	SHORT $LN5@finish
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN11@finish

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
$LN11@finish:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
	mov	BYTE PTR [eax], 0
	inc	DWORD PTR [edi+516]
$LN5@finish:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3586 :                 completed_bytes++;

	inc	DWORD PTR [esi+8]
$LN13@finish:

; 3587 :               }
; 3588 :           }
; 3589 :         return completed_bytes;

	mov	eax, DWORD PTR [esi+8]
	pop	edi
	pop	ebx
	pop	esi

; 3590 :       }

	ret	0
$LN14@finish:

; 3587 :               }
; 3588 :           }
; 3589 :         return completed_bytes;

	mov	eax, DWORD PTR [esi+8]
	pop	esi

; 3590 :       }

	ret	0
?finish@kd_header_out@@QAEHXZ ENDP			; kd_header_out::finish
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?put_bit@kd_header_out@@QAEXH@Z
_TEXT	SEGMENT
_bit$ = 8						; size = 4
?put_bit@kd_header_out@@QAEXH@Z PROC			; kd_header_out::put_bit, COMDAT
; _this$ = ecx

; 3559 :       { // Output a header bit

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 3560 :         assert(bit == (bit & 1));
; 3561 :         if (bits_left == 0)

	cmp	DWORD PTR [esi+4], 0
	jne	SHORT $LN2@put_bit

; 3562 :           { if (out != NULL) out->put(byte);

	push	edi
	mov	edi, DWORD PTR [esi+12]
	test	edi, edi
	je	SHORT $LN3@put_bit
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [edi+516]
	push	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3562 :           { if (out != NULL) out->put(byte);

	mov	bl, BYTE PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [edi+520]
	jne	SHORT $LN6@put_bit

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	call	DWORD PTR [eax+4]
$LN6@put_bit:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [edi+516]
	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [edi+516]
	pop	ebx
$LN3@put_bit:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3563 :             completed_bytes++;

	inc	DWORD PTR [esi+8]

; 3564 :             bits_left = (byte==0xFF)?7:8;

	xor	eax, eax
	cmp	BYTE PTR [esi], 255			; 000000ffH

; 3565 :             byte = 0; }

	mov	BYTE PTR [esi], 0
	setne	al
	add	eax, 7
	mov	DWORD PTR [esi+4], eax
	pop	edi
$LN2@put_bit:

; 3566 :         byte += byte + bit;

	mov	al, BYTE PTR [esi]
	add	al, al
	add	al, BYTE PTR _bit$[ebp]

; 3567 :         bits_left--;

	dec	DWORD PTR [esi+4]
	mov	BYTE PTR [esi], al
	pop	esi

; 3568 :       }

	pop	ebp
	ret	4
?put_bit@kd_header_out@@QAEXH@Z ENDP			; kd_header_out::put_bit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_header_out@@QAE@PAVkdu_output@@@Z
_TEXT	SEGMENT
_out$ = 8						; size = 4
??0kd_header_out@@QAE@PAVkdu_output@@@Z PROC		; kd_header_out::kd_header_out, COMDAT
; _this$ = ecx

; 3556 :     kd_header_out(kdu_output *out=NULL) // Null for simulating header

	push	ebp
	mov	ebp, esp

; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }

	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR [ecx+12], eax
	mov	eax, ecx
	mov	BYTE PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 8
	mov	DWORD PTR [ecx+8], 0
	pop	ebp
	ret	4
??0kd_header_out@@QAE@PAVkdu_output@@@Z ENDP		; kd_header_out::kd_header_out
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?finish@kd_header_in@@QAEHXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?finish@kd_header_in@@QAEHXZ PROC			; kd_header_in::finish, COMDAT
; _this$ = ecx

; 3531 :       { // Call this when the header is all read, to consume any stuffing byte

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 3532 :         // Returns total header length
; 3533 :         if ((bits_left == 0) && (byte == 0xFF))

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN2@finish
	cmp	BYTE PTR [esi+4], 255			; 000000ffH
	lea	eax, DWORD PTR [esi+4]
	jne	SHORT $LN2@finish

; 3534 :           {
; 3535 :             bits_left = 7;
; 3536 :             if (!source->get(byte))

	mov	ecx, DWORD PTR [esi]
	push	eax
	mov	DWORD PTR [esi+8], 7
	call	?get@kd_input@@QAE_NAAE@Z		; kd_input::get
	test	al, al
	je	SHORT $LN6@finish

; 3538 :             header_bytes++;

	inc	DWORD PTR [esi+12]
$LN2@finish:

; 3539 :           }
; 3540 :         return header_bytes;

	mov	eax, DWORD PTR [esi+12]
	pop	esi

; 3541 :       }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@finish:

; 3537 :               throw this;

	push	OFFSET __TI2PAVkd_header_in@@
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T1[ebp], esi
	push	eax
	call	__CxxThrowException@8
$LN8@finish:
$LN5@finish:
	int	3
?finish@kd_header_in@@QAEHXZ ENDP			; kd_header_in::finish
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_bit@kd_header_in@@QAEHXZ
_TEXT	SEGMENT
$T1 = -4						; size = 4
?get_bit@kd_header_in@@QAEHXZ PROC			; kd_header_in::get_bit, COMDAT
; _this$ = ecx

; 3500 :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	esi
	mov	esi, ecx

; 3501 :         if (bits_left==0)

	cmp	DWORD PTR [esi+8], 0
	jne	SHORT $LN2@get_bit

; 3502 :           {
; 3503 :             bits_left = (byte==0xFF)?7:8;
; 3504 :             if (!source->get(byte))

	mov	ecx, DWORD PTR [esi]
	lea	edx, DWORD PTR [esi+4]
	xor	eax, eax
	cmp	BYTE PTR [edx], 255			; 000000ffH
	push	edx
	setne	al
	add	eax, 7
	mov	DWORD PTR [esi+8], eax
	call	?get@kd_input@@QAE_NAAE@Z		; kd_input::get
	test	al, al
	je	SHORT $LN6@get_bit

; 3506 :             header_bytes++;

	inc	DWORD PTR [esi+12]
$LN2@get_bit:

; 3507 :           }
; 3508 :         bits_left--;

	dec	DWORD PTR [esi+8]

; 3509 :         return (byte >> bits_left) & 1;

	movzx	eax, BYTE PTR [esi+4]
	mov	cl, BYTE PTR [esi+8]
	shr	eax, cl
	and	eax, 1
	pop	esi

; 3510 :       }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN6@get_bit:

; 3505 :               { bits_left = 0; throw this; }

	push	OFFSET __TI2PAVkd_header_in@@
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR [esi+8], 0
	push	eax
	mov	DWORD PTR $T1[ebp], esi
	call	__CxxThrowException@8
$LN8@get_bit:
$LN5@get_bit:
	int	3
?get_bit@kd_header_in@@QAEHXZ ENDP			; kd_header_in::get_bit
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_header_in@@QAE@PAVkd_input@@@Z
_TEXT	SEGMENT
_source$ = 8						; size = 4
??0kd_header_in@@QAE@PAVkd_input@@@Z PROC		; kd_header_in::kd_header_in, COMDAT
; _this$ = ecx

; 3497 :     kd_header_in(kd_input *source)

	push	ebp
	mov	ebp, esp

; 3498 :       { this->source = source; bits_left=0; byte=0; header_bytes=0; }

	mov	eax, DWORD PTR _source$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	mov	DWORD PTR [ecx+8], 0
	mov	BYTE PTR [ecx+4], 0
	mov	DWORD PTR [ecx+12], 0
	pop	ebp
	ret	4
??0kd_header_in@@QAE@PAVkd_input@@@Z ENDP		; kd_header_in::kd_header_in
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Ekd_resolution@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Ekd_resolution@@QAEPAXI@Z PROC			; kd_resolution::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Ekd_resolution@@QAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ebx, DWORD PTR ___flags$[ebp]
	test	bl, 2
	je	SHORT $LN2@vector
	push	OFFSET ??1kd_resolution@@QAE@XZ		; kd_resolution::~kd_resolution
	push	DWORD PTR [esi-4]
	lea	edi, DWORD PTR [esi-4]
	push	604					; 0000025cH
	push	esi
	call	??_M@YGXPAXIIP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN3@vector
	imul	ecx, DWORD PTR [edi], 604
	add	ecx, 4
	push	ecx
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN3@vector:
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@vector:
	call	??1kd_resolution@@QAE@XZ		; kd_resolution::~kd_resolution
	test	bl, 1
	je	SHORT $LN4@vector
	push	604					; 0000025cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@vector:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Ekd_resolution@@QAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Ekd_resolution@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Ekd_resolution@@QAEPAXI@Z ENDP			; kd_resolution::`vector deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?complete_initialization@kd_resolution@@QAEXXZ
_TEXT	SEGMENT
_blocks$1 = -76						; size = 16
_prec_dims$2 = -60					; size = 16
$T3 = -44						; size = 16
_band$1$ = -28						; size = 4
_precinct_blocks$1$ = -28				; size = 4
_node$1$ = -24						; size = 4
_p_idx$2$ = -20						; size = 4
_p_idx$1$ = -16						; size = 4
_branch_x$1$ = -12					; size = 4
_branch_y$1$ = -12					; size = 4
tv863 = -12						; size = 4
_branch_y$1$ = -8					; size = 4
_branch_x$1$ = -8					; size = 4
_b$2$ = -1						; size = 1
?complete_initialization@kd_resolution@@QAEXXZ PROC	; kd_resolution::complete_initialization, COMDAT
; _this$ = ecx

; 4158 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	mov	esi, ecx

; 4159 :   /* The purpose of this function is to configure the `max_blocks_per_precinct'
; 4160 :      member.  The implementation is based on the observation that it is
; 4161 :      sufficient to consider the upper left hand 2x2 block of precincts in the
; 4162 :      current tile-component-resolution.  One of these must have the maximum
; 4163 :      size, either because it is a full sized precinct, having the nominal
; 4164 :      precinct dimensions for the resolution, or because the resolution has no
; 4165 :      more than these 4 precincts. */
; 4166 :   max_blocks_per_precinct = 0; // Initial value
; 4167 : 
; 4168 :   kdu_coords p_idx;
; 4169 :   for (p_idx.y=0; p_idx.y < 2; p_idx.y++)

	xor	ebx, ebx
	push	edi
	mov	DWORD PTR _p_idx$1$[ebp], ebx
	mov	DWORD PTR [esi+168], 0
	npad	6
$LL4@complete_i:

; 4170 :     for (p_idx.x=0; p_idx.x < 2; p_idx.x++)

	xor	eax, eax
	mov	DWORD PTR _p_idx$2$[ebp], eax
	npad	11
$LL7@complete_i:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	ecx, DWORD PTR [esi+140]
	mov	edx, DWORD PTR [esi+136]
	add	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4173 :         node.prec_dims = precinct_partition;

	movups	xmm0, XMMWORD PTR [esi+120]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	edx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4173 :         node.prec_dims = precinct_partition;

	movups	XMMWORD PTR [esi+76], xmm0

; 4174 :         node.prec_dims.pos.x += pos_idx.x * node.prec_dims.size.x;

	mov	eax, DWORD PTR [esi+88]
	imul	eax, ecx
	add	DWORD PTR [esi+80], eax

; 4175 :         node.prec_dims.pos.y += pos_idx.y * node.prec_dims.size.y;

	mov	eax, DWORD PTR [esi+84]
	imul	eax, edx
	add	DWORD PTR [esi+76], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	edi, DWORD PTR [esi+88]
	add	edi, DWORD PTR [esi+80]
	mov	eax, DWORD PTR [esi+36]
	add	eax, DWORD PTR [esi+28]
	mov	ebx, DWORD PTR [esi+84]
	add	ebx, DWORD PTR [esi+76]
	mov	ecx, DWORD PTR [esi+32]
	add	ecx, DWORD PTR [esi+24]

; 231  :     kdu_coords minus(const kdu_coords &rhs)
; 232  :       { /* [SYNOPSIS] Same as `operator-', but more suitable for
; 233  :                       some language bindings. */
; 234  :            return (*this)-rhs;
; 235  :       }
; 236  :     kdu_coords operator+=(const kdu_coords &rhs)
; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }
; 238  :     kdu_coords add(const kdu_coords &rhs)
; 239  :       { /* [SYNOPSIS] Same as `operator+=', but more suitable for some
; 240  :                       language bindings. */
; 241  :         x+=rhs.x; y+=rhs.y; return *this;
; 242  :       }
; 243  :     kdu_coords operator-=(const kdu_coords &rhs)
; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }
; 245  :     kdu_coords subtract(const kdu_coords &rhs)
; 246  :       { /* [SYNOPSIS] Same as `operator-=', but more suitable for some
; 247  :                       language bindings. */
; 248  :         x-=rhs.x; y-=rhs.y; return *this;
; 249  :       }
; 250  :     bool operator==(const kdu_coords &rhs)
; 251  :       { return (x==rhs.x) && (y==rhs.y); }
; 252  :     bool equals(const kdu_coords &rhs)
; 253  :       { /* [SYNOPSIS] Same as `operator==', but more suitable for
; 254  :                       some language bindings. */
; 255  :            return (*this)==rhs;
; 256  :       }
; 257  :     bool operator!=(const kdu_coords &rhs)
; 258  :       { return (x!=rhs.x) || (y!=rhs.y); }
; 259  :     void from_apparent(bool transp, bool vflip, bool hflip)
; 260  :       { /* [SYNOPSIS]
; 261  :              Converts a point from the apparent coordinate system established
; 262  :              by `kdu_codestream::change_appearance' to the real coordinates.
; 263  :              The `transp', `vflip' and `hflip' parameters are identical to
; 264  :              those supplied to `kdu_codestream::change_appearance'.
; 265  :         */
; 266  :         x=(hflip)?(-x):x;
; 267  :         y=(vflip)?(-y):y;
; 268  :         if (transp) transpose();
; 269  :       }
; 270  :     void to_apparent(bool transp, bool vflip, bool hflip)
; 271  :       { /* [SYNOPSIS]
; 272  :              Does the reverse of `from_apparent', assuming the same values
; 273  :              for `transp', `vflip' and `hflip' are supplied.
; 274  :         */
; 275  :         if (transp) transpose();
; 276  :         x = (hflip)?(-x):x;
; 277  :         y = (vflip)?(-y):y;
; 278  :       }
; 279  :   };
; 280  : 
; 281  : /*****************************************************************************/
; 282  : /*                                kdu_dims                                   */
; 283  : /*****************************************************************************/
; 284  : 
; 285  : struct kdu_dims {
; 286  :   /* [BIND: copy]
; 287  :      [SYNOPSIS]
; 288  :        Generic structure for holding location and size information for various
; 289  :        partitions on the canvas.  The `size' coordinates identify the
; 290  :        dimensions of the specific tile, tile-component, precinct, code-block,
; 291  :        etc., while the `pos' coordinates identify the absolute location of
; 292  :        its upper left hand corner.
; 293  :        [//]
; 294  :        When used to describe partitions, the dimensions of the partition
; 295  :        element are maintained by `size', while `pos' holds the anchor
; 296  :        point for the partition.  The anchor point is the absolute coordinates
; 297  :        of the upper left hand corner of a reference partition element. */
; 298  :   public: // Data
; 299  :     kdu_coords pos;
; 300  :       /* [SYNOPSIS] Upper left hand corner. */
; 301  :     kdu_coords size;
; 302  :       /* [SYNOPSIS] Dimensions of rectangle or partition element. */
; 303  :   public: // Convenience functions
; 304  :     kdu_dims() {};
; 305  :     void assign(const kdu_dims &src) { *this = src; }
; 306  :       /* [SYNOPSIS] Copies the contents of `src' to the present object.
; 307  :          This function is useful only when using a language binding
; 308  :          which does not support data member access or direct copying
; 309  :          of contents. */
; 310  :     kdu_coords *access_pos() { return &pos; }
; 311  :       /* [SYNOPSIS] Returns a pointer (reference) to the public
; 312  :          `pos' member.  This is useful when working with a language
; 313  :          binding which does not support data member access.  When
; 314  :          used with the Java language binding, for example, interacting
; 315  :          with the returned object, is equivalent to interacting with
; 316  :          the `pos' member of the present object directly. */
; 317  :     kdu_coords *access_size() { return &size; }
; 318  :       /* [SYNOPSIS] Returns a pointer (reference) to the public
; 319  :          `size' member.  This is useful when working with a language
; 320  :          binding which does not support data member access.  When
; 321  :          used with the Java language binding, for example, interacting
; 322  :          with the returned object, is equivalent to interacting with
; 323  :          the `size' member of the present object directly. */
; 324  :     kdu_long area()
; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }
; 326  :       /* [SYNOPSIS]
; 327  :          Returns the product of the horizontal and vertical dimensions. */
; 328  :     void transpose()
; 329  :       { size.transpose(); pos.transpose(); }
; 330  :       /* [SYNOPSIS]
; 331  :          Swap the roles played by horizontal and vertical coordinates. */
; 332  :     kdu_dims operator&(kdu_dims &rhs) // Intersects region with RHS.
; 333  :       { kdu_dims result = *this; result &= rhs; return result; }
; 334  :       /* [SYNOPSIS]
; 335  :            Returns the intersection of the region represented by `rhs' with
; 336  :            that represented by the current object.
; 337  :       */
; 338  :     kdu_dims intersection(kdu_dims &rhs)
; 339  :       { /* [SYNOPSIS] Same as `operator&', but more appropriate for
; 340  :                       some language bindings. */
; 341  :         return (*this) & rhs;
; 342  :       }
; 343  :     kdu_dims operator&=(kdu_dims &rhs) // Returns intersection of operands
; 344  :       {
; 345  :       /* [SYNOPSIS]
; 346  :            Intersects the region represented by `rhs' with that  represented
; 347  :            by the current object.
; 348  :       */
; 349  :         kdu_coords lim = pos+size;
; 350  :         kdu_coords rhs_lim = rhs.pos + rhs.size;
; 351  :         if (lim.x > rhs_lim.x) lim.x = rhs_lim.x;

	cmp	edi, eax
	cmovg	edi, eax

; 352  :         if (lim.y > rhs_lim.y) lim.y  = rhs_lim.y;
; 353  :         if (pos.x < rhs.pos.x) pos.x = rhs.pos.x;

	mov	eax, DWORD PTR [esi+28]
	cmp	ebx, ecx
	cmovg	ebx, ecx
	cmp	DWORD PTR [esi+80], eax
	jge	SHORT $LN28@complete_i
	mov	DWORD PTR [esi+80], eax
$LN28@complete_i:

; 354  :         if (pos.y < rhs.pos.y) pos.y = rhs.pos.y;

	mov	eax, DWORD PTR [esi+24]
	cmp	DWORD PTR [esi+76], eax
	jge	SHORT $LN29@complete_i
	mov	DWORD PTR [esi+76], eax
$LN29@complete_i:

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	edi, DWORD PTR [esi+80]
	sub	ebx, DWORD PTR [esi+76]

; 355  :         size = lim-pos;

	mov	DWORD PTR [esi+84], ebx
	mov	DWORD PTR [esi+88], edi

; 356  :         if (size.x < 0) size.x = 0;

	test	edi, edi
	jge	SHORT $LN30@complete_i
	mov	DWORD PTR [esi+88], 0
$LN30@complete_i:

; 357  :         if (size.y < 0) size.y = 0;

	test	ebx, ebx
	jge	SHORT $LN31@complete_i
	mov	DWORD PTR [esi+84], 0
$LN31@complete_i:

; 358  :         return *this;
; 359  :       }
; 360  : 
; 361  :     bool intersects(kdu_dims &rhs)
; 362  :       {
; 363  :       /* [SYNOPSIS]
; 364  :            Checks whether or not the region represented by `rhs' has
; 365  :            a non-empty intersection with that represented by the current
; 366  :            object.
; 367  :          [RETURNS]
; 368  :            True if the intersection is non-empty.
; 369  :       */
; 370  :         if ((pos.x+size.x) <= rhs.pos.x) return false;
; 371  :         if ((pos.y+size.y) <= rhs.pos.y) return false;
; 372  :         if (pos.x >= (rhs.pos.x+rhs.size.x)) return false;
; 373  :         if (pos.y >= (rhs.pos.y+rhs.size.y)) return false;
; 374  :         if ((size.x <= 0) || (size.y <= 0) ||
; 375  :             (rhs.size.x <= 0) || (rhs.size.y <= 0))
; 376  :           return false;
; 377  :         return true;
; 378  :       }
; 379  :     bool operator!()
; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	cmp	DWORD PTR [esi+88], 0
	jle	$LN5@complete_i
	cmp	DWORD PTR [esi+84], 0
	jle	$LN5@complete_i
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4181 :         int precinct_blocks = 0;

	xor	ebx, ebx
	mov	DWORD PTR _precinct_blocks$1$[ebp], ebx

; 4182 :         for (b=0; b < num_intermediate_nodes; b++)

	cmp	BYTE PTR [esi+175], bl
	jbe	$LN9@complete_i
	npad	7
$LL10@complete_i:

; 4183 :           {
; 4184 :             kd_node *node = intermediate_nodes + b;

	movzx	eax, bl
	imul	ecx, eax, 104
	add	ecx, DWORD PTR [esi+176]
	mov	DWORD PTR _node$1$[ebp], ecx

; 4185 :             node->prec_dims = get_child_dims(node->parent->prec_dims,

	movzx	eax, BYTE PTR [ecx+41]
	mov	DWORD PTR _branch_y$1$[ebp], eax
	movzx	eax, BYTE PTR [ecx+40]
	mov	DWORD PTR _branch_x$1$[ebp], eax
	mov	eax, DWORD PTR [ecx]
	movups	xmm1, XMMWORD PTR [eax+60]

; 122  :   kdu_coords min = parent_dims.pos;

	movaps	xmm0, xmm1
	movd	edx, xmm1
	psrldq	xmm0, 4
	movd	edi, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	psrldq	xmm1, 8
	movd	ecx, xmm0
	movd	eax, xmm1
	add	ecx, edi
	add	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 125  :   if ((branch_x & ~1) == 0)

	test	DWORD PTR _branch_x$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN50@complete_i

; 126  :     { // Parent node is split horizontally
; 127  :       min.x -= (branch_x)?high_support_max:low_support_max;
; 128  :       lim.x -= (branch_x)?high_support_min:low_support_min;
; 129  :       min.x = (min.x + 1 - branch_x) >> 1;

	sub	edi, DWORD PTR _branch_x$1$[ebp]

; 130  :       lim.x = (lim.x + 1 - branch_x) >> 1;

	sub	ecx, DWORD PTR _branch_x$1$[ebp]
	inc	edi
	inc	ecx
	sar	edi, 1
	sar	ecx, 1
$LN50@complete_i:

; 131  :     }
; 132  : 
; 133  :   if ((branch_y & ~1) == 0)

	test	DWORD PTR _branch_y$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN51@complete_i

; 134  :     { // Parent node is split vertically
; 135  :       min.y -= (branch_y)?high_support_max:low_support_max;
; 136  :       lim.y -= (branch_y)?high_support_min:low_support_min;
; 137  :       min.y = (min.y + 1 - branch_y) >> 1;

	sub	edx, DWORD PTR _branch_y$1$[ebp]

; 138  :       lim.y = (lim.y + 1 - branch_y) >> 1;

	sub	eax, DWORD PTR _branch_y$1$[ebp]
	inc	edx
	inc	eax
	sar	edx, 1
	sar	eax, 1
$LN51@complete_i:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 142  :   result.pos = min;

	mov	DWORD PTR $T3[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ecx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 143  :   result.size = lim-min;

	mov	DWORD PTR $T3[ebp+8], eax

; 4185 :             node->prec_dims = get_child_dims(node->parent->prec_dims,

	mov	eax, DWORD PTR _node$1$[ebp]
	inc	bl

; 142  :   result.pos = min;

	mov	DWORD PTR $T3[ebp+4], edi

; 143  :   result.size = lim-min;

	mov	DWORD PTR $T3[ebp+12], ecx

; 4185 :             node->prec_dims = get_child_dims(node->parent->prec_dims,

	movups	xmm0, XMMWORD PTR $T3[ebp]
	movups	XMMWORD PTR [eax+60], xmm0
	cmp	bl, BYTE PTR [esi+175]
	jb	$LL10@complete_i
	mov	ebx, DWORD PTR _precinct_blocks$1$[ebp]
$LN9@complete_i:

; 4186 :                                              node->branch_x,node->branch_y);
; 4187 :           }
; 4188 :         for (b=0; b < num_subbands; b++)

	xor	al, al
	mov	BYTE PTR _b$2$[ebp], al
	cmp	BYTE PTR [esi+174], al
	jbe	$LN12@complete_i
	npad	13
$LL13@complete_i:

; 4189 :           {
; 4190 :             kd_subband *band = subbands + b;

	movzx	eax, al
	imul	ecx, eax, 132
	add	ecx, DWORD PTR [esi+184]
	mov	DWORD PTR _band$1$[ebp], ecx

; 4191 :             kdu_dims prec_dims = get_child_dims(band->parent->prec_dims,

	movzx	eax, BYTE PTR [ecx+41]
	mov	DWORD PTR _branch_y$1$[ebp], eax
	movzx	eax, BYTE PTR [ecx+40]
	mov	DWORD PTR _branch_x$1$[ebp], eax
	mov	eax, DWORD PTR [ecx]
	movups	xmm1, XMMWORD PTR [eax+60]

; 122  :   kdu_coords min = parent_dims.pos;

	movaps	xmm0, xmm1
	movd	ecx, xmm1
	psrldq	xmm0, 4
	movd	edi, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	psrldq	xmm1, 8
	movd	edx, xmm0
	movd	eax, xmm1
	add	edx, edi
	add	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 125  :   if ((branch_x & ~1) == 0)

	test	DWORD PTR _branch_x$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN68@complete_i

; 126  :     { // Parent node is split horizontally
; 127  :       min.x -= (branch_x)?high_support_max:low_support_max;
; 128  :       lim.x -= (branch_x)?high_support_min:low_support_min;
; 129  :       min.x = (min.x + 1 - branch_x) >> 1;

	sub	edi, DWORD PTR _branch_x$1$[ebp]

; 130  :       lim.x = (lim.x + 1 - branch_x) >> 1;

	sub	edx, DWORD PTR _branch_x$1$[ebp]
	inc	edi
	inc	edx
	sar	edi, 1
	sar	edx, 1
$LN68@complete_i:

; 131  :     }
; 132  : 
; 133  :   if ((branch_y & ~1) == 0)

	test	DWORD PTR _branch_y$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN69@complete_i

; 134  :     { // Parent node is split vertically
; 135  :       min.y -= (branch_y)?high_support_max:low_support_max;
; 136  :       lim.y -= (branch_y)?high_support_min:low_support_min;
; 137  :       min.y = (min.y + 1 - branch_y) >> 1;

	sub	ecx, DWORD PTR _branch_y$1$[ebp]

; 138  :       lim.y = (lim.y + 1 - branch_y) >> 1;

	sub	eax, DWORD PTR _branch_y$1$[ebp]
	inc	ecx
	inc	eax
	sar	ecx, 1
	sar	eax, 1
$LN69@complete_i:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 142  :   result.pos = min;

	mov	DWORD PTR _prec_dims$2[ebp], ecx

; 4194 :               get_partition_indices(band->block_partition,prec_dims);

	mov	ecx, DWORD PTR _band$1$[ebp]
	sub	esp, 16					; 00000010H

; 143  :   result.size = lim-min;

	mov	DWORD PTR _prec_dims$2[ebp+8], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	edx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4194 :               get_partition_indices(band->block_partition,prec_dims);

	mov	eax, esp

; 143  :   result.size = lim-min;

	mov	DWORD PTR _prec_dims$2[ebp+12], edx
	mov	DWORD PTR _prec_dims$2[ebp+4], edi

; 4194 :               get_partition_indices(band->block_partition,prec_dims);

	sub	esp, 16					; 00000010H
	movups	xmm0, XMMWORD PTR _prec_dims$2[ebp]
	movups	XMMWORD PTR [eax], xmm0
	mov	eax, esp
	movups	xmm0, XMMWORD PTR [ecx+68]
	movups	XMMWORD PTR [eax], xmm0
	lea	eax, DWORD PTR _blocks$1[ebp]
	push	eax
	call	?get_partition_indices@@YA?AUkdu_dims@@U1@0@Z ; get_partition_indices

; 4195 : 
; 4196 :             // Convert the dimensions of the block array into a tag tree size
; 4197 :             int level_nodes = blocks.size.x * blocks.size.y;

	mov	ecx, DWORD PTR _blocks$1[ebp+8]
	add	esp, 36					; 00000024H
	mov	edx, DWORD PTR _blocks$1[ebp+12]
	mov	eax, ecx
	imul	eax, edx

; 4198 :             precinct_blocks += level_nodes;

	add	ebx, eax

; 4199 :             while (level_nodes > 1)

	cmp	eax, 1
	jle	SHORT $LN11@complete_i
$LL14@complete_i:

; 4202 :                 blocks.size.y = (blocks.size.y+1)>>1;

	inc	ecx
	inc	edx
	sar	ecx, 1
	sar	edx, 1

; 4203 :                 level_nodes = blocks.size.x * blocks.size.y;

	mov	eax, ecx
	imul	eax, edx

; 4204 :                 precinct_blocks += level_nodes;

	add	ebx, eax
	cmp	eax, 1
	jg	SHORT $LL14@complete_i

; 4200 :               {
; 4201 :                 blocks.size.x = (blocks.size.x+1)>>1;

	mov	DWORD PTR _blocks$1[ebp+8], ecx
	mov	DWORD PTR _blocks$1[ebp+12], edx
$LN11@complete_i:

; 4186 :                                              node->branch_x,node->branch_y);
; 4187 :           }
; 4188 :         for (b=0; b < num_subbands; b++)

	mov	al, BYTE PTR _b$2$[ebp]
	inc	al
	mov	BYTE PTR _b$2$[ebp], al
	cmp	al, BYTE PTR [esi+174]
	jb	$LL13@complete_i
$LN12@complete_i:

; 4205 :               }
; 4206 :           }
; 4207 :         if (precinct_blocks > max_blocks_per_precinct)

	cmp	ebx, DWORD PTR [esi+168]
	jle	SHORT $LN5@complete_i

; 4208 :           max_blocks_per_precinct = precinct_blocks;

	mov	DWORD PTR [esi+168], ebx
$LN5@complete_i:

; 4170 :     for (p_idx.x=0; p_idx.x < 2; p_idx.x++)

	mov	eax, DWORD PTR _p_idx$2$[ebp]
	mov	ebx, DWORD PTR _p_idx$1$[ebp]
	inc	eax
	mov	DWORD PTR _p_idx$2$[ebp], eax
	cmp	eax, 2
	jl	$LL7@complete_i

; 4159 :   /* The purpose of this function is to configure the `max_blocks_per_precinct'
; 4160 :      member.  The implementation is based on the observation that it is
; 4161 :      sufficient to consider the upper left hand 2x2 block of precincts in the
; 4162 :      current tile-component-resolution.  One of these must have the maximum
; 4163 :      size, either because it is a full sized precinct, having the nominal
; 4164 :      precinct dimensions for the resolution, or because the resolution has no
; 4165 :      more than these 4 precincts. */
; 4166 :   max_blocks_per_precinct = 0; // Initial value
; 4167 : 
; 4168 :   kdu_coords p_idx;
; 4169 :   for (p_idx.y=0; p_idx.y < 2; p_idx.y++)

	inc	ebx
	mov	DWORD PTR _p_idx$1$[ebp], ebx
	cmp	ebx, 2
	jl	$LL4@complete_i

; 4209 :       }
; 4210 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?complete_initialization@kd_resolution@@QAEXXZ ENDP	; kd_resolution::complete_initialization
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?build_decomposition_structure@kd_resolution@@QAEXPAVkdu_params@@AAVkdu_kernels@@@Z
_TEXT	SEGMENT
_hval$1 = -252						; size = 8
_lval$2 = -252						; size = 8
_lval$3 = -244						; size = 8
_hval$4 = -244						; size = 8
_hor_extra_stage_high$ = -236				; size = 3
_vert_extra_stage_high$ = -232				; size = 3
_next_inode_idx$ = -228					; size = 4
_next_band_idx$ = -224					; size = 4
_this$GSCopy$1$ = -220					; size = 4
_hor_bibo_gains$1$ = -220				; size = 4
_kernels$GSCopy$1$ = -216				; size = 4
_decomp$ = -212						; size = 4
_tdesc$2$ = -208					; size = 4
_dfs_mask$1$ = -208					; size = 4
$T5 = -208						; size = 4
$T6 = -208						; size = 4
$T7 = -208						; size = 4
$T8 = -208						; size = 4
_transpose_band_descriptors$ = -204			; size = 98
_band_descriptors$ = -104				; size = 98
__$ArrayPad$ = -4					; size = 4
_coc$ = 8						; size = 4
_kernels$ = 12						; size = 4
?build_decomposition_structure@kd_resolution@@QAEXPAVkdu_params@@AAVkdu_kernels@@@Z PROC ; kd_resolution::build_decomposition_structure, COMDAT
; _this$ = ecx

; 4005 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 252				; 000000fcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	eax, DWORD PTR _kernels$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _kernels$GSCopy$1$[ebp], eax
	mov	ecx, DWORD PTR _coc$[ebp]
	mov	DWORD PTR _this$GSCopy$1$[ebp], edi

; 4006 :   int decomp = 3;

	mov	DWORD PTR _decomp$[ebp], 3

; 4007 :   int transpose_decomp = 3;
; 4008 :   kdu_int16 band_descriptors[49];
; 4009 :   kdu_int16 transpose_band_descriptors[49];
; 4010 :   num_subbands = 1;
; 4011 :   if (res_level > 0)

	cmp	BYTE PTR [edi+12], 0
	mov	BYTE PTR [edi+174], 1
	jbe	SHORT $LN32@build_deco

; 4012 :     {
; 4013 :       if (coc != NULL)

	test	ecx, ecx
	je	SHORT $LN34@build_deco

; 4014 :         coc->get(Cdecomp,dwt_level-1,0,decomp);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _decomp$[ebp]
	push	eax
	movzx	eax, BYTE PTR [edi+13]
	push	0
	dec	eax
	push	eax
	push	OFFSET ??_C@_07MIOINIMK@Cdecomp?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN34@build_deco:

; 4015 :       transpose_decomp = cod_params::transpose_decomp(decomp);

	push	DWORD PTR _decomp$[ebp]
	call	?transpose_decomp@cod_params@@SAHH@Z	; cod_params::transpose_decomp
	mov	esi, eax

; 4016 :       num_subbands = (kdu_byte)

	lea	eax, DWORD PTR _band_descriptors$[ebp]
	push	eax
	push	DWORD PTR _decomp$[ebp]
	call	?expand_decomp_bands@cod_params@@SAHHQAF@Z ; cod_params::expand_decomp_bands
	dec	al
	mov	BYTE PTR [edi+174], al

; 4017 :         cod_params::expand_decomp_bands(decomp,band_descriptors) - 1;
; 4018 :       cod_params::expand_decomp_bands(transpose_decomp,

	lea	eax, DWORD PTR _transpose_band_descriptors$[ebp]
	push	eax
	push	esi
	call	?expand_decomp_bands@cod_params@@SAHHQAF@Z ; cod_params::expand_decomp_bands
	add	esp, 20					; 00000014H

; 4019 :                                       transpose_band_descriptors);
; 4020 :     }
; 4021 :   else

	jmp	SHORT $LN33@build_deco
$LN32@build_deco:

; 4022 :     band_descriptors[0] = transpose_band_descriptors[0] = 0;

	xor	eax, eax
	mov	WORD PTR _transpose_band_descriptors$[ebp], ax
	mov	WORD PTR _band_descriptors$[ebp], ax
$LN33@build_deco:

; 4023 : 
; 4024 :   // Initialize the subbands
; 4025 :   kdu_byte b, k;
; 4026 :   assert(subbands == NULL);
; 4027 :   if (num_subbands <= 3)

	mov	al, BYTE PTR [edi+174]
	cmp	al, 3
	ja	SHORT $LN35@build_deco

; 4028 :     subbands = subband_store;

	lea	eax, DWORD PTR [edi+192]

; 4029 :   else

	jmp	SHORT $LN157@build_deco
$LN35@build_deco:

; 4030 :     subbands = subband_handle = new kd_subband[num_subbands];

	movzx	esi, al
	xor	ecx, ecx
	mov	eax, esi
	mov	DWORD PTR $T8[ebp], esi
	mov	edx, 132				; 00000084H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	test	eax, eax
	je	SHORT $LN51@build_deco
	mov	ebx, eax
	test	esi, esi
	je	SHORT $LN52@build_deco
	npad	3
$LL62@build_deco:
	mov	ecx, ebx
	call	??0kd_subband@@QAE@XZ
	add	ebx, 132				; 00000084H
	sub	esi, 1
	jne	SHORT $LL62@build_deco
	mov	eax, DWORD PTR $T7[ebp]
	jmp	SHORT $LN52@build_deco
$LN51@build_deco:
	xor	eax, eax
$LN52@build_deco:
	mov	DWORD PTR [edi+188], eax
$LN157@build_deco:

; 4031 :   for (b=0; b < num_subbands; b++)

	xor	dl, dl
	mov	DWORD PTR [edi+184], eax
	cmp	BYTE PTR [edi+174], dl
	jbe	SHORT $LN3@build_deco
	npad	14
$LL4@build_deco:

; 4032 :     {
; 4033 :       kd_subband *band = subbands + b;

	movzx	eax, dl
	imul	ecx, eax, 132
	add	ecx, DWORD PTR [edi+184]

; 4034 :       band->parent = NULL; // Until we find the true parent

	mov	DWORD PTR [ecx], 0

; 4035 :       band->resolution = this;

	mov	DWORD PTR [ecx+4], edi

; 4036 :       band->is_leaf = true;

	mov	BYTE PTR [ecx+42], 1

; 4037 : 
; 4038 :       if (res_level == 0)

	cmp	BYTE PTR [edi+12], 0
	jne	SHORT $LN37@build_deco

; 4039 :         band->descriptor = 0;

	xor	eax, eax

; 4040 :       else

	jmp	SHORT $LN158@build_deco
$LN37@build_deco:

; 4041 :         band->descriptor = band_descriptors[b+1];

	mov	ax, WORD PTR _band_descriptors$[ebp+eax*2+2]
$LN158@build_deco:

; 4042 :       band->sequence_idx = b;

	mov	BYTE PTR [ecx+47], dl
	inc	dl
	mov	WORD PTR [ecx+44], ax
	cmp	dl, BYTE PTR [edi+174]
	jb	SHORT $LL4@build_deco
$LN3@build_deco:

; 4043 :     }
; 4044 : 
; 4045 :   // Find transpose subband sequence indices
; 4046 :   kdu_int16 tdesc;
; 4047 :   for (b=0; b < num_subbands; b++)

	xor	bl, bl
	cmp	BYTE PTR [edi+174], bl
	jbe	$LN6@build_deco
	npad	6
$LL7@build_deco:

; 4048 :     {
; 4049 :       if (res_level == 0)

	cmp	BYTE PTR [edi+12], 0
	jne	SHORT $LN39@build_deco

; 4050 :         tdesc = 0;

	xor	ecx, ecx

; 4051 :       else

	jmp	SHORT $LN40@build_deco
$LN39@build_deco:

; 4052 :         tdesc = transpose_band_descriptors[b+1];

	movzx	eax, bl
	movzx	ecx, WORD PTR _transpose_band_descriptors$[ebp+eax*2+2]
$LN40@build_deco:

; 4053 :       tdesc = ((tdesc & 0x00FF)<<8) | ((tdesc>>8) & 0x00FF);

	mov	eax, ecx

; 4054 :       for (k=0; k < num_subbands; k++)

	xor	dl, dl
	sar	eax, 8
	shl	ecx, 8
	movzx	eax, al
	or	eax, ecx
	mov	cl, BYTE PTR [edi+174]
	movzx	eax, ax
	mov	DWORD PTR _tdesc$2$[ebp], eax
	test	cl, cl
	je	SHORT $LN109@build_deco

; 4055 :         if (subbands[k].descriptor == tdesc)

	mov	esi, DWORD PTR [edi+184]
	mov	edi, eax
	npad	1
$LL10@build_deco:
	movzx	eax, dl
	imul	eax, eax, 132
	cmp	WORD PTR [eax+esi+44], di
	je	SHORT $LN156@build_deco

; 4054 :       for (k=0; k < num_subbands; k++)

	inc	dl
	cmp	dl, cl
	jb	SHORT $LL10@build_deco
$LN156@build_deco:
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN109@build_deco:

; 4056 :           break;
; 4057 :       assert(k < num_subbands);
; 4058 :       subbands[b].transpose_sequence_idx = k;

	movzx	eax, bl
	inc	bl
	imul	ecx, eax, 132
	mov	eax, DWORD PTR [edi+184]
	mov	BYTE PTR [ecx+eax+48], dl
	cmp	bl, BYTE PTR [edi+174]
	jb	SHORT $LL7@build_deco
$LN6@build_deco:

; 4059 :     }
; 4060 : 
; 4061 :   // Find out how many intermediate nodes we need
; 4062 :   int n;
; 4063 :   assert(intermediate_nodes == NULL);
; 4064 :   num_intermediate_nodes = 0;

	mov	BYTE PTR [edi+175], 0

; 4065 :   for (n=2; n <= 30; n+=2)

	mov	ecx, 2
$LL13@build_deco:

; 4066 :     if ((decomp >> n) & 3)

	mov	eax, DWORD PTR _decomp$[ebp]
	sar	eax, cl
	test	al, 3
	je	SHORT $LN11@build_deco

; 4067 :       num_intermediate_nodes++;

	inc	BYTE PTR [edi+175]
$LN11@build_deco:

; 4065 :   for (n=2; n <= 30; n+=2)

	add	ecx, 2
	cmp	ecx, 30					; 0000001eH
	jle	SHORT $LL13@build_deco

; 4068 :   if (num_intermediate_nodes != 0)

	mov	al, BYTE PTR [edi+175]
	test	al, al
	je	$LN43@build_deco

; 4069 :     intermediate_nodes = new kd_node[num_intermediate_nodes];

	movzx	esi, al
	xor	ecx, ecx
	mov	eax, esi
	mov	DWORD PTR $T6[ebp], esi
	mov	edx, 104				; 00000068H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T5[ebp], eax
	test	eax, eax
	je	$LN53@build_deco
	test	esi, esi
	je	$LN54@build_deco
	lea	ecx, DWORD PTR [eax+36]
	npad	6
$LL66@build_deco:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx-28], 0
	lea	ecx, DWORD PTR [ecx+104]
	mov	DWORD PTR [ecx-128], 0
	mov	DWORD PTR [ecx-124], 0
	mov	DWORD PTR [ecx-120], 0
	mov	DWORD PTR [ecx-116], 0
	mov	DWORD PTR [ecx-112], 0
	mov	DWORD PTR [ecx-108], 0
	mov	DWORD PTR [ecx-104], 0
	mov	DWORD PTR [ecx-96], 0
	mov	DWORD PTR [ecx-92], 0
	mov	DWORD PTR [ecx-88], 0
	mov	DWORD PTR [ecx-84], 0
	mov	DWORD PTR [ecx-80], 0
	mov	DWORD PTR [ecx-76], 0
	mov	DWORD PTR [ecx-72], 0
	mov	DWORD PTR [ecx-68], 0
	sub	esi, 1
	jne	SHORT $LL66@build_deco
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4069 :     intermediate_nodes = new kd_node[num_intermediate_nodes];

	jmp	SHORT $LN54@build_deco
$LN53@build_deco:
	xor	eax, eax
$LN54@build_deco:
	mov	DWORD PTR [edi+176], eax
$LN43@build_deco:

; 4070 : 
; 4071 :   node.resolution = this;
; 4072 :   node.is_leaf = false;
; 4073 :   node.num_descendant_nodes = 0;

	xor	eax, eax
	mov	DWORD PTR [edi+20], edi

; 4074 :   node.num_descendant_leaves = 0;
; 4075 :   for (b=0; b < num_intermediate_nodes; b++)

	xor	bl, bl
	mov	BYTE PTR [edi+58], 0
	mov	DWORD PTR [edi+110], eax
	cmp	BYTE PTR [edi+175], al
	jbe	$LN15@build_deco
	npad	4
$LL16@build_deco:

; 4076 :     {
; 4077 :       assert(res_level > 0);
; 4078 :       intermediate_nodes[b].parent = NULL; // Until we find the true parent

	mov	eax, DWORD PTR [edi+176]

; 4079 :       intermediate_nodes[b].resolution = this;
; 4080 :       intermediate_nodes[b].is_leaf = false;
; 4081 :       intermediate_nodes[b].num_descendant_nodes = 0;

	xor	esi, esi
	movzx	edx, bl
	inc	bl
	imul	ecx, edx, 104
	mov	DWORD PTR [ecx+eax], 0
	mov	eax, DWORD PTR [edi+176]
	mov	DWORD PTR [eax+ecx+4], edi
	mov	eax, DWORD PTR [edi+176]
	mov	BYTE PTR [eax+ecx+42], 0
	mov	eax, DWORD PTR [edi+176]
	mov	WORD PTR [eax+ecx+94], si

; 4082 :       intermediate_nodes[b].num_descendant_leaves = 0;

	mov	eax, DWORD PTR [edi+176]
	mov	WORD PTR [eax+ecx+96], si

; 4083 :       intermediate_nodes[b].bibo_gains = false;

	mov	eax, DWORD PTR [edi+176]
	mov	DWORD PTR [eax+ecx+100], esi

; 4084 :       for (n=0; n < 4; n++)
; 4085 :         intermediate_nodes[b].children[n] = NULL;

	mov	eax, DWORD PTR [edi+176]
	imul	ecx, edx, 26
	mov	DWORD PTR [eax+ecx*4+76], esi
	mov	eax, DWORD PTR [edi+176]
	mov	DWORD PTR [eax+ecx*4+80], esi
	mov	eax, DWORD PTR [edi+176]
	mov	DWORD PTR [eax+ecx*4+84], esi
	mov	eax, DWORD PTR [edi+176]
	mov	DWORD PTR [eax+ecx*4+88], esi
	cmp	bl, BYTE PTR [edi+175]
	jb	SHORT $LL16@build_deco
$LN15@build_deco:

; 4086 :     }
; 4087 : 
; 4088 :   // Create parent-child pointers
; 4089 :   for (n=0; n < 4; n++)
; 4090 :     node.children[n] = NULL;

	lea	ebx, DWORD PTR [edi+96]
	mov	DWORD PTR [edi+92], 0
	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [edi+100], 0
	mov	DWORD PTR [edi+104], 0

; 4091 :   this->can_flip = true; // Until proven otherwise inside `create_child_node'
; 4092 :   if (res_level == 0)

	cmp	BYTE PTR [edi+12], 0
	mov	BYTE PTR [edi+173], 1
	jne	SHORT $LN44@build_deco

; 4093 :     {
; 4094 :       node.children[LL_BAND] = subbands;

	mov	eax, DWORD PTR [edi+184]

; 4095 :       node.num_descendant_leaves = 1;
; 4096 :       subbands[0].parent = &node;

	lea	ecx, DWORD PTR [edi+16]
	mov	DWORD PTR [edi+92], eax
	mov	eax, 1
	mov	WORD PTR [edi+112], ax
	mov	eax, DWORD PTR [edi+184]
	mov	DWORD PTR [eax], ecx

; 4097 :       subbands[0].dims = node.dims;

	mov	eax, DWORD PTR [edi+184]
	movups	xmm0, XMMWORD PTR [edi+24]
	movups	XMMWORD PTR [eax+8], xmm0

; 4098 :       subbands[0].branch_x = subbands[0].branch_y = 2;

	mov	eax, DWORD PTR [edi+184]
	mov	BYTE PTR [eax+41], 2
	mov	eax, DWORD PTR [edi+184]
	mov	BYTE PTR [eax+40], 2

; 4099 :       subbands[0].orientation = (kdu_byte) LL_BAND;

	mov	eax, DWORD PTR [edi+184]
	pop	edi
	pop	esi
	pop	ebx
	mov	BYTE PTR [eax+46], 0

; 4145 :         assert((next_inode_idx <= (int) num_intermediate_nodes) &&
; 4146 :                (next_band_idx <= (int) num_subbands));
; 4147 :       }
; 4148 :   assert((next_inode_idx == (int) num_intermediate_nodes) &&
; 4149 :          (next_band_idx == (int) num_subbands));
; 4150 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
$LN44@build_deco:

; 4100 :       return;
; 4101 :     }
; 4102 : 
; 4103 :   kd_comp_info *ci = codestream->comp_info + tile_comp->cnum;

	mov	eax, DWORD PTR [edi+4]

; 4104 :   int next_band_idx=0, next_inode_idx=0;
; 4105 :   int dfs_mask =
; 4106 :     (((int) ci->hor_depth[dwt_level]) - hor_depth) +

	movzx	edx, BYTE PTR [edi+13]
	mov	eax, DWORD PTR [eax+12]
	lea	esi, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edi]
	shl	esi, 5
	add	esi, DWORD PTR [eax+256]
	movzx	eax, BYTE PTR [edi+15]
	mov	DWORD PTR _next_band_idx$[ebp], 0
	mov	DWORD PTR _next_inode_idx$[ebp], 0
	movzx	ecx, BYTE PTR [edx+esi+54]
	sub	ecx, eax
	movzx	eax, BYTE PTR [edx+esi+21]

; 4107 :     ((((int) ci->vert_depth[dwt_level]) - vert_depth)<<1);
; 4108 : 
; 4109 :   node.num_hor_steps = (kdu_byte)

	mov	edx, DWORD PTR [edi+4]
	lea	ecx, DWORD PTR [eax+ecx*2]
	movzx	eax, BYTE PTR [edi+14]
	sub	ecx, eax
	mov	DWORD PTR _dfs_mask$1$[ebp], ecx
	test	cl, 1
	je	SHORT $LN55@build_deco
	mov	eax, DWORD PTR [edx+76]
	jmp	SHORT $LN56@build_deco
$LN55@build_deco:
	xor	eax, eax
$LN56@build_deco:
	mov	BYTE PTR [edi+108], al

; 4110 :     ((dfs_mask & 1)?(tile_comp->kernel_num_steps):0);
; 4111 :   node.num_vert_steps = (kdu_byte)

	test	cl, 2
	je	SHORT $LN57@build_deco
	mov	ecx, DWORD PTR [edx+76]
	jmp	SHORT $LN58@build_deco
$LN57@build_deco:
	xor	ecx, ecx
$LN58@build_deco:
	mov	BYTE PTR [edi+109], cl

; 4112 :     ((dfs_mask & 2)?(tile_comp->kernel_num_steps):0);
; 4113 :   node.bibo_gains = new float[node.num_hor_steps+node.num_vert_steps+2];

	mov	edx, 4
	movzx	ecx, cl
	movzx	eax, al
	add	eax, 2
	add	eax, ecx
	xor	ecx, ecx
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]

; 4114 :   float *hor_bibo_gains = node.bibo_gains;
; 4115 :   float *vert_bibo_gains = node.bibo_gains + (1+node.num_hor_steps);

	movzx	ecx, BYTE PTR [edi+108]
	add	esp, 4
	mov	DWORD PTR _hor_bibo_gains$1$[ebp], eax
	mov	DWORD PTR [edi+116], eax

; 4116 :   hor_bibo_gains[0] = (float) kernels.get_bibo_gain(hor_depth,0,NULL);

	push	0
	lea	esi, DWORD PTR [eax+ecx*4]
	movzx	ecx, BYTE PTR [edi+14]
	push	0
	push	ecx
	mov	ecx, DWORD PTR _kernels$GSCopy$1$[ebp]
	call	?get_bibo_gain@kdu_kernels@@QAENHHQA_N@Z ; kdu_kernels::get_bibo_gain
	mov	eax, DWORD PTR _hor_bibo_gains$1$[ebp]
	fstp	DWORD PTR [eax]

; 4117 :   if (node.num_hor_steps > 0)

	cmp	BYTE PTR [edi+108], 0
	jbe	SHORT $LN24@build_deco

; 4118 :     {
; 4119 :       double lval, hval, *gains =
; 4120 :         kernels.get_bibo_gains(hor_depth,0,NULL,lval,hval);

	mov	ecx, DWORD PTR _kernels$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _hval$4[ebp]
	push	eax
	lea	eax, DWORD PTR _lval$2[ebp]
	push	eax
	movzx	eax, BYTE PTR [edi+14]
	push	0
	push	0
	push	eax
	call	?get_bibo_gains@kdu_kernels@@QAEPANHHQA_NAAN1@Z ; kdu_kernels::get_bibo_gains

; 4121 :       for (b=0; b < node.num_hor_steps; b++)

	xor	dl, dl
	cmp	BYTE PTR [edi+108], dl
	jbe	SHORT $LN24@build_deco
	mov	ebx, DWORD PTR _hor_bibo_gains$1$[ebp]
	npad	9
$LL25@build_deco:

; 4122 :         hor_bibo_gains[b+1] = (float) gains[b];

	movzx	ecx, dl
	inc	dl
	movsd	xmm0, QWORD PTR [eax+ecx*8]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [ebx+ecx*4+4], xmm0
	cmp	dl, BYTE PTR [edi+108]
	jb	SHORT $LL25@build_deco
	lea	ebx, DWORD PTR [edi+96]
$LN24@build_deco:

; 4123 :     }
; 4124 :   vert_bibo_gains[0] = (float) kernels.get_bibo_gain(vert_depth,0,NULL);

	movzx	eax, BYTE PTR [edi+15]
	mov	ecx, DWORD PTR _kernels$GSCopy$1$[ebp]
	push	0
	push	0
	push	eax
	call	?get_bibo_gain@kdu_kernels@@QAENHHQA_N@Z ; kdu_kernels::get_bibo_gain
	fstp	DWORD PTR [esi+4]

; 4125 :   if (node.num_vert_steps > 0)

	cmp	BYTE PTR [edi+109], 0
	jbe	SHORT $LN27@build_deco

; 4126 :     {
; 4127 :       double lval, hval, *gains =
; 4128 :         kernels.get_bibo_gains(vert_depth,0,NULL,lval,hval);

	mov	ecx, DWORD PTR _kernels$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _hval$1[ebp]
	push	eax
	lea	eax, DWORD PTR _lval$3[ebp]
	push	eax
	movzx	eax, BYTE PTR [edi+15]
	push	0
	push	0
	push	eax
	call	?get_bibo_gains@kdu_kernels@@QAEPANHHQA_NAAN1@Z ; kdu_kernels::get_bibo_gains

; 4129 :       for (b=0; b < node.num_vert_steps; b++)

	xor	dl, dl
	cmp	BYTE PTR [edi+109], dl
	jbe	SHORT $LN27@build_deco
$LL28@build_deco:

; 4130 :         vert_bibo_gains[b+1] = (float) gains[b];

	movzx	ecx, dl
	inc	dl
	movsd	xmm0, QWORD PTR [eax+ecx*8]
	cvtpd2ps xmm0, xmm0
	movss	DWORD PTR [esi+ecx*4+8], xmm0
	cmp	dl, BYTE PTR [edi+109]
	jb	SHORT $LL28@build_deco
$LN27@build_deco:

; 4131 :     }
; 4132 : 
; 4133 :   bool hor_extra_stage_high[3], vert_extra_stage_high[3];
; 4134 :   assert(dfs_mask == (decomp & 3));
; 4135 :   decomp >>= 2;

	mov	ecx, DWORD PTR _decomp$[ebp]

; 4136 :   for (n=1; n < 4; n++)

	mov	esi, 1
	mov	edx, DWORD PTR _dfs_mask$1$[ebp]
	sar	ecx, 2
	mov	DWORD PTR _decomp$[ebp], ecx
$LL31@build_deco:

; 4137 :     if (n == (n & dfs_mask))

	mov	eax, edx
	and	eax, esi
	cmp	esi, eax
	jne	SHORT $LN29@build_deco

; 4138 :       {
; 4139 :         node.children[n] =

	push	DWORD PTR _kernels$GSCopy$1$[ebp]
	lea	eax, DWORD PTR _vert_extra_stage_high$[ebp]
	and	ecx, 1023				; 000003ffH
	push	eax
	push	0
	lea	eax, DWORD PTR _hor_extra_stage_high$[ebp]
	push	eax
	push	0
	push	0
	push	0
	push	esi
	push	1
	push	ecx
	lea	eax, DWORD PTR _next_band_idx$[ebp]
	push	eax
	push	DWORD PTR [edi+184]
	lea	eax, DWORD PTR _next_inode_idx$[ebp]
	push	eax
	push	DWORD PTR [edi+176]
	lea	eax, DWORD PTR [edi+16]
	push	edx
	push	esi
	push	eax
	call	?create_child_node@@YAPAUkd_leaf_node@@PAUkd_node@@HH0AAHPAUkd_subband@@1HHH_N3HQA_NH4AAVkdu_kernels@@@Z ; create_child_node

; 4140 :           create_child_node(&node,n,dfs_mask,intermediate_nodes,next_inode_idx,
; 4141 :                             subbands,next_band_idx,(decomp & 0x3FF),1,
; 4142 :                             n,false,false,0,hor_extra_stage_high,
; 4143 :                             0,vert_extra_stage_high,kernels);
; 4144 :         decomp >>= 10;

	mov	ecx, DWORD PTR _decomp$[ebp]
	add	esp, 68					; 00000044H
	mov	edx, DWORD PTR _dfs_mask$1$[ebp]
	sar	ecx, 10					; 0000000aH
	mov	DWORD PTR [ebx], eax
	mov	DWORD PTR _decomp$[ebp], ecx
$LN29@build_deco:

; 4136 :   for (n=1; n < 4; n++)

	inc	esi
	add	ebx, 4
	cmp	esi, 4
	jl	SHORT $LL31@build_deco

; 4145 :         assert((next_inode_idx <= (int) num_intermediate_nodes) &&
; 4146 :                (next_band_idx <= (int) num_subbands));
; 4147 :       }
; 4148 :   assert((next_inode_idx == (int) num_intermediate_nodes) &&
; 4149 :          (next_band_idx == (int) num_subbands));
; 4150 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	edi
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?build_decomposition_structure@kd_resolution@@QAEXPAVkdu_params@@AAVkdu_kernels@@@Z ENDP ; kd_resolution::build_decomposition_structure
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_resolution@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kd_resolution@@QAE@XZ PROC				; kd_resolution::~kd_resolution, COMDAT
; _this$ = ecx

; 3417 :       {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_resolution@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 3418 :         if (node.bibo_gains != NULL) delete[] node.bibo_gains;

	mov	eax, DWORD PTR [edi+116]
	test	eax, eax
	je	SHORT $LN5@kd_resolut
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@kd_resolut:

; 3419 :         for (int n=0; n < (int) num_intermediate_nodes; n++)

	xor	esi, esi
	cmp	BYTE PTR [edi+175], 0
	jbe	SHORT $LN3@kd_resolut
	xor	ebx, ebx
$LL4@kd_resolut:

; 3420 :           if (intermediate_nodes[n].bibo_gains != NULL)

	mov	eax, DWORD PTR [edi+176]
	mov	eax, DWORD PTR [eax+ebx+100]
	test	eax, eax
	je	SHORT $LN2@kd_resolut

; 3421 :             delete[] intermediate_nodes[n].bibo_gains;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@kd_resolut:

; 3419 :         for (int n=0; n < (int) num_intermediate_nodes; n++)

	movzx	eax, BYTE PTR [edi+175]
	inc	esi
	add	ebx, 104				; 00000068H
	cmp	esi, eax
	jl	SHORT $LL4@kd_resolut
$LN3@kd_resolut:

; 3422 :         if (precinct_refs != NULL) delete[] precinct_refs;

	mov	eax, DWORD PTR [edi+180]
	test	eax, eax
	je	SHORT $LN16@kd_resolut
	push	OFFSET ??1kd_precinct_ref@@QAE@XZ	; kd_precinct_ref::~kd_precinct_ref
	push	DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	8
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax*8+4]
	push	eax
	push	esi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN16@kd_resolut:

; 3423 :         if (subband_handle != NULL) delete[] subband_handle;

	mov	eax, DWORD PTR [edi+188]
	test	eax, eax
	je	SHORT $LN8@kd_resolut
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN8@kd_resolut:

; 3424 :         if (intermediate_nodes != NULL) delete[] intermediate_nodes;

	mov	eax, DWORD PTR [edi+176]
	test	eax, eax
	je	SHORT $LN9@kd_resolut
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN9@kd_resolut:

; 3425 :       }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1kd_resolution@@QAE@XZ$0:
	call	___std_terminate
	ret	0
__ehhandler$??1kd_resolution@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_resolution@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_resolution@@QAE@XZ ENDP				; kd_resolution::~kd_resolution
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_resolution@@QAE@XZ
_TEXT	SEGMENT
??0kd_resolution@@QAE@XZ PROC				; kd_resolution::kd_resolution, COMDAT
; _this$ = ecx

; 3409 :     kd_resolution()

	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 3410 :       {

	lea	ecx, DWORD PTR [esi+16]
	call	??0kd_node@@QAE@XZ
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [esi+120], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3467 :     kd_subband *subband_handle; // For dynamically allocated subbands

	lea	edi, DWORD PTR [esi+192]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [esi+124], 0
	mov	ebx, 3
	mov	DWORD PTR [esi+128], 0
	mov	DWORD PTR [esi+132], 0
	mov	DWORD PTR [esi+136], 0
	mov	DWORD PTR [esi+140], 0
	mov	DWORD PTR [esi+144], 0
	mov	DWORD PTR [esi+148], 0
	mov	DWORD PTR [esi+152], 0
	mov	DWORD PTR [esi+156], 0
	mov	DWORD PTR [esi+160], 0
	mov	DWORD PTR [esi+164], 0
	npad	6
$LL22@kd_resolut:
	mov	ecx, edi
	call	??0kd_subband@@QAE@XZ
	add	edi, 132				; 00000084H
	sub	ebx, 1
	jne	SHORT $LL22@kd_resolut
	mov	DWORD PTR [esi+588], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3415 :       }

	mov	eax, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [esi+592], ebx
	mov	DWORD PTR [esi+596], ebx
	mov	DWORD PTR [esi+600], ebx
	pop	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3411 :         codestream = NULL; tile_comp = NULL; rescomp = NULL;

	mov	DWORD PTR [esi], ebx
	mov	DWORD PTR [esi+4], ebx
	mov	DWORD PTR [esi+8], ebx

; 3412 :         precinct_refs = NULL; subbands = subband_handle = NULL; num_subbands=0;

	mov	DWORD PTR [esi+180], ebx
	mov	DWORD PTR [esi+188], ebx
	mov	DWORD PTR [esi+184], ebx
	mov	WORD PTR [esi+174], bx

; 3413 :         num_intermediate_nodes = 0; intermediate_nodes = NULL;

	mov	DWORD PTR [esi+176], ebx

; 3414 :         can_flip = true;  node.bibo_gains = NULL;

	mov	DWORD PTR [esi+116], ebx
	mov	BYTE PTR [esi+173], 1
	pop	esi
	pop	ebx

; 3415 :       }

	ret	0
??0kd_resolution@@QAE@XZ ENDP				; kd_resolution::kd_resolution
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kd_subband@@QAE@XZ
_TEXT	SEGMENT
??0kd_subband@@QAE@XZ PROC				; kd_subband::kd_subband, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+8], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+68], 0
	mov	DWORD PTR [ecx+72], 0
	mov	DWORD PTR [ecx+76], 0
	mov	DWORD PTR [ecx+80], 0
	mov	DWORD PTR [ecx+84], 0
	mov	DWORD PTR [ecx+88], 0
	mov	DWORD PTR [ecx+92], 0
	mov	DWORD PTR [ecx+96], 0
	mov	DWORD PTR [ecx+100], 0
	mov	DWORD PTR [ecx+104], 0
	mov	DWORD PTR [ecx+108], 0
	mov	DWORD PTR [ecx+112], 0
	mov	DWORD PTR [ecx+116], 0
	mov	DWORD PTR [ecx+120], 0
	mov	DWORD PTR [ecx+124], 0
	mov	DWORD PTR [ecx+128], 0
	ret	0
??0kd_subband@@QAE@XZ ENDP				; kd_subband::kd_subband
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kd_node@@QAE@XZ
_TEXT	SEGMENT
??0kd_node@@QAE@XZ PROC					; kd_node::kd_node, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+8], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+64], 0
	mov	DWORD PTR [ecx+68], 0
	mov	DWORD PTR [ecx+72], 0
	ret	0
??0kd_node@@QAE@XZ ENDP					; kd_node::kd_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?adjust_cover@kd_node@@QAEXUkdu_dims@@HH@Z
_TEXT	SEGMENT
_node_min$2$ = -4					; size = 4
_child_cover$ = 8					; size = 16
_child_branch_x$ = 24					; size = 4
_child_branch_y$ = 28					; size = 4
?adjust_cover@kd_node@@QAEXUkdu_dims@@HH@Z PROC		; kd_node::adjust_cover, COMDAT
; _this$ = ecx

; 4541 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4542 :   if ((child_cover.size.x < 0) || (child_cover.size.y < 0))

	mov	eax, DWORD PTR _child_cover$[ebp+12]
	test	eax, eax
	js	$LN3@adjust_cov
	mov	edx, DWORD PTR _child_cover$[ebp+8]
	test	edx, edx
	js	$LN3@adjust_cov

; 4544 :   kdu_coords node_min = child_cover.pos;

	push	ebx
	mov	ebx, DWORD PTR _child_cover$[ebp+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	eax, ebx
	push	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4546 :   if ((child_branch_x & ~1) == 0)

	mov	esi, DWORD PTR _child_branch_x$[ebp]
	push	edi
	mov	edi, DWORD PTR _child_cover$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	edx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4544 :   kdu_coords node_min = child_cover.pos;

	mov	DWORD PTR _node_min$2$[ebp], edi

; 4546 :   if ((child_branch_x & ~1) == 0)

	test	esi, -2					; fffffffeH
	jne	SHORT $LN4@adjust_cov

; 4547 :     { // Child was obtained after a horizontal split
; 4548 :       node_min.x += node_min.x + child_branch_x;
; 4549 :       node_lim.x += node_lim.x + child_branch_x - 1;

	lea	eax, DWORD PTR [eax*2-1]
	lea	ebx, DWORD PTR [esi+ebx*2]
	add	eax, esi
$LN4@adjust_cov:

; 4550 :     }
; 4551 :   if ((child_branch_y & ~1) == 0)

	mov	esi, DWORD PTR _child_branch_y$[ebp]
	test	esi, -2					; fffffffeH
	jne	SHORT $LN5@adjust_cov

; 4552 :     { // Child was obtained after a vertical split
; 4553 :       node_min.y += node_min.y + child_branch_y;

	lea	edi, DWORD PTR [esi+edi*2]

; 4554 :       node_lim.y += node_lim.y + child_branch_y - 1;

	lea	edx, DWORD PTR [edx*2-1]
	mov	DWORD PTR _node_min$2$[ebp], edi
	add	edx, esi
$LN5@adjust_cov:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	cmp	DWORD PTR [ecx+56], 0
	jle	SHORT $LN19@adjust_cov
	cmp	DWORD PTR [ecx+52], 0
	jle	SHORT $LN19@adjust_cov
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4564 :       if ((delta = region_cover.pos.x - node_min.x) > 0)

	mov	edi, DWORD PTR [ecx+48]
	mov	esi, edi
	sub	esi, ebx
	test	esi, esi
	jle	SHORT $LN8@adjust_cov

; 4565 :         {
; 4566 :           region_cover.pos.x -= delta;

	sub	edi, esi

; 4567 :           region_cover.size.x += delta;

	add	DWORD PTR [ecx+56], esi
	mov	DWORD PTR [ecx+48], edi
$LN8@adjust_cov:

; 4568 :         }
; 4569 :       if ((delta = node_lim.x - region_cover.pos.x - region_cover.size.x) > 0)

	sub	eax, DWORD PTR [ecx+48]
	mov	esi, DWORD PTR [ecx+56]
	sub	eax, esi
	test	eax, eax
	jle	SHORT $LN9@adjust_cov

; 4570 :         region_cover.size.x += delta;

	add	eax, esi
	mov	DWORD PTR [ecx+56], eax
$LN9@adjust_cov:

; 4571 :       if ((delta = region_cover.pos.y - node_min.y) > 0)

	mov	esi, DWORD PTR [ecx+44]
	mov	eax, esi
	sub	eax, DWORD PTR _node_min$2$[ebp]
	test	eax, eax
	jle	SHORT $LN10@adjust_cov

; 4572 :         {
; 4573 :           region_cover.pos.y -= delta;

	sub	esi, eax

; 4574 :           region_cover.size.y += delta;

	add	DWORD PTR [ecx+52], eax
	mov	DWORD PTR [ecx+44], esi
$LN10@adjust_cov:

; 4575 :         }
; 4576 :       if ((delta = node_lim.y - region_cover.pos.y - region_cover.size.y) > 0)

	sub	edx, DWORD PTR [ecx+44]
	mov	eax, DWORD PTR [ecx+52]
	sub	edx, eax
	test	edx, edx
	jle	SHORT $LN26@adjust_cov

; 4577 :         region_cover.size.y += delta;

	pop	edi
	add	eax, edx
	pop	esi
	mov	DWORD PTR [ecx+52], eax
	pop	ebx

; 4578 :     }
; 4579 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
$LN19@adjust_cov:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	eax, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4558 :       region_cover.pos = node_min;

	mov	DWORD PTR [ecx+44], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	edx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4558 :       region_cover.pos = node_min;

	mov	DWORD PTR [ecx+48], ebx

; 4559 :       region_cover.size = node_lim - node_min;

	mov	DWORD PTR [ecx+52], edx
	mov	DWORD PTR [ecx+56], eax
$LN26@adjust_cov:
	pop	edi
	pop	esi
	pop	ebx
$LN3@adjust_cov:

; 4578 :     }
; 4579 : }

	mov	esp, ebp
	pop	ebp
	ret	24					; 00000018H
?adjust_cover@kd_node@@QAEXUkdu_dims@@HH@Z ENDP		; kd_node::adjust_cover
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kd_leaf_node@@QAE@XZ
_TEXT	SEGMENT
??0kd_leaf_node@@QAE@XZ PROC				; kd_leaf_node::kd_leaf_node, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+8], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+36], 0
	ret	0
??0kd_leaf_node@@QAE@XZ ENDP				; kd_leaf_node::kd_leaf_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Ekd_precinct_ref@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Ekd_precinct_ref@@QAEPAXI@Z PROC			; kd_precinct_ref::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Ekd_precinct_ref@@QAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ebx, DWORD PTR ___flags$[ebp]
	test	bl, 2
	je	SHORT $LN2@vector
	push	OFFSET ??1kd_precinct_ref@@QAE@XZ	; kd_precinct_ref::~kd_precinct_ref
	push	DWORD PTR [esi-4]
	lea	edi, DWORD PTR [esi-4]
	push	8
	push	esi
	call	??_M@YGXPAXIIP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN3@vector
	mov	ecx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [ecx*8+4]
	push	ecx
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN3@vector:
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@vector:

; 3069 :       { if (!((state == 0) || (state & 1))) close(); }

	mov	ecx, DWORD PTR [esi]
	mov	eax, ecx
	or	eax, DWORD PTR [esi+4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	je	SHORT $LN7@vector
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN7@vector
	mov	ecx, esi
	call	?close@kd_precinct_ref@@QAEXXZ		; kd_precinct_ref::close
$LN7@vector:
	test	bl, 1
	je	SHORT $LN4@vector
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@vector:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Ekd_precinct_ref@@QAEPAXI@Z$0:
	call	___std_terminate
	ret	0
__ehhandler$??_Ekd_precinct_ref@@QAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Ekd_precinct_ref@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Ekd_precinct_ref@@QAEPAXI@Z ENDP			; kd_precinct_ref::`vector deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z
_TEXT	SEGMENT
tv271 = -28						; size = 8
tv295 = -24						; size = 4
_tc$1$ = -20						; size = 4
_result$1$ = -16					; size = 4
_tile$1$ = -12						; size = 4
_id$1$ = -8						; size = 4
_id$3$ = -4						; size = 4
_res$ = 8						; size = 4
_pos_idx$ = 12						; size = 8
?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z PROC ; kd_precinct_ref::instantiate_precinct, COMDAT
; _this$ = ecx

; 6477 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 28					; 0000001cH
	push	ebx

; 6478 :   kd_precinct *result =
; 6479 :     res->codestream->precinct_server->get(res->max_blocks_per_precinct,

	mov	ebx, DWORD PTR _res$[ebp]
	push	esi
	push	edi
	mov	edi, ecx
	movzx	eax, BYTE PTR [ebx+174]
	mov	ecx, DWORD PTR [ebx]
	push	eax
	push	DWORD PTR [ebx+168]
	mov	ecx, DWORD PTR [ecx+40]
	call	?get@kd_precinct_server@@QAEPAUkd_precinct@@HH@Z ; kd_precinct_server::get

; 6480 :                                           res->num_subbands);
; 6481 :   result->initialize(res,pos_idx);

	push	DWORD PTR _pos_idx$[ebp+4]
	mov	esi, eax
	push	DWORD PTR _pos_idx$[ebp]
	mov	ecx, esi
	mov	DWORD PTR _result$1$[ebp], esi
	push	ebx
	call	?initialize@kd_precinct@@QAEXPAUkd_resolution@@Ukdu_coords@@@Z ; kd_precinct::initialize

; 6482 :   result->ref = this;

	mov	DWORD PTR [esi+4], edi

; 6483 :   if (state & 1)

	mov	eax, DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [edi]
	mov	DWORD PTR tv271[ebp+4], eax
	mov	eax, ecx
	and	eax, 1
	or	eax, 0
	je	SHORT $LN5@instantiat

; 6484 :     {
; 6485 :       if (state & 2)

	and	ecx, 2
	or	ecx, 0
	je	SHORT $LN6@instantiat

; 6486 :         result->flags |= (KD_PFLAG_ADDRESSABLE | KD_PFLAG_PARSED);

	or	DWORD PTR [esi+8], 264			; 00000108H

; 6487 :       else

	jmp	SHORT $LN7@instantiat
$LN6@instantiat:

; 6488 :         result->flags |= KD_PFLAG_ADDRESSABLE;

	or	DWORD PTR [esi+8], 8
$LN7@instantiat:

; 6489 :           // result->addressable = true;
; 6490 :       result->unique_address = state >> 2;

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+4]
	shrd	eax, ecx, 2
	mov	DWORD PTR [esi+32], eax

; 6491 :       state = _addr_to_kdu_long(result); assert(!(state & 1));

	mov	eax, esi
	sar	ecx, 2
	mov	DWORD PTR [esi+36], ecx
	cdq
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], edx

; 6492 :       if (res->codestream->interchange)

	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax+335], 0
	jne	$LN9@instantiat

; 6493 :         return result;
; 6494 :       assert(result->num_outstanding_blocks > 0);
; 6495 :         // Otherwise, the client is opening a precinct which covers no
; 6496 :         // blocks in the region of interest, which makes no sense.
; 6497 :       result->flags |= KD_PFLAG_DESEQUENCED;

	or	DWORD PTR [esi+8], 4

; 6498 :         // result->desequenced = true;
; 6499 :       result->next_layer_idx = res->tile_comp->tile->num_layers;

	mov	eax, DWORD PTR [ebx+4]
	pop	edi
	mov	eax, DWORD PTR [eax+4]

; 6521 :         return result;
; 6522 :       result->flags |= KD_PFLAG_DESEQUENCED;
; 6523 :         // result->desequenced = true;
; 6524 :       result->next_layer_idx = tile->num_layers;

	mov	eax, DWORD PTR [eax+132]
	mov	DWORD PTR [esi+16], eax

; 6525 :     }
; 6526 :   return result;

	mov	eax, esi
	pop	esi
	pop	ebx

; 6527 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN5@instantiat:

; 6500 :       return result;
; 6501 :     }
; 6502 : 
; 6503 :   // If we get here, we are creating the precinct for the first time.
; 6504 :   assert(state == 0);
; 6505 :   state = _addr_to_kdu_long(result); assert(!(state & 1));

	mov	eax, esi
	cdq
	mov	DWORD PTR [edi], eax
	mov	DWORD PTR [edi+4], edx

; 6506 :   if (res->codestream->cached || res->codestream->interchange)

	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax+338], 0
	jne	SHORT $LN10@instantiat
	cmp	BYTE PTR [eax+335], 0
	je	$LN9@instantiat
$LN10@instantiat:

; 6507 :     { /* Cached source receives a negative seek address equal to -(1+id),
; 6508 :          where `id' is the precinct's unique identifier. */
; 6509 :       kd_tile_comp *tc = res->tile_comp;

	mov	eax, DWORD PTR [ebx+4]

; 6512 :       for (kd_resolution *rp=res-res->res_level; rp != res; rp++)

	mov	edi, ebx
	movzx	ecx, BYTE PTR [ebx+12]
	mov	DWORD PTR _tc$1$[ebp], eax
	imul	ecx, ecx, 604
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _tile$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+148]
	imul	eax, DWORD PTR _pos_idx$[ebp]
	sub	edi, ecx
	add	eax, DWORD PTR _pos_idx$[ebp+4]
	cdq
	mov	DWORD PTR _id$1$[ebp], eax
	mov	DWORD PTR _id$3$[ebp], edx
	cmp	edi, ebx
	je	SHORT $LN3@instantiat

; 6507 :     { /* Cached source receives a negative seek address equal to -(1+id),
; 6508 :          where `id' is the precinct's unique identifier. */
; 6509 :       kd_tile_comp *tc = res->tile_comp;

	lea	ecx, DWORD PTR [edi+144]
	mov	esi, edx
	npad	12
$LL4@instantiat:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [ecx+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6512 :       for (kd_resolution *rp=res-res->res_level; rp != res; rp++)

	lea	ecx, DWORD PTR [ecx+604]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	imul	DWORD PTR [ecx-604]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6513 :         id += rp->precinct_indices.area();

	add	DWORD PTR _id$1$[ebp], eax
	adc	esi, edx
	add	edi, 604				; 0000025cH
	cmp	edi, ebx
	jne	SHORT $LL4@instantiat
	mov	DWORD PTR _id$3$[ebp], esi
	mov	esi, DWORD PTR _result$1$[ebp]
$LN3@instantiat:

; 6514 :       id = id*tile->num_components + tc->cnum;

	mov	eax, DWORD PTR _tile$1$[ebp]
	push	DWORD PTR _id$3$[ebp]
	push	DWORD PTR _id$1$[ebp]
	mov	eax, DWORD PTR [eax+128]
	cdq
	push	edx
	push	eax
	call	__allmul

; 6515 :       id = id*res->codestream->tile_span.x*res->codestream->tile_span.y;

	mov	ebx, DWORD PTR [ebx]
	mov	edi, eax
	mov	eax, DWORD PTR _tc$1$[ebp]
	mov	ecx, edx
	mov	eax, DWORD PTR [eax+12]
	cdq
	add	edi, eax
	mov	eax, DWORD PTR [ebx+168]
	adc	ecx, edx
	cdq
	push	edx
	push	eax
	push	ecx
	push	edi
	call	__allmul
	mov	edi, eax
	mov	ecx, edx
	mov	eax, DWORD PTR [ebx+164]
	cdq
	push	edx
	push	eax
	push	ecx
	push	edi
	call	__allmul
	mov	edi, eax
	mov	ebx, edx

; 6516 :       id += tile->t_num; // id now holds the precinct's unique identifier.

	mov	eax, DWORD PTR _tile$1$[ebp]
	mov	eax, DWORD PTR [eax+4]
	cdq
	add	edi, eax
	adc	ebx, edx

; 6517 :       result->flags |= KD_PFLAG_ADDRESSABLE;

	mov	edx, DWORD PTR [esi+8]

; 6518 :         // result->addressable = true;
; 6519 :       result->unique_address = -(1+id);

	or	ecx, -1
	or	edx, 8
	mov	eax, ecx
	mov	DWORD PTR [esi+8], edx
	sub	eax, edi
	mov	DWORD PTR [esi+32], eax

; 6520 :       if (res->codestream->interchange)

	mov	eax, DWORD PTR _res$[ebp]
	sbb	ecx, ebx
	mov	DWORD PTR [esi+36], ecx
	mov	eax, DWORD PTR [eax]
	cmp	BYTE PTR [eax+335], 0
	jne	SHORT $LN9@instantiat

; 6521 :         return result;
; 6522 :       result->flags |= KD_PFLAG_DESEQUENCED;
; 6523 :         // result->desequenced = true;
; 6524 :       result->next_layer_idx = tile->num_layers;

	mov	eax, DWORD PTR _tile$1$[ebp]
	or	edx, 4
	mov	DWORD PTR [esi+8], edx
	mov	eax, DWORD PTR [eax+132]
	mov	DWORD PTR [esi+16], eax
$LN9@instantiat:

; 6525 :     }
; 6526 :   return result;

	pop	edi
	mov	eax, esi
	pop	esi
	pop	ebx

; 6527 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z ENDP ; kd_precinct_ref::instantiate_precinct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?set_address@kd_precinct_ref@@QAE_NPAUkd_resolution@@Ukdu_coords@@_J@Z
_TEXT	SEGMENT
_codestream$1$ = 8					; size = 4
_res$ = 8						; size = 4
_pos_idx$ = 12						; size = 8
_seek_address$ = 20					; size = 8
?set_address@kd_precinct_ref@@QAE_NPAUkd_resolution@@Ukdu_coords@@_J@Z PROC ; kd_precinct_ref::set_address, COMDAT
; _this$ = ecx

; 6561 : { 

	push	ebp
	mov	ebp, esp
	push	ecx

; 6562 :   assert(seek_address > 0);
; 6563 :   kd_tile_comp *comp = res->tile_comp;

	mov	edx, DWORD PTR _res$[ebp]
	push	ebx
	push	esi
	push	edi
	mov	ebx, DWORD PTR [edx+4]
	mov	esi, ecx

; 6564 :   kd_tile *tile = comp->tile;

	mov	edi, DWORD PTR [ebx+4]

; 6565 :   kd_codestream *codestream = tile->codestream;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _codestream$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }

	mov	eax, DWORD PTR [esi]
	and	eax, 1
	or	eax, 0
	jne	SHORT $LN2@set_addres
	mov	esi, DWORD PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6567 :   if (precinct != NULL)

	test	esi, esi
	je	SHORT $LN23@set_addres

; 6568 :     {
; 6569 :       assert(precinct->next_layer_idx == 0);
; 6570 :       precinct->next_layer_idx = tile->num_layers;

	mov	eax, DWORD PTR [edi+132]

; 6571 :       precinct->flags |= KD_PFLAG_ADDRESSABLE;

	or	DWORD PTR [esi+8], 8
	mov	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+16], eax

; 6572 :         // precinct->addressable = true;
; 6573 :       precinct->unique_address = seek_address;

	mov	eax, DWORD PTR _seek_address$[ebp]
	mov	DWORD PTR [esi+32], eax
	mov	eax, DWORD PTR _seek_address$[ebp+4]
	mov	DWORD PTR [esi+36], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4176 :         if (flags & KD_PFLAG_DESEQUENCED)

	test	cl, 4
	jne	SHORT $LN18@set_addres

; 4177 :           return;
; 4178 :         flags |= KD_PFLAG_DESEQUENCED;

	or	ecx, 4

; 4179 :           // desequenced = true;
; 4180 :         if (next_layer_idx == 0)

	cmp	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+8], ecx
	jne	SHORT $LN17@set_addres

; 4181 :           {
; 4182 :             flags |= KD_PFLAG_ADDRESSABLE;

	or	ecx, 8

; 4183 :               // addressable = true;
; 4184 :             unique_address = 0;

	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+8], ecx
	mov	DWORD PTR [esi+36], 0
$LN17@set_addres:

; 4185 :           }
; 4186 :         if (num_outstanding_blocks == 0)

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN18@set_addres

; 4187 :           release();

	mov	ecx, esi
	call	?release@kd_precinct@@QAEXXZ		; kd_precinct::release
$LN18@set_addres:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6575 :       if (precinct->flags & KD_PFLAG_RELEVANT)

	test	BYTE PTR [esi+8], 64			; 00000040H
	je	$LN7@set_addres

; 6576 :         tile->sequenced_relevant_packets += tile->max_relevant_layers;
; 6577 :     }
; 6578 :   else

	jmp	SHORT $LN22@set_addres
$LN23@set_addres:
	mov	esi, ecx
$LN2@set_addres:

; 6579 :     {
; 6580 :       state = (seek_address<<2) + 1;

	mov	eax, DWORD PTR _seek_address$[ebp]
	mov	ecx, DWORD PTR _seek_address$[ebp+4]
	shld	ecx, eax, 2
	shl	eax, 2
	add	eax, 1
	mov	DWORD PTR [esi], eax

; 6583 :       if ((!codestream->persistent) &&

	mov	eax, DWORD PTR _codestream$1$[ebp]
	adc	ecx, 0
	mov	DWORD PTR [esi+4], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	mov	esi, DWORD PTR _pos_idx$[ebp+4]
	mov	ecx, DWORD PTR _pos_idx$[ebp]
	add	esi, DWORD PTR [edx+140]
	add	ecx, DWORD PTR [edx+136]
	mov	DWORD PTR _pos_idx$[ebp+4], esi
	mov	DWORD PTR _pos_idx$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6583 :       if ((!codestream->persistent) &&

	cmp	BYTE PTR [eax+337], 0
	jne	SHORT $LN22@set_addres
	movzx	eax, BYTE PTR [edx+12]
	cmp	eax, DWORD PTR [ebx+60]
	jg	SHORT $LN7@set_addres
	cmp	BYTE PTR [ebx+152], 0
	je	SHORT $LN7@set_addres
	mov	ebx, DWORD PTR [edx+156]
	cmp	esi, ebx
	jl	SHORT $LN7@set_addres
	cmp	ecx, DWORD PTR [edx+152]
	jl	SHORT $LN7@set_addres
	mov	eax, DWORD PTR [edx+164]
	add	eax, ebx
	cmp	esi, eax
	jge	SHORT $LN7@set_addres
	mov	eax, DWORD PTR [edx+160]
	add	eax, DWORD PTR [edx+152]
	cmp	ecx, eax
	jge	SHORT $LN7@set_addres
$LN22@set_addres:

; 6584 :           ((res->res_level > comp->apparent_dwt_levels) || (!comp->enabled) ||
; 6585 :            (pos_idx.x < res->region_indices.pos.x) ||
; 6586 :            (pos_idx.y < res->region_indices.pos.y) ||
; 6587 :            (pos_idx.x >= (res->region_indices.pos.x +
; 6588 :                           res->region_indices.size.x)) ||
; 6589 :            (pos_idx.y >= (res->region_indices.pos.y +
; 6590 :                           res->region_indices.size.y))))
; 6591 :         is_relevant = false;
; 6592 :       if (is_relevant)
; 6593 :         tile->sequenced_relevant_packets += tile->max_relevant_layers;

	mov	eax, DWORD PTR [edi+140]
	add	DWORD PTR [edi+248], eax
$LN7@set_addres:

; 6594 :     }
; 6595 :   if (tile->sequenced_relevant_packets == tile->max_relevant_packets)

	mov	eax, DWORD PTR [edi+248]
	cdq
	cmp	eax, DWORD PTR [edi+152]
	jne	SHORT $LN9@set_addres
	cmp	edx, DWORD PTR [edi+156]
	jne	SHORT $LN9@set_addres

; 6596 :     {
; 6597 :       if (tile->finished_reading())

	mov	ecx, edi
	call	?finished_reading@kd_tile@@QAE_NXZ	; kd_tile::finished_reading
	test	al, al
	je	SHORT $LN9@set_addres

; 6598 :         return false; // tile was destroyed inside `finished_reading'

	pop	edi
	pop	esi
	xor	al, al
	pop	ebx

; 6601 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN9@set_addres:
	pop	edi
	pop	esi

; 6599 :     }
; 6600 :   return true;

	mov	al, 1
	pop	ebx

; 6601 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?set_address@kd_precinct_ref@@QAE_NPAUkd_resolution@@Ukdu_coords@@_J@Z ENDP ; kd_precinct_ref::set_address
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?is_desequenced@kd_precinct_ref@@QAE_NXZ
_TEXT	SEGMENT
?is_desequenced@kd_precinct_ref@@QAE_NXZ PROC		; kd_precinct_ref::is_desequenced, COMDAT
; _this$ = ecx

; 4661 :   register kdu_long state_val = state;

	mov	edx, DWORD PTR [ecx]

; 4662 :   return ((state_val != 0) &&

	mov	eax, edx
	or	eax, DWORD PTR [ecx+4]
	je	SHORT $LN4@is_deseque
	mov	eax, edx
	and	eax, 1
	or	eax, 0
	jne	SHORT $LN3@is_deseque
	test	BYTE PTR [edx+8], 4
	je	SHORT $LN4@is_deseque
$LN3@is_deseque:
	mov	al, 1

; 4663 :           ((state_val & 1) ||
; 4664 :            (((kd_precinct *) _kdu_long_to_addr(state_val))->flags &
; 4665 :             KD_PFLAG_DESEQUENCED)));
; 4666 : }

	ret	0
$LN4@is_deseque:

; 4662 :   return ((state_val != 0) &&

	xor	al, al

; 4663 :           ((state_val & 1) ||
; 4664 :            (((kd_precinct *) _kdu_long_to_addr(state_val))->flags &
; 4665 :             KD_PFLAG_DESEQUENCED)));
; 4666 : }

	ret	0
?is_desequenced@kd_precinct_ref@@QAE_NXZ ENDP		; kd_precinct_ref::is_desequenced
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?clear@kd_precinct_ref@@QAEXXZ
_TEXT	SEGMENT
?clear@kd_precinct_ref@@QAEXXZ PROC			; kd_precinct_ref::clear, COMDAT
; _this$ = ecx

; 4670 : {

	push	edi
	mov	edi, ecx

; 4671 :   if (state && !(state & 1))

	mov	edx, DWORD PTR [edi]
	mov	eax, edx
	or	eax, DWORD PTR [edi+4]
	je	SHORT $LN8@clear
	and	edx, 1
	or	edx, 0
	jne	SHORT $LN8@clear

; 4672 :     {
; 4673 :       kd_precinct *precinct = (kd_precinct *) _kdu_long_to_addr(state);

	push	ebx
	push	esi
	mov	esi, DWORD PTR [edi]

; 4674 :       precinct->ref = NULL; // Satisfy the test in `kd_precinct::closing'
; 4675 :       precinct->closing();

	mov	ecx, esi
	mov	DWORD PTR [esi+4], edx
	call	?closing@kd_precinct@@QAEXXZ		; kd_precinct::closing

; 283  :       }
; 284  :     kdu_long augment_cache_threshold(kdu_long increment)
; 285  :       { // Use to adjust the cache threshold either up or down
; 286  :         return (cache_threshold_bytes += increment);
; 287  :       }
; 288  :     bool cache_threshold_exceeded()
; 289  :       { return (cache_threshold_bytes <
; 290  :                 (structure_bytes + num_allocated_pages *
; 291  :                  (KD_CODE_BUFFER_LEN*KDU_CODE_BUFFERS_PER_PAGE))); }
; 292  :       /* This function is called from the `kd_precinct_server::get' function
; 293  :          before it serves up a new precinct container, whenever one or more
; 294  :          precincts are currently on its inactive list.  The function returns
; 295  :          true if the cache threshold has been exceeded, meaning that one or
; 296  :          more inactive precincts should be closed (unloaded from
; 297  :          memory, along with all their associated code buffers).  For more
; 298  :          on this, consult the comments appearing below the declaration of
; 299  :          the `kd_precinct_server' class.
; 300  :             The function is also called whenever a new tile-part is started,
; 301  :          to determine whether there are unloadable tiles which should be
; 302  :          unloaded to bring memory consumption below the cache threshold. */
; 303  :     void attach_thread_buf_server(kd_thread_buf_server *tbs);
; 304  :     void detach_thread_buf_server(kd_thread_buf_server *tbs);
; 305  :       /* The above two functions may be called only with the
; 306  :          `KD_THREADLOCK_GENERAL' mutex already locked by the caller.  They
; 307  :          are used only in multi-threading applications. */
; 308  :   private: // Definitions
; 309  :       struct kd_code_alloc {
; 310  :           kd_code_alloc *next;
; 311  :           kdu_byte block[1]; // Actual structure is allocated to be a much
; 312  :                              // larger memory block, from which aligned
; 313  :                              // virtual cache pages are extracted.
; 314  :         };
; 315  :   private: // Helper functions
; 316  :     void alloc_pages();
; 317  :       /* This function is called when there is insufficient remaining
; 318  :          storage on the free list. */
; 319  :   private: // Data
; 320  :     kd_code_alloc *alloc; // Linked list of allocated memory blocks
; 321  :     kd_code_buffer *free_head;
; 322  :     kdu_long total_pages;
; 323  :     kdu_long num_allocated_pages; // Number of fully allocated pages
; 324  :     kdu_long peak_allocated_pages;
; 325  :     kdu_long structure_bytes; // Bytes in tile/comp/subband/precinct structures
; 326  :     kdu_long peak_structure_bytes;
; 327  :     kdu_long cache_threshold_bytes;
; 328  :     int num_users; // Number of users currently sharing the object.
; 329  :     kd_thread_buf_server *attached_thread_buf_servers;
; 330  :   };
; 331  : 
; 332  : /*****************************************************************************/
; 333  : /*                           kd_thread_buf_server                            */
; 334  : /*****************************************************************************/
; 335  : 
; 336  : #define KD_THREAD_PEAK_STORE_FAC 4
; 337  : 
; 338  : class kd_thread_buf_server {
; 339  :   public: // Member functions
; 340  :     void init(kd_thread_env *env) { this->env=env; reset(); }
; 341  :     void set_codestream_buf_server(kd_buf_server *buf_server);
; 342  :       /* This function is used to nominate a particular codestream's
; 343  :          `kd_buf_server' object as the ultimate source of all future
; 344  :          buffers served by the present object.  If we are already
; 345  :          attached to a different codestream `buf_server', we must
; 346  :          first detach, releasing any buffers in our local store to
; 347  :          the codestream `buf_server' from which they came.  These
; 348  :          operations are all guarded by the KD_THREADLOCK_GENERAL mutex,
; 349  :          but the present function is always invoked from a context in
; 350  :          which the mutex is not locked.  If `buf_server' is NULL, the
; 351  :          function simply detaches us from any codestream `buf_server'
; 352  :          to which we might presently be attached. */
; 353  :     bool is_attached() { return (ultimate_buf_server != NULL); }
; 354  :       /* Returns true if the last call to `set_codestream_buf_server'
; 355  :          specified a non-NULL codestream `buf_server'. */
; 356  :     void detach_while_holding_general_lock()
; 357  :       { /* Called by `discard_all', so we don't have to unlock and then
; 358  :            relock the `KD_THREADLOCK_GENERAL' mutex. */
; 359  :         if (ultimate_buf_server != NULL)
; 360  :           ultimate_buf_server->detach_thread_buf_server(this);
; 361  :       }
; 362  :     kd_code_buffer *get()
; 363  :       { /* Behaves like `kd_buf_server::get', but allocates initially
; 364  :            from the thread's local buffer store, getting extra data from the
; 365  :            codestream specified in the most recent call to
; 366  :            `set_codestream_buf_server' where required.  This function must
; 367  :            not be called while holding any lock, since it may need to
; 368  :            temporarily instantiate a lock to get extra storage from the
; 369  :            underlying codestream. */
; 370  :         if (head == NULL) augment_local_store(false);
; 371  :         kd_code_buffer *result = head;
; 372  :         if ((head = result->next) == NULL)
; 373  :           tail = NULL;
; 374  :         result->next = NULL;
; 375  :         num_available_buffers--;
; 376  :         return result;
; 377  :       }
; 378  :     void adjust_peak_buffers();
; 379  :       /* This function is called from within `kd_thread_env::flush' to
; 380  :          adjust the value of `peak_buffers', which records the maximum
; 381  :          number of buffers we would like to make available locally
; 382  :          in this thread buffer server.  The calculation uses the fact that
; 383  :          `ref_available_buffers'-`num_available_buffers' equals the number
; 384  :          of buffers which have been obtained via `get', since the last call
; 385  :          to this function.  This quantity is multiplied by a factor
; 386  :          `KD_THREAD_PEAK_STORE_FAC' to obtain a reasonable value for
; 387  :          `peak_buffer', the value of which is adjusted only ever upwards. */
; 388  :     void augment_local_store(bool general_lock_held);
; 389  :       /* This function is used to allocate new buffers from the underlying
; 390  :          codestream, specified in the last call to `set_codestream'.
; 391  :          If `adjust_peak_buffers' has never been called, the
; 392  :          function allocates `KD_THREAD_PEAK_STORE_FAC' times the number of
; 393  :          buffers which have already been served via `get'.  Otherwise, it
; 394  :          allocates exactly `peak_buffers' new buffers.
; 395  :             If `general_lock_held' is false, the `KD_THREADLOCK_GENERAL'
; 396  :          lock is not currently held and must be acquired prior to actually
; 397  :          allocating any new buffers (and released again before returning,
; 398  :          of course).  The function is called in this way only when a call
; 399  :          to `get' finds that the local store of buffers has been
; 400  :          completely exhausted.
; 401  :             The function is called with `general_lock_held' equal to true
; 402  :          from within `kd_thread_env::flush' to take advantage of the fact
; 403  :          that the general lock is already held for other reasons -- i.e.,
; 404  :          to piggy-back the activity of refilling the local buffer store
; 405  :          onto other activities which required the lock. */
; 406  :   private: // Helper functions
; 407  :     friend class kd_buf_server;
; 408  :     void reset()
; 409  :       { // Called by `kd_buf_server::detach_thread_buf_server' after removing
; 410  :         // us from its attached thread buffer list.  This function is also
; 411  :         // used to do most of the work of our own constructor.
; 412  :         ultimate_buf_server = NULL;
; 413  :         next_attached = prev_attached = NULL;
; 414  :         ref_available_buffers = 0;
; 415  :         peak_buffers = 0;
; 416  :         num_available_buffers = 0;
; 417  :         head = tail = NULL;
; 418  :       }
; 419  :   private: // Data
; 420  :     kd_thread_env *env;
; 421  :     int peak_buffers; // See the `adjust_peak_buffers' function.
; 422  :     int num_available_buffers; // Number of buffers on the `head' list.
; 423  :     int ref_available_buffers; // Adjusted so that `ref_available_buffers' -
; 424  :          // `num_available_buffers' is always equal to the number of buffers
; 425  :          // allocated via `get' since the last call to `adjust_peak_buffers'.
; 426  :     kd_code_buffer *head;
; 427  :     kd_code_buffer *tail;
; 428  :     kd_buf_server *ultimate_buf_server; // All buffers are allocated from here
; 429  :     kd_thread_buf_server *next_attached; // Used to build a doubly linked list
; 430  :     kd_thread_buf_server *prev_attached; // of objects which are all attached
; 431  :                      // to the same `ultimate_buf_server'.
; 432  :   };
; 433  : 
; 434  : /*****************************************************************************/
; 435  : /*                             kd_compressed_output                          */
; 436  : /*****************************************************************************/
; 437  : 
; 438  : class kd_compressed_output : public kdu_output {
; 439  :   public: // Member functions
; 440  :     kd_compressed_output(kdu_compressed_target *target)
; 441  :       { this->target=target; flushed_bytes = 0; }
; 442  :     virtual ~kd_compressed_output()
; 443  :       { flush_buf(); }
; 444  :     kdu_compressed_target *access_tgt()
; 445  :       { /* You may call this function to access the underlying `target'
; 446  :            object, but you should never manipulate that object if you
; 447  :            have written anything to the present object, without re-accessing
; 448  :            it. */
; 449  :            flush_buf();  return target;
; 450  :       }
; 451  :     kdu_long get_bytes_written()
; 452  :       { return (flushed_bytes + (next_buf-buffer)); }
; 453  :     void flush()
; 454  :       { flush_buf(); }
; 455  :   protected: // Virtual functions which implement required services.
; 456  :     virtual void flush_buf()
; 457  :       {
; 458  :         if (next_buf > buffer)
; 459  :           target->write(buffer,(int)(next_buf-buffer));
; 460  :         flushed_bytes += next_buf - buffer;
; 461  :         next_buf = buffer;
; 462  :       }
; 463  :   private: // Data
; 464  :     kdu_compressed_target *target;
; 465  :     kdu_long flushed_bytes;
; 466  :   };
; 467  : 
; 468  : /*****************************************************************************/
; 469  : /*                                kd_input                                   */
; 470  : /*****************************************************************************/
; 471  : 
; 472  : #define KD_IBUF_SIZE 512
; 473  : #define KD_IBUF_PUTBACK 6 // Maximum number of bytes you can put back.
; 474  : 
; 475  : class kd_input {
; 476  :   /* This abstract base class must be derived to construct meaningful
; 477  :      input devices.  Currently, we have two derived classes in mind: one
; 478  :      for reading from the code-stream and one for recovering packet
; 479  :      headers from PPM or PPT markers.  Since there may be many low level
; 480  :      byte-oriented transactions, we emphasize efficiency for such
; 481  :      transactions. */
; 482  :   public: // Member functions
; 483  :     kd_input()
; 484  :       { first_unread = first_unwritten = buffer+KD_IBUF_PUTBACK;
; 485  :         exhausted = fully_buffered = throw_markers = false; }
; 486  :     virtual ~kd_input() { return; }
; 487  :     bool is_fully_buffered() { return fully_buffered; }
; 488  :     void enable_marker_throwing(bool reject_all=false)
; 489  :       { /* If `reject_all' is false, subsequent reads will throw an exception
; 490  :            if a bona fide SOP or SOT marker is found. In this case, the
; 491  :            function will check to make sure that the length field is correct,
; 492  :            putting the length field and marker code bytes back to the source
; 493  :            before throwing the exception, so that the catch statement can read
; 494  :            them again.
; 495  :               If `reject_all' is true, subsequent reads will throw an
; 496  :            exception if any marker code in the range FF90 to FFFF is found.
; 497  :            Again, the marker code itself is put back onto the stream before
; 498  :            throwing the exception.
; 499  :               Marker throwing is disabled before throwing an exception for
; 500  :            either of the above reasons.
; 501  :               Note that code-stream reading may be slowed down
; 502  :            when this marker throwing is enabled.  For this reason, the
; 503  :            capability is best used only when error resilience or error
; 504  :            detection capabilities are required. */
; 505  :         this->reject_all = reject_all; throw_markers = true; have_FF = false;
; 506  :       }
; 507  :     bool disable_marker_throwing()
; 508  :       { /* Disable marker exception throwing.  Returns true unless the
; 509  :            last byte which was read was an FF, in which case the function
; 510  :            returns false.  This allows the caller to catch markers which
; 511  :            were partially read.  Any code-stream segment which is not
; 512  :            permitted to contain a marker code in the range FF90 through FFFF
; 513  :            is also not permitted to terminate with an FF. */
; 514  :         if (!throw_markers) return true;
; 515  :         throw_markers = false; // Must not touch `reject_all' here.
; 516  :         if (exhausted) have_FF = false;
; 517  :         return !have_FF;
; 518  :       }
; 519  :     void terminate_prematurely()
; 520  :       { /* This function may be called in non-resilient mode if an EOC marker
; 521  :            is encountered before the stream physically ends. */
; 522  :         exhausted = true;
; 523  :       }
; 524  :     bool failed()
; 525  :       { /* Returns true if any of the input functions, `get', `read' or
; 526  :            `ignore' failed to completely fulfill its objective due to
; 527  :            exhaustion of the relevant source. */
; 528  :         return exhausted;
; 529  :       }
; 530  :     bool get(kdu_byte &byte) // throws (kdu_uint16 code): unexpected marker
; 531  :       { /* Access a single byte, returning false if and only if the source is
; 532  :            exhausted, in which case future calls to `failed' return true. */
; 533  :         if (exhausted || ((first_unread==first_unwritten) && !load_buf()))
; 534  :           return false; // If `load_buf' fails it sets `exhausted' for us.
; 535  :         byte = *(first_unread++);
; 536  :         if (throw_markers)
; 537  :           {
; 538  :             if (have_FF && (byte > 0x8F))
; 539  :               process_unexpected_marker(byte);
; 540  :             have_FF = (byte==0xFF);
; 541  :           }
; 542  :         return true;
; 543  :       }
; 544  :     void putback(kdu_byte byte)
; 545  :       { /* You may put back more than 1 byte, but you may not call this
; 546  :            function if a previous read has ever failed.  It is also illegal
; 547  :            to call this function while marker throwing is enabled. */
; 548  :         assert(!exhausted);
; 549  :         assert(!throw_markers);
; 550  :         first_unread--;
; 551  :         if (!fully_buffered)
; 552  :           {
; 553  :             assert(first_unread >= buffer);
; 554  :             *first_unread = byte;
; 555  :           }
; 556  :       }
; 557  :     void putback(kdu_uint16 code)
; 558  :       { /* This function is designed to improve the readability of code
; 559  :            which puts marker codes back to the input object from which they
; 560  :            were read. */
; 561  :         assert(!exhausted);
; 562  :         assert(!throw_markers);
; 563  :         first_unread-=2;
; 564  :         if (!fully_buffered)
; 565  :           {
; 566  :             assert(first_unread >= buffer);
; 567  :             first_unread[0] = (kdu_byte)(code>>8);
; 568  :             first_unread[1] = (kdu_byte) code;
; 569  :           }
; 570  :       }
; 571  :     int pseudo_read(kdu_byte * &addr, int count)
; 572  :       { /* This function should be called only for `fully_buffered' sources.
; 573  :            It behaves like `read', except that it does not actually read
; 574  :            any bytes.  Instead, it puts the address of the block of data
; 575  :            that would have been read into the variable referenced by the
; 576  :            `addr' argument. */
; 577  :         assert(fully_buffered);
; 578  :         addr = first_unread;
; 579  :         if (throw_markers)
; 580  :           return read(addr,count); // Slower path, looks for markers
; 581  :         first_unread += count;
; 582  :         if (first_unread > first_unwritten)
; 583  :           {
; 584  :             count -= (int)(first_unread - first_unwritten);
; 585  :             first_unread = first_unwritten; exhausted = true;
; 586  :           }
; 587  :         return count;
; 588  :       }
; 589  :     int read(kdu_byte *buf, int count);
; 590  :       /* More efficient than `get' when the number of bytes to be read is
; 591  :          more than 2 or 3.  Returns the number of bytes actually read.  If
; 592  :          less than `count', future calls to `failed' will return true.  Note
; 593  :          that this function is less efficient if marker throwing is enabled. */
; 594  :     int read(kd_code_buffer * &cbuf, kdu_byte &buf_pos,
; 595  :              kd_buf_server *buf_server, int length);
; 596  :       /* Same as the above function, except that the requested bytes are
; 597  :          written to a linked list of `kd_code_buffer' buffers, headed by
; 598  :          `cbuf', where the `buf_pos' indicates the next free byte in the
; 599  :          `cbuf' buffer.  The function automatically grows the linked list
; 600  :          of buffers, as required, using `buf_server->get()'.  Upon return,
; 601  :          the `cbuf' and `buf_pos' variables are advanced to refer to the
; 602  :          most recently written `kd_code_buffer' object and the already
; 603  :          written prefix of that object, respectively.  The function
; 604  :          returns the actual number of bytes transferred in this way, which
; 605  :          is equal to `length' unless the ultimate source of data ran dry. */
; 606  :     virtual kdu_long ignore(kdu_long count);
; 607  :       /* Skips over the indicated number of bytes, returning the number of
; 608  :          bytes actually skipped.  If less than `count', future calls to
; 609  :          `failed' will return true.  The function may be overridden by
; 610  :          derived classes which support seeking. */
; 611  :   protected: // Data and functions used for buffer management.
; 612  :     virtual bool load_buf() = 0;
; 613  :       /* Returns false and sets `exhausted' to true if the source is unable
; 614  :          to provide any more data.  Otherwise, augments the internal buffer
; 615  :          and returns true.  Buffer manipulation must conform to the following
; 616  :          conventions.  The `first_unread' pointer should be set to
; 617  :          `buffer'+KD_IBUF_PUTBACK and then bytes should be loaded into the
; 618  :          remaining KD_IBUF_SIZE bytes of the `buffer' array. The
; 619  :          `first_unwritten' pointer should then be set to point just beyond
; 620  :          the last byte actually written into the buffer.  The only exception
; 621  :          to the above conventions is for fully buffered sources, in which
; 622  :          the entire data source lies in a contiguous external memory buffer.
; 623  :          In this case, the internal `buffer' is not used; the first call to
; 624  :          `load_buf' sets `first_unread' to point to the start of the external
; 625  :          memory buffer and `first_unwritten' to point just beyond the external
; 626  :          memory buffer.  In this case, the `fully_buffered' flag should be
; 627  :          set to true, which signals to the `putback' functions that it is
; 628  :          sufficient for them to adjust the `first_unread' pointer, without
; 629  :          actually writing anything. */
; 630  :     kdu_byte buffer[KD_IBUF_SIZE+KD_IBUF_PUTBACK];
; 631  :     kdu_byte *first_unread; // Points to next byte to retrieve from buffer.
; 632  :     kdu_byte *first_unwritten; // Points beyond last available byte in buffer
; 633  :     bool fully_buffered;
; 634  :     bool exhausted;
; 635  :     bool throw_markers; // If true, must look for unexpected markers.
; 636  :   private: // Functions
; 637  :     void process_unexpected_marker(kdu_byte last_byte);
; 638  :       /* This function is called when marker throwing is enabled and a
; 639  :          marker code in the range FF90 through FFFF has been found.  The
; 640  :          least significant byte of the marker code is supplied as the
; 641  :          `last_byte' argument.  The function determines whether to throw
; 642  :          the exception or not.  If not, reading continues unaffected. */
; 643  :   private: // Data
; 644  :     bool have_FF; // Valid only with `throw_markers'. Means last byte was FF.
; 645  :     bool reject_all; // If `false' marker throwing is only for SOP's and SOT's
; 646  :   };
; 647  :   
; 648  : /*****************************************************************************/
; 649  : /*                             kd_compressed_input                           */
; 650  : /*****************************************************************************/
; 651  : 
; 652  : class kd_compressed_input : public kd_input {
; 653  :   public: // Member functions
; 654  :     kd_compressed_input(kdu_compressed_source *source);
; 655  :     int get_capabilities()
; 656  :       { return source->get_capabilities(); }
; 657  :     bool set_tileheader_scope(int tnum, int num_tiles);
; 658  :       /* Generates an error through `kdu_error' if the embedded source does
; 659  :          not support the `KDU_SOURCE_CAP_CACHED' capability.  This function
; 660  :          simply calls the source's own `set_tileheader_scope' function and
; 661  :          clears the internal state variables (especially, the `exhausted'
; 662  :          member) so that subsequent reads will recover bytes from the indicated
; 663  :          tile's header.  For more information, refer to the comments appearing
; 664  :          with `kdu_compressed_source::set_tileheader_scope'. */
; 665  :     kdu_long get_offset()
; 666  :       { /* Returns the address of the next byte which will be returned by the
; 667  :            base object's `get' function.  If seeking is enabled, the source
; 668  :            may be repositioned to this point by supplying this address as the
; 669  :            `unique_address' argument to `seek'.  Even if seeking is not
; 670  :            enabled, `get_offset' will return the correct address and this may
; 671  :            be used to determine appropriate arguments for the `ignore' member
; 672  :            function declared below.  May not be called if the source is in
; 673  :            anything other than code-stream scope. */
; 674  :         assert(!special_scope);
; 675  :         return cur_offset + last_loaded_bytes - (first_unwritten-first_unread);
; 676  :       }
; 677  :     void seek(kdu_long unique_address);
; 678  :       /* If `unique_address' is non-negative, it is treated as a code-stream
; 679  :          offset and the function seeks to a point `unique_address' bytes past
; 680  :          the beginning of the code-stream (SOC marker), using the embedded
; 681  :          `kdu_compressed_source' object's `seek' function.  In this case,
; 682  :          a terminal error is generated if the source does not
; 683  :          offer the KDU_SOURCE_CAP_SEEKABLE capability.
; 684  :             If `unique_address' is negative, the function treats
; 685  :          -(1+`unique_address') as the unique identifier associated with a
; 686  :          cached precinct, supplying this identifier to the embedded
; 687  :          `kdu_compressed_source' object's `set_precinct_scope' function.  In
; 688  :          this case, a terminal error is generated if the source does not
; 689  :          offer the KDU_SOURCE_CAP_CACHEABLE capability.
; 690  :             In either case, the function may clear or set the "exhausted"
; 691  :          state, so that the base object's `failed' member function may return
; 692  :          false, having previously returned true, or vice-versa. */
; 693  :     kdu_long ignore(kdu_long count); // Overrides `kd_input::ignore'.
; 694  :     void set_max_bytes(kdu_long limit);
; 695  :       /* No effect except when reading in code-stream scope. */
; 696  :     kdu_long get_bytes_read();
; 697  :       /* Returns the smallest initial prefix of the source stream which
; 698  :          contains all of the bytes consumed from `kd_input'.  Note that more
; 699  :          bytes may have been read from the compressed data source and
; 700  :          buffered internally, without having been actually used.
; 701  :             For cached sources (those advertising the KDU_SOURCE_CAP_CACHED
; 702  :          capability), the function's return value will be 0, unless we
; 703  :          are still reading the main header. */
; 704  :     kdu_long get_suspended_bytes();
; 705  :       /* Returns the total number of bytes which have been read in the
; 706  :          suspended state.  The returned value may be subtracted from
; 707  :          the value returned by `get_bytes_read' to determine the total
; 708  :          number of bytes which have been read in a non-suspended state.
; 709  :          Byte limits apply only to non-suspended reads. */
; 710  :     void set_suspend(bool state)
; 711  :       {
; 712  :         if (special_scope) return;
; 713  :         if ((suspend_ptr == NULL) && state)
; 714  :           { // Enter suspended mode
; 715  :             suspend_ptr = first_unread;
; 716  :             if (alt_first_unwritten != NULL)
; 717  :               {
; 718  :                 assert(alt_first_unwritten > first_unwritten);
; 719  :                 last_loaded_bytes += alt_first_unwritten - first_unwritten;
; 720  :                 first_unwritten = alt_first_unwritten;
; 721  :                 alt_first_unwritten = NULL;
; 722  :               }
; 723  :           }
; 724  :         else if ((suspend_ptr != NULL) && !state)
; 725  :           { // Leave suspended mode
; 726  :             suspended_bytes += first_unread-suspend_ptr;  suspend_ptr = NULL;
; 727  :             kdu_long limit = suspended_bytes + max_bytes_allowed - cur_offset;
; 728  :             if (limit < last_loaded_bytes)
; 729  :               { // We have already loaded the buffer with too many bytes
; 730  :                 alt_first_unwritten = first_unwritten;
; 731  :                 first_unwritten -= (last_loaded_bytes - limit);
; 732  :                 last_loaded_bytes = limit;
; 733  :                 if (first_unwritten < first_unread)
; 734  :                   { // We have already read past the end.
; 735  :                     exhausted = true;
; 736  :                     suspended_bytes -= (first_unread-first_unwritten);
; 737  :                     first_unwritten = first_unread;
; 738  :                     alt_first_unwritten = NULL;
; 739  :                   }
; 740  :               }
; 741  :           }
; 742  :       }
; 743  :   protected: // Virtual functions which implement required services.
; 744  :     virtual bool load_buf();
; 745  :   private: // Data
; 746  :     kdu_compressed_source *source;
; 747  :     kdu_long cur_offset; // Offset from start of code-stream
; 748  :     kdu_long max_bytes_allowed; // Source may have fewer bytes than this
; 749  :     kdu_long max_address_read; // Address of last byte read from base object.
; 750  :     kdu_long suspended_bytes; // Bytes read while in suspended mode.
; 751  :     kdu_long last_loaded_bytes; // Num bytes added by last call to `load_buf'
; 752  :     kdu_byte *suspend_ptr; // Points into the buffer
; 753  :     kdu_byte *alt_first_unwritten; // See below
; 754  :     bool special_scope; // True for anything other than code-stream scope.
; 755  :   };
; 756  :   /* Notes:
; 757  :         The `cur_offset' member holds the offset from the start of the
; 758  :      code-stream to the first nominal byte in the input buffer; i.e., the
; 759  :      byte at kd_input::buffer + KD_IBUF_PUTBACK.  The actual number of bytes
; 760  :      which have been read from `source' is larger by the amount
; 761  :      `kd_input::first_unwritten' - (`kd_input::buffer'+KD_IBUF_PUTBACK).
; 762  :         The object may be placed in a suspended mode while reading data
; 763  :      which belongs to code-stream packets which lie outside the current
; 764  :      resolution, components or layers of interest.  This allows the
; 765  :      application to set a byte limit which applies only to the relevant
; 766  :      data which would be left if the irrelevant data were first parsed
; 767  :      out of the code-stream.  The object is in suspended mode if and only
; 768  :      if `suspend_ptr' is non-NULL.  In this case, `suspend_ptr' holds the
; 769  :      value of `kd_input::first_unread' immediately prior to the point at
; 770  :      which the object entered the suspended mode.  The total number of
; 771  :      bytes consumed while in the suspended mode is maintained by the
; 772  :      `suspended_bytes' member, but use the function, `get_suspended_bytes'
; 773  :      to evaluate a reliable count of the number of suspended bytes, which
; 774  :      takes into account activity within the `kd_input' object of which
; 775  :      the derived object might not be aware.
; 776  :         The `alt_first_unwritten' member is used to keep track of bytes in
; 777  :      the buffer which may be inaccessible while in the regular (non-suspended)
; 778  :      mode, which may need to be made accessible while the object is in the
; 779  :      suspended mode.  This member holds NULL until exiting the suspended mode
; 780  :      requires `first_unwritten' to be truncated to account for a byte limit.
; 781  :      At that point, it is set to the value of the `first_unwritten' member
; 782  :      prior to truncation.  When the object enters the suspended mode, any
; 783  :      non-NULL `alt_first_unwritten' value is copied to `first_unwritten'. */
; 784  : 
; 785  : /*****************************************************************************/
; 786  : /*                               kd_pph_input                                */
; 787  : /*****************************************************************************/
; 788  : 
; 789  : class kd_pph_input : public kd_input {
; 790  :   /* Alternate input for packet header bytes, which is used in conjunction
; 791  :      with the PPM and PPT marker segments. */
; 792  :   public: // Member functions
; 793  :     kd_pph_input(kd_buf_server *server)
; 794  :       { buf_server = server; first_buf = read_buf = write_buf = NULL; }
; 795  :     virtual ~kd_pph_input();
; 796  :     void add_bytes(kdu_byte *data, int num_bytes);
; 797  :       /* This function is called when unpacking a PPM or PPT marker, to
; 798  :          augment the current object. */
; 799  :   protected: // Virtual functions which implement required services.
; 800  :     virtual bool load_buf();
; 801  :   private: // Data
; 802  :     kd_code_buffer *first_buf;
; 803  :     kd_code_buffer *read_buf, *write_buf;
; 804  :     int read_pos, write_pos;
; 805  :     kd_buf_server *buf_server;
; 806  :   };
; 807  :   /* Notes:
; 808  :         `first_buf' points to the first in a linked list of buffers used to
; 809  :      temporarily store PPM or PPT marker segment bytes.
; 810  :         `read_buf' points to the element in the linked list of code buffers
; 811  :      which is currently being read; `read_pos' points to the next element of
; 812  :      the current buffer which will be read. This may be equal to
; 813  :      KD_CODE_BUFFER_LEN, in which case the next element in the code buffer
; 814  :      list must be accessed when the next read attempt occurs.
; 815  :         `write_buf' points to the last element in the linked list of code
; 816  :      buffers and `write_pos' identifies the first unwritten byte in this
; 817  :      element.  `write_pos' may equal KD_CODE_BUFFER_LEN, in which case a
; 818  :      new element will need to be added before further data can be written.
; 819  :         `buf_server' points to the object which is used to add and release
; 820  :      code buffer elements.  This is a shared resource. */
; 821  : 
; 822  : /*****************************************************************************/
; 823  : /*                                kd_marker                                  */
; 824  : /*****************************************************************************/
; 825  : 
; 826  : class kd_marker {
; 827  :   /* Objects of this class are used to read and store code-stream marker
; 828  :      segments. The most efficient way to use the class is to construct a
; 829  :      single serving object which is used to read the markers one by one and
; 830  :      then copy any markers which need to be preserved into new instances of
; 831  :      the class, using the copy constructor.  This concentrates wasted buffer
; 832  :      space in the one server marker which actually reads from the input
; 833  :      code-stream. */
; 834  :   public: // Member functions
; 835  :     kd_marker(kd_input *input, kd_codestream *cs)
; 836  :       { this->source = input; this->codestream = cs;
; 837  :         code = 0; length = 0; max_length = 0; buf = NULL;
; 838  :         encountered_skip_code = false; }
; 839  :     kd_marker(const kd_marker &orig);
; 840  :       /* Copies any marker segment stored in `orig'. Note that the `source'
; 841  :          pointer is not copied, meaning that the `read' member function may
; 842  :          not be invoked on the copy. */
; 843  :     ~kd_marker() { if (buf != NULL) delete[] buf; }
; 844  :     kd_marker *move(kd_input *input, kd_codestream *cs)
; 845  :       { this->source = input; this->codestream = cs; return this; }
; 846  :         /* This function is used when a `kd_marker' object must be moved
; 847  :          to a different codestream, or to work with a different source of
; 848  :          data. */
; 849  :     void print_current_code(kdu_message &out)
; 850  :       { /* Prints a text string identifying the current marker code. */
; 851  :         print_marker_code(this->code,out);
; 852  :       }
; 853  :     bool read(bool exclude_stuff_bytes=false, bool skip_to_marker=false);
; 854  :       /* Reads a new marker (or marker segment) from the `kd_input' object
; 855  :          supplied during construction.
; 856  :              Returns true if successful.  Causes of failure may be: 1) the
; 857  :          code-stream source is exhausted; 2) a valid marker code was not found;
; 858  :          or 3) an SOP or SOT marker code was found, but followed by an invalid
; 859  :          length field.  This third cause of failure is important since it
; 860  :          prevents the function from attempting to consume an invalid SOP or
; 861  :          SOT marker segment, in the process of which it might consume any
; 862  :          number of useful packets, having their own SOP markers.
; 863  :               A valid marker code must commence with an FF.  If
; 864  :          `exclude_stuff_bytes' is true then the second byte of a valid marker
; 865  :          code must be strictly greater than 0x8F.  Otherwise, the second byte
; 866  :          is arbitrary.  If `skip_to_marker' is true, the function consumes
; 867  :          bytes indefinitely, until the source is exhausted or a valid marker
; 868  :          code is found.  In this case, the function returns false only if the
; 869  :          source is exhausted. Otherwise, the function expects to find a valid
; 870  :          marker code immediately.
; 871  :              As a convenience feature, the function automatically skips over
; 872  :          any EOC marker it encounters.  This has two advantages: 1) we can
; 873  :          detect the end of the code-stream without having to explicitly check
; 874  :          for an EOC marker; 2) we should not be overly troubled by EOC
; 875  :          markers which arise due to corruption of the code-stream (this has
; 876  :          quite a high likelihood of occurring if the code-stream is subject
; 877  :          to corruption).
; 878  :              In the event that the source is not exhausted but a valid
; 879  :          marker code is not found, the function puts back any bytes it consumed
; 880  :          before returning false.  This allows the caller to continue reading
; 881  :          from the point where the function was first called. */
; 882  :     kdu_uint16 get_code() { return code; }
; 883  :       /* Returns 0 if no actual marker is available yet. */
; 884  :     int get_length() { return length; }
; 885  :       /* Returns length of marker segment (not including the length specifier).
; 886  :          Returns 0 if no actual marker available, or if the marker is a
; 887  :          delimiter (no segment). */
; 888  :     kdu_byte *get_bytes() { return buf; }
; 889  :       /* Returns pointer to marker segment bytes immediately following the
; 890  :          length specifier. */
; 891  :     void clear() { code = 0; length = 0; encountered_skip_code = false; }
; 892  :       /* Erase internal state so that not marker is advertised.  This is
; 893  :          useful if the marker has already been inspected and found to be
; 894  :          not useful. */
; 895  :   private: // Data
; 896  :     kd_input *source; // If NULL, `read' may not be used.
; 897  :     kd_codestream *codestream;
; 898  :     kdu_uint16 code;
; 899  :     int length;
; 900  :     int max_length; // Number of bytes which the buffer can store.
; 901  :     kdu_byte *buf;
; 902  :     bool encountered_skip_code;
; 903  :   };
; 904  : 
; 905  : /*****************************************************************************/
; 906  : /*                                 kd_pp_markers                             */
; 907  : /*****************************************************************************/
; 908  : 
; 909  : class kd_pp_markers {
; 910  :   public: // Member functions
; 911  :     kd_pp_markers()
; 912  :       { list = NULL; }
; 913  :     ~kd_pp_markers();
; 914  :     void add_marker(kd_marker &copy_source); 
; 915  :       /* Copies the `kd_marker' object into a new `kd_pp_marker_list'
; 916  :          element, inserting it into the evolving list on the basis of its
; 917  :          Zppm or Zppt index.  Markers need not be added in order. */
; 918  :     void transfer_tpart(kd_pph_input *pph_input);
; 919  :       /* Transfers an entire tile-part of packed packet header data from
; 920  :          the internal marker list to the `pph_input' object, which may
; 921  :          then be used as a source object for packet header reading.  If the
; 922  :          object is managing a list of PPM markers, the function expects to
; 923  :          find the total number of bytes associated with the next tile-part
; 924  :          embedded in the current marker segment.  Otherwise, all marker
; 925  :          segments are dumped into the `pph_input' object.  Marker segments
; 926  :          whose data have been consumed are deleted automatically. */
; 927  :     void ignore_tpart();
; 928  :       /* Same as `transfer_tpart' except that the data are simply discarded.
; 929  :          This is useful when discarding a tile for which PPM marker information
; 930  :          has been provided. */
; 931  :   private: // Definitions
; 932  : 
; 933  :       class kd_pp_marker_list : public kd_marker {
; 934  :         public: // Member functions
; 935  :           kd_pp_marker_list(kd_marker &copy_source) : kd_marker(copy_source)
; 936  :             { next = NULL; }
; 937  :         public: // Data
; 938  :           kd_pp_marker_list *next;
; 939  :           int znum;
; 940  :           int bytes_read;
; 941  :         };
; 942  : 
; 943  :   private: // Convenience functions
; 944  :     void advance_list();
; 945  :   private: // Data
; 946  :     bool is_ppm; // Otherwise, list contains PPT markers.
; 947  :     kd_pp_marker_list *list;
; 948  :   };
; 949  : 
; 950  : /*****************************************************************************/
; 951  : /*                            kd_tpart_pointer                               */
; 952  : /*****************************************************************************/
; 953  : 
; 954  : struct kd_tpart_pointer {
; 955  :     kdu_long address; // Offset relative to the start of the code-stream.
; 956  :     kd_tpart_pointer *next; // For building linked lists.
; 957  :   };
; 958  : 
; 959  : /*****************************************************************************/
; 960  : /*                               kd_tile_ref                                 */
; 961  : /*****************************************************************************/
; 962  : 
; 963  : struct kd_tile_ref {
; 964  :     kd_tpart_pointer *tpart_head;
; 965  :     kd_tpart_pointer *tpart_tail;
; 966  :     kd_tile *tile;
; 967  :   };
; 968  :   /* Notes:
; 969  :        This structure is used to build an array of references to each tile
; 970  :        in the code-stream.  The array is allocated when the codestream is
; 971  :        constructed, but the actual `kd_tile' objects are only instantiated
; 972  :        when needed and destroyed as soon as possible.
; 973  :           The `tpart_head' and `tpart_tail' members manage a list of
; 974  :        addresses to tile-parts of the tile.  The list may be constructed
; 975  :        by reading TLM marker segments in the main code-stream header, or it
; 976  :        may be constructed dynamically as tile-parts are encountered within
; 977  :        the code-stream, enabling them to be re-opened at a later point if
; 978  :        the compressed data-source supports seeking.  The list should be
; 979  :        empty if the source does not support seeking.
; 980  :           Once we are sure that all tile-part addresses have been found
; 981  :        for the tile, the `tpart_tail' member is set to NULL.
; 982  :           Once a tile has been opened and destroyed in non-persistent mode,
; 983  :        the `tile' pointer value is set to KD_EXPIRED_TILE, marking it
; 984  :        as unusable. */
; 985  : 
; 986  : /*****************************************************************************/
; 987  : /*                              kd_tlm_generator                             */
; 988  : /*****************************************************************************/
; 989  : 
; 990  : class kd_tlm_generator {
; 991  :   public: // Member functions
; 992  :     kd_tlm_generator()
; 993  :       {
; 994  :         num_tiles = max_tparts = num_elts = 0; elts = NULL;
; 995  :         tile_data_bytes=0;
; 996  :       }
; 997  :     ~kd_tlm_generator() { if (elts != NULL) delete[] elts; }
; 998  :     bool init(int num_tiles, int max_tparts);
; 999  :       /* Call this function after construction or `clear' in order to
; 1000 :          initialize the object in preparation for generating TLM marker
; 1001 :          segments.  If the number of tiles or tile-parts identified here
; 1002 :          cannot be accommodated by a legal set of TLM marker segments, the
; 1003 :          function returns false and `exists' will continue to return false.
; 1004 :          Otherwise, the object is initialized and subsequent calls to
; 1005 :          `exists' will return true.  Note that the number of tiles given
; 1006 :          here is the total number in the entire code-stream.  This might
; 1007 :          be more than the number of tiles being compressed in the
; 1008 :          current fragment, in which case the `elts' array will not be
; 1009 :          full by the time `write_tlms' is called. */
; 1010 :     bool exists() { return (num_tiles > 0); }
; 1011 :     bool operator!() { return (num_tiles == 0); }
; 1012 :     void clear()
; 1013 :       {
; 1014 :         num_tiles = max_tparts = num_elts = 0;
; 1015 :         tile_data_bytes = 0;
; 1016 :         if (elts != NULL)
; 1017 :           { delete[] elts; elts = NULL; }
; 1018 :       }
; 1019 :     int get_max_tparts() { return max_tparts; }
; 1020 :       /* Returns the parameter recorded with the `ORGgen_tlm' parameter
; 1021 :          attribute, which triggered the creation of this object.  The
; 1022 :          value returned here is guaranteed to lie in the range 1 to 255. */
; 1023 :     int get_tlm_bytes() { return tlm_bytes; }
; 1024 :       /* Returns the total number of bytes occupied by TLM marker segments.
; 1025 :          This value is computed immediately by the object's constructor; it
; 1026 :          does not depend on the actual tile-part length values added later
; 1027 :          via `add_tpart_length'. */
; 1028 :     void write_dummy_tlms(kd_compressed_output *out);
; 1029 :       /* Writes a properly sized set of TLM marker segments to the `out'
; 1030 :          object, except that all tile-part lengths are set equal to 0.  It
; 1031 :          is most important that the TLM marker segments appear at the very
; 1032 :          end of the main codestream header, since a pointer to the start
; 1033 :          of the TLM data will later be generated on the basis of the
; 1034 :          amount of tile-data which has been written, plus the size of the
; 1035 :          TLM data. */
; 1036 :     void add_tpart_length(int tnum, kdu_long length);
; 1037 :       /* Call this function as the tile-part length information becomes
; 1038 :          available while generating the code-stream.  The actual marker
; 1039 :          TLM marker segments can be written only once all tile-part lengths
; 1040 :          have been added. */
; 1041 :     void write_tlms(kdu_compressed_target *tgt,
; 1042 :                     int prev_tiles_written, kdu_long prev_tile_bytes_written);
; 1043 :       /* This function writes the final TLM marker segments.  The `tgt'
; 1044 :          object's `start_rewrite' and `end_rewrite' functions are used to
; 1045 :          reposition the output stream over the previously written dummy
; 1046 :          TLM marker segments and rewrite them with valid tile-part length
; 1047 :          values.  The `prev_tiles_written' and `prev_tile_bytes_written'
; 1048 :          arguments are identical to the values originally supplied to
; 1049 :          `kdu_codestream::create'.  They are used to determine the
; 1050 :          location of the TLM marker information which must be written,
; 1051 :          since some of it may have previously been written when compressing
; 1052 :          different codestream fragments. */
; 1053 :   private: // Structures
; 1054 :       struct kd_tlm_elt {
; 1055 :           kdu_uint16 tnum;
; 1056 :           kdu_uint32 length;
; 1057 :         };
; 1058 :   private: // Data
; 1059 :     int num_tiles;
; 1060 :     int max_tparts;
; 1061 :     int tlm_bytes; // Total number of bytes occupied by TLM marker segments
; 1062 :     int num_elts; // num_tiles * max_tparts
; 1063 :     int elt_ctr; // Pointer to next unfilled entry in `elts'
; 1064 :     kdu_long tile_data_bytes; // sum of all the tile-part lengths added so far
; 1065 :     kd_tlm_elt *elts; // One element for each tile-part, in sequence.
; 1066 :   };
; 1067 : 
; 1068 : /*****************************************************************************/
; 1069 : /*                         kd_tpart_pointer_server                           */
; 1070 : /*****************************************************************************/
; 1071 : 
; 1072 : class kd_tpart_pointer_server {
; 1073 :   public: // Member functions
; 1074 :     kd_tpart_pointer_server()
; 1075 :       {
; 1076 :         groups = NULL; free_list = NULL; tlm_markers = NULL;
; 1077 :         translated_tlm_markers = false;
; 1078 :       }
; 1079 :     ~kd_tpart_pointer_server();
; 1080 :     bool using_tlm_info() { return translated_tlm_markers; }
; 1081 :       /* Returns true if TLM data was used to construct tile-part
; 1082 :          address lists in the most recent call to `translate_markers'. */
; 1083 :     void add_tlm_marker(kd_marker &marker);
; 1084 :       /* Call this function whenever a TLM marker segment is encountered,
; 1085 :          while parsing the main header. */
; 1086 :     void translate_markers(kdu_long first_sot_address,
; 1087 :                            int num_tiles, kd_tile_ref *tile_refs);
; 1088 :       /* Call this function when the main header has been completely read,
; 1089 :          passing in the seek position associated with the first byte of
; 1090 :          the first SOT marker in the code-stream.  This is the location of
; 1091 :          the SOT marker, relative to the start of the code-stream.  It is
; 1092 :          used to convert tile-part lengths into absolute addresses for
; 1093 :          each tile-part.  If no TLM marker segments have been read, the
; 1094 :          function does nothing.  Otherwise, it fills in the tile-part
; 1095 :          address list in each of the `num_tiles' entries of the
; 1096 :          `tile_refs' array.  If the available TLM information is
; 1097 :          insufficient to fully initialize the addresses of all tile-parts
; 1098 :          of each tile, the function issues a warning (since is is strictly
; 1099 :          illegal to have only partial TLM information). */
; 1100 :     void add_tpart(kd_tile_ref *tile_ref, kdu_long sot_address);
; 1101 :       /* Call this function when a new tile-part is encountered in a
; 1102 :          persistent seekable compressed data source, where the tile-part
; 1103 :          address was not already in the list of known tile-part addresses
; 1104 :          for the tile.  This allows the tile to be loaded or reloaded at
; 1105 :          a later time without reparsing the entire code-stream. */
; 1106 :   private: // Definitions
; 1107 : 
; 1108 : #     define KD_POINTER_GROUP_SIZE 32
; 1109 :       struct kd_pointer_group {
; 1110 :           kd_tpart_pointer elements[KD_POINTER_GROUP_SIZE];
; 1111 :           kd_pointer_group *next;
; 1112 :         };
; 1113 :         /* The purpose of this structure is to avoid an unnecessarily large
; 1114 :            number of calls to `new' and `delete'. */
; 1115 : 
; 1116 :       class kd_tlm_marker_list : public kd_marker {
; 1117 :         public: // Member functions
; 1118 :           kd_tlm_marker_list(kd_marker &copy_source) : kd_marker(copy_source)
; 1119 :             { next = NULL; }
; 1120 :         public: // Data
; 1121 :           kd_tlm_marker_list *next;
; 1122 :           int znum; // TLM sequence number used for concatenating info.
; 1123 :         };
; 1124 :         /* Objects of this class are used to store TLM marker segments in
; 1125 :            a list, so that they can be correctly ordered and their contents
; 1126 :            extracted. */
; 1127 : 
; 1128 :   private: // Data
; 1129 :     kd_tlm_marker_list *tlm_markers; // List of TLM marker segments.
; 1130 :     kd_pointer_group *groups; // List of pointer record groups allocated.
; 1131 :     kd_tpart_pointer *free_list; // List of empty pointer records not yet used
; 1132 :     bool translated_tlm_markers;
; 1133 :   };
; 1134 :   /* Notes:
; 1135 :        This object serves two roles: 1) it collects, resequences and
; 1136 :        translates TLM marker segments from the code-stream's main header;
; 1137 :        and 2) it manages the allocation of tile-part address lists, so as
; 1138 :        to avoid excessive memory fragmentation.  The storage for these
; 1139 :        lists is deallocated only when the present object is destroyed. */
; 1140 : 
; 1141 : /*****************************************************************************/
; 1142 : /*                          kd_precinct_pointer_server                       */
; 1143 : /*****************************************************************************/
; 1144 : 
; 1145 : class kd_precinct_pointer_server {
; 1146 :   public: // Member functions
; 1147 :     kd_precinct_pointer_server()
; 1148 :       { buf_server = NULL; }
; 1149 :     ~kd_precinct_pointer_server()
; 1150 :       { disable(); }
; 1151 :     void restart()
; 1152 :       { disable(); } // Called if the code-stream is restarted.
; 1153 :     bool is_active()
; 1154 :       { return (buf_server != NULL); }
; 1155 :     void initialize(kd_buf_server *buf_server)
; 1156 :       /* Call this function when constructing the tile to which the
; 1157 :          object is attached, unless the code-stream is being read from
; 1158 :          a non-seekable source, in which case you should leave the object
; 1159 :          uninitialized and none of the other functions will have any effect. */
; 1160 :       { assert(this->buf_server == NULL); this->buf_server = buf_server;
; 1161 :         head = tail = NULL; head_pos = tail_pos = available_addresses = 0;
; 1162 :         next_address = 0; tpart_bytes_left = 0; num_layers = 0;
; 1163 :         something_served = final_tpart_with_unknown_length = false;
; 1164 :         next_znum = 0; packets_left_in_precinct=0; }
; 1165 :     void add_plt_marker(kd_marker &marker, kdu_params *cod_params,
; 1166 :                         kdu_params *poc_params);
; 1167 :       /* Call this function whenever a PLT marker segment is encountered,
; 1168 :          while parsing a tile-part header.  The `cod_params' and `poc_params'
; 1169 :          arguments must point to the relevant tile's COD and POC parameter
; 1170 :          objects.  The function uses these to determine whether or not the
; 1171 :          pointer information can be used.  In particular, it is used only
; 1172 :          if the current progression order sequences all packets of any
; 1173 :          given precinct together and if the POC object indicates that there
; 1174 :          will be no progression order changes.  These conditions are checked
; 1175 :          again after each tile-part header has been loaded (see the
; 1176 :          `start_tpart_body' member function).  The reason for the conditions
; 1177 :          is that at most one seek address can be maintained for any given
; 1178 :          precinct. */
; 1179 :     void start_tpart_body(kdu_long start_address, kdu_uint32 tpart_body_length,
; 1180 :                           kdu_params *cod_params, kdu_params *poc_params,
; 1181 :                           bool packed_headers,
; 1182 :                           bool final_tpart_with_unknown_length);
; 1183 :       /* This function must be called before addresses can be recovered for
; 1184 :          precincts whose packets appear in the current tile-part.  The
; 1185 :          `start_address' and `tpart_body_length' arguments identify the
; 1186 :          absolute seeking address of the first byte in the body of the
; 1187 :          tile-part and the total number of body bytes in the tile-part.
; 1188 :          These will be used to determine which packets belong to the
; 1189 :          tile-part.  If this is the last tile-part of the tile and its
; 1190 :          length is unknown, the `final_tpart_with_unknown_length' argument
; 1191 :          should be true, and `tpart_body_length' is ignored.
; 1192 :             This function may determine that precinct address information
; 1193 :          cannot be served up for the current tile, for one of a number of
; 1194 :          This is generally because the packets of each precinct are found
; 1195 :          not to be contiguous within the tile-part, or because the presence
; 1196 :          of POC information renders this a likely problem.  If the
; 1197 :          number of quality layers is found to have changed from the point
; 1198 :          when packet length information was first converted into precinct
; 1199 :          lengths and addresses, we must also conclude that address information
; 1200 :          is not available.  A further reason for discarding packet length
; 1201 :          information is if packet headers have been packed into marker
; 1202 :          segments, since this requires that the packets be processed in order
; 1203 :          and once one by one.  If any such determination is made before any
; 1204 :          precinct addresses have been served up, the object is simply
; 1205 :          disabled so that calls to `get_precinct_address' will return 0.
; 1206 :          Otherwise, a terminal error is generated.  In this event, the
; 1207 :          code-stream might need to be opened again with seeking disabled
; 1208 :          so that the present object will never be initialized. */
; 1209 :     kdu_long get_precinct_address()
; 1210 :       { return ((buf_server==NULL)?((kdu_long) 0):pop_address()); }
; 1211 :       /* Returns the address of the next precinct (in the sequence determined
; 1212 :          by the current progression order) in the tile.  This address may be
; 1213 :          used to seek to the relevant location when reading the precinct's
; 1214 :          packets.
; 1215 :             The function returns 0 if seeking is not possible, if
; 1216 :          packet length information cannot be found in the code-stream,
; 1217 :          or if packet length information is not usable for one of a number
; 1218 :          of reasons.  As explained above, packet length information is usable
; 1219 :          only if the packets of a precinct all appear consecutively so that
; 1220 :          each precinct is characterized by only one seeking address.
; 1221 :             The function returns -1 if seeking is possible, but the first
; 1222 :          packet of the precinct belongs to a tile-part which has not yet been
; 1223 :          opened.  In this event, the `kd_tile::read_tile_part_header' member
; 1224 :          function will have to be called until the information becomes
; 1225 :          available. */
; 1226 :   private: // Helper functions
; 1227 :     kdu_long pop_address();
; 1228 :       /* Does all the work of `get_precinct_address'. */
; 1229 :     void disable()
; 1230 :       { // Call to discard contents and cease recording new PLT info.
; 1231 :         if (buf_server == NULL) return;
; 1232 :         while ((tail=head) != NULL)
; 1233 :           { head = tail->next; buf_server->release(tail); }
; 1234 :         buf_server = NULL;
; 1235 :       }
; 1236 :     void initialize_recording()
; 1237 :       { // Call before parsing the first PLT marker segment.
; 1238 :         assert((buf_server != NULL) && (head == NULL));
; 1239 :         head = tail = buf_server->get();
; 1240 :       }
; 1241 :     void record_byte(kdu_byte val)
; 1242 :       { // Call to record a byte of encoded precinct length info.
; 1243 :         assert(tail != NULL);
; 1244 :         if (tail_pos == KD_CODE_BUFFER_LEN)
; 1245 :           { tail=tail->next=buf_server->get(); tail_pos = 0; }
; 1246 :         tail->buf[tail_pos++] = val;
; 1247 :       }
; 1248 :     kdu_byte retrieve_byte()
; 1249 :       { // Call to retrieve a byte of encoded precinct length info.
; 1250 :         assert((head != tail) || (head_pos < tail_pos));
; 1251 :         if (head_pos == KD_CODE_BUFFER_LEN)
; 1252 :           { kd_code_buffer *tmp = head; head=head->next; head_pos = 0;
; 1253 :             buf_server->release(tmp); }
; 1254 :         return head->buf[head_pos++];
; 1255 :       }
; 1256 :   private: // Data
; 1257 :     kd_buf_server *buf_server;
; 1258 :     kd_code_buffer *head, *tail;
; 1259 :     int head_pos; // First valid byte in the `head' buffer (for retrieving)
; 1260 :     int tail_pos; // First unused byte in the `tail' buffer (for recording)
; 1261 :     int available_addresses; // Precinct addresses recorded, but not retrieved
; 1262 :     kdu_long next_address; // Address of the next precinct in current tile-part
; 1263 :     kdu_uint32 tpart_bytes_left; // Bytes left in the current tile-part
; 1264 :     bool final_tpart_with_unknown_length; // If true, previous member ignored
; 1265 :     int num_layers; // Packets/precinct assumption used to parse PLT info
; 1266 :     bool something_served; // False until the first valid address is served
; 1267 :     kdu_byte next_znum; // PLT markers must appear in sequence
; 1268 :     kdu_long precinct_length; // Accumulator for lengths of packets
; 1269 :     int packets_left_in_precinct;
; 1270 :   };
; 1271 : 
; 1272 : /*****************************************************************************/
; 1273 : /*                             kd_compressed_stats                           */
; 1274 : /*****************************************************************************/
; 1275 : 
; 1276 : class kd_compressed_stats {
; 1277 :   /* An object of this class is used to monitor statistics of the compression
; 1278 :      process.  One application of these statistics is the provision of feedback
; 1279 :      to the block encoder concerning a conservative lower bound to the
; 1280 :      distortion-length slope threshold which will be found by the PCRD-opt
; 1281 :      rate allocation algorithm when the image has been fully compressed.  This
; 1282 :      allows the encoder to skip coding passes which are almost certain to be
; 1283 :      discarded.
; 1284 :         The current very simple implementation makes the naive assumption
; 1285 :      that the compressibility of all subband samples is the same, regardless
; 1286 :      of the subband or resolution level.  This is OK if the number of samples
; 1287 :      which have been processed for each subband is proportional to the
; 1288 :      size of the subband, since then the average compressibility is a good
; 1289 :      measure to use in predicting rate control properties.  In practice,
; 1290 :      though, delay through the wavelet transform means that the percentage
; 1291 :      of samples seen for higher resolution subbands is generally higher than
; 1292 :      that seen for lower frequency subbands, until everything has been
; 1293 :      compressed. Since the higher frequency subbands are almost invariably
; 1294 :      more compressible, the predicted compressibility of the source is
; 1295 :      estimated too high and so the predicted rate-distortion slope threshold
; 1296 :      passes considerably more bits than the final rate allocation will.  This
; 1297 :      renders the prediction excessively conservative for most images.  A
; 1298 :      good fix for this would be to keep track of the percentage of subband
; 1299 :      samples which have been compressed in each resolution level and use this
; 1300 :      information to form a more reliable predictor.  This improvement might
; 1301 :      be included in a future version. */
; 1302 :   public: // Member functions
; 1303 :     kd_compressed_stats() { init(); }
; 1304 :     kd_compressed_stats(kdu_long total_samples, kdu_long target_bytes,
; 1305 :                         bool enable_trimming)
; 1306 :       {
; 1307 :         init();
; 1308 :         this->total_samples = total_samples;
; 1309 :         next_trim = (total_samples+7) >> 3;
; 1310 :         conservative_extra_samples = 4096 + (total_samples>>4);
; 1311 :         target_rate =
; 1312 :           (total_samples==0)?1.0:(((double) target_bytes)/total_samples);
; 1313 :         this->trimming_enabled = enable_trimming;
; 1314 :       }
; 1315 :     void init()
; 1316 :       {
; 1317 :         total_samples=num_coded_samples=conservative_extra_samples=next_trim=0;
; 1318 :         target_rate = 0.0;
; 1319 :         min_quant_slope = 4095; max_quant_slope = 0;
; 1320 :         block_slope_threshold = remaining_slope_threshold = 0;
; 1321 :         for (int n=0; n < 4096; n++)
; 1322 :           quant_slope_rates[n] = 0;
; 1323 :         trimming_enabled = false;
; 1324 :       }
; 1325 :     bool is_empty() { return (num_coded_samples == 0); }
; 1326 :       /* Returns true if some information has been entered via the
; 1327 :          `update_stats' function. */
; 1328 :     bool update_stats(kdu_block *block)
; 1329 :       { /* Invoked by "kdu_subband::close_block".  If the function returns
; 1330 :            true, it is recommended that the compressed data be trimmed back
; 1331 :            to a size consistent with the target compressed length at this
; 1332 :            point.  Remember to invoke `update_quant_slope_thresholds' once
; 1333 :            this function returns. */
; 1334 :         num_coded_samples += block->size.x*block->size.y;
; 1335 :         int quant_slope, length = 0;
; 1336 :         for (int n=0; n < block->num_passes; n++)
; 1337 :           {
; 1338 :             length += block->pass_lengths[n];
; 1339 :             if (block->pass_slopes[n] == 0)
; 1340 :               continue;
; 1341 :             quant_slope = block->pass_slopes[n] >> 4;
; 1342 :             if (quant_slope < min_quant_slope) min_quant_slope = quant_slope;
; 1343 :             if (quant_slope > max_quant_slope) max_quant_slope = quant_slope;
; 1344 :             quant_slope_rates[quant_slope] += length;
; 1345 :             length = 0;
; 1346 :           }
; 1347 :         if (trimming_enabled && (num_coded_samples > next_trim))
; 1348 :           { next_trim += (total_samples+7)>>4; return true; }
; 1349 :         return false;
; 1350 :       }
; 1351 :     bool update_stats(kd_compressed_stats &src)
; 1352 :       { /* Similar to the first version of the `update_stats' function, except
; 1353 :            that the information is copied from the `src' object, returning it
; 1354 :            to the empty state. */
; 1355 :         num_coded_samples += src.num_coded_samples;  src.num_coded_samples = 0;
; 1356 :         if (src.min_quant_slope < this->min_quant_slope)
; 1357 :           this->min_quant_slope = src.min_quant_slope;
; 1358 :         if (src.max_quant_slope > this->max_quant_slope)
; 1359 :           this->max_quant_slope = src.max_quant_slope;
; 1360 :         for (int n=src.min_quant_slope; n <= src.max_quant_slope; n++)
; 1361 :           { quant_slope_rates[n] += src.quant_slope_rates[n];
; 1362 :             src.quant_slope_rates[n] = 0; }
; 1363 :         src.min_quant_slope = 4095;  src.max_quant_slope = 0;
; 1364 :         if (trimming_enabled && (num_coded_samples > next_trim))
; 1365 :           { next_trim += (total_samples+7)>>4; return true; }
; 1366 :         return false;
; 1367 :       }
; 1368 :     void update_quant_slope_thresholds()
; 1369 :       { /* This function should be called after `update_stats' to ensure that
; 1370 :            the most up-to-date slope threshold is available for return via
; 1371 :            `get_conservative_slope_threshold'.  If desired, multiple calls
; 1372 :            to `update_stats' may precede the call to this function, which
; 1373 :            may improve efficiency.  The reason for computing the slope
; 1374 :            threshold here, rather than in `get_conservative_slope_threshold'
; 1375 :            is that the latter function may be invoked asynchronously by any
; 1376 :            number of threads of execution, whereas the present function is
; 1377 :            always invoked while holding the `KD_THREADLOCK_STATS' mutex
; 1378 :            (in multi-threaded applications) so that other threads cannot
; 1379 :            modify the statistics while this function is in progress. */
; 1380 :         int n;  kdu_long max_bytes, cumulative_bytes;
; 1381 :         // Adjust `block_slope_threshold'
; 1382 :         max_bytes = num_coded_samples + conservative_extra_samples;
; 1383 :         max_bytes = 1 + (kdu_long)(max_bytes * target_rate);
; 1384 :         for (cumulative_bytes=0, n=max_quant_slope; n >= min_quant_slope; n--)
; 1385 :           if ((cumulative_bytes += quant_slope_rates[n]) >= max_bytes)
; 1386 :             break;
; 1387 :         block_slope_threshold = n;
; 1388 :         // Adjust `remaining_slope_threshold'
; 1389 :         max_bytes = total_samples;
; 1390 :         max_bytes = 1 + (kdu_long)(max_bytes * target_rate);
; 1391 :         for (cumulative_bytes=0, n=max_quant_slope; n >= min_quant_slope; n--)
; 1392 :           if ((cumulative_bytes += quant_slope_rates[n]) >= max_bytes)
; 1393 :             break;
; 1394 :         remaining_slope_threshold = n;
; 1395 :       }
; 1396 :     kdu_uint16 get_conservative_slope_threshold(bool assume_all_coded=false)
; 1397 :       { /* The slope threshold generated by PCRD-opt is unlikely to be
; 1398 :            smaller than that returned here -- remember that smaller thresholds
; 1399 :            mean that more compressed data are included in the code-stream.
; 1400 :            If `assume_all_coded' is true, the slope threshold is based on the
; 1401 :            assumption that no bytes will be generated for any further samples.
; 1402 :            Otherwise, the assumption is that future samples will have the
; 1403 :            same average compressibility as those already coded.  Note that
; 1404 :            since compressors tend to output a higher proportion of high
; 1405 :            frequency subband samples than low frequency subband samples at
; 1406 :            any point up to the end of the image, the actual compressibility
; 1407 :            of future samples can be expected to be lower on average, making
; 1408 :            our estimate more conservative. */
; 1409 :         int val =
; 1410 :           (assume_all_coded)?remaining_slope_threshold:block_slope_threshold;
; 1411 :         val = (val<<4)-1;
; 1412 :         return (kdu_uint16)((val>0)?val:1);
; 1413 :       }
; 1414 :   private: // Data
; 1415 :     double target_rate; // Expressed in bytes per sample, not bits per sample
; 1416 :     kdu_long total_samples; // Total number of subband sample in entire image
; 1417 :     kdu_long next_trim; // Num samples at which memory should next be trimmed
; 1418 :     kdu_long conservative_extra_samples; // Add to coded samples to be safe
; 1419 :     kdu_long num_coded_samples; // Number of samples already coded
; 1420 :     kdu_long quant_slope_rates[4096]; // See below
; 1421 :     int min_quant_slope, max_quant_slope;
; 1422 :     int block_slope_threshold; // See below
; 1423 :     int remaining_slope_threshold; // See below
; 1424 :     bool trimming_enabled;
; 1425 :   };
; 1426 :   /* Notes:
; 1427 :         The `quant_slope_rates' array holds the total number of coded
; 1428 :      bytes which belong to each of a set of 4096 quantized distortion-length
; 1429 :      slope bins.  The original distortion-length slopes have a 16-bit unsigned
; 1430 :      logarithmic representation (see discussion of the "pass_slopes" member
; 1431 :      array in the "kdu_block" structure).  The index of the bin to which a
; 1432 :      given slope, lambda, belongs is given by
; 1433 :          bin = floor(lambda/16).
; 1434 :      Rounding down means that 16*bin is the smallest slope consistent with the
; 1435 :      bin so that summing the entries from bin to 4095 yields the maximum number
; 1436 :      of code-block bytes which could be contributed to the compressed image
; 1437 :      if the PCRD-opt algorithm selected a slope threshold of 16*bin.  Note,
; 1438 :      however, that bin 0 represents only those slopes in the range 1 to 15,
; 1439 :      since 0 is not a valid slope threshold.
; 1440 :         The `block_slope_threshold' member essentially gives the current
; 1441 :      conservative slope threshold to be used during block coding -- this
; 1442 :      is the slope we want when calling `get_conservative_slope_threshold'
; 1443 :      with the `assume_all_coded' argument set to false.  More specifically,
; 1444 :      `block_slope_threshold' is the smallest index into the `quant_slope_rates'
; 1445 :      array such that the cumulative number of bytes represented by that
; 1446 :      entry and all higher entries is strictly less than the target rate
; 1447 :      multiplied by the number of samples coded so far (plus some
; 1448 :      conservative extra samples).  The corresponding slope threshold is
; 1449 :      obtained by multiplying this value by 16 and subtracting 1.
; 1450 :         The `remaining_slope_threshold' member plays the same role as
; 1451 :      `block_slope_threshold', except that it is based upon the total number
; 1452 :      of samples in the entire image, rather than just the total number of
; 1453 :      samples coded so far.  In this way, it essentially provides a
; 1454 :      conservative distortion-length slope threshold, which can safely be
; 1455 :      used to trim already generated coding passes from their respective
; 1456 :      code-blocks.  This value is used to generate the return value from
; 1457 :      `get_conservative_slope_threshold' when its `assume_all_coded' argument
; 1458 :      is set to true. */
; 1459 : 
; 1460 : /*****************************************************************************/
; 1461 : /*                            kd_codestream_comment                          */
; 1462 : /*****************************************************************************/
; 1463 : 
; 1464 : class kd_codestream_comment {
; 1465 :   public: // Member functions
; 1466 :     kd_codestream_comment()
; 1467 :       { readonly=false; max_chars=num_chars=0; text_buf=NULL; next=NULL; }
; 1468 :     ~kd_codestream_comment()
; 1469 :       { if (text_buf != NULL) delete[] text_buf; }
; 1470 :     void set_text(int length, kdu_byte *data);
; 1471 :       /* This function is used only when parsing comment markers from a
; 1472 :          code-stream, where the comment marker indicates that it contains
; 1473 :          text.  The `data' array contains `length' characters, starting from
; 1474 :          the first byte in the body of the comment marker.  The array of
; 1475 :          characters may or may not be terminated with a null character.  If
; 1476 :          not, a null character is automatically appended to the internal
; 1477 :          representation.
; 1478 :             This function leaves the object in the `read-only' state.
; 1479 :       */
; 1480 :     int write_marker(kdu_output *out, int force_length=0);
; 1481 :       /* If `out' is NULL, the marker segment is ony simulated.  In
; 1482 :          any event, the function returns the total number of bytes consumed
; 1483 :          by the comment marker segment, from the marker code to the
; 1484 :          last segment byte.
; 1485 :             If `force_length' is not 0, the marker segment will be forced
; 1486 :          to occupy an exact number of bytes.  If necessary, the text body of
; 1487 :          the marker segment will be truncated, or padded to the specified
; 1488 :          length.  A non-zero `force_length' value may not be less than 6,
; 1489 :          which is the length of the comment marker header.
; 1490 :             This function leaves the object in the `read-only' state.
; 1491 :       */
; 1492 :   private: // Data
; 1493 :     friend class kdu_codestream_comment;
; 1494 :     bool readonly; // True if you are not allowed to write to the text buffer
; 1495 :     int max_chars; // `text_buf' can hold this many chars, plus a null
; 1496 :     int num_chars; // Number of characters written to `text_buf'.
; 1497 :     char *text_buf; // Holds comment text.
; 1498 :   public: // Links
; 1499 :     kd_codestream_comment *next;
; 1500 :   };
; 1501 : 
; 1502 : /*****************************************************************************/
; 1503 : /*                             kd_packet_sequencer                           */
; 1504 : /*****************************************************************************/
; 1505 : 
; 1506 : class kd_packet_sequencer {
; 1507 :   public: // Member functions
; 1508 :     kd_packet_sequencer(kd_tile *tile)
; 1509 :       {
; 1510 :         this->tile = tile;
; 1511 :         init();
; 1512 :       }
; 1513 :     void init();
; 1514 :       /* Called when the containing tile is re-initialized for processing a
; 1515 :          new code-stream with exactly the same structural properties as the
; 1516 :          previous one. */
; 1517 :     void save_state();
; 1518 :       /* Saves all quantities associated with packet sequencing, both within
; 1519 :          this object and in the associated tile and its constituent precincts,
; 1520 :          so that they can be later restored to resume sequencing from where
; 1521 :          we left off. */
; 1522 :     void restore_state();
; 1523 :       /* Restores the state saved by the `save_state' member function. */
; 1524 :     kd_precinct_ref *next_in_sequence(kd_resolution* &res, kdu_coords &idx);
; 1525 :       /* This function returns a pointer to the `kd_precinct_ref' object
; 1526 :          which manages the precinct associated with the next packet in the
; 1527 :          relevant tile's packet sequence (see below for the possibility of
; 1528 :          a NULL return value).  The function also returns a
; 1529 :          pointer to the `kd_resolution' object which manages the returned
; 1530 :          precinct and the horizontal and vertical coordinates of the
; 1531 :          precinct within that resolution.  The precinct itself may be
; 1532 :          opened, if required, by passing `res' and `idx' directly into the
; 1533 :          `kd_precinct_ref::open' function -- see description of that
; 1534 :          function for more information.
; 1535 :             When desequencing packets from an input code-stream, the caller
; 1536 :          should first invoke the returned reference's
; 1537 :          `kd_precinct_ref::is_desequenced' member function to determine
; 1538 :          whether or not the present function has done all of the required
; 1539 :          desequencing for the precinct itself.  This happens if the
; 1540 :          precinct is directly addressable via a seek address recovered from
; 1541 :          the relevant tile's `kd_precinct_pointer_server' object.  If
; 1542 :          `kd_precinct_ref::is_desequenced' returns false, the caller should
; 1543 :          proceed to open the precinct with `kd_precinct_ref::open' and
; 1544 :          parse the next packet using `kd_precinct::desequence_packet'.  This
; 1545 :          has the effect of updating the precinct state so that the next
; 1546 :          call to `next_in_sequence' can move on to the next packet in
; 1547 :          sequence.
; 1548 :             When sequencing packets for an output code-stream, the caller
; 1549 :          should usually open the precinct and then call
; 1550 :          `kd_precinct::write_packet'.  Again, this enables the next call
; 1551 :          to `next_in_sequence' to move on to the next packet in sequence.
; 1552 :             If the caller does not actually take steps to desequence the
; 1553 :          next input packet or to write the next output packet, subsequent
; 1554 :          calls to this function will return exactly with exactly the same
; 1555 :          precinct reference.  This allows the caller to delay its packet
; 1556 :          parsing or generation activities.
; 1557 :              For both input and output codestreams, this function may return
; 1558 :          NULL.   In either case, a NULL return value means that
; 1559 :          no further packets can be sequenced based on the information
; 1560 :          available for the current tile-part.  For output codestreams, a
; 1561 :          NULL return value means that the caller must write another tile-part
; 1562 :          (or simulate such an activity).  After such an activity, the
; 1563 :          next call to this function will have access to the packet sequencing
; 1564 :          specifications in a new POC marker segment (if this were not possible
; 1565 :          the function would have generated a terminal error instead of
; 1566 :          returning NULL).  For input codestreams, a NULL return value means
; 1567 :          that the caller must advance to a new tile-part.  There are two
; 1568 :          possible reasons for this: 1) a new POC marker segment may be
; 1569 :          required to obtain sequencing specifications for the next packet;
; 1570 :          or 2) the `kd_precinct_pointer_server::get_precinct_address' function
; 1571 :          might have returned -1, meaning that precincts are addressable, but
; 1572 :          the first packet of the next precinct belongs to the tile's next
; 1573 :          tile-part.
; 1574 :              The function also returns NULL if all packets have been
; 1575 :          transferred to or from the code-stream. This event may be detected
; 1576 :          by checking the tile's `num_sequenced_packets' field; the value
; 1577 :          of that field is advanced by `kd_precinct::desequence_packet' when
; 1578 :          it is called or from within the present function if the precinct
; 1579 :          is addressable (this is the condition under which the returned
; 1580 :          reference's `kd_precinct_ref::is_desequenced' returns true
; 1581 :          immediately). */
; 1582 :   private: // Member functions
; 1583 :     bool next_progression();
; 1584 :       /* Sets up the next progression (or the very first progression).
; 1585 :          Returns false, if no further progressions are available without
; 1586 :          starting a new tile-part. */
; 1587 :     kd_precinct_ref *next_in_lrcp(kd_resolution* &res, kdu_coords &idx);
; 1588 :     kd_precinct_ref *next_in_rlcp(kd_resolution* &res, kdu_coords &idx);
; 1589 :     kd_precinct_ref *next_in_rpcl(kd_resolution* &res, kdu_coords &idx);
; 1590 :     kd_precinct_ref *next_in_pcrl(kd_resolution* &res, kdu_coords &idx);
; 1591 :     kd_precinct_ref *next_in_cprl(kd_resolution* &res, kdu_coords &idx);
; 1592 :        // These functions do most of the work of `next_in_sequence'.  They
; 1593 :        // return NULL if there are no more packets to sequence within the
; 1594 :        // current progression order.
; 1595 :   private: // Declarations
; 1596 :       struct kd_packet_sequencer_state {
; 1597 :         public: // Current sequencing bounds
; 1598 :           int order; // One of the orders defined in the scope of `cod_params'
; 1599 :           int res_min, comp_min; // Lower bounds (inclusive) for loops
; 1600 :           int layer_lim, res_lim, comp_lim; // Exclusive upper bounds for loops
; 1601 :         public: // Current looping state.
; 1602 :           int layer_idx; // Current layer index
; 1603 :           int comp_idx; // Current component index
; 1604 :           int res_idx; // Current resolution level index
; 1605 :           kdu_coords pos; // Precinct position indices in current tile-comp-res
; 1606 :         public: // Spatial sequencing parameters.
; 1607 :           kdu_coords grid_min; // Common grid start for spatial loops
; 1608 :           kdu_coords grid_inc; // Common grid increments for spatial loops
; 1609 :           kdu_coords grid_loc; // Common grid location for spatial loops
; 1610 :         public: // POC access parameters
; 1611 :           kdu_params *poc; // NULL unless POC-based sequencing
; 1612 :           int next_poc_record; // Index of next order record in current POC
; 1613 :         };
; 1614 :   private: // Data
; 1615 :     kd_tile *tile;
; 1616 :     int max_dwt_levels; // Over all components.
; 1617 :     bool common_grids; // True if all components have power-of-2 sub-sampling.
; 1618 :     kdu_coords grid_lim; // Point just beyond tile on the canvas
; 1619 :     bool state_saved;
; 1620 :     kd_packet_sequencer_state state;
; 1621 :     kd_packet_sequencer_state saved_state; // Used by `save_state' member.
; 1622 :   };
; 1623 : 
; 1624 : /*****************************************************************************/
; 1625 : /*                          kd_reslength_checker                             */
; 1626 : /*****************************************************************************/
; 1627 : 
; 1628 : class kd_reslength_checker {
; 1629 :   public: // Member functions
; 1630 :     kd_reslength_checker() { memset(this,0,sizeof(*this)); }
; 1631 :     ~kd_reslength_checker() { if (specs != NULL) delete[] specs; }
; 1632 :     bool init(cod_params *cod);
; 1633 :       /* Initializes the contents of the object based on any `Creslength'
; 1634 :          parameter attribute found within `cod'.  In practice, `cod'
; 1635 :          is the relevant global, tile-specific, component-specific, or
; 1636 :          tile-component specific object retrieved by a call to
; 1637 :          `kdu_params::access_unique' with the appropriate tile and component
; 1638 :          indices; it may well be NULL, in which case the object is initialize
; 1639 :          with no constraints.  The function returns true if and only if
; 1640 :          an appropriate `Creslength' attribute was found. */
; 1641 :     void set_layer(int layer_idx);
; 1642 :       /* Use this function to walk thorugh the quality layers.  The object's
; 1643 :          `max_bytes' and `num_bytes' arrays maintain state for only a current
; 1644 :          quality layer.  If `layer_idx' is non-zero, it must be either the
; 1645 :          same or one more than the value of `layer_idx' which was last
; 1646 :          supplied to the function, so that the `prev_layer_bytes' array
; 1647 :          can be used to correctly initialize the `num_bytes' entries
; 1648 :          internally. */
; 1649 :     bool check_packet(kdu_long packet_bytes, int depth)
; 1650 :       /* Updates internal records of the number of bytes associated with
; 1651 :          the given resolution (highest resolution corresponds to `depth'=0)
; 1652 :          and all higher resolutions (smaller depths).  Checks for violation
; 1653 :          of constraints, returning false if any constraints is violated. */
; 1654 :       {
; 1655 :         assert((depth >= 0) && (depth <= 32));
; 1656 :         if ((current_layer_idx < 0) || (specs == NULL)) return true;
; 1657 :         kdu_long lim;
; 1658 :         for (int d=0; (d <= depth) && ((lim=max_bytes[d]) > 0); d++)
; 1659 :           if ((num_bytes[d] += packet_bytes) > lim) return false;
; 1660 :         return true;
; 1661 :       }
; 1662 :   private: // Member variables
; 1663 :     int num_specs;
; 1664 :     kdu_long *specs;
; 1665 :     int current_layer_idx; // -1 if no call to `set_layer' yet.
; 1666 :     kdu_long max_bytes[33]; // Limit for this resolution
; 1667 :     kdu_long num_bytes[33]; // Accumulated number of bytes; see below
; 1668 :     kdu_long prev_layer_bytes[33];
; 1669 :   };
; 1670 :   /* This object manages a single collection of resolution length constraints,
; 1671 :      as provided via the `Creslength' coding parameter attribute.  There
; 1672 :      are potentially (1+T)*(1+C) of these objects in a codestream, where T
; 1673 :      is the number of tiles and C is the number of image components.  These
; 1674 :      correspond to one global form, C component-specific forms, T
; 1675 :      tile-specific forms and C*T tile-component-specific forms.
; 1676 :         `num_specs' and `specs' together hold the parameter values actually
; 1677 :      extracted from the relevant `Creslength' attribute, via the `init'
; 1678 :      function.  These together represent a collection of limits on the
; 1679 :      number of bytes at one or more resolutions, potentially for more than
; 1680 :      one quality layer.  Quality layers are separated by 0's in the
; 1681 :      `specs' array.
; 1682 :         `max_bytes' holds one limit for each potential resolution, starting
; 1683 :      from the full resolution and working down.  The entries in this array
; 1684 :      are derived from the `specs' array, for the quality layer whose index
; 1685 :      is passed to `set_layer'.
; 1686 :         `num_bytes[d]' holds the cumulative number of bytes for all packets
; 1687 :      whose lengths have been passed to `check_packet' so far, for packets
; 1688 :      at depth d or deeper.  This value is compared with `max_bytes[d]' to
; 1689 :      determine whether the resolution length constraint at depth d has been
; 1690 :      violated.
; 1691 :         `prev_layer_bytes' is used to initialize the `num_bytes' entries
; 1692 :      at the start of each new quality layer, based on the total number of
; 1693 :      bytes accumulated by `check_packet' in the previous layer, if any. */
; 1694 : 
; 1695 : /*****************************************************************************/
; 1696 : /*                           kd_global_rescomp                               */
; 1697 : /*****************************************************************************/
; 1698 : 
; 1699 : struct kd_global_rescomp {
; 1700 :   public: // Member functions
; 1701 :     kd_global_rescomp()
; 1702 :       {
; 1703 :         codestream = NULL; depth = comp_idx = 0;
; 1704 :         total_area = area_used_by_tiles = area_covered_by_tiles = 0;
; 1705 :         remaining_area = ready_area = 0;
; 1706 :         ready_fraction = reciprocal_fraction = -1.0;
; 1707 :         first_ready = last_ready = NULL;
; 1708 :       }
; 1709 :     ~kd_global_rescomp() { close_all(); }
; 1710 :     void close_all();
; 1711 :       /* Closes all precincts currently stored on the ready list. */
; 1712 :     void initialize(kd_codestream *codestream, int depth, int comp_idx);
; 1713 :       /* Call this function upon creation or restart of an output
; 1714 :          `kdu_codestream' object.  Releases any existing precincts and
; 1715 :          initializes all counters. */
; 1716 :     void notify_tile_status(kdu_dims tile_dims, bool uses_this_resolution);
; 1717 :       /* Call this function when each tile is opened, to indicate whether or
; 1718 :          not this resolution level exists within each component of that tile.
; 1719 :          This updates internal counters used for incremental rate control and
; 1720 :          slope prediction. */
; 1721 :     void add_ready_precinct(kd_precinct *precinct);
; 1722 :     void close_ready_precinct(kd_precinct *precinct);
; 1723 :       /* Extracts the precinct from the list and releases all of its resources.
; 1724 :          This function is called from `write_packet'. */
; 1725 :   public: // Data
; 1726 :     kd_codestream *codestream;
; 1727 :     int depth, comp_idx;
; 1728 :     kdu_long total_area;
; 1729 :     kdu_long area_used_by_tiles;
; 1730 :     kdu_long area_covered_by_tiles;
; 1731 :     kdu_long remaining_area;
; 1732 :     kd_precinct *first_ready;
; 1733 :     kd_precinct *last_ready;
; 1734 :     kdu_long ready_area;
; 1735 :     double ready_fraction;
; 1736 :     double reciprocal_fraction; // 1/ready_fraction.
; 1737 :   };
; 1738 :   /* Notes:
; 1739 :         `depth' is 0 for the highest resolution level, increasing from there.
; 1740 :         `total_area' is the total area of this component-resolution.
; 1741 :         `area_used_by_tiles' is the area associated with the portion of this
; 1742 :      component-resolution covered by tiles which have already been opened and
; 1743 :      have precincts which contribute to the component-resolution.
; 1744 :         `area_covered_by_tiles' is the area associated with the portion of this
; 1745 :      component-resolution covered by tiles which have already been opened,
; 1746 :      regardless of whether those tiles have precincts which contribute to the
; 1747 :      component-resolution or not.  The ratio between `area_used_by_tiles' and
; 1748 :      `area_covered_by_tiles' is used to estimate the proportion of the
; 1749 :      remaining area which is likely to contribute precincts.
; 1750 :         `remaining_area' is the maximum area for which precincts must still
; 1751 :      be written to the code-stream.  This is equal to `total_area' minus
; 1752 :      `area_unused_by_tiles' minus the total area associated with all precincts
; 1753 :      in this component-resolution for which at least one packet has already
; 1754 :      been written out to the code-stream.
; 1755 :         `ready_area' is the area associated with all precincts in the
; 1756 :      ready list headed by `first_ready'.  The ready precincts have been fully
; 1757 :      generated, but none of their packets have yet been written to the
; 1758 :      code-stream.  Whenever it is done, rate allocation is performed on these
; 1759 :      precincts.
; 1760 :         `ready_fraction' holds a quantity in the range 0 to 1, representing
; 1761 :      the expected fraction of the remaining area which is represented by the
; 1762 :      ready precincts.  A negative value means that this quantity has not
; 1763 :      yet been computed, or it needs to be recomputed.  The value is computed
; 1764 :      from
; 1765 :         F = `ready_area' / A
; 1766 :      where A is given by
; 1767 :         A = (`remaining_area'-T)
; 1768 :           + T * (`area_used_by_tiles'/`area_covered_by_tiles')
; 1769 :      and
; 1770 :         T = `total_area' - `area_covered_by_tiles'
; 1771 :   */
; 1772 : 
; 1773 : /*****************************************************************************/
; 1774 : /*                              kd_comp_info                                 */
; 1775 : /*****************************************************************************/
; 1776 : 
; 1777 : struct kd_comp_info {
; 1778 :   public: // Data
; 1779 :     kdu_coords sub_sampling; // Component sub-sampling factors.
; 1780 :     float crg_x, crg_y; // Component registration offsets.
; 1781 :     int precision; // Original component bit-depths.
; 1782 :     bool is_signed; // Signed/unsigned nature of original components
; 1783 :     kdu_byte hor_depth[33];
; 1784 :     kdu_byte vert_depth[33];
; 1785 :     int apparent_idx; // See below
; 1786 :     kd_comp_info *from_apparent; // See below
; 1787 :   };
; 1788 :   /* Notes:
; 1789 :        This structure holds codestream-wide information for a single image
; 1790 :        component.
; 1791 :           The `hor_depth' and `vert_depth' arrays contain information which
; 1792 :        might be affected by DFS marker segments in the codestream's main
; 1793 :        header.  The values of `hor_depth'[d] and `vert_depth'[d] identify
; 1794 :        the total number of horizontal and vertical low-pass filtering and
; 1795 :        downsampling stages which are involved in creating the resolution
; 1796 :        level which is `d' levels below the original full image resolution.
; 1797 :        Neither value may exceed d.  Thus, `hor_depth'[0] and `vert_depth'[0]
; 1798 :        are guaranteed to equal zero -- these entries exist only to make the
; 1799 :        implementation more regular.  Codestreams conforming to JPEG2000
; 1800 :        Part-1 must have `hor_depth'[d] = `vert_depth'[d] = d for all d.
; 1801 :        Part-2 codestreams, however, may have custom downsampling factor
; 1802 :        styles (represented by DFS marker segments in the main header).
; 1803 :           The `apparent_idx' and `from_apparent' members are provided
; 1804 :        because the `kdu_codestream' interface (and its descendants) might
; 1805 :        be limited to exposing only a subset of the actual image components
; 1806 :        which are available.  This subset is selected via
; 1807 :        `kdu_codestream::apply_input_restrictions'.  The `apparent_idx'
; 1808 :        member identifies the index (starting from 0) of the present
; 1809 :        codestream image component, as it appears to the external API.  This
; 1810 :        value will be 0 if the component is not visible across the API.  The
; 1811 :        `from_apparent' member is used to translate apparent component
; 1812 :        indices into true codestream component indices.  Specifically, the
; 1813 :        `kd_codestream::comp_info[c].from_apparent' member points to the
; 1814 :        particular entry in the `kd_codestream::comp_info' array which
; 1815 :        represents the true codestream image component whose apparent index is
; 1816 :        c.  This is NULL if c >= `kd_codestream::num_apparent_components'. */
; 1817 : 
; 1818 : /*****************************************************************************/
; 1819 : /*                           kd_output_comp_info                             */
; 1820 : /*****************************************************************************/
; 1821 : 
; 1822 : struct kd_output_comp_info {
; 1823 :   public: // Member functions
; 1824 :     kd_output_comp_info()
; 1825 :       {
; 1826 :         precision=0; is_signed=false; subsampling_ref = NULL;
; 1827 :         apparent_idx=-1; from_apparent=0;
; 1828 :         block=NULL; block_comp_idx=0; apparent_block_comp_idx=0;
; 1829 :         is_of_interest=false; ss_tmp=0.0F;
; 1830 :       }
; 1831 :   public: // Data
; 1832 :     int precision;
; 1833 :     bool is_signed;
; 1834 :     kd_comp_info *subsampling_ref;
; 1835 :     int apparent_idx;
; 1836 :     int from_apparent;
; 1837 :     kd_mct_block *block;
; 1838 :     int block_comp_idx;
; 1839 :     int apparent_block_comp_idx;
; 1840 :     bool is_of_interest; // See below
; 1841 :     float ss_tmp; // Temporary storage used in sensitivity calculations;
; 1842 :                   // see `kd_mct_block::analyze_sensitivity'.
; 1843 :   };
; 1844 :   /* Notes:
; 1845 :         This structure is used to describe the image components produced at
; 1846 :      the output of any given MCT transform (synthesis) stage.  It is
; 1847 :      also used to describe the image components at the output of the
; 1848 :      multi-component transform from a global perspective.  The `is_signed'
; 1849 :      and `precision' members are meaningful only where this record is
; 1850 :      found at the output of the last MCT stage in the inverse multi-component
; 1851 :      transform, or in the global `output_comp_info' array managed by
; 1852 :      `kd_codestream'.
; 1853 :         If the inverse multi-component transform does not produce any data for
; 1854 :      this output component, its `subsampling_ref' member is NULL.  Otherwise
; 1855 :      `subsampling_ref' points to the `kd_comp_info' structure which describes
; 1856 :      any of the codestream image components which is involved in
; 1857 :      reconstructing this output component -- it does not matter which one.
; 1858 :      The purpose of this reference is to facilitate the determination of the
; 1859 :      dimensions and sub-sampling attributes of the relevant output component.
; 1860 :      All codestream image components involved in the reconstruction of
; 1861 :      any given MCT output component must have identical dimensions, so it
; 1862 :      is sufficient to reference only one of them.
; 1863 :         The `apparent_idx' and `from_apparent' members work in exactly the
; 1864 :      same way as their namesakes in `kd_comp_info' to facilitate translation
; 1865 :      between true image component indices and apparent image component
; 1866 :      indices, as presented to the application.  The only difference is
; 1867 :      that `from_apparent' is the index (rather than the address) of the
; 1868 :      true output image component which appears to have the index of the
; 1869 :      current component.  The apparent component indices are influenced by
; 1870 :      calls to the second form of the `kdu_codestream::change_appearance'
; 1871 :      function.
; 1872 :         The last four members are used only when the object is found in
; 1873 :      the `output_comp_info' array of a `kd_mct_stage' object.  In this case,
; 1874 :      `block' points to the MCT transform block which is used to produce this
; 1875 :      component within the relevant stage, while `block_comp_idx' indicates
; 1876 :      which of the output components from that transform stage corresponds
; 1877 :      to the current component.  The `apparent_block_comp_idx' member
; 1878 :      identifies the apparent index of this output component within the
; 1879 :      referenced transform block, which may be smaller than `block_comp_idx'
; 1880 :      if some earlier output components from the transform block are not
; 1881 :      apparent.  This value is guaranteed to lie between 0 and
; 1882 :      `block->num_apparent_outputs'-1.  `is_of_interest' is set to false
; 1883 :      if and only if `apparent_idx' is negative, except in the final
; 1884 :      transform stage, where it is also set to false if the corresponding
; 1885 :      component is not of interest to the application, as identified by
; 1886 :      calls to `kdu_tile::set_components_of_interest'.
; 1887 :         If the object is found in `kd_codestream::output_comp_info',
; 1888 :      the `block' member will be NULL and `block_comp_idx',
; 1889 :      `apparent_block_idx' and `is_of_interest' have no meaning. */
; 1890 : 
; 1891 : /*****************************************************************************/
; 1892 : /*                            kd_mct_ss_model                                */
; 1893 : /*****************************************************************************/
; 1894 : 
; 1895 : struct kd_mct_ss_model {
; 1896 :   public: // Member functions
; 1897 :     kd_mct_ss_model()  { ss_vals = ss_handle = NULL; }
; 1898 :     ~kd_mct_ss_model() { if (ss_handle != NULL) delete[] ss_handle; }
; 1899 :   public: // Data
; 1900 :     kdu_int16 range_min;
; 1901 :     kdu_int16 range_len;
; 1902 :     float *ss_vals;
; 1903 :     float *ss_handle;
; 1904 :   };
; 1905 :   /* See the discussion of `kd_mct_block::ss_models' for an explanation of
; 1906 :      this structure. */
; 1907 : 
; 1908 : /*****************************************************************************/
; 1909 : /*                              kd_mct_block                                 */
; 1910 : /*****************************************************************************/
; 1911 : 
; 1912 : struct kd_mct_block {
; 1913 :   public: // Member functions
; 1914 :     kd_mct_block() { memset(this,0,sizeof(*this)); }
; 1915 :     ~kd_mct_block()
; 1916 :       {
; 1917 :         if (input_indices != NULL) delete[] input_indices;
; 1918 :         if (inputs_required != NULL) delete[] inputs_required;
; 1919 :         if (output_indices != NULL) delete[] output_indices;
; 1920 :         if (dwt_step_info != NULL) delete[] dwt_step_info;
; 1921 :         if (dwt_coefficients != NULL) delete[] dwt_coefficients;
; 1922 :         if (scratch != NULL) delete[] scratch;
; 1923 :         if (ss_models != NULL) delete[] ss_models;
; 1924 :       }
; 1925 :     void analyze_sensitivity(int which_input, float input_weight,
; 1926 :                              int &min_output_idx, int &max_output_idx,
; 1927 :                              bool restrict_to_interest);
; 1928 :       /* This function plays a central role in the calculation of energy
; 1929 :          weights.  It determines the contribution of the block input
; 1930 :          component identified by `which_input' to the set of stage output
; 1931 :          components for the MCT stage in which the block resides,
; 1932 :          multiplying the contribution by `input_weight' and adding it into
; 1933 :          the `kd_output_comp_info::ss_tmp' members of all affected stage
; 1934 :          outputs.  The `which_input' argument must lie in the range 0 to
; 1935 :          `num_inputs'-1, where `num_inputs' is the number of inputs for
; 1936 :          this block.
; 1937 :             The `min_output_idx' and `max_output_idx' arguments
; 1938 :          play a key role in minimizing the complexity of sensitivity
; 1939 :          calculations for multi-component transforms which involve large
; 1940 :          numbers of image components.  On entry, these identify the range
; 1941 :          of stage output components whose `kd_output_comp_info::ss_tmp'
; 1942 :          members have already been affected by sensitivity calculations
; 1943 :          for other transform blocks in the same stage; if this is the first
; 1944 :          stage, the `min_output_idx' value supplied on entry should be
; 1945 :          strictly greater than the `max_output_idx' value, to indicate that
; 1946 :          the range of affected stage outputs is empty so far.  On exit,
; 1947 :          the `min_output_idx' and `max_output_idx' arguments represent the
; 1948 :          augmented range of affected outputs.  Whenever this range grows,
; 1949 :          the function first initialized the affected `ss_tmp' members to 0,
; 1950 :          so there is no need to explicitly initialize all `ss_tmp' members
; 1951 :          in the `kd_mct_stage::output_comp_info' array.  This can also save
; 1952 :          quite a bit of wasted effort when there are a very large number
; 1953 :          of components.
; 1954 :             If `restrict_to_interest' is true, the sensitivity analysis is
; 1955 :          restricted to include only those output components for which
; 1956 :          `kd_output_comp_info::is_of_interest' is true. */
; 1957 :   private: // Helper functions
; 1958 :     void create_matrix_ss_model();
; 1959 :     void create_rxform_ss_model();
; 1960 :     void create_old_rxform_ss_model();
; 1961 :     void create_dependency_ss_model();
; 1962 :     void create_dwt_ss_model();
; 1963 :   public: // Data
; 1964 :     kd_mct_stage *stage;
; 1965 :     int num_inputs;
; 1966 :     int num_required_inputs;
; 1967 :     int *input_indices;
; 1968 :     bool *inputs_required;
; 1969 :     int num_outputs;
; 1970 :     int num_apparent_outputs;
; 1971 :     int *output_indices;
; 1972 :     kd_mct_ss_model *ss_models;
; 1973 :     bool is_reversible;
; 1974 :     bool is_null_transform;
; 1975 :     kdu_params *offset_params;
; 1976 :     kdu_params *matrix_params;
; 1977 :     kdu_params *old_mat_params; // For compatibility with versions before v6.0
; 1978 :     kdu_params *triang_params;
; 1979 :     int dwt_num_steps, dwt_num_levels, dwt_canvas_origin;
; 1980 :     bool dwt_symmetric, dwt_symmetric_extension;
; 1981 :     kdu_kernel_step_info *dwt_step_info;
; 1982 :     float *dwt_coefficients;
; 1983 :     int dwt_low_synth_min, dwt_low_synth_max;
; 1984 :     int dwt_high_synth_min, dwt_high_synth_max;
; 1985 :     float dwt_synth_gains[2]; // Subband gains applied before synthesis lifting
; 1986 :     float *scratch; // Contains `num_inputs' entries if allocated
; 1987 :   };
; 1988 :   /* Notes:
; 1989 :         This structure manages a single transform block within a stage of the
; 1990 :      multi-component transform.  Most types of transform blocks have an
; 1991 :      identical number of input and output components, but irreversible
; 1992 :      decorrelation transforms can have more or less output components than
; 1993 :      input components.
; 1994 :         The `input_indices' array provides the indices of the stage input
; 1995 :      components which are used by this block.  These must lie in the range
; 1996 :      0 to `stage->num_input_components'-1.  Moreover, if this is not the
; 1997 :      first stage, these same indices may be used to address the
; 1998 :      `stage->prev_stage->output_comp_info' array, to discover how the input
; 1999 :      components are produced.
; 2000 :         The output_indices' array provides the indices of the stage output
; 2001 :      components which are produced by this block.  These indices may be
; 2002 :      used to address the `stage->output_comp_info' array to discover whether
; 2003 :      each output component is apparent or not, amongst other things.
; 2004 :         The `ss_models' array is created and manipulated by calls to the
; 2005 :      `analyze_sensitivity' function.  If non-NULL, the array contains
; 2006 :      `num_inputs' entries, each of which identifies the linearized
; 2007 :      contribution of a unit change in the corresponding input to the
; 2008 :      block's output components.  For reasons of efficiency, each input
; 2009 :      identifies the range of block output indices which it affects, via the
; 2010 :      corresponding `kd_mct_ss_model::range_min' and
; 2011 :      `kd_mct_ss_model::range_len' members.  The contribution of each input
; 2012 :      to the affected block outputs is given by its `kd_mct_ss_model::ss_vals'
; 2013 :      array, with length `kd_mct_ss_model::range_len'.  This array is created
; 2014 :      (set to a non-NULL value) only on demand.  Note also that the
; 2015 :      `kd_mct_ss_model::ss_vals' arrays can be allocated in a variety of
; 2016 :      ways and can be shared between different input models, wherever this
; 2017 :      allows for improved efficiency.  This is achieved by separately
; 2018 :      keeping track of actual allocated memory blocks via the
; 2019 :      `kd_mct_ss_model::ss_handle' members.
; 2020 :         Each transform block notionally has an offset vector, whose
; 2021 :      elements are to be added to the output component samples as the final
; 2022 :      step in the transform process.  If `offset_params' is non-NULL, the
; 2023 :      offsets are derived from its `Mvector' attribute.  Otherwise, the
; 2024 :      offsets are all 0.
; 2025 :         If `matrix_params', `triang_params' and `dwt_step_info' are all NULL,
; 2026 :      the transform block does nothing else.  We refer to blocks of this form
; 2027 :      as "NULL blocks".  NULL blocks map their i'th input component to their
; 2028 :      i'th output component, with the possible addition of an offset from
; 2029 :      `offset_params'.  NULL blocks are useful primarily as a tool for
; 2030 :      discarding certain input components, since only the first
; 2031 :      `num_outputs' components find their way through the block.  They are
; 2032 :      also useful for introducing permutations and offsets.  The JPEG2000
; 2033 :      standard, Part 2, refers to NULL transform blocks in this same sense,
; 2034 :      although the text in the standard is potentially unclear.
; 2035 :         For NULL transform blocks, the `is_reversible' flag will be false.
; 2036 :      For all other types of transform blocks, the `is_reversible' flag plays
; 2037 :      an important role in determining how the transformation is implemented.
; 2038 :         Apart from NULL transform blocks, there are four other types of
; 2039 :      transforms:
; 2040 :      [>>] Irreversible decorrelation transforms are described by a matrix,
; 2041 :           whose coefficients are provided by the `Mmatrix' attribute
; 2042 :           managed by `matrix_params'.  This type of transform is used if
; 2043 :           `matrix_params' is non-NULL and `is_reversible' is false.
; 2044 :      [>>] Reversible decorrelation transforms are described by a matrix
; 2045 :           of SERM factorization coefficients.  In this case, `is_reversible'
; 2046 :           is true and the value of `num_outputs' must equal `num_inputs'.
; 2047 :           Codestreams generated prior to v6.0 will have `old_mat_xforms'
; 2048 :           non-NULL, in which case the corresponding matrix coefficients
; 2049 :           have an organization with `num_outputs' rows and `num_outputs'+1
; 2050 :           columns, where the columns represent successive lifting steps.
; 2051 :           Codestreams generated from v6.0 onwards have `matrix_xforms'
; 2052 :           non-NULL, in which case the matrix coefficients have an organization
; 2053 :           with `num_outputs'+1 rows and `num_outputs' columns, where the
; 2054 :           rows represent successive lifting steps.  This matrix organization
; 2055 :           is transposed in answering calls to `kdu_tile::get_mct_rxform_info'.
; 2056 :      [>>] Reversible or irreversible dependency transform.  In this case,
; 2057 :           the `triang_params' member is non-NULL and its `Mtriang'
; 2058 :           attribute is used to access the transform coefficients.
; 2059 :      [>>] Reversible or irreversible DWT (Discrete Wavelet Transform).  In
; 2060 :           this case, `dwt_step_info' is non-NULL.  The DWT transform kernel
; 2061 :           is described by the `dwt_step_info', `dwt_num_steps',
; 2062 :           `dwt_symmetric', `dwt_symmetric_extension' and `dwt_coefficients'
; 2063 :           members.  The number of DWT levels to be applied is described by
; 2064 :           the `dwt_num_levels' member, and the canvas origin which defines
; 2065 :           the coordinate system for the DWT is given by `dwt_canvas_origin'.
; 2066 :           The regions of support occupied by each of the synthesis filters
; 2067 :           are identified by the `dwt_low_synth_min' through
; 2068 :           `dwt_high_synth_max' members.
; 2069 :      
; 2070 :         All transform coefficients and offsets are represented using the
; 2071 :      normalization conventions of the JPEG2000 marker segments from which
; 2072 :      they are derived.  This convention means that the supplied coefficients
; 2073 :      would produce the correct output image component samples, at their
; 2074 :      declared bit-depths, if applied to codestream image components which
; 2075 :      are also expressed at their declared bit-depths. */
; 2076 : 
; 2077 : /*****************************************************************************/
; 2078 : /*                              kd_mct_stage                                 */
; 2079 : /*****************************************************************************/
; 2080 : 
; 2081 : struct kd_mct_stage {
; 2082 :   public : // Static member function
; 2083 :     static void
; 2084 :       create_stages(kd_mct_stage * &result_head,
; 2085 :                     kd_mct_stage * &result_tail,
; 2086 :                     kdu_params *params_root, int tile_num,
; 2087 :                     int num_codestream_components,
; 2088 :                     kd_comp_info *codestream_component_info,
; 2089 :                     int num_output_components,
; 2090 :                     kd_output_comp_info *output_component_info);
; 2091 :       /* This function is used to create a linked list of `kd_mct_stage'
; 2092 :          objects, which describe the inverse multi-component transform for
; 2093 :          a particular tile, identified by the `tile_num' argument.  The list
; 2094 :          of MCT stages is created from the descriptions found in the
; 2095 :          coding parameter sub-system, whose root is given by `params_root'.
; 2096 :          The remaining arguments describe the input and output image
; 2097 :          components associated with the transform.  The contents of these
; 2098 :          arrays are not modified, but they are used to contribute to the
; 2099 :          initialization of the stage contents.  Note that the
; 2100 :          `kd_output_comp_info::ref_subsampling' member of the
; 2101 :          `output_component_info' array is ignored by this function.  The
; 2102 :          caller may later use the corresponding member of the internal
; 2103 :          `output_comp_info' member array to check for dimensional
; 2104 :          consistency with the corresponding global value.
; 2105 :             The head and tail of the created list are both returned via
; 2106 :          `result_head' and `result_tail'.  A number of conditions could
; 2107 :          cause this function to fail through `kdu_error'.  In many
; 2108 :          applications this causes an exception to be thrown, after
; 2109 :          which any partially created list of transform stages should be
; 2110 :          cleaned up.  The easiest way to do this is for the function to
; 2111 :          grow the list inside an object which will persist beyond any
; 2112 :          such exception -- in practice, this is the `kd_codestream' or
; 2113 :          `kd_tile' object, both of which maintain head/tail member
; 2114 :          variables for MCT stage lists.
; 2115 :             If `tile_num' is negative, this function is being used to create
; 2116 :          the `global_mct_head' & `global_mct_tail' members of
; 2117 :          `kd_codestream' based only on information in the main codestream
; 2118 :          header.  Strictly speaking, it is possible that insufficient
; 2119 :          marker segments might be found in the main header to do this
; 2120 :          successfully in a legal Part 2 codestream.  However, without
; 2121 :          this information it is not possible to know the dimensions of
; 2122 :          the output components ahead of time, which is an accidental oversight
; 2123 :          by the committee which defined JPEG2000 Part2.  For this reason,
; 2124 :          we shall treat such codestreams as illegal, but we shall not
; 2125 :          insist that any of the transform coefficients (linear coefficients
; 2126 :          or offsets) be available from the main codestream header; only
; 2127 :          the structure is required (MCO and MCT marker segments).  In
; 2128 :          particular, this means that the present function leaves all but
; 2129 :          the first 6 member fields of each `kd_mct_block' equal to 0
; 2130 :          (i.e., as if each transform block was a null transform) when
; 2131 :          invoked with a negative `tile_num' argument. */
; 2132 :   public: // Member functions
; 2133 :     kd_mct_stage() { memset(this,0,sizeof(*this)); }
; 2134 :     ~kd_mct_stage()
; 2135 :       {
; 2136 :         if (input_required_indices != NULL)
; 2137 :           delete[] input_required_indices;
; 2138 :         if (output_comp_info != NULL) delete[] output_comp_info;
; 2139 :         if (blocks != NULL) delete[] blocks;
; 2140 :       }
; 2141 :     void apply_output_restrictions(kd_output_comp_info *output_comp_info,
; 2142 :                                    int num_components_of_interest=0,
; 2143 :                                    const int *components_of_interest=NULL);
; 2144 :       /* This function should be directly invoked on the last stage in a
; 2145 :          list of `kd_mct_stage' objects (i.e., on the object whose
; 2146 :          `next_stage' member is NULL).  It converts the restrictions on
; 2147 :          the set of required output components, as identified by the
; 2148 :          `kd_output_comp_info::apparent_idx' values in the supplied
; 2149 :          `output_comp_info' argument (this should be the global
; 2150 :          `kd_codestream::output_comp_info' array), into a set of required
; 2151 :          input components for each stage.  Specifically, it starts
; 2152 :          by reflecting the output component requirements to the final stage
; 2153 :          in the list.  It then works backward through the stages until it
; 2154 :          arrives at the first stage, at which point the set of required
; 2155 :          codestream components is known.  In each stage, the function sets
; 2156 :          the `input_required_indices' array entries, the `apparent_idx',
; 2157 :          `from_apparent' and `apparent_block_comp_idx' members of each
; 2158 :          `output_comp_info' array, the `kd_mct_stage::num_apparent_outputs'
; 2159 :          and the `kd_mct_block::num_apparent_outputs' values.
; 2160 :             The `num_components' of interest and `components_of_interest'
; 2161 :          arguments have the same interpretation as their namesakes in the
; 2162 :          `kdu_tile::set_components_of_interest' function. */
; 2163 :   public: // Data
; 2164 :     int num_inputs;
; 2165 :     int num_required_inputs;
; 2166 :     int *input_required_indices;
; 2167 :     int num_outputs;
; 2168 :     int num_apparent_outputs;
; 2169 :     kd_output_comp_info *output_comp_info;
; 2170 :     int num_blocks;
; 2171 :     kd_mct_block *blocks;
; 2172 :     kd_mct_stage *prev_stage; // Closer to the codestream image components
; 2173 :     kd_mct_stage *next_stage; // Closer to the output image components
; 2174 :   };
; 2175 :   /* Notes:
; 2176 :        Each stage of the multi-component transform has a well-defined
; 2177 :      contiguous set of input and output components, even if not all of the
; 2178 :      components in this range are fully used or defined.  The stages appear
; 2179 :      in the order required for inverse transformation (synthesis) during
; 2180 :      decompression.  For this reason, the first `num_inputs'
; 2181 :      member for the first MCT stage is guaranteed to be equal to the
; 2182 :      number of codestream image components.
; 2183 :         In order to satisfy the constraints described by IS 15444-2,
; 2184 :      the `num_inputs' value of any one stage must not be less
; 2185 :      than the `num_outputs' value of the previous stage.  Also,
; 2186 :      every one of the `num_inputs' must be "touched" by one or
; 2187 :      another MCT block.  However, not all of the `num_outputs'
; 2188 :      need to be explicitly generated by any MCT block.  Those which are
; 2189 :      not are known as NULL components -- they are defined to be identically
; 2190 :      equal to 0.
; 2191 :         Once the list of stages has been created, the `num_outputs' value
; 2192 :      from one stage is augmented (if necessary) to the `num_inputs' value
; 2193 :      of the next stage.  This is done only to simplify the way in which
; 2194 :      stages are manipulated.
; 2195 :         The `input_required_indices' array contains one entry for each
; 2196 :      of the input components.  The k'th entry is non-negative if and only
; 2197 :      if input component k is "required", meaning that it contributes to at
; 2198 :      least one of the output components which are apparent and of interest
; 2199 :      to the application, as identified by the
; 2200 :      `kd_output_comp_info::is_of_interest' values in the
; 2201 :      `output_comp_info' array.  Moreover, non-negative indices in the
; 2202 :      `input_required_indices' array identify the ordinal position
; 2203 :      occupied by the corresponding component, in the set of all required
; 2204 :      components.  For non-initial stages, this ordinal position is the same
; 2205 :      as the apparent index of the previous stage's output component.
; 2206 :         It may not always be easy (or expedient) to determine
; 2207 :      precisely whether an input component actually contributes to the
; 2208 :      output produced by a transform block, so it is possible that the
; 2209 :      set of input components which are marked as "required" contains
; 2210 :      some components which could potentially be ignored.  Nevertheless,
; 2211 :      reasonable efforts are made to limit the set of required input
; 2212 :      components, based on the set of required output components.
; 2213 :         The `num_required_inputs' member holds the total number of
; 2214 :      non-negative entries in the `input_required_indices' array.
; 2215 :         The `prev_stage' member is NULL if this is the first stage in
; 2216 :      the inverse (synthesis) multi-component transform, meaning that the
; 2217 :      stage's input components are the codestream image components.
; 2218 :         The `next_stage' member is NULL if this is the last stage in the
; 2219 :      inverse (synthesis) multi-component transform, meaning that the stage's
; 2220 :      output components are the final output image components produced by
; 2221 :      the decompression process. */
; 2222 : 
; 2223 : /*****************************************************************************/
; 2224 : /*                              kd_codestream                                */
; 2225 : /*****************************************************************************/
; 2226 : 
; 2227 : struct kd_codestream { // State structure for the "kdu_codestream" interface
; 2228 :   public: // Member functions
; 2229 :     kd_codestream()
; 2230 :       { // We will be relying on all fields starting out as 0.
; 2231 :         memset(this,0,sizeof(*this));
; 2232 :         max_unloadable_tiles = 64; // A reasonable default value
; 2233 :       }
; 2234 :     ~kd_codestream();
; 2235 :     void construct_common();
; 2236 :       /* Called from within `kdu_codestream::create' after some initial
; 2237 :          construction work to set the thing up for input or output. */
; 2238 :     void construct_output_comp_info();
; 2239 :       /* Called if `output_comp_info' is NULL, but before (or if
; 2240 :          necessary inside) `finalize_construction'.  During reading, this
; 2241 :          function may not be called until all main header information
; 2242 :          has been parsed, since the information in `siz' is not
; 2243 :          complete until both the SIZ and CBD marker segments have been
; 2244 :          parsed.  For codestreams created for writing or for interchange,
; 2245 :          this function is called from within `construct_common'. */
; 2246 :     void finalize_construction();
; 2247 :       /* For input codestreams, this function is called immediately after
; 2248 :          the main header has been read.  For output codestreams, the
; 2249 :          call is deferred so as to give the caller an opportunity to
; 2250 :          modify coding parameters and call `kdu_params::finalize_all'.  It
; 2251 :          is invoked when information from those coding parameters is
; 2252 :          first required, which will be no later than the first call to
; 2253 :          `kdu_codestream::open_tile'. */
; 2254 :     void restrict_to_fragment(kdu_dims fragment_region,
; 2255 :                               int fragment_tiles_generated,
; 2256 :                               kdu_long fragment_tile_bytes_generated);
; 2257 :       /* This function is called immediately after `construct_common'
; 2258 :          if the `kdu_codestream::create' function supplied a non-NULL
; 2259 :          `fragment_region'. */
; 2260 :     void restart();
; 2261 :       /* Called from within `kdu_codestream::restart' to perform common
; 2262 :          re-initialization steps for an existing code-stream. */
; 2263 :     kd_tile *create_tile(kdu_coords idx);
; 2264 :       /* Creates and completely initializes a new tile, installing it in the
; 2265 :          internal array of tile references and returning a pointer to the
; 2266 :          new tile.  The pointer returned may be equal to KD_EXPIRED_TILE if
; 2267 :          the tile was found not to belong to the current region of interest.
; 2268 :          Note that this function might reclaim previously released tiles
; 2269 :          from a cache of released typical tiles, managed by the
; 2270 :          `typical_tile_cache' member.  The `idx' argument holds the absolute
; 2271 :          index of the tile, which must lie within the range represented by
; 2272 :          the `tile_indices' region member. */
; 2273 :     void trim_compressed_data();
; 2274 :       /* This function may be called periodically to trim away the storage
; 2275 :          associated with compressed data bytes which will never be included
; 2276 :          in the final compressed representation.  The function can do nothing
; 2277 :          unless `kdu_codestream::set_max_bytes' has been called to establish
; 2278 :          a target compressed length. */
; 2279 :     void calculate_min_header_cost();
; 2280 :       /* Estimates the minimum total number of header bytes required by
; 2281 :          mandatory code-stream headers, recording the results in the member
; 2282 :          variables, `min_fixed_header_size' and `min_layer_header_size'.
; 2283 :          The minimum header cost for the first k quality layers is equal to
; 2284 :          `min_fixed_header_size' + `min_layer_header_size'*k.  The initial
; 2285 :          cost includes the main header, any tile-part headers and the EOC
; 2286 :          marker.  The per-layer cost includes 1 byte for every precinct, plus
; 2287 :          an additional 2 bytes per precinct if EPH markers are used and an
; 2288 :          additional 6 bytes per precinct if SOP marker segments are used.  The
; 2289 :          costs reported here deliberately exclude the cost of any optional PLT
; 2290 :          or TLM pointer marker segments and may underestimate the cost of
; 2291 :          tile-part headers under some conditions. */
; 2292 :     kdu_long simulate_output(kdu_long &header_bytes,
; 2293 :                              int layer_idx, kdu_uint16 slope_threshold,
; 2294 :                              bool finalize_layer, bool last_layer,
; 2295 :                              kdu_long max_bytes=KDU_LONG_HUGE,
; 2296 :                              kdu_long *sloppy_bytes=NULL);
; 2297 :       /* This function plays a critical role in rate control and preparing
; 2298 :          for code-stream generation.  It may be used in applications which
; 2299 :          generate the entire code-stream once all precinct data has been
; 2300 :          generated, but it may also be used in applications which generate
; 2301 :          the code-stream incrementally, periodically sizing and generating
; 2302 :          whatever portion of the code-stream can be written, given the
; 2303 :          code-blocks which have been encoded so far.
; 2304 :             To understand the operation of this function, it is helpful to
; 2305 :          know that whenever a precinct's code-blocks have been encoded, the
; 2306 :          precinct is entered onto a "ready" list.  When the present function
; 2307 :          is called, it simulates the process of generating final code-stream
; 2308 :          output for a single quality layer of all such "ready" precincts.
; 2309 :          If the "ready" precincts are not sufficient to generate the
; 2310 :          full code-stream, their size is automatically scaled, using an
; 2311 :          algorithm which attempts to estimate the number of bytes which
; 2312 :          would be occupied by all packets belonging to the indicated layer
; 2313 :          which have not yet been written to the code-stream.  For this reason,
; 2314 :          the `max_bytes' value supplied to this function should represent
; 2315 :          the maximum number of bytes which are allowed for all packets
; 2316 :          belonging to the indicated layer, minus the number of bytes which
; 2317 :          have already been written for packets belonging to that layer.
; 2318 :             The simulation process is driven by the supplied distortion-length
; 2319 :          slope threshold.  A slope threshold of 0 yields the largest possible
; 2320 :          output size and 0xFFFF yielding the smallest possible output size
; 2321 :          (all code-block bytes discarded).
; 2322 :             The number of bytes returned includes the extra cost of tile and
; 2323 :          packet headers.  The number of such header bytes is also separately
; 2324 :          returned via the `header_bytes' argument.  The function deliberately
; 2325 :          does not count the cost of PLT or TLM marker segments.  Also,
; 2326 :          certain combinations of the ORGtparts and Porder code-stream
; 2327 :          parameter attributes can lead to minor inaccuracies in the simulated
; 2328 :          lengths due to difficulties in anticipating the number of tile-parts
; 2329 :          which will need to be written.  Both the return value and the
; 2330 :          `header_bytes' value are scaled to represent the expected cost over
; 2331 :          all packets of the indicated layer which have not yet been written
; 2332 :          to the code-stream.
; 2333 :             The `finalize_layer' argument should be true if this is the last
; 2334 :          call to this function with the current layer index.  This causes the
; 2335 :          packet header state information to be saved to a place from which
; 2336 :          it will be restored in each simulation attempt for the next layer.
; 2337 :          Also, it is mandatory to finalize the layers during simulation
; 2338 :          before actually generating packet data.
; 2339 :             The `last_layer' argument should be true if this is the final
; 2340 :          layer for which any information will be generated.  If any tile
; 2341 :          contains more layers, their contribution will be included at this
; 2342 :          point as empty packets (i.e., the empty packet bit is set to 0).
; 2343 :          Any such empty packet is never assigned an SOP marker.
; 2344 :             The `max_bytes' argument may be used to supply an upper bound on
; 2345 :          the total number of bytes which are allowed to be generated here.
; 2346 :          This allows the simulation process to stop as soon as this limit
; 2347 :          is exceeded.  In this case, the returned byte count may not be a
; 2348 :          true reflection of the full cost of generating the layer, but it
; 2349 :          is guaranteed to exceed the `max_bytes' limit.
; 2350 :             When the function is called with `finalize_layer' true, the
; 2351 :          `max_bytes' limit must not, under any circumstances be exceeded.
; 2352 :          The assumption is that the caller has already done the work of
; 2353 :          figuring out a slope threshold which will satisfy the relevant
; 2354 :          rate constraint -- if not, `max_bytes' can be set to
; 2355 :          KDU_LONG_HUGE (the default).  Note that KDU_LONG_HUGE is a
; 2356 :          very large "kdu_long" value which can be represented exactly as a
; 2357 :          double precision floating point quantity; it may be less than
; 2358 :          KDU_LONG_MAX.
; 2359 :             A non-NULL `sloppy_bytes' argument may be supplied only when
; 2360 :          finalizing the last layer, once all code-blocks in the entire
; 2361 :          code-stream have been generated.  In this case, the caller must be
; 2362 :          certain that a slope threshold of `slope_threshold'+1 can satisfy
; 2363 :          the limit imposed by `max_bytes'.  The function first runs the low
; 2364 :          level packet-oriented simulation tools with this value of
; 2365 :          `slope_threshold'+1 and then runs them again (this time finalizing)
; 2366 :          with `slope_threshold'.  On the second run, any additional coding
; 2367 :          passes which would be contributed due to the reduced threshold are
; 2368 :          trimmed away from the relevant code-blocks (they cannot be recovered
; 2369 :          later on) until the number of additional bytes is less than the value
; 2370 :          of *`sloppy_bytes'.  The *`sloppy_bytes' is progressively decremented,
; 2371 :          so that upon return the caller may determine the total number of
; 2372 :          available bytes which could not be used up.  The caller should then
; 2373 :          generate packet data using the supplied slope threshold.
; 2374 :             This `sloppy_bytes' option slows down the rate control process and
; 2375 :          is recommended primarily when you can expect quite a few code-block
; 2376 :          passes to have the same length-distortion slope value.  This happens
; 2377 :          during transcoding, where the only slope information available comes
; 2378 :          from the indices of the quality layers to which the coding passes
; 2379 :          originally contributed.  It may also happen if the block encoder
; 2380 :          does not collect a rich set of length-distortion statistics, simply
; 2381 :          estimating a rough prioritization instead. */
; 2382 :     void pcrd_opt(bool trim_to_rate, double tolerance);
; 2383 :       /* Runs the PCRD-opt algorithm to find the slope thresholds for each
; 2384 :          of the `num_sized_layers' quality layers for which an entry appears
; 2385 :          in the `layer_targets', `layer_sizes' and `layer_thresholds' arrays.
; 2386 :          Upon return, the `layer_thresholds' array holds the distortion-length
; 2387 :          slope thresholds for each quality layer, which are found to achieve
; 2388 :          the cumulative layer sizes specified in the `layer_targets' array, as
; 2389 :          closely as possible.
; 2390 :             Non-zero entries in the `layer_targets' array are not altered by
; 2391 :          this function.  Any entry which is found to be zero is replaced by
; 2392 :          a suitable non-zero target size, based on the following principles:
; 2393 :          1) Cumulative layer target sizes are to be spaced logarithmically.
; 2394 :             This policy allows target sizes to be assigned to any layer which
; 2395 :             falls between layers having known target sizes.
; 2396 :          2) If the last quality layer has an unknown size, all remaining
; 2397 :             coded data will be included in that layer and its entry in the
; 2398 :             `layer_targets' array will be set equal to the actual cumulative
; 2399 :             number of bytes allocated to all quality layers.
; 2400 :          3) If one or more initial layer have an unknown target size, their
; 2401 :             target sizes will be assigned logarithmically following the
; 2402 :             convention that each layer should increase the cumulative size
; 2403 :             by a factor of sqrt(2).
; 2404 :                The function is designed to work under both single flush and
; 2405 :          incremental flushing conditions.  When incremental flushing is used,
; 2406 :          the function will be called multiple times.  Each call determines a
; 2407 :          suitable set of slope thresholds for incremental code-stream, after
; 2408 :          which the caller performs the incremental code-stream generation.
; 2409 :          This latter activity updates entries in the `layer_sizes' array
; 2410 :          which keeps track of the total size of each quality layer, excluding
; 2411 :          optional pointer information.  The `layer_targets' values refer to
; 2412 :          the cumulative size at each layer, spread over the entire code-stream.
; 2413 :          The present function finds slope thresholds which, if applied to
; 2414 :          all code-blocks not yet written to the code-stream, would be expected
; 2415 :          to produce a number of bytes equal to the relevant `layer_targets'
; 2416 :          value minus the corresponding `layer_sizes' value.
; 2417 :                The `trim_to_rate' argument has the same interpretation as it
; 2418 :          does in the `kdu_codestream::flush' function.  You should not use this
; 2419 :          option unless all code-blocks have already been encoded, meaning that
; 2420 :          this is the last call to this function prior to complete generation
; 2421 :          of the code-stream.
; 2422 :                The `tolerance' argument also has the same interpretation as it
; 2423 :          does in the `kdu_codestream::flush' function.  There is no restriction
; 2424 :          on its use.
; 2425 :     */
; 2426 :     bool generate_codestream(int max_layers);
; 2427 :       /* Generates as much of the final code-stream as possible, given the
; 2428 :          packet progression order which has been selected and the precincts
; 2429 :          which have actually been finalized.  Returns true if the code-stream
; 2430 :          has been completely generated after this function finishes its
; 2431 :          work; in this case, the EOC marker is also written.
; 2432 :          Returns false otherwise.
; 2433 :             The contents of each quality layer are determined from the
; 2434 :          distortion-length slope thresholds recorded in the `layer_thresholds'
; 2435 :          member array.  The number of available thresholds must not be less
; 2436 :          than `max_layers'.  If `max_layers' is less than the number of actual
; 2437 :          quality layers in any tile, the additional quality layers will all
; 2438 :          be assigned empty packets.
; 2439 :             The "prcr_opt" member function will normally be used first to find
; 2440 :          distortion-length slope thresholds for the various quality layers.
; 2441 :          In any event, some simulation must have been performed to set up the
; 2442 :          packet size information required to determine tile-part header sizes,
; 2443 :          which are required for writing SOT marker segments.  This function
; 2444 :          always creates at least one new tile-part for every tile.  If
; 2445 :          requested, PLT marker segments are written into the tile-part headers
; 2446 :          to identify the lengths of packets generated in this call. */
; 2447 :     void set_reserved_layer_info_bytes(int num_layers);
; 2448 :       /* Sets aside a certain number of bytes for writing a comment marker
; 2449 :          containing a text description of the size and distortion-length slope
; 2450 :          associated with each layer.  The actual marker must be written by
; 2451 :          a subsequent call to `gen_layer_info_comment'. */
; 2452 :     void gen_layer_info_comment(int num_layers, kdu_long *layer_bytes,
; 2453 :                                 kdu_uint16 *thresholds);
; 2454 :       /* Writes the comment marker identified above in connection with
; 2455 :          `set_reserved_layer_info_bytes'. */
; 2456 :     void unload_tiles_to_cache_threshold();
; 2457 :       /* Releases unloadable tiles until the memory cache and/or unloadable
; 2458 :          tile count threshold is reached.  The function first tries to
; 2459 :          release those unloadable tiles which do not lie in the current
; 2460 :          region of interest.  If one or both thresholds are still exceeded,
; 2461 :          the function continues to release unloadable tiles, even if they
; 2462 :          do belong to the current region of interest. */
; 2463 :   private: // Helper functions
; 2464 :     void read_main_header();
; 2465 :       /* Only for input objects.  Reads all main header marker segments
; 2466 :          (starting just after the SIZ marker segment) up to and
; 2467 :          including the first SOT marker.  This function is shared
; 2468 :          by both `construct_common' and `restart'. */
; 2469 :     void freeze_comments();
; 2470 :       /* Called right before any generation or simulation tasks for code-stream
; 2471 :          generation. */
; 2472 :   public: // Links to Other Objects
; 2473 :     kdu_message *textualize_out; // NULL unless params to be textualized
; 2474 : 
; 2475 :   public: // Owned Resources
; 2476 :     kd_compressed_input *in; // NULL unless an input codestream object.
; 2477 :     kd_compressed_output *out; // NULL unless an output codestream object.
; 2478 :     siz_params *siz;
; 2479 :     kd_marker *marker; // General marker reading service. NULL if `in' is NULL
; 2480 :     kd_pp_markers *ppm_markers; // NULL unless PPM markers are used.
; 2481 :     kd_buf_server *buf_server; // Serves resources to buffer compressed data
; 2482 :     kdu_block *block; // Shared resource, used by non-threaded applications
; 2483 :     kd_compressed_stats *stats; // NULL unless rate prediction is being used.
; 2484 :     kd_tpart_pointer_server *tpart_ptr_server; // NULL if not keeping addresses
; 2485 :     kd_precinct_server *precinct_server; // Always active
; 2486 :     kd_codestream_comment *comhead, *comtail; // Linked list of comments
; 2487 :     kd_tlm_generator tlm_generator; // Not initialized until the first
; 2488 :                  // call to `generate_codestream', and then only if required.
; 2489 :     kd_mct_stage *global_mct_head; // Provided for robust cleanup if error
; 2490 :     kd_mct_stage *global_mct_tail; // occurs while constructing MCT stage list.
; 2491 : 
; 2492 :   public: // Dimensions and Parameters
; 2493 :     int profile; // 0 thru 5.  Adjusted if a violation is detected.
; 2494 :     bool uses_mct; // If the `Sextensions_MCT' flag is present in SIZ.
; 2495 :     int num_components; // Number of codestream image components.
; 2496 :     int num_apparent_components; // Codestream components visible acrosss API
; 2497 :     int num_output_components; // Same as `num_components' unless MCT is used
; 2498 :     int num_apparent_output_components; // =`num_apparent_components' if no MCT
; 2499 :     kdu_component_access_mode component_access_mode; // See below
; 2500 :     kdu_dims canvas; // Holds the image origin and dimensions; this is
; 2501 :                      // affected by fragment regions
; 2502 :     kdu_dims tile_partition; // Holds the tiling origin and dimensions; this
; 2503 :                              // is not affected by fragment regions
; 2504 :     kdu_coords tile_span; // Tiles across and down the entire codestream
; 2505 :     kdu_dims tile_indices; // Range of tile indices in `tile_refs' array
; 2506 :     int discard_levels, min_dwt_levels, max_apparent_layers;
; 2507 :     int max_tile_layers; // Max layers in any tile opened so far.
; 2508 :     int num_open_tiles; // Number of tiles opened, but not yet closed.
; 2509 :     kdu_dims region; // Current region of interest; often identical to `canvas'
; 2510 :     bool cannot_flip; // If true, codestream not compatible with view flipping
; 2511 :     bool initial_fragment; // These are both true, except possibly when
; 2512 :     bool final_fragment; // generating fragmented codestreams
; 2513 :     double fragment_area_fraction; // Fraction of image in current fragment
; 2514 :     int prev_tiles_written;           // These two parameters are zero, except
; 2515 :     kdu_long prev_tile_bytes_written; // when `initial_fragment' is false.
; 2516 : 
; 2517 :   public: // Arrays
; 2518 :     kd_comp_info *comp_info; // Array with `num_components' members
; 2519 :     kd_output_comp_info *output_comp_info; // `num_output_components' members
; 2520 :     kd_tile_ref *tile_refs; // One for each tile, in raster order
; 2521 : 
; 2522 :   public: // Information used for code-stream generation and rate control
; 2523 :     kd_tile *tiles_in_progress_head; // Head & tail for list of tiles which
; 2524 :     kd_tile *tiles_in_progress_tail; // have been opened, but not yet flushed
; 2525 :     kd_global_rescomp *global_rescomps; // Manages precincts ready for output
; 2526 :     int num_incomplete_tiles; // Number of tiles for which one or more
; 2527 :                               // packets have yet to be generated.
; 2528 :     int num_sized_layers; // Number of elements in each of the following arrays
; 2529 :     kdu_long *layer_sizes; // Bytes written to each layer; non-cumulative
; 2530 :     kdu_long *layer_targets; // Target sizes for each layer; cumulative
; 2531 :       // maintain state between multiple invocations of `kdu_codestream::flush'
; 2532 :     kdu_uint16 *layer_thresholds; // Used by `kdu_codestream::flush' to store
; 2533 :       // slope thresholds between code-stream sizing and generation.
; 2534 :     kdu_long min_fixed_header_size; // See description of the function,
; 2535 :     kdu_long min_layer_header_size; // `calculate_min_header_cost'.
; 2536 :     bool reslength_constraints_used; // If reslength constraints used anywhere 
; 2537 :     bool reslength_constraints_violated; // If any reslength constraint failed
; 2538 :     bool reslength_warning_issued; // If using together with incremental flush
; 2539 :     kd_reslength_checker *reslength_checkers; // 1+`num_components' entries;
; 2540 :         // first entry holds global reslength checker; then one per component.
; 2541 :   
; 2542 :   public: // Flags and other State Variables
; 2543 :     bool allow_restart; // True if `kdu_codestream::restart' is allowed
; 2544 :     bool transpose, vflip, hflip; // Geometric manipulation parameters
; 2545 :     bool resilient; // If true, error resilience is maximized.
; 2546 :     bool expect_ubiquitous_sops; // See declaration of "set_resilient" function
; 2547 :     bool fussy; // If true, sensitivity to correctness is maximized.
; 2548 :     bool interchange; // True if `in' and `out' are both NULL.
; 2549 :     bool simulate_parsing_while_counting_bytes; // See `set_max_bytes'
; 2550 :     bool persistent; // If `interchange' is true or if an input object's
; 2551 :                      // `kdu_codestream::set_persistent' function was called
; 2552 :     bool cached; // True if compressed source advertises KDU_SOURCE_CAP_CACHED
; 2553 :     bool in_memory_source; // True if `in' offers `KDU_SOURCE_CAP_IN_MEMORY'
; 2554 :     bool tiles_accessed; // Becomes false after first tile access
; 2555 :     bool construction_finalized; // True once `finalize_construction' is called
; 2556 :     bool comments_frozen; // True after header sizing has started
; 2557 :     bool header_generated; // True once main header has been written.
; 2558 :     kdu_int32 block_truncation_factor;// Used only by `kdu_subband::open_block'
; 2559 :     kdu_long header_length; // Num bytes written to main header
; 2560 :     int reserved_layer_info_bytes; // Bytes reserved for layer info COM segment
; 2561 :     kd_tile *active_tile; // NULL unless we are in the middle of reading a tile
; 2562 :     kdu_long next_sot_address; // For seeking to the next unread tile-part.
; 2563 :     int next_tnum; // Negative, except while scanning 1'st tparts in Profile-0
; 2564 :     int num_completed_tparts; // Number of tile-parts actually read or written.
; 2565 :     kdu_uint16 min_slope_threshold; // 0 until `set_min_slope_threshold' called
; 2566 :     clock_t start_time; // Used by `report_cpu_time'.
; 2567 : 
; 2568 :   public: // Tile cache management
; 2569 :     kd_tile *unloadable_tiles_head;
; 2570 :     kd_tile *unloadable_tiles_tail; // Tiles enter list from the tail
; 2571 :     kd_tile *unloadable_tile_scan; // Points to next tile in the list, to be
; 2572 :         // checked by `unload_tiles_to_cache_threshold' to see if it belongs
; 2573 :         // to the current region of interest.  Becomes NULL if all tiles in
; 2574 :         // the unloadable list belong to the region of interest.
; 2575 :     int num_unloadable_tiles; // Number of tiles in unloadable list
; 2576 :     int max_unloadable_tiles; // Limits the length of the unloadable tiles
; 2577 :         // list to avoid long searches for tiles which belong to the current
; 2578 :         // region of interest.
; 2579 :     kd_tile *typical_tile_cache; // List of released typical tiles, all of
; 2580 :                                  // which have `kd_tile::tile_ref'=NULL.
; 2581 :   };
; 2582 :   /* Notes:
; 2583 :          The `num_tparts_used' count does not include tiles which we skipped
; 2584 :      over since they had no intersection with the region of interest.
; 2585 :          The `active_tile' member is used during code-stream parsing to keep
; 2586 :      track of the tile whose tile-part is being actively parsed.  If `cached'
; 2587 :      is true, the compressed data is managed by a cache and there is no
; 2588 :      parsing as such.  In this case, `active_tile' is always NULL and
; 2589 :      `tpart_ptr_server' should remain NULL.
; 2590 :          The `global_rescomps' array contains 33*num_components entries.
; 2591 :      The entry at location d*num_components+c is used to manage precincts
; 2592 :      which are ready for rate-control simulation, belonging to component c
; 2593 :      at resolution depth d.  Depth 0 corresponds to the highest resolution
; 2594 :      level of each tile of component c.
; 2595 :          Information is maintained for two different types of image
; 2596 :      components here.  Most of the machinery is concerned with so-called
; 2597 :      "codestream image components".  These are the ones which are subjected
; 2598 :      to spatial DWT, quantization and block coding processes.  Consequently,
; 2599 :      we commonly refer to these simply as the components.  The image
; 2600 :      components, however, are often subjected to subsequent inverse
; 2601 :      colour or multi-component transformation processes in order to
; 2602 :      reconstruct a final image.  We refer to the components (or planes) of
; 2603 :      the final reconstructed image as "output image components".  The
; 2604 :      output components are described by the `num_output_components',
; 2605 :      `num_apparent_output_components' and `output_comp_info' members.
; 2606 :          As discussed extensively in the comments appearing with the second
; 2607 :      form of the `kdu_codestream::apply_input_restrictions' function, the
; 2608 :      set of visible (or apparent) output components may be different to
; 2609 :      the set of visible (or apparent) codestream components.  In fact, only
; 2610 :      one of these two sets of components may be restricted at any given
; 2611 :      time, depending on the state of the `component_access_mode' member.
; 2612 :         If `component_access_mode' is set to `KDU_WANT_CODESTREAM_COMPONENTS',
; 2613 :      the set of codestream components may be restricted or permuted via the
; 2614 :      `num_apparent_components' member, working in conjunction with
; 2615 :      `kd_comp_info::apparent_idx' and `kd_comp_info::from_apparent'.  In this
; 2616 :      case, however, information about output components will not be made
; 2617 :      available over the API -- output components will be treated as synonymous
; 2618 :      with codestream components.
; 2619 :         If `component_access_mode' is set to `KDU_WANT_OUTPUT_COMPONENTS', the
; 2620 :      set of output components may be restricted or permuted via the
; 2621 :      `num_apparent_output_components' member, working in conjunction with
; 2622 :      `kd_output_comp_info::apparent_idx' and
; 2623 :      `kd_output_comp_info::from_apparent'.  In this case, all codestream
; 2624 :      components are visible across the API in their original form, except
; 2625 :      that applications will not be able to access a non-empty
; 2626 :      `kdu_tile_comp' interface for any tile-component which is not
; 2627 :      involved in the reconstruction of any visible output components within
; 2628 :      the relevant tile (this may vary from tile to tile). */
; 2629 : 
; 2630 : /*****************************************************************************/
; 2631 : /*                                kd_tile                                    */
; 2632 : /*****************************************************************************/
; 2633 : 
; 2634 : #define KD_EXPIRED_TILE ((kd_tile *)(-1))
; 2635 : 
; 2636 : struct kd_tile { // State structure for the "kdu_tile" interface
; 2637 :   public: // Member functions
; 2638 :     kd_tile(kd_codestream *codestream, kd_tile_ref *tref,
; 2639 :             kdu_coords idx, kdu_dims tile_dims);
; 2640 :       /* Sets up only enough information for the tile to locate itself
; 2641 :          within the codestream canvas.  `idx' holds the absolute index of
; 2642 :          the tile, but this must lie within the range identified by
; 2643 :          `codestream->tile_indices'. */
; 2644 :     ~kd_tile();
; 2645 :       /* Note that this function also detaches the tile object from the
; 2646 :          codestream object which references it, replacing the pointer with
; 2647 :          the special illegal value, KD_EXPIRED_TILE. */
; 2648 :     void release();
; 2649 :       /* This function serves a similar role to the destructor, except that
; 2650 :          it reserves the option to move the object onto a list of cached
; 2651 :          "typical" tiles managed by the `kd_codestream' object.  This is
; 2652 :          done if the tile has its `is_typical' member set to true and if the
; 2653 :          codestream is open for reading.  The cached typical tile's structure
; 2654 :          can be reused in the future, without rebuilding it from scratch,
; 2655 :          subject to appropriate conditions.  If the function chooses not to
; 2656 :          move the tile onto the typical list, the destructor will be invoked,
; 2657 :          so this is a self-efacing function. */
; 2658 :     void initialize();
; 2659 :       /* Called immediately after a successful construction.  Builds all
; 2660 :          subordinate structures and fills in all fields.   If the codestream
; 2661 :          object has the persistent mode (applies to persistent input objects
; 2662 :          and all interchange objects), the region of interest members
; 2663 :          in the tile and all of its subordinate structures will be set to
; 2664 :          empty regions. Otherwise, the `set_elements_of_interest' function
; 2665 :          will be called immediately. */
; 2666 :     void recycle(kd_tile_ref *tref, kdu_coords idx, kdu_dims tile_dims);
; 2667 :       /* This function is similar to `initialize', but works on a previously
; 2668 :          constructed (typical) tile, rather than a tile which has been
; 2669 :          freshly created using the constructor.  If possible, the function
; 2670 :          will reuse the previously constructed structures (this is generally
; 2671 :          possible if the new tile is also a typical one).  Otherwise, it
; 2672 :          will delete those structures and invoke `initialize' to start over
; 2673 :          again.  The function is called only from `kd_codestream::create_tile'
; 2674 :          and only on tiles which were previously added to the typical tile
; 2675 :          cache by `kd_tile::release'. */
; 2676 :     void restart();
; 2677 :       /* Called from within `kdu_codestream::restart', so as to recycle all
; 2678 :          resources as early as possible and reset state variables in
; 2679 :          preparation for re-use.  Sets the `needs_reinit' flag, since
; 2680 :          the `reinitialize' function must be called to complete the restart
; 2681 :          operation -- this is deferred until the tile is first accessed
; 2682 :          (opened, or accessed for parsing). */
; 2683 :     void reinitialize();
; 2684 :       /* Called when a tile is first accessed in any way, after a previous
; 2685 :          call to `restart' (i.e., after a code-stream restart). */
; 2686 :     void open();
; 2687 :       /* Called by `kdu_codestream::open_tile' after the tile has been
; 2688 :          constructed and initialized (if necessary).  The function marks
; 2689 :          the tile as open until it is subsequently closed.  If the codestream
; 2690 :          object has the persistent mode (applies to persistent and all
; 2691 :          interchange objects), the tile's region of interest fields will
; 2692 :          all be set up here. */
; 2693 :     bool read_tile_part_header();
; 2694 :       /* Returns false, if the code-stream source was exhausted before a
; 2695 :          new tile-part header could be completely read (up to and including
; 2696 :          the SOD marker).  Except in this event, the current tile become's
; 2697 :          the codestream object's active tile upon return. */
; 2698 :     bool finished_reading();
; 2699 :       /* This function may be called as soon as we can be sure that no more
; 2700 :          information can be read for the tile.  When this happens, the tile
; 2701 :          is marked as `exhausted' and a search is conducted to see if we can
; 2702 :          destroy any precincts whose existence serves only to allow the parsing
; 2703 :          of packet headers.
; 2704 :             It can happen that the tile deletes itself inside this function,
; 2705 :          if the tile's resources are no longer needed by the application.  In
; 2706 :          this case, the function returns true, indicating to the caller that
; 2707 :          no further attempt should be made to reference the tile.  In all
; 2708 :          other circumstances, the function returns false. */
; 2709 :     kdu_long generate_tile_part(int max_layers, kdu_uint16 slope_thresholds[]);
; 2710 :       /* If all packets for the tile have already been transferred, the
; 2711 :          function does nothing and returns 0.  Otherwise, it generates the
; 2712 :          next tile-part header and all packets for that tile-part, using the
; 2713 :          packet sequencer to determine both the order of packets and the
; 2714 :          number of packets which belong to this tile-part.  The number
; 2715 :          of packets generated may be limited by the number of precincts
; 2716 :          for which code-block data is currently available.  The function
; 2717 :          returns the total number of bytes in the tile-part, including all
; 2718 :          marker codes and segments.
; 2719 :             The `max_layers' argument indicates the number of quality layers
; 2720 :          for which rate allocation information is available in the
; 2721 :          `slope_thresholds' array.  If the tile contains additional layers,
; 2722 :          the corresponding packets are assigned the special empty packet code,
; 2723 :          occupying only a single byte.
; 2724 :             If this function completes the generation of all the tile data,
; 2725 :          it may release the tile itself, unless its continued existence is
; 2726 :          otherwise required (e.g., it may be open for access by the
; 2727 :          application).  Also, if the maximum number of tile-parts advertised
; 2728 :          by a `codestream->tlm_generator' object exceeds the number of
; 2729 :          tile-parts actually generated when the tile data has all been
; 2730 :          written, the function writes extra empty tile-parts as required.
; 2731 :          The empty tile-parts are each 14 bytes long, but the function
; 2732 :          returns only the size of the last non-empty tile-part which was
; 2733 :          generated. */
; 2734 :     void remove_from_in_progress_list();
; 2735 :       /* This function is called after the last tile-part of a tile has been
; 2736 :          generated.  It is also called when destroying or restarting a tile,
; 2737 :          just to be on the safe side, although it should have been removed
; 2738 :          from the in-progress list previously.  See the notes below for a
; 2739 :          discussion of "in-progress" tiles. */
; 2740 :     void adjust_unloadability()
; 2741 :       { // Called when any of the conditions described in the notes below
; 2742 :         // associated with tile unloadability might have changed.
; 2743 :         if ((!codestream->persistent) ||
; 2744 :             ((codestream->tpart_ptr_server==NULL) && !codestream->cached))
; 2745 :           { assert(!is_unloadable); return; }
; 2746 :         if (is_open || (this==codestream->active_tile))
; 2747 :           { // Should not be on the unloadable list
; 2748 :             if (is_unloadable)
; 2749 :               withdraw_from_unloadable_list();
; 2750 :           }
; 2751 :         else
; 2752 :           { // Should be on the unloadable list
; 2753 :             if (!is_unloadable)
; 2754 :               add_to_unloadable_list();
; 2755 :           }
; 2756 :       }
; 2757 :   private: // Helper functions
; 2758 :     friend class kdu_tile;
; 2759 :     void set_elements_of_interest();
; 2760 :       /* Called from within `kd_tile::open' and/or `kd_tile::initialize'
; 2761 :          to mark each component, resolution, subband, precinct and
; 2762 :          precinct-band with the current region of interest, resolution of
; 2763 :          interest, components of interest and layers of interest.  If the
; 2764 :          codestream mode is "persistent" (applies to input objects and all
; 2765 :          interchange objects), this function is delayed until the tile is
; 2766 :          opened (an event which may occur any number of times, with different
; 2767 :          regions, resolutions, components and layers of interest).  Otherwise,
; 2768 :          the function is called only once, when the tile is initialized.  This
; 2769 :          is important, since non-persistent input objects' resources will be
; 2770 :          cleaned up as soon as they are known not to be
; 2771 :          required.  To do this, region of interest information must be made
; 2772 :          available during parsing, which may occur prior to the point at which
; 2773 :          a tile is actually opened. */
; 2774 :     void withdraw_from_unloadable_list();
; 2775 :       /* Removes a tile, whose `is_unloadable' member is true, from the
; 2776 :          unloadable tiles list managed by `kd_codestream', leaving
; 2777 :          `is_unloadable' equal to false. */
; 2778 :     void add_to_unloadable_list();
; 2779 :       /* Adds a tile, whose `is_unloadable' member is false, to the
; 2780 :          unloadable tiles list managed by `kd_codestream', leaving
; 2781 :          `is_unloadable' equal to true. */
; 2782 :     float find_multicomponent_energy_gain(int comp_idx,
; 2783 :                                           bool restrict_to_interest);
; 2784 :       /* Finds the energy gain factor associated with the contribution of
; 2785 :          the indicated codestream image component to the output image
; 2786 :          components.  For this purpose, an impulsive distortion in codestream
; 2787 :          component `comp_idx' is considered, having magnitude equal to the
; 2788 :          component's nominal range.  The impact of this impulsive distortion
; 2789 :          is evaluated at the outputs of any multi-component transform, or
; 2790 :          Part-1 colour transform.  The resulting output distortion is
; 2791 :          expressed relative to each output component's nominal range and
; 2792 :          the sum of these squared normalized quantities is taken and returned.
; 2793 :          If `restrict_to_interest' is true, output distortion contributions
; 2794 :          are ignored if they are not currently of interest to the
; 2795 :          application. */
; 2796 :   public: // Links and Identification
; 2797 :     kd_codestream *codestream;
; 2798 :     int t_num; // Absolute tile-number, as used by parameter sub-system
; 2799 :     kdu_coords t_idx; // Absolute 2D tile-index
; 2800 :     kd_tile_ref *tile_ref; // Points to entry in `kd_codestream::tile_refs'
; 2801 :                            // which points to us, or NULL if we are not there.
; 2802 :     kd_tpart_pointer *tpart_ptrs; // Pointers for seekable sources
; 2803 :     kd_tile *in_progress_next, *in_progress_prev; // See below
; 2804 :     kd_tile *unloadable_next, *unloadable_prev; // See below
; 2805 :     kd_tile *typical_next; // Used to build a list of released typical tiles.
; 2806 :                            // Tiles on this list have `tile_ref'=NULL
; 2807 : 
; 2808 :   public: // Owned Resources
; 2809 :     kd_pp_markers *ppt_markers; // NULL except possibly in tpart header reading
; 2810 :     kd_pph_input *packed_headers; // NULL unless tile has packed packet headers
; 2811 :     kd_packet_sequencer *sequencer;
; 2812 :     kd_precinct_pointer_server precinct_pointer_server;
; 2813 :     kd_reslength_checker *reslength_checkers; // 1+`num_components' entries;
; 2814 :       // same structure as `kd_codestream::reslength_checkers' but for
; 2815 :       // tile-specific reslength constraints.
; 2816 :   
; 2817 :   public: // Dimensions and Parameters
; 2818 :     bool is_typical; // All typical tiles have the same structure & transform
; 2819 :     bool fully_typical; // All fully typical tiles have identical coding params
; 2820 :     int num_components; // Number of tile-components
; 2821 :     int num_layers;
; 2822 :     int num_apparent_layers;
; 2823 :     int max_relevant_layers; // See below
; 2824 :     kdu_long total_precincts; // Used only during code-stream generation
; 2825 :     kdu_long max_relevant_packets; // See below
; 2826 :     kdu_dims dims; // Region occupied by the tile on the canvas
; 2827 :     kdu_dims region; // Region of interest within tile.
; 2828 :     kdu_coords coding_origin;
; 2829 : 
; 2830 :   public: // Arrays and Lists
; 2831 :     kd_mct_stage *mct_head; // Linked list of MCT stages, starting from the one
; 2832 :     kd_mct_stage *mct_tail; // whose input components are the tile-components
; 2833 :     kd_tile_comp *comps;
; 2834 :     kdu_long structure_bytes; // Total bytes contained in all embedded
; 2835 :         // structures, excepting only precincts and code-block bit-stream
; 2836 :         // buffers.  Whenever this value changes, the changes should also be
; 2837 :         // reflected in the `codestream->buf_server' object, so that the total
; 2838 :         // memory load associated with tile data structures can be included in
; 2839 :         // cache threshold calculations.  This enables precinct and tile
; 2840 :         // unloading decisions to be made in a wholistic way, based on
; 2841 :         // total memory consumption.
; 2842 : 
; 2843 :   public: // Flags and other State Variables
; 2844 :     bool use_sop, use_eph, use_ycc;
; 2845 :     bool empty_shell; // True if tile header was not available when opened.
; 2846 :     bool is_in_progress; // See `in_progress_next' and `in_progress_prev'
; 2847 :     bool is_open;
; 2848 :     bool is_unloadable; // See below
; 2849 :     bool is_addressable; // See below
; 2850 :     bool closed; // Once closed, the tile may no longer be accessed.
; 2851 :                  // Persistent tiles are never marked as closed.
; 2852 :     bool initialized; // Fields below here are valid only once initialized
; 2853 :     bool needs_reinit; // Set inside `reset' to indicate the need for
; 2854 :                        // reinitialization when the tile is first accessed.
; 2855 :     bool insert_plt_segments; // If true, PLT marker segs introduced
; 2856 :     bool resolution_tparts; // Start new tile-part at resolution boundaries
; 2857 :     bool component_tparts; // Start new tile-part at component boundaries
; 2858 :     bool layer_tparts; // Start new tile-part at layer boundaries
; 2859 :     int num_tparts; // Zero if number of tile-parts unknown.
; 2860 :     int next_tpart; // Index of next tile-part to be read or written.
; 2861 :     int sequenced_relevant_packets; // See below
; 2862 :     int next_input_packet_num;
; 2863 :     bool skipping_to_sop; // See notes below.
; 2864 :     int next_sop_sequence_num; // Valid only if `skipping_to_sop' is true.
; 2865 :     int saved_num_sequenced_packets;// For "kdu_packet_sequencer::save_state"
; 2866 :     bool exhausted; // True if no more tile-parts are available for this tile.
; 2867 :   };
; 2868 :   /* Notes:
; 2869 :         The `max_relevant_layers' member indicates the maximum number of
; 2870 :      layers from the current tile which can ever be relevant to the
; 2871 :      application.  It holds the same value as `num_layers', unless the
; 2872 :      code-stream was created for reading and is non-persistent, in which
; 2873 :      case it holds the value of `num_apparent_layers'.  This member is used
; 2874 :      to avoid parsing any more packets than we have to when reading
; 2875 :      non-persistent code-streams.
; 2876 :         The `max_relevant_packets' member is equal to the total number of
; 2877 :      packets in the tile, unless the code-stream was created for reading,
; 2878 :      is non-persistent, and `kdu_codestream::apply_input_restrictions' has
; 2879 :      been used to reduce the spatial region of interest, or to identify one
; 2880 :      or more resolutions, components or layers as irrelevant to the
; 2881 :      application.  In that case it holds the product of the number of the
; 2882 :      `max_relevant_layers' value and the number of precincts which are
; 2883 :      actually relevant to the identify spatial region, resolution and
; 2884 :      components.
; 2885 :         Similarly, `sequenced_relevant_packets' counts the number of packets
; 2886 :      which have been sequenced (either written or read, as appropriate) so
; 2887 :      far, skipping only those packets which are deemed to be irrelevant to
; 2888 :      the application.  As for `max_relevant_packets', all packets are
; 2889 :      considered relevant if the code-stream was not created for reading, or
; 2890 :      if the code-stream is persistent, regardless of any calls to
; 2891 :      `kdu_codestream::apply_input_restrictions'.  When this value reaches
; 2892 :      the value of `max_relevant_packets', there is no need to parse any
; 2893 :      further contents from the tile.
; 2894 :         If `skipping_to_sop' is true, packets are automatically discarded
; 2895 :      (this is a pseudo-transfer which leaves the packet empty) until one is
; 2896 :      reached whose packet number agrees with the value of
; 2897 :      `next_sop_sequence_num'.  To assist this operation, the
; 2898 :      `next_input_packet_num' counter keeps track of the zero-based index
; 2899 :      of the next packet to be parsed.  Note that we need a separate counter,
; 2900 :      in addition to `sequenced_relevant_packets', since not all packets
; 2901 :      which are parsed need necessarily be relevant to the application.
; 2902 :         A tile is said to be "unloadable" once the following conditions have
; 2903 :      been satisfied:
; 2904 :      1) the codestream is in persistent mode;
; 2905 :      2) the compressed data source is seekable or a cache;
; 2906 :      3) this tile is not currently open;
; 2907 :      4) this tile is not the one referenced by `kd_codestream::active';
; 2908 :      Such tiles are enterered on a list managed by the `unloadable_next'
; 2909 :      and `unloadable_prev' members, and have their `is_unloadable' flag set
; 2910 :      to true.  When an unloadable tile is deleted, the corresponding
; 2911 :      `kd_tile_ref::tile' entry is set to NULL rather than `KD_EXPIRED_TILE'.
; 2912 :      This ensures that the tile can be re-parsed from the compressed data
; 2913 :      source if required again at a later point.  Tiles on the unloadable
; 2914 :      list may be deleted automatically, according to a tile memory management
; 2915 :      policy.
; 2916 :         A tile is said to be "addressable" if the following conditions hold:
; 2917 :      1) the codestream is in input (reading) mode;
; 2918 :      2) the compressed data source is not a cache;
; 2919 :      3) the compressed data source is seekable; and
; 2920 :      4) the current tile-part contains usable precinct pointer information.
; 2921 :      Such tiles are identified by the `is_addressable' flag.  This flag is
; 2922 :      set on each call to `read_tile_part_header'.  All that actually
; 2923 :      matters is that we correctly identify when the codestream has an
; 2924 :      active tile which is not addressable; in that case, the tile's
; 2925 :      packets must be desequenced up until the end of the tile-part before
; 2926 :      any seeking on the compressed data source can be allowed.
; 2927 :         A tile is said to be "in-progress" if the following conditions
; 2928 :      apply:
; 2929 :      1) the codestream was created for output;
; 2930 :      2) the tile has already been opened -- it may or may not have been closed;
; 2931 :      3) the tile's contents have not yet been fully flushed to the codestream.
; 2932 :      In-progress tiles are entered onto a doubly-linked list managed by the
; 2933 :      `in_progress_next' and `in_progress_prev' pointers.  The head and
; 2934 :      tail of this list are managed by `kd_codestream::tiles_in_progress_head'
; 2935 :      and `kd_codestream::tiles_in_progress_tail'. */ 
; 2936 : 
; 2937 : /*****************************************************************************/
; 2938 : /*                              kd_tile_comp                                 */
; 2939 : /*****************************************************************************/
; 2940 : 
; 2941 : struct kd_tile_comp { // State structure for the "kdu_tile_comp" interface
; 2942 :   public: // Member functions
; 2943 :     kd_tile_comp()
; 2944 :       { // We will be relying on all fields starting out as 0.
; 2945 :         memset(this,0,sizeof(*this));
; 2946 :         G_tc = G_tc_restricted = -1.0F;
; 2947 :       }
; 2948 :     ~kd_tile_comp();
; 2949 :     void initialize_kernel_parameters(int atk_idx, kdu_kernels &kernels);
; 2950 :       /* On entry, the `kernel_id' member is valid.  On exit, the
; 2951 :          other `kernel_xxx' parameters are valid.  The `atk_idx' value is
; 2952 :          used only if `kernel_id' is equal to `Ckernels_ATK'.  The
; 2953 :          function leaves `kernels' initialized with the relevant transform
; 2954 :          kernel, for further use by the caller if desired. */
; 2955 :     void reset_layer_stats()
; 2956 :       {
; 2957 :         if (layer_stats != NULL)
; 2958 :           {
; 2959 :             int num_entries = ((1+dwt_levels)*tile->num_layers)<<1;
; 2960 :             memset(layer_stats,0,(size_t)(sizeof(kdu_long)*num_entries));
; 2961 :           }
; 2962 :       }
; 2963 :   public: // Links and Identification
; 2964 :     kd_codestream *codestream;
; 2965 :     kd_tile *tile;
; 2966 :     kd_comp_info *comp_info; // Ptr to relevant `codestream->comp_info' entry
; 2967 :     int cnum;
; 2968 : 
; 2969 :   public: // Dimensions and Parameters
; 2970 :     kdu_coords sub_sampling;
; 2971 :     kdu_dims dims;
; 2972 :     kdu_dims region;
; 2973 :     int dwt_levels, apparent_dwt_levels;
; 2974 :     bool reversible;
; 2975 :     int kernel_id; // Ckernels_W5X3, Ckernels_W9X7 or Ckernels_ATK
; 2976 :     bool kernel_symmetric, kernel_symmetric_extension;
; 2977 :     int kernel_num_steps;
; 2978 :     kdu_kernel_step_info *kernel_step_info, *kernel_step_info_flipped;
; 2979 :     float *kernel_coefficients, *kernel_coefficients_flipped;
; 2980 :     float kernel_low_scale; // Amount to scale low-pass lifting analysis output
; 2981 :     float kernel_high_scale; // Amount to scale hi-pass lifting analysis output
; 2982 :     int low_support_min, low_support_max; // low-pass synthesis impulse support
; 2983 :     int high_support_min, high_support_max; // high-pass synth impulse support
; 2984 :     float G_tc; // Global multi-component energy gain term; -ve if not known
; 2985 :     float G_tc_restricted; // Multi-component energy gain term based only on
; 2986 :             // those output components currently of interest; -ve if not known
; 2987 :     int recommended_extra_bits;
; 2988 :     kdu_coords blk; // Nominal code-block dimensions.
; 2989 :     int modes; // Block coder modes.  Flags defined in scope `cod_params'
; 2990 : 
; 2991 :   public: // Arrays
; 2992 :     kd_resolution *resolutions; // Contains 1+`dwt_levels' entries.
; 2993 :     kdu_long *layer_stats; // Contains `num_layers' pairs per resolution,
; 2994 :       // starting from the lowest resolution (`res_level'=0); each pair holds
; 2995 :       // number of parsed packets for the layer-resolution, followed by
; 2996 :       // number of parsed packet bytes for the layer-resolution.  Available
; 2997 :       // only for input codestreams; populated by `kd_precinct::read_packet'.
; 2998 : 
; 2999 :   public: // Flags and Other State Variables
; 3000 :     bool enabled; // See below
; 3001 :     bool is_of_interest; // See below
; 3002 :     kdu_coords grid_min; // These fields are used by "kd_packet_sequencer"
; 3003 :     kdu_coords grid_inc; // for spatially oriented progressions.
; 3004 :     kdu_coords saved_grid_min; // For "kd_packet_sequencer::save_state"
; 3005 :     kdu_coords saved_grid_inc; // For "kd_packet_sequencer::save_state"
; 3006 :   };
; 3007 :   /* Notes:
; 3008 :         `recommended_extra_bits' may be added to the sample bit-depth
; 3009 :      (precision) for this component to determine an appropriate number
; 3010 :      of bits for internal representations associated with the data
; 3011 :      processing path.
; 3012 :         In the reversible path, the value is set to the maximum bit-depth
; 3013 :      expansion factor, as reported in Table 17.4 of the book by Taubman and
; 3014 :      Marcellin, adding an extra 1 bit if the RCT has been used -- note that it
; 3015 :      is not desirable for luminance and chrominance components to have
; 3016 :      different numeric representations, since that would significantly
; 3017 :      complicate the colour transform procedure.
; 3018 :         In the irreversible path, the value is set to 7, which means
; 3019 :      that 16-bit representations are judged sufficient for 9 bit
; 3020 :      imagery or less.  Of course, the impact of selecting a reduced
; 3021 :      representation precision is only reduced accuracy in the
; 3022 :      irreversible processing path.
; 3023 :         The `enabled' flag is used to efficiently identify the tile-components
; 3024 :      which are enabled.  Remember that a tile-component may be disabled,
; 3025 :      either because the corresponding codestream image component is not
; 3026 :      apparent (only when the `kd_codestream::component_access_mode' is
; 3027 :      `KDU_WANT_CODESTREAM_COMPONENTS'), or because the tile-component
; 3028 :      is not involved in the construction of an apparent output image
; 3029 :      component (when the `kd_codestream::component_access_mode' is
; 3030 :      `KDU_WANT_OUTPUT_COMPONENTS').  In the latter case, all codestream
; 3031 :      image components are apparent, but disabled ones cannot be
; 3032 :      accessed -- this is important, since in the latter case the set
; 3033 :      of enabled components may vary from tile to tile.
; 3034 :         The `is_of_interest' flag is used to store the identify of components
; 3035 :      which are marked as being of interest, by calls to
; 3036 :      `kdu_tile::set_components_of_interest'.  This is done only when the
; 3037 :      component access mode is `KDU_WANT_CODESTREAM_COMPONENTS' or the
; 3038 :      `mct_head' member is NULL.  Otherwise, the components of interest are
; 3039 :      passed directly to the `kd_mct_stage::apply_output_restrictions'
; 3040 :      function.  Note that the `is_of_interest' flags do not generally
; 3041 :      belong to the component in which they are stored.  They are just
; 3042 :      copies of the information supplied to
; 3043 :      `kdu_tile::set_components_of_interest', without any attempt to apply
; 3044 :      any component index permutations which might be relevant. */
; 3045 : 
; 3046 : /*****************************************************************************/
; 3047 : /*                            kd_precinct_ref                                */
; 3048 : /*****************************************************************************/
; 3049 : 
; 3050 :   /* Objects of this class provide the vehicle through which precincts
; 3051 :      references are instantiated and removed from the array of precinct
; 3052 :      references maintained by the `kd_resolution' object.  It is important
; 3053 :      that the state information be small.  In particular, it has the same
; 3054 :      size as `kdu_long', which should never be smaller than the size of
; 3055 :      a memory pointer, but may be larger -- see the declaration of
; 3056 :      `kdu_long' in "elementary.h".  For precincts whose seek addresses are
; 3057 :      deduced from PLT marker segments in the code-stream, or precincts which
; 3058 :      are maintained by a caching data source, or precincts which are used by
; 3059 :      codestream objects created for interchange, this object provides
; 3060 :      facilities for recycling a disused precinct's resources while keeping its
; 3061 :      unique address around for rapid reloading in the event that it
; 3062 :      is required at a later point. */
; 3063 : 
; 3064 : class kd_precinct_ref {
; 3065 :   public: // Member functions
; 3066 :     kd_precinct_ref()
; 3067 :       { state = 0; }
; 3068 :     ~kd_precinct_ref()
; 3069 :       { if (!((state == 0) || (state & 1))) close(); }
; 3070 :     bool parsed_and_unloaded()
; 3071 :       { return ((state & 3) == 3) && (state != 3); }
; 3072 :       /* Returns true if the precinct is addressable (i.e., dynamically
; 3073 :          loadable) and it has been parsed and subsequently unloaded from
; 3074 :          memory. */
; 3075 :     kd_precinct *deref()
; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }
; 3077 :       /* Returns NULL unless the reference identifies a valid `kd_precinct'
; 3078 :          object, which is already loaded in memory. */
; 3079 :     kd_precinct *active_deref();
; 3080 :       /* Returns NULL unless the reference identifies a valid `kd_precinct'
; 3081 :          object, which is already loaded in memory and is in the active
; 3082 :          state. */
; 3083 :     kd_precinct *open(kd_resolution *res, kdu_coords pos_idx,
; 3084 :                       bool need_activate);
; 3085 :       /* Attempts to open the precinct at the indicated position within the
; 3086 :          array of precincts maintained by the indicated resolution object.
; 3087 :          `pos_idx' holds the horizontal and vertical position of the
; 3088 :          precinct (starting from 0) within the array of precincts for
; 3089 :          the given resolution.  That is, `pos_idx' holds a relative, not
; 3090 :          an absolute precinct index.
; 3091 :             If the precinct is known to be unloadable (this happens if the
; 3092 :          precinct has previously been opened and has then been permanently
; 3093 :          closed), the function returns NULL.
; 3094 :             If the precinct currently exists in memory (the `state' variable
; 3095 :          contains a valid pointer to the precinct), the function returns a
; 3096 :          pointer to that precinct; however, if `need_activate' is true
; 3097 :          and the precincts's `released' flag is true, `kd_precinct::activate'
; 3098 :          is called before returning the `kd_precinct' pointer.  When the
; 3099 :          codestream object was created for input or for interchange, the
; 3100 :          `need_activate' argument should be set to true only when the
; 3101 :          precinct is being opened in order to access code-block data.  In
; 3102 :          that case, the precinct must belong to an open tile and lie within
; 3103 :          the application's current region of interest, meaning that it will
; 3104 :          be released again when the tile is closed.  For codestream objects
; 3105 :          created for output, the argument should have no effect, since
; 3106 :          output precincts are not actually released.
; 3107 :             Otherwise, the function obtains a new `kd_precinct' object from
; 3108 :          the code-stream's precinct server and calls its `initialize'
; 3109 :          function.  If the `state' variable held the precinct's unique
; 3110 :          address value on entry, that address is written into the newly
; 3111 :          instantiated `kd_precinct' object's `unique_address' field, and
; 3112 :          the P bit (see notes on `state' below) is copied to the precinct's
; 3113 :          KD_PFLAG_PARSED flag.  If compressed data comes from a cached source,
; 3114 :          or the codestream object was created for interchange (no compressed
; 3115 :          data sources or targets), the newly created precinct is automatically
; 3116 :          marked as addressable, with its `unique_address' set to the
; 3117 :          precinct's unique identifier, as described in the comments appearing
; 3118 :          with the declaration of `kd_precinct::unique_address'.  For
; 3119 :          precincts which can be addressed using a seek address (for seekable
; 3120 :          compressed data sources), the seek address is installed using
; 3121 :          `set_address' from within the `kd_packet_sequencer::next_in_sequence'
; 3122 :          function.
; 3123 :             It is worth noting that this function may cause other precincts
; 3124 :          to be unloaded from memory, in order to conserve memory resources.
; 3125 :          If this happens, only precincts which have been released and
; 3126 :          which do not intersect with the current region of interest will be
; 3127 :          unloaded. */
; 3128 :     void close();
; 3129 :       /* Closes the active `kd_precinct' object whose pointer is in
; 3130 :          `state', calling its `closing' member function and recycling its
; 3131 :          storage.  If the precinct is marked as addressable, its
; 3132 :          `unique_address' member and KD_PFLAG_PARSED flag are recorded in
; 3133 :          `state' using the convention outlined in the notes below, allowing
; 3134 :          the precinct to be re-opened at a later point.
; 3135 :             In many cases, you are better off calling the `release' member
; 3136 :          function instead of `close' (see below).
; 3137 :             Note that this function may be safely invoked even when the
; 3138 :          precinct is not currently active -- it does nothing unless `state'
; 3139 :          holds a valid precinct address. */
; 3140 :     void close_and_reset();
; 3141 :       /* This function is used only by `kdu_tile::parse_all_relevant_packets'
; 3142 :          and then only if it is asked to parse everything from scratch.  The
; 3143 :          behaviour is similar to calling `close', except that the internal
; 3144 :          `state' record is left with its P flag reset, so that when the
; 3145 :          precinct is reloaded, its packet statistics will be entered into
; 3146 :          the `kd_tile_comp::layer_stats' array -- the caller invariably
; 3147 :          resets this array. */
; 3148 :     void release();
; 3149 :       /* This function should be called once a precinct is no longer
; 3150 :          required, in preference to the `close' function.  If the system is
; 3151 :          running low on resources, the function may unload the precinct from
; 3152 :          memory to recycle its resources.  Alternatively, the function is at
; 3153 :          liberty to leave the precinct in memory, moving it to a list of
; 3154 :          inactive precincts which are subject to unloading at some point in
; 3155 :          the future, when resources may be running low.  Non-addressable or
; 3156 :          cached precincts are unloaded immediately, since they are
; 3157 :          guaranteed never to be re-opened once `release' has been called. */
; 3158 :     void clear();
; 3159 :       /* This function recycles the storage associated with any existing
; 3160 :          precinct and sets the internal `state' variable to 0.  It is called
; 3161 :          when the code-stream management machinery is restarted. */
; 3162 :     bool is_desequenced();
; 3163 :       /* This function is intended for use within
; 3164 :          `kd_packet_sequencer::next_in_sequence', for checking whether
; 3165 :          or not the precinct which is returned by that function needs
; 3166 :          to have its contents read from a compressed data source in
; 3167 :          order to desequence a new packet.  Opening precincts can be a time
; 3168 :          consuming task, especially when there are an enormous number of
; 3169 :          precincts (this can happen when working with huge untiled images,
; 3170 :          especially in geospatial applications).  This function takes
; 3171 :          advantage of the fact that there is no need to actually open a
; 3172 :          precinct which is not already loaded into memory.  The fact that this
; 3173 :          function is called first by the packet desequencer, allows a precinct
; 3174 :          which has already been fully generated to be closed immediately
; 3175 :          during packet generation mode.
; 3176 :             The function works as follows.  If the precinct is already loaded
; 3177 :          in memory, its `sequenced' flag is accessed directly.   Otherwise,
; 3178 :          if the reference `state' variable identifies a valid unique
; 3179 :          address for the precinct, it is known to be addressable and
; 3180 :          therefore must have already been fully desequenced.  Also, if the
; 3181 :          `state' variable indicates that the precinct is unloadable, or that
; 3182 :          it has been closed in packet generation mode, it is interpreted as
; 3183 :          sequenced, in the sense that the application cannot sequence further
; 3184 :          packets for the precinct.  Otherwise, the `state' variable must hold
; 3185 :          0 (see below), from which we deduce that the precinct has not yet
; 3186 :          been sequenced. */
; 3187 :     bool set_address(kd_resolution *res, kdu_coords pos_idx,
; 3188 :                      kdu_long seek_address);
; 3189 :       /* Called from within `kd_packet_sequencer::next_in_sequence', this
; 3190 :          function installs a seek address for a precinct whose packets are
; 3191 :          contiguous within the code-stream and have valid pointer information
; 3192 :          stored in PLT marker segments.  Subsequent calls to `is_sequenced'
; 3193 :          will return true.  The precinct itself may either be open or closed
; 3194 :          when this function is called.  The `pos_idx' argument is provided
; 3195 :          for computing the relevance of this precinct to the application.  It
; 3196 :          holds a relative precinct index, having the same interpretation as
; 3197 :          that passed to `kd_precinct::initialize' and `kdu_precinct_ref::open'.
; 3198 :             It can happen that this function causes the tile, and hence the
; 3199 :          precinct reference, to be destroyed.  This happens if the call to
; 3200 :          this function renders the resolution or tile completely parsed,
; 3201 :          and it is known that the application has no need for any further
; 3202 :          access to the tile.  In this case, and only in this case, the
; 3203 :          function returns false, meaning that the caller must not make
; 3204 :          any further attempt to access the tile or any of its resources. */
; 3205 :   private: // Utility functions
; 3206 :     kd_precinct *instantiate_precinct(kd_resolution *res, kdu_coords pos_idx);
; 3207 :       /* Called from `open' if the `kd_precinct' object is not in memory at
; 3208 :          the time and can legitimately be created at this point. */
; 3209 :   private: // Data
; 3210 :     kdu_long state;
; 3211 :   };
; 3212 :   /* Notes:
; 3213 :         `state' holds 0 if no information is yet available concerning the
; 3214 :      precinct associated with this reference.
; 3215 :         If the precinct is currently active in memory, `state' holds the
; 3216 :      address in memory (pointer) of the `kd_precinct' structure.
; 3217 :         If the precinct is known to be addressable, `state' holds an odd
; 3218 :      integer, equal to 4*A + 2*P + 1, where A is the precinct's
; 3219 :      `unique_address' value and P is a flag, equal to 1 if the precinct
; 3220 :      has been loaded and parsed previously.
; 3221 :         The `unique_address' value has the same definition as the
; 3222 :      corresponding data member in `kd_precinct'.
; 3223 :         This P flag plays the same role as the KD_PFLAG_PARSED bit in
; 3224 :      `kd_precinct::flags'.  It is used to avoid collecting layer size
; 3225 :      statistics twice for the same precinct which could otherwise happen
; 3226 :      when precincts get swapped in and out of memory on demand.
; 3227 :         A value of `state'=1 means that the precinct can be re-instantiated,
; 3228 :      but that it is known to contain no packets whatsoever.
; 3229 :         If a previously active precinct's resources have been recycled and
; 3230 :      re-loading is not possible, `state' is assigned the special value of 3. */
; 3231 : 
; 3232 : /*****************************************************************************/
; 3233 : /*                               kd_leaf_node                                */
; 3234 : /*****************************************************************************/
; 3235 : 
; 3236 : struct kd_leaf_node {
; 3237 :     public: // Data
; 3238 :       kd_node *parent; // Every leaf node has a non-leaf parent node
; 3239 :       kd_resolution *resolution; // Always points to the owning resolution
; 3240 :       kdu_dims dims; // Dimensions & location of the image at this node
; 3241 :       kdu_dims region; // See below
; 3242 :       kdu_byte branch_x, branch_y; // See below
; 3243 :       bool is_leaf; // False if this object is the base of `kd_node'
; 3244 :   };
; 3245 :   /* Notes:
; 3246 :         This structure is the base of the richer `kd_node' structure.  The
; 3247 :      key difference is that leaf nodes have no children, so we do not waste
; 3248 :      storage recording pointers to them.
; 3249 :         The `branch_x' and `branch_y' members describe how this node is
; 3250 :      derived from its parent node, if any.  `branch_x' holds 0 if horizontal
; 3251 :      low-pass filtering and decimation were used to obtain the node from its
; 3252 :      parent; it holds 1 if horizontal high-pass filtering and decimation were
; 3253 :      used; it holds 2 if no filtering or decimation were involved in the
; 3254 :      horizontal direction.  `branch_y' plays a similar role in describing the
; 3255 :      vertical filtering and decimation processes.  If `parent' is NULL,
; 3256 :      the `branch_x' and `branch_y' members have no meaning.
; 3257 :         This structure manages two different, yet related regions
; 3258 :      (location, plus dimensions) which deserve some explanation here.
; 3259 :      * The `dims' member serves the usual role of identifying the location and
; 3260 :        dimensions of the image, as it appears on entry into this node,
; 3261 :        during forward transformation (analysis).  For primary nodes,
; 3262 :        these are the dimensions and location of the tile-component-resolution
; 3263 :        within its canvas.
; 3264 :      * `region' identifies a subset of the `dims' region, containing
; 3265 :        all of the node's samples which are involved in the synthesis of the
; 3266 :        current region of interest, as specified in the most recent call to
; 3267 :        `kdu_codestream::apply_input_restrictions'. */
; 3268 : 
; 3269 : /*****************************************************************************/
; 3270 : /*                                 kd_node                                   */
; 3271 : /*****************************************************************************/
; 3272 : 
; 3273 : struct kd_node : public kd_leaf_node {
; 3274 :     public: // Member functions
; 3275 :       void adjust_cover(kdu_dims child_cover,
; 3276 :                         int child_branch_x, int child_branch_y);
; 3277 :         /* This function is used to find the `region_cover' members.  In
; 3278 :            a downward sweep through the decomposition branches associated
; 3279 :            with a given resolution level, the `region_cover' members are all
; 3280 :            set to empty regions.  We then assign each leaf node (subband)
; 3281 :            a region cover (not actually recorded in the leaf node) equal to
; 3282 :            its region of interest and work back up the tree from the
; 3283 :            leaves to the primary node of the resolution in question, calling
; 3284 :            this function to grow the region cover so as to encompass the
; 3285 :            smallest region which covers each of its children. */
; 3286 :     public: // Data
; 3287 :       kdu_dims region_cover; // See below
; 3288 :       kdu_dims prec_dims; // Temp storage for calculating precinct dimensions
; 3289 :       kd_leaf_node *children[4]; // Indexed by `LL_BAND' through `HH_BAND'
; 3290 :       kdu_byte num_hor_steps, num_vert_steps; // See below
; 3291 :       kdu_uint16 num_descendant_nodes;
; 3292 :       kdu_uint16 num_descendant_leaves;
; 3293 :       float *bibo_gains; // See below
; 3294 :   };
; 3295 :   /* Notes:
; 3296 :         This object is used to construct descriptions of all non-leaf
; 3297 :      nodes in the DWT decomposition structure.  Each node in the structure
; 3298 :      may be decomposed horizontally, vertically or both.  If it is decomposed
; 3299 :      in the horizontal direction, `children[HL_BAND]' will be non-NULL.  If it
; 3300 :      is decomposed in the vertical direction, `children[LH_BAND]' will be
; 3301 :      non-NULL.  If it is decomposed in both directions, `children[HH_BAND]'
; 3302 :      will also be non-NULL.  If it is decomposed at all, `children[LL_BAND]'
; 3303 :      will always be non-NULL.
; 3304 :         The decomposition structure consists of a collection of primary
; 3305 :      nodes, each of which is embedded within a `kd_resolution' object.
; 3306 :      In the case of the simple Mallat structure, each primary node has
; 3307 :      4 children, with the LL child embedded within the next lower
; 3308 :      resolution object and the remaining children embedded within
; 3309 :      `kd_subband' objects.  In wavelet packet decomposition structures,
; 3310 :      detail subbands produced by a primary node may, themselves, be
; 3311 :      decomposed further into subbands.
; 3312 :         The actual object pointed to by each non-NULL member of the `children'
; 3313 :      array may need to be cast to type `kd_node', rather than `kd_leaf_node'
; 3314 :      if the `kd_leaf_node::is_leaf' member is false.
; 3315 :         The `children[LL_BAND]' entry of a primary node always points to
; 3316 :      the node which is embedded within the next lower resolution
; 3317 :      `kd_resolution' object, except at the lowest resolution of all.
; 3318 :      The lowest `kd_resolution' object's embedded node has only one
; 3319 :      child, with `children[LL_BAND]' pointing to the single (LL) subband
; 3320 :      belonging to that resolution.
; 3321 :         The `num_hor_steps' and `num_vert_steps' members identify the number
; 3322 :      of horizontal and vertical lifting steps associated with the horizontal
; 3323 :      and vertical transform operations applied at this node to produce its
; 3324 :      children.  One or both of these may be 0, either because the transform
; 3325 :      is trivial (lazy wavelet) or because the node is split only in the
; 3326 :      horizontal direction, only in the vertical direction, or is not split
; 3327 :      at all.
; 3328 :         The `num_descendant_nodes' member holds a count of the total number
; 3329 :      of nodes (leaf nodes and non-leaf nodes) which may be reached via the
; 3330 :      `children' array.  The `num_descendant_leaves' member holds a count of
; 3331 :      the number of these descendant nodes which are leaves.  Neither of these
; 3332 :      counts includes the current node.  Clearly there is no need to
; 3333 :      maintain this information with leaf nodes, since the counts would both
; 3334 :      be 0 in this case.
; 3335 :         The `bibo_gains' member point to an array with
; 3336 :      2+`num_hor_steps'+`num_vert_steps' entries.  The first 1+`num_hor_steps'
; 3337 :      entries describe BIBO gains for the horizontal transform performed
; 3338 :      at this node.  The remaining `+`num_vert_steps' entries describe BIBO
; 3339 :      gains for the vertical transform performed at this node.  Within each
; 3340 :      of these 2 sets of BIBO gains the first entry holds the BIBO gain from
; 3341 :      the original input image to the image which is presented at the input
; 3342 :      to this node.  Subsequent entries hold the BIBO gains from the original
; 3343 :      input image to the image which is presented at the output of each
; 3344 :      successive analysis lifting step.  Al BIBO gains are assessed relative to
; 3345 :      the nominal transform normalization, in which reversible lifting steps
; 3346 :      are applied as-is, while irreversible lifting steps are followed by the
; 3347 :      relevant `kd_tile_comp::low_scale' and `kd_tile_comp::high_scale' values.
; 3348 :         The interpretation of `region_cover' is similar to that of
; 3349 :      `kd_leaf_node::region', with a subtle, yet important twist.  In order to
; 3350 :      reconstruct each sample in `region', it is necessary to decode a
; 3351 :      particular set of samples from the subbands which are associated with
; 3352 :      this node.  Each of these subband samples has a mapping onto the
; 3353 :      coordinate system associated with the node, following the usual rules of
; 3354 :      the canvas coordinate system.  `res_cover' holds the smallest region
; 3355 :      which contains all of these mapped subband sample locations, except that
; 3356 :      the LL subband branch is included only if this is not a primary node.
; 3357 :      This ensures that the primary node embedded inside each `kd_resolution'
; 3358 :      object will have a `region_cover' which spans the nominal locations of
; 3359 :      all subband samples of interest, which are represented by codestream
; 3360 :      packets associated with that resolution. */
; 3361 : 
; 3362 : /*****************************************************************************/
; 3363 : /*                                kd_subband                                 */
; 3364 : /*****************************************************************************/
; 3365 : 
; 3366 : struct kd_subband : public kd_leaf_node {
; 3367 :     // State structure for the "kdu_subband" interface
; 3368 :   public: // Identification
; 3369 :     kdu_int16 descriptor; // See `cod_params::expand_decomp_bands'
; 3370 :     kdu_byte orientation; // One of LL_BAND, HL_BAND, LH_BAND or HH_BAND.
; 3371 :                      // This is the orientation of the primary subband from
; 3372 :                      // which we are derived within the same resolution level.
; 3373 :     kdu_byte sequence_idx; // Index within the `kd_resolution::subbands' array
; 3374 :                      // This is also the order in which subbands contribute
; 3375 :                      // code-blocks to codestream packets.
; 3376 :     kdu_byte transpose_sequence_idx; // Index of the real subband which appears
; 3377 :                       // to have this `sequence_idx' value when
; 3378 :                       // `kdu_codestream::change_appearance' has been used to
; 3379 :                       // transpose the codestream's appearance.
; 3380 :   public: // Dimensions and Parameters
; 3381 :     kdu_byte epsilon; // Ranging parameter.
; 3382 :     kdu_byte K_max; // Maximum magnitude bit-planes, not including ROI upshift
; 3383 :     kdu_byte K_max_prime; // Max magnitude bit-planes, including ROI upshift
; 3384 :     float delta; // Step size, normalized for image data range of -0.5 to 0.5
; 3385 :     float G_b; // Subband energy gain factor.
; 3386 :     float W_b; // Subband amplitude weight; needs squaring to get energy weight
; 3387 :     float roi_weight; // Extra amplitude weight for ROI foreground blocks.
; 3388 :     kdu_dims block_partition; // Holds the coding origin and dimensions.
; 3389 :     kdu_dims block_indices; // Holds the range of valid block indices.
; 3390 :     kdu_dims region_indices;  // Same as `block_indices', but restricted to
; 3391 :                               // blocks which overlap the region of interest.
; 3392 :     kdu_coords blocks_per_precinct; // precinct size / block size
; 3393 :     kdu_coords log2_blocks_per_precinct; // log2 of precinct size/block size
; 3394 :   };
; 3395 :   /* Notes:
; 3396 :         It may come as a surprise to notice that this object has no
; 3397 :      direct connection to code-blocks.  To access a code-block, the object
; 3398 :      first determines the precinct to which it belongs, creating that
; 3399 :      precinct if necessary; this, in turn, creates its precinct-bands and
; 3400 :      the associated code-blocks.  In this way, no memory whatsoever need be
; 3401 :      dedicated to code-blocks which lie in unaccessed precincts. */
; 3402 : 
; 3403 : /*****************************************************************************/
; 3404 : /*                              kd_resolution                                */
; 3405 : /*****************************************************************************/
; 3406 : 
; 3407 : struct kd_resolution { // State structure for the "kdu_resolution" interface
; 3408 :   public: // Member functions
; 3409 :     kd_resolution()
; 3410 :       {
; 3411 :         codestream = NULL; tile_comp = NULL; rescomp = NULL;
; 3412 :         precinct_refs = NULL; subbands = subband_handle = NULL; num_subbands=0;
; 3413 :         num_intermediate_nodes = 0; intermediate_nodes = NULL;
; 3414 :         can_flip = true;  node.bibo_gains = NULL;
; 3415 :       }
; 3416 :     ~kd_resolution()
; 3417 :       {
; 3418 :         if (node.bibo_gains != NULL) delete[] node.bibo_gains;
; 3419 :         for (int n=0; n < (int) num_intermediate_nodes; n++)
; 3420 :           if (intermediate_nodes[n].bibo_gains != NULL)
; 3421 :             delete[] intermediate_nodes[n].bibo_gains;
; 3422 :         if (precinct_refs != NULL) delete[] precinct_refs;
; 3423 :         if (subband_handle != NULL) delete[] subband_handle;
; 3424 :         if (intermediate_nodes != NULL) delete[] intermediate_nodes;
; 3425 :       }
; 3426 :     void build_decomposition_structure(kdu_params *coc, kdu_kernels &kernels);
; 3427 :       /* This function creates the `subbands' and `intermediate_nodes'
; 3428 :          arrays and fills in all the relevant pointers.  It uses `kernels'
; 3429 :          to create and fill in the `kdu_node::hor_bibo_gains' and
; 3430 :          `kdu_node::vert_bibo_gains' arrays, where required. */
; 3431 :     void complete_initialization();
; 3432 :       /* Called from within `kd_tile::initialize' to finish the initialization
; 3433 :          process, after all of the key parameters have been set.  Currently,
; 3434 :          the only task performed here is the initialization of the
; 3435 :          `max_blocks_per_precinct' member. */
; 3436 :   public: // Links and Identification
; 3437 :     kd_codestream *codestream;
; 3438 :     kd_tile_comp *tile_comp;
; 3439 :     kd_global_rescomp *rescomp;
; 3440 :     kdu_byte res_level; // Runs from 0 (LL band) to `num_dwt_levels'
; 3441 :     kdu_byte dwt_level; // Runs from `num_dwt_levels' (res level 0 and 1) to 1
; 3442 :     kdu_byte hor_depth; // From relevant entry of `kd_comp_info::hor_depth'
; 3443 :     kdu_byte vert_depth; // From relevant entry of `kd_comp_info::vert_depth'
; 3444 : 
; 3445 :   public: // Embedded node
; 3446 :     kd_node node; // Each resolution is a primary node in the decomposition
; 3447 : 
; 3448 :   public: // Dimensions and Parameters
; 3449 :     kdu_dims precinct_partition; // Holds the coding origin and dimensions.
; 3450 :     kdu_dims precinct_indices; // Holds the range of valid precinct indices.
; 3451 :     kdu_dims region_indices; // Holds range of indices for precincts whose
; 3452 :                              // code-blocks contribute to region of interest.
; 3453 :   public: // Derived quantities
; 3454 :     int max_blocks_per_precinct; // See discussion under `kd_precinct_band'
; 3455 :     bool propagate_roi; // True if ROI masks to be propagated to descendants
; 3456 : 
; 3457 :     bool can_flip; // Set to false if this level contains subband decomposition
; 3458 :                    // styles which are incompatible with view flipping.
; 3459 : 
; 3460 :   public: // Arrays
; 3461 :     kdu_byte num_subbands; // Excludes the LL band unless `res_level'=0
; 3462 :     kdu_byte num_intermediate_nodes; // Enough for all non-leaf nodes descended
; 3463 :                                  // from the primary node in this object.
; 3464 :     kd_node *intermediate_nodes; // Array with `num_intermediate_nodes' entries
; 3465 :     kd_precinct_ref *precinct_refs;
; 3466 :     kd_subband *subbands; // Points to `subband_store' or `subband_handle'.
; 3467 :     kd_subband *subband_handle; // For dynamically allocated subbands
; 3468 :     kd_subband subband_store[3]; // Avoid dynamic allocation for common case
; 3469 : 
; 3470 :   public: // Flags and Other State Variables
; 3471 :     kdu_coords current_sequencer_pos; // Used by `kd_packet_sequencer'.
; 3472 :     kdu_coords saved_current_sequencer_pos; // For saving the sequencer state
; 3473 :   };
; 3474 :   /* Notes:
; 3475 :         The `current_sequencer_pos' coordinates are used to sequence
; 3476 :      spatially oriented packet progressions.  They maintain the
; 3477 :      indices (starting from [0,0], rather than `precinct_indices.pos')
; 3478 :      of the precinct which is currently being sequenced.
; 3479 :         The `region_indices' member holds the smallest range of precinct
; 3480 :      indices, such that the code-blocks contained within these precincts
; 3481 :      are sufficient to reconstruct all samples inside `node.region'.
; 3482 :      Equivalently, the range in `precinct_indices' yields the set of
; 3483 :      precincts which intersect with `node.region_cover'.
; 3484 :         It is worth noting that the area of intersection between each
; 3485 :      precinct's region on the resolution and the `node.region_cover' region
; 3486 :      is used to compute the information returned by
; 3487 :      `kdu_resolution::get_precinct_relevance'. */
; 3488 : 
; 3489 : /*****************************************************************************/
; 3490 : /*                             kd_header_in                                  */
; 3491 : /*****************************************************************************/
; 3492 : 
; 3493 : class kd_header_in {
; 3494 :   /* Manages the reading of packet header bytes from the code-stream, along
; 3495 :      with bit stuffing and unpacking. */
; 3496 :   public: // Member functions
; 3497 :     kd_header_in(kd_input *source)
; 3498 :       { this->source = source; bits_left=0; byte=0; header_bytes=0; }
; 3499 :     int get_bit() // throws its own "this" pointer if the source is exhausted.
; 3500 :       {
; 3501 :         if (bits_left==0)
; 3502 :           {
; 3503 :             bits_left = (byte==0xFF)?7:8;
; 3504 :             if (!source->get(byte))
; 3505 :               { bits_left = 0; throw this; }
; 3506 :             header_bytes++;
; 3507 :           }
; 3508 :         bits_left--;
; 3509 :         return (byte >> bits_left) & 1;
; 3510 :       }
; 3511 :     kdu_uint32 get_bits(int num_bits) // thorws(kd_header_in *)
; 3512 :       { kdu_uint32 result = 0;
; 3513 :         while (num_bits > 0)
; 3514 :           {
; 3515 :             if (bits_left==0)
; 3516 :               {
; 3517 :                 bits_left = (byte==0xFF)?7:8;
; 3518 :                 if (!source->get(byte))
; 3519 :                   { bits_left = 0; throw this; }
; 3520 :                 header_bytes++;
; 3521 :               }
; 3522 :             int xfer_bits = (num_bits<bits_left)?num_bits:bits_left;
; 3523 :             bits_left -= xfer_bits;
; 3524 :             num_bits -= xfer_bits;
; 3525 :             result <<= xfer_bits;
; 3526 :             result |= ((byte >> bits_left) & ~(0xFF << xfer_bits));
; 3527 :           }
; 3528 :         return result;
; 3529 :       }
; 3530 :     int finish()
; 3531 :       { // Call this when the header is all read, to consume any stuffing byte
; 3532 :         // Returns total header length
; 3533 :         if ((bits_left == 0) && (byte == 0xFF))
; 3534 :           {
; 3535 :             bits_left = 7;
; 3536 :             if (!source->get(byte))
; 3537 :               throw this;
; 3538 :             header_bytes++;
; 3539 :           }
; 3540 :         return header_bytes;
; 3541 :       }
; 3542 :   private: // Data
; 3543 :     kd_input *source; // Provides the input mechanism.
; 3544 :     kdu_byte byte;
; 3545 :     int bits_left;
; 3546 :     int header_bytes;
; 3547 :   };
; 3548 : 
; 3549 : /*****************************************************************************/
; 3550 : /*                                kd_header_out                              */
; 3551 : /*****************************************************************************/
; 3552 : 
; 3553 : class kd_header_out {
; 3554 :   /* Manages the simulated and real output of packet header bytes. */
; 3555 :   public: // Member functions
; 3556 :     kd_header_out(kdu_output *out=NULL) // Null for simulating header
; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }
; 3558 :     void put_bit(int bit)
; 3559 :       { // Output a header bit
; 3560 :         assert(bit == (bit & 1));
; 3561 :         if (bits_left == 0)
; 3562 :           { if (out != NULL) out->put(byte);
; 3563 :             completed_bytes++;
; 3564 :             bits_left = (byte==0xFF)?7:8;
; 3565 :             byte = 0; }
; 3566 :         byte += byte + bit;
; 3567 :         bits_left--;
; 3568 :       }
; 3569 :     void put_bits(kdu_int32 val, int num_bits)
; 3570 :       { // Output the least significant `num_bits' of `val'
; 3571 :         while (num_bits > 0)
; 3572 :           put_bit((val >> (--num_bits)) & 1);
; 3573 :       }
; 3574 :     int finish()
; 3575 :       { // Returns the total number of bytes consumed by the packet header.
; 3576 :         if (bits_left < 8)
; 3577 :           {
; 3578 :             byte <<= bits_left;
; 3579 :             if (out != NULL)
; 3580 :               out->put(byte);
; 3581 :             completed_bytes++;
; 3582 :             if (byte == 0xFF)
; 3583 :               { // Need the stuffing byte.
; 3584 :                 if (out != NULL)
; 3585 :                   out->put((kdu_byte) 0);
; 3586 :                 completed_bytes++;
; 3587 :               }
; 3588 :           }
; 3589 :         return completed_bytes;
; 3590 :       }
; 3591 :   private: // Data
; 3592 :     kdu_byte byte;
; 3593 :     int bits_left;
; 3594 :     int completed_bytes;
; 3595 :     kdu_output *out;
; 3596 :   };
; 3597 : 
; 3598 : /*****************************************************************************/
; 3599 : /*                                 kd_block                                  */
; 3600 : /*****************************************************************************/
; 3601 : 
; 3602 : class kd_block {
; 3603 :   /* For a very small size (only 24 bytes on 32-bit machines), this class
; 3604 :      defines a lot of member functions!. */
; 3605 :   // --------------------------------------------------------------------------
; 3606 :   public: // Lifecycle member functions
; 3607 :     void cleanup(kd_buf_server *buf_server)
; 3608 :       {
; 3609 :         while ((current_buf=first_buf) != NULL)
; 3610 :           { first_buf=current_buf->next;  buf_server->release(current_buf); }
; 3611 :         set_discard(); // Discard from any packets parsed in the future
; 3612 :       }
; 3613 :     kd_code_buffer *cleanup()
; 3614 :       { // As above, but returns the linked list of buffers
; 3615 :         kd_code_buffer *result = first_buf;  first_buf = current_buf = NULL;
; 3616 :         set_discard();
; 3617 :         return result;
; 3618 :       }
; 3619 : 
; 3620 :   // --------------------------------------------------------------------------
; 3621 :   public: // Packet manipulation member functions
; 3622 :     int parse_packet_header(kd_header_in &head, kd_buf_server *buf_server,
; 3623 :                             int layer_idx); // Throws (kdu_uint16 code)
; 3624 :       /* Parses bits in the packet header corresponding to the current
; 3625 :          block for the current layer (this must be the next layer for which
; 3626 :          information has not yet been parsed).  The function returns the
; 3627 :          number of new body bytes contributed by the code-block in this layer
; 3628 :          and also stores this value internally to be used in subsequent calls
; 3629 :          to the `read_body_bytes' member function.
; 3630 :             The `kd_header_in' object may throw an exception if the packet
; 3631 :          data terminates unexpectedly.  Moreover, to assist in locating and
; 3632 :          possibly recovering from errors, the present function may throw a
; 3633 :          16-bit unsigned integer exception code, which is either the value of
; 3634 :          an illegal marker code encountered in the packet header, or one of
; 3635 :          the special exception codes, KDU_EXCEPTION_PRECISION or
; 3636 :          KDU_EXCEPTION_ILLEGAL_LAYER. */
; 3637 :     void read_body_bytes(kd_input *source, kd_buf_server *buf_server,
; 3638 :                          bool in_memory_source)
; 3639 :       { /* This function should be called after parsing the header of a
; 3640 :            packet.  It reads the code-bytes contributed by the code-block to
; 3641 :            this packet.  If `in_memory_source' is true, only the address of
; 3642 :            the code-bytes is recorded, and then only if the length of the
; 3643 :            code-byte segment is non-zero. */
; 3644 :         if (this->temp_length > 0)
; 3645 :           {
; 3646 :             if (num_passes == 255)
; 3647 :               { // Read and discard the code-bytes.
; 3648 :                 assert(first_buf == NULL);  source->ignore(this->temp_length);
; 3649 :               }
; 3650 :             else if (in_memory_source)
; 3651 :               {
; 3652 :                 kdu_byte *addr;
; 3653 :                 this->num_bytes += source->pseudo_read(addr,this->temp_length);
; 3654 :                 put_address(addr,buf_server);
; 3655 :               }
; 3656 :             else
; 3657 :               this->num_bytes +=
; 3658 :                 source->read(current_buf,buf_pos,buf_server,this->temp_length);
; 3659 :             this->temp_length = 0;
; 3660 :           }
; 3661 :       }
; 3662 :     void retrieve_data(kdu_block *block, int max_layers, int discard_passes,
; 3663 :                        bool in_memory_source);
; 3664 :       /* Retrieves compressed code-bytes, number of coding passes and codeword
; 3665 :          segment lengths from the current code-block and stores them in the
; 3666 :          `block' object.  All fields which are common for compression and
; 3667 :          decompression have already been filled out by the caller.  The
; 3668 :          byte buffer is allocated so as to be large enough to allow a
; 3669 :          2 byte marker code to be appended to the compressed data,
; 3670 :          if desired -- see declaration of "kdu_subband::open_block".
; 3671 :             The `max_layers' argument identifies the maximum number of
; 3672 :          quality layers for which code-block contributions are to be
; 3673 :          retrieved.
; 3674 :             The `discard_passes' argument indicates the number of additional
; 3675 :          coding passes to be removed, if any.
; 3676 :             If `in_memory_source' is true, the layer code bytes are not
; 3677 :          stored in the `kd_code_buffer' list embedded inside `block'.  Instead,
; 3678 :          the `kd_code_buffer' list stores only the header information for
; 3679 :          each layer, along with the address of the code bytes, which reside
; 3680 :          in the memory block managed by an in-memory compressed data source
; 3681 :          (one which offers the `KDU_SOURCE_CAP_IN_MEMORY') capability.  In
; 3682 :          this case, we retrieve the address and then perform a simple memory
; 3683 :          block copy operation to efficiently retrieve the code bytes for
; 3684 :          each layer. */
; 3685 :     void store_data(kdu_block *block, kd_buf_server *buf_server);
; 3686 :       /* Stores compressed code-bytes, pass length and pass slope information
; 3687 :          from the `block' object into the current code-block.  This function
; 3688 :          is invoked by "kdu_subband::close_block" when the containing
; 3689 :          codestream object was not constructed for input.  Also reflects
; 3690 :          the `msbs_w' value into higher nodes in the tag tree. */
; 3691 :     void store_data(kdu_block *block, kd_thread_buf_server *thread_buf_server);
; 3692 :       /* Same as the above function, but uses `kd_thread_buf_server::get'
; 3693 :          rather than `kd_buf_server::get' to get new code buffers.  This
; 3694 :          version is used to save code-block state in multi-threaded
; 3695 :          environments so as to minimize cache coherency bottlenecks and the
; 3696 :          need to lock shared resources. */
; 3697 :     void transfer_data(kd_block &src)
; 3698 :       { /* Like `store_data', but gets results from another block.  Exploits
; 3699 :            the layout of the object to copy only whole pointers or whole
; 3700 :            32-bit words, even where these represent multiple fields. */
; 3701 :         current_buf = first_buf = src.first_buf;
; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);
; 3703 :         src.current_buf = src.first_buf = NULL;
; 3704 :       }
; 3705 :     bool trim_data(kdu_uint16 slope_threshold, kd_buf_server *buf_server);
; 3706 :       /* This function serves two purposes: it helps reduce the amount of
; 3707 :          compressed data which must be buffered in memory while compressing
; 3708 :          an image; and it allows individual block contributions to be
; 3709 :          discarded during packet construction in order to tightly fit the
; 3710 :          generated bit-rate to the target compressed bit-rate.
; 3711 :             The function sets all coding pass slopes which are less than or
; 3712 :          equal to the supplied slope threshold to 0 and then discards all
; 3713 :          code bytes which could not possibly be included in the final
; 3714 :          code-stream, as a result of this modification.
; 3715 :             If anything was discarded, the function returns true.  Otherwise,
; 3716 :          it returns false. */
; 3717 :     int start_packet(int layer_idx, kdu_uint16 slope_threshold);
; 3718 :       /* Call this function only during rate allocation or packet generation.
; 3719 :          Before the first call to this function, you must reset the tag tree
; 3720 :          (see the "reset_output_tree" member function).  If you are calling
; 3721 :          the function multiple times with the same layer for rate allocation
; 3722 :          purposes, you must use "save_output_tree" and "restore_output_tree"
; 3723 :          as described below.
; 3724 :             The function leaves behind information about the number of new
; 3725 :          coding passes and the number of new code bytes which would be
; 3726 :          contributed by this code-block if the supplied threshold were actually
; 3727 :          used.  The final contributing coding pass must have a non-zero
; 3728 :          distortion-length slope which is strictly greater than the slope
; 3729 :          threshold.  It also updates the tag tree structure to reflect any
; 3730 :          new knowledge about the first layer to which this code-block would
; 3731 :          contribute.  This information is picked up by "write_packet_header".
; 3732 :             The function's return value is the total number of new code-bytes
; 3733 :          contributed by the block.  This allows the PCRD-opt algorithm to
; 3734 :          determine roughly the right slope threshold before committing to the
; 3735 :          work of simulating packet header generation. */
; 3736 :     void write_packet_header(kd_header_out &head, int layer_idx,
; 3737 :                              bool simulate);
; 3738 :       /* Call this function only after a `start_packet' call.  It writes
; 3739 :          (or simulates the writing of) packet header information corresponding
; 3740 :          to the code-block inclusion information set up by `start_packet'.
; 3741 :          If `simulate' is true, some internal state adjustments are delayed
; 3742 :          until the next call to "save_output_tree", so multiple calls to
; 3743 :          "start_packet" and "write_packet_header" may be issued with the same
; 3744 :          layer index to determine an optimal slope threshold.  Otherwise,
; 3745 :          if `simulate' is false, the internal state information is fully
; 3746 :          updated and the "save_output_tree" and "restore_output_tree" functions
; 3747 :          need not and should not be called. */
; 3748 :     void write_body_bytes(kdu_output *dest);
; 3749 :       /* This function should be called after a non-simulated
; 3750 :          "write_packet_header" call to output the newly included body bytes.
; 3751 :          The actual number of bytes to be written was left behind by
; 3752 :          the preceding "start_packet" call in the `temp_length' field. */
; 3753 :   // --------------------------------------------------------------------------
; 3754 :   public: // Static functions used to operate on tag-trees built from kd_block
; 3755 :     static kd_block *build_tree(kdu_coords size, kdu_byte * &mem_block);
; 3756 :       /* Builds a full tag tree returning a pointer to the upper left hand
; 3757 :          corner leaf node.  Apart from the `up_down' navigation pointers,
; 3758 :          all fields are initialized to 0.  This is appropriate for tag tree
; 3759 :          decoding, but encoders will need to call "reset_output_tree" and
; 3760 :          use "start_packet" to install appropriate node values.
; 3761 :             The tag tree is not allocated from the heap.  Instead, it is
; 3762 :          allocated from an existing memory block, identified by the `mem_block'
; 3763 :          argument.  This memory block is assumed to be large enough to hold
; 3764 :          the array of `kd_block' structures.  Upon return, the `mem_block'
; 3765 :          value is advanced by an amount equal to the size of the tag tree
; 3766 :          array. */
; 3767 :     static void reset_output_tree(kd_block *tree, kdu_coords size);
; 3768 :       /* Call this function immediately before simulating or actually
; 3769 :          generating any packet data for the relevant code-blocks.  Once
; 3770 :          the PCRD-opt algorithm has completed, you should call this function
; 3771 :          a second time to prepare for actual packet output.  The function
; 3772 :          initializes the threshold state variables, `layer_w_bar' and
; 3773 :          `msbs_w_bar' to 0, and the value state variables, `layer_w' and
; 3774 :          `msbs_w' to their maximum representable values.  The succession of
; 3775 :          "start_packet" calls will update the value variables `layer_w'
; 3776 :          and `msbs_w' in such a way that the tag tree coding process runs
; 3777 :          correctly in each subsequent call to "write_packet_header". */
; 3778 :     static void save_output_tree(kd_block *tree, kdu_coords size);
; 3779 :       /* Call this only during rate allocation, before moving on to a new
; 3780 :          layer.  The function saves the current state (`msbs_wbar' and
; 3781 :          `layer_wbar') of each node in the tag tree.  For leaf nodes, it also
; 3782 :          commits the number of new coding passes found in the last call to
; 3783 :          "start_packet". */
; 3784 :     static void restore_output_tree(kd_block *tree, kdu_coords size);
; 3785 :       /* Call this during rate allocation before supplying a new slope
; 3786 :          threshold for the same layer index, in a new "start_packet" call.
; 3787 :          The function restores the `msbs_w_bar' and `layer_w_bar' values
; 3788 :          previously saved by "save_output_tree". */
; 3789 :   // --------------------------------------------------------------------------
; 3790 :   public: // State identification functions
; 3791 :     void set_discard()
; 3792 :       { /* Use this function only with input-oriented operations.  It informs
; 3793 :            the object that none of the code-blocks associated with this
; 3794 :            block will ever be accessed, so that it is free to skip over them
; 3795 :            when reading a packet.  This can save a lot of memory if you have
; 3796 :            a defined region of interest for decompression. */
; 3797 :         num_passes = 255;
; 3798 :       }
; 3799 :     bool empty()
; 3800 :       { // Returns true if the block has no code-bytes yet.
; 3801 :         return first_buf == NULL;
; 3802 :       }
; 3803 :     void set_modes(int modes)
; 3804 :       {
; 3805 :         assert(modes == (modes & 0xFF));
; 3806 :         this->modes = (kdu_byte) modes;
; 3807 :       }
; 3808 :   // --------------------------------------------------------------------------
; 3809 :   private: // Convenience functions for transferring data to/from code buffers.
; 3810 :     void start_buffering(kd_buf_server *buf_server) // Call before `put_byte'
; 3811 :       { assert(first_buf == NULL);
; 3812 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3813 :     void start_buffering(kd_thread_buf_server *buf_server)
; 3814 :       { assert(first_buf == NULL);
; 3815 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3816 :     void put_byte(kdu_byte val, kd_buf_server *buf_server)
; 3817 :       {
; 3818 :         assert(current_buf != NULL);
; 3819 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3820 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3821 :         current_buf->buf[buf_pos++] = val;
; 3822 :       }
; 3823 :     void put_word(int val, kd_buf_server *buf_server)
; 3824 :       {
; 3825 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3826 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))
; 3827 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3828 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;
; 3829 :         buf_pos += 2;
; 3830 :       }
; 3831 :     void put_address(kdu_byte *addr, kd_buf_server *buf_server)
; 3832 :       {
; 3833 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3834 :         if (buf_pos > (KD_CODE_BUFFER_LEN-KDU_POINTER_BYTES))
; 3835 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3836 : 
; 3837 :         ((kdu_byte **)(current_buf->buf+buf_pos))[0] = addr;
; 3838 :         buf_pos += KDU_POINTER_BYTES;
; 3839 :       }
; 3840 :     void put_byte(kdu_byte val, kd_thread_buf_server *buf_server)
; 3841 :       {
; 3842 :         assert(current_buf != NULL);
; 3843 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3844 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3845 :         current_buf->buf[buf_pos++] = val;
; 3846 :       }
; 3847 :     void put_word(int val, kd_thread_buf_server *buf_server)
; 3848 :       {
; 3849 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3850 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))
; 3851 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3852 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;
; 3853 :         buf_pos += 2;
; 3854 :       }
; 3855 :     void put_address(kdu_byte *addr, kd_thread_buf_server *buf_server)
; 3856 :       {
; 3857 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3858 :         if (buf_pos > (KD_CODE_BUFFER_LEN-KDU_POINTER_BYTES))
; 3859 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3860 : 
; 3861 :         ((kdu_byte **)(current_buf->buf+buf_pos))[0] = addr;
; 3862 :         buf_pos += KDU_POINTER_BYTES;
; 3863 :       }
; 3864 :     kdu_byte get_byte()
; 3865 :       {
; 3866 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3867 :           { buf_pos=0; current_buf=current_buf->next;
; 3868 :             assert(current_buf != NULL); }
; 3869 :         return current_buf->buf[buf_pos++];
; 3870 :       }
; 3871 :     int get_word()
; 3872 :       {
; 3873 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3874 :         buf_pos += 2; // Advance the buffer pointer
; 3875 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3876 :           { buf_pos=2; current_buf=current_buf->next;
; 3877 :             assert(current_buf != NULL); }
; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];
; 3879 :       }
; 3880 :     kdu_byte *get_address()
; 3881 :       {
; 3882 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3883 :         buf_pos += KDU_POINTER_BYTES; // Advance the buffer pointer
; 3884 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3885 :           { buf_pos=KDU_POINTER_BYTES; current_buf=current_buf->next;
; 3886 :             assert(current_buf != NULL); }
; 3887 :         return ((kdu_byte **)(current_buf->buf+buf_pos))[-1];
; 3888 :       }
; 3889 :     void skip_word()
; 3890 :       {
; 3891 :         buf_pos += 2 + (buf_pos & 1); // Align and advance the buffer pointer
; 3892 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3893 :           { buf_pos=2; current_buf=current_buf->next;
; 3894 :             assert(current_buf != NULL); }
; 3895 :       }
; 3896 :     void skip_address()
; 3897 :       {
; 3898 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3899 :         buf_pos += KDU_POINTER_BYTES; // Advance the buffer pointer
; 3900 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3901 :           { buf_pos=KDU_POINTER_BYTES; current_buf=current_buf->next;
; 3902 :             assert(current_buf != NULL); }
; 3903 :       }
; 3904 :   // --------------------------------------------------------------------------
; 3905 :   private: // Data (lots of unions to make it as small as possible!)
; 3906 :     union {
; 3907 :       kd_code_buffer *first_buf;
; 3908 :       kdu_uint16 save_layer_w; // Used for saving non-leaf node state
; 3909 :       };
; 3910 :     union {
; 3911 :       kd_code_buffer *current_buf;
; 3912 :       kdu_uint16 save_layer_wbar; // Used for saving_non-leaf node state
; 3913 :       };
; 3914 :     union {
; 3915 :       kdu_byte buf_pos; // Location of next read/write byte in `current_buf'.
; 3916 :       kdu_byte save_msbs_wbar; // Used for saving non-leaf node state
; 3917 :       };
; 3918 :     kdu_byte msbs_w;
; 3919 :     kdu_byte num_passes;
; 3920 :     kdu_byte pass_idx;
; 3921 :     union {
; 3922 :       kdu_uint16 layer_w; // Used only when `pass_idx'=0
; 3923 :       kdu_uint16 body_bytes_offset; // Used in packet output if `pass_idx' > 0
; 3924 :       kdu_byte save_beta; // Used during output simulation if `pass_idx' > 0
; 3925 :       };
; 3926 :     union {
; 3927 :       kdu_uint16 layer_wbar;
; 3928 :       kdu_uint16 num_bytes; // Used only for input operations
; 3929 :       kdu_byte pending_new_passes; // Used only for output operations
; 3930 :       };
; 3931 :     union {
; 3932 :       kdu_byte msbs_wbar;
; 3933 :       kdu_byte beta;
; 3934 :       };
; 3935 :     kdu_byte modes;
; 3936 :     kdu_uint16 temp_length; // Temporary storage of length quantities.
; 3937 :     kd_block *up_down;
; 3938 :   };
; 3939 :   /* Notes:
; 3940 :         This structure has been designed to provide sufficient state
; 3941 :      information for each code-block to perform packet header parsing as
; 3942 :      well as block encoding and decoding.  For coding purposes, the information
; 3943 :      represented by the structure is generally transferred to or from a
; 3944 :      much less tightly packed representation for speed of execution of the
; 3945 :      block coding routines.  As it stands, the total size of this structure
; 3946 :      should be 24 bytes on a 32-bit architecture. An array of code-blocks is
; 3947 :      maintained by each precinct-band.  The array contains one entry for
; 3948 :      every block in the relevant precinct-band, but also contains additional
; 3949 :      entries to be used as tag-tree nodes.  The total number of such extra
; 3950 :      nodes is about 1/3 the number of code-blocks and should not be a
; 3951 :      significant cause of concern for overall memory consumption. There is
; 3952 :      also substantial benefit to be had by locating the tag tree nodes in
; 3953 :      the same contiguous memory block.  Notice that the structure contains
; 3954 :      no reference back to the precinct-band to which it belongs.  When
; 3955 :      necessary, this reference must be supplied separately to interested
; 3956 :      functions. One consequence of this memory saving step is that the
; 3957 :      object's destructor cannot do anything useful.  It only checks to make
; 3958 :      sure that the explicit `cleanup' function has already been called.
; 3959 :         If a block is to be discarded (since it does not intersect with a
; 3960 :      user-specified region of interest), the `num_passes' field will hold
; 3961 :      the otherwise impossible value, 255.
; 3962 :         The `first_buf', `current_buf' and `buf_pos' fields constitute the
; 3963 :      compressed data buffer management mechanism, which is used to store all
; 3964 :      quantities whose length is unpredictable a priori. In particular, a
; 3965 :      linked list of `kd_code_buffer' structures is provided, which grows on
; 3966 :      demand through access to the codestream object's embedded `buffering'
; 3967 :      object.  Data is stored in these buffers in the following formats:
; 3968 :            * Input Format -- [<layer #> (<#bytes> <#passes> ...)] data [<...
; 3969 :              That is, for each layer to which the code-block makes a non-empty
; 3970 :              contribution, we record first the layer number (2 bytes) and
; 3971 :              then one or more #bytes/#passes pairs.  #bytes is represented
; 3972 :              using 2 bytes, while #passes is represented using only 1 byte.
; 3973 :              There is one such 3 byte pair for each layer and one additional
; 3974 :              3 byte pair for each codeword segment terminating pass which
; 3975 :              is not the final pass contributed in the layer.  In this way,
; 3976 :              sufficient information is provided to recover all termination
; 3977 :              lengths, as well as to build layer associations.  The most
; 3978 :              significant bit of the #bytes field is used as a marker to
; 3979 :              indicate whether or not this is the last such field prior to
; 3980 :              the appearance of the code bytes contributed by that layer.  A
; 3981 :              1 means that there are more fields to go before the code bytes
; 3982 :              appear.
; 3983 :            * In-memory Format --[<layer #>(<#bytes> <#passes>...)] <addr> [<...
; 3984 :              This format is used as an alternative to the Input Format above,
; 3985 :              in the special case when the compressed data source supports the
; 3986 :              `KDU_SOURCE_CAP_IN_MEMORY' capability, so that
; 3987 :              `kd_codestream::in_memory_source' is true.  In this case, the
; 3988 :              "data" field is replaced by the address where the data can be
; 3989 :              found in the memory block managed by the compressed data source.
; 3990 :              Moreover, if the number of code-bytes associated with a layer
; 3991 :              is zero, the <addr> field is missing.
; 3992 :            * Output Format -- [<RD slope> <#bytes>] ... [<RD ...] data
; 3993 :              That is, all of the header information for all coding passes
; 3994 :              appears up front, followed by all of the code bytes associated
; 3995 :              with those coding passes.  The reason for putting all the
; 3996 :              header information up front is that it facilitates the
; 3997 :              identification of appropriate layer contributions by the
; 3998 :              rate control algorithm.  Each coding pass has a 4 byte header,
; 3999 :              with 2 bytes for the distortion-length slope value and 2 bytes
; 4000 :              for the number of code-bytes for the pass.
; 4001 :      The particular format which is used to store data depends upon the
; 4002 :      member functions which are used, since these implicitly determine
; 4003 :      whether the codestream object is being used for input or output.
; 4004 :         The `modes' field holds the block coder mode fields.  Some of these
; 4005 :      are required even for correct packet header parsing, regardless of whether
; 4006 :      the block is to be actually decoded.
; 4007 :         `msbs_w' and `msbs_wbar' are the state information required
; 4008 :      for tag-tree coding of the number of missing MSB's for a code-block
; 4009 :      which is about to make its first non-empty contribution to the
; 4010 :      code-stream. Similarly, `layer_w' and `layer_wbar' hold the state
; 4011 :      information required for tag-tree coding of the layer index in which a
; 4012 :      code-block first contributes to the code-stream.  The operation of
; 4013 :      tag-tree coding and the `w' and `wbar' terminology are explained in
; 4014 :      Section 8.4 of the book by Taubman and Marcellin.
; 4015 :         The `beta' field shares storage with `msbs_wbar'.  This is not
; 4016 :      required until the number of missing MSB's has been encoded or decoded,
; 4017 :      at which point we initialize `beta' to 3 (see the JPEG2000 standard or
; 4018 :      Section 12.5.4 of the book by Taubman and Marcellin).  A useful
; 4019 :      consequence of this behaviour is that `beta' may be tested at any
; 4020 :      point of the packet header encoding or decoding process to determine
; 4021 :      whether or not the code-block has yet contributed to the code-stream
; 4022 :      -- the value will be non-zero if and only if it has done so.
; 4023 :         The `num_bytes' field shares storage with `layer_wbar'.  It
; 4024 :      identifies the total number of bytes included by the code-block in
; 4025 :      all packets read or written so far.  The value is taken to be 0 if
; 4026 :      the code-block has not yet contributed to any packets (`beta'=0),
; 4027 :      during which time the `layer_wbar' state variable is in use.
; 4028 :         The `up_down' field is used to efficiently navigate the tag-tree
; 4029 :      structure.  When the tag tree is not actually being navigated, the
; 4030 :      field points up to the current node's parent in the tag tree.  The
; 4031 :      root mode is readily identified by the fact that it has a NULL `up_down'
; 4032 :      pointer. During navigation, the tag-tree coder first walks from a
; 4033 :      leaf node up to the root, modifying the `up_down' pointers as it goes
; 4034 :      so that each successive parent's `up_down' field points bacl down to the
; 4035 :      child from which the parent was reached.  The coder then walks back down
; 4036 :      from the root to the original leaf node, restoring the `up_down' fields to
; 4037 :      their original `up' state. */
; 4038 : 
; 4039 : /*****************************************************************************/
; 4040 : /*                             kd_precinct_band                              */
; 4041 : /*****************************************************************************/
; 4042 : 
; 4043 : struct kd_precinct_band {
; 4044 :   /* Used to store state information for an element of the precinct partition
; 4045 :      within a single subband.  Once we get down to precincts and ultimately
; 4046 :      code-blocks, we have to be careful not to waste too much memory, since
; 4047 :      an image may have a very large number of these.  Moreover, it may be
; 4048 :      necessary to maintain tag-trees and other state information even for
; 4049 :      precincts which do not lie within our region of interest, so that the
; 4050 :      relevant packet headers can be parsed -- otherwise, we may have no way
; 4051 :      of knowing how to skip over packets which are not interesting to us. */
; 4052 :     kd_subband *subband;
; 4053 :     kdu_dims block_indices; /* Range of code-block indices for this precinct.
; 4054 :         This is a subset of the `block_indices' specified by the `subband'. */
; 4055 :     kd_block *blocks;
; 4056 :   };
; 4057 :   /* Notes:
; 4058 :      In order to make the representation of this object as efficient as
; 4059 :      possible, the two tag trees and all additional information required to
; 4060 :      correctly parse packet headers is maintained within the code-block
; 4061 :      array itself.  The `blocks' array consists of one element for each
; 4062 :      code-block, organized in raster fashion, plus additional elements to
; 4063 :      represent higher nodes in the tag-tree structure.  See the comments
; 4064 :      associated with the definition of `kd_block' for more information on
; 4065 :      this.
; 4066 :         In practice, the `blocks' array is not allocated separately on the
; 4067 :      heap.  Instead, the block of memory allocated to hold the `kd_precinct'
; 4068 :      structure is augmented by an amount sufficient to hold all of the
; 4069 :      code-blocks for all of the subbands in the precinct.  This is
; 4070 :      accomplished by the custom `kd_precinct::new' operator, which is
; 4071 :      informed of the maximum number of code-blocks required by any precinct
; 4072 :      within the containing `kd_resolution' object.  This value is maintained
; 4073 :      by the `kd_resolution::max_blocks_per_precinct" data member.  The
; 4074 :      `blocks' fields are initialized to the NULL state by the
; 4075 :      `kd_precinct::initialize' member function and are later set to point
; 4076 :      into appropriate locations in the precinct's memory block during
; 4077 :      tag-tree construction. */
; 4078 : 
; 4079 : /*****************************************************************************/
; 4080 : /*                                kd_precinct                                */
; 4081 : /*****************************************************************************/
; 4082 : 
; 4083 :   /* Precincts and all of their subordinate entities (precinct-bands and
; 4084 :      code-blocks) are maintained by a code-stream wide precinct server
; 4085 :      object, which allows for efficient allocation and recycling of the
; 4086 :      memory resources. The constructor is invoked from within the server,
; 4087 :      while the `initialize' and `release' functions are invoked from
; 4088 :      within the `kd_precinct_ref' class which manages references to
; 4089 :      precincts from within the `kd_resolution' object. */
; 4090 : 
; 4091 : // Interpretation of the following flags is given with the `flags' member:
; 4092 : #define KD_PFLAG_GENERATING  0x0001
; 4093 : #define KD_PFLAG_CORRUPTED   0x0002
; 4094 : #define KD_PFLAG_DESEQUENCED 0x0004
; 4095 : #define KD_PFLAG_ADDRESSABLE 0x0008
; 4096 : #define KD_PFLAG_RELEASED    0x0010
; 4097 : #define KD_PFLAG_INACTIVE    0x0020
; 4098 : #define KD_PFLAG_RELEVANT    0x0040
; 4099 : #define KD_PFLAG_SIGNIFICANT 0x0080
; 4100 : #define KD_PFLAG_PARSED      0x0100
; 4101 : 
; 4102 : struct kd_precinct {
; 4103 :   public: // Member functions
; 4104 :     void initialize(kd_resolution *resolution, kdu_coords pos_idx);
; 4105 :       /* Called from within `kd_precinct_ref::open' to configure a newly
; 4106 :          allocated (or recycled) object.  `pos_idx' holds the horizontal and
; 4107 :          vertical position of the precinct (starting from 0) within the array
; 4108 :          of precincts for the relevant resolution level.  Thus, `pos_idx'
; 4109 :          holds a relative index, rather than an absolute index. */
; 4110 :     void activate();
; 4111 :       /* This function is called from within `kd_precinct_ref::open' to
; 4112 :          re-activate a previously released precinct, which has not actually
; 4113 :          been unloaded from memory.  Substantially less work is required in
; 4114 :          this case, and the function must be careful to respect the current
; 4115 :          contents of the precinct's code-blocks.  The function sets the
; 4116 :          `num_required_layers' field for this activation (may change between
; 4117 :          successive `kd_tile::open' calls) and also sets the
; 4118 :          `num_outstanding_blocks' field to the total number of code-blocks
; 4119 :          which lie within the current region of interest. */
; 4120 :     void closing();
; 4121 :       /* Called from within `kd_precinct_ref::close' immediately prior to
; 4122 :          recycling the storage associated with the precinct, its precinct-bands
; 4123 :          and their code-blocks.  This function should release any resources
; 4124 :          which are specific to this particular precinct.  These resources
; 4125 :          include any non-NULL `layer_bytes' array and any code-byte buffers.
; 4126 :          Note that the `kd_precinct_ref::close' function may be called
; 4127 :          indirectly while opening a different precinct, if the current
; 4128 :          precinct has already been released.  This enables open calls to
; 4129 :          deal with resource limitations by unloading precincts which are not
; 4130 :          currently active. */
; 4131 :     void release()
; 4132 :       /* Used only for input codestream objects, this function is called once
; 4133 :          all code-blocks within the current region of interest have been
; 4134 :          consumed.  The function sets `num_outstanding_blocks' to 0, although
; 4135 :          in most cases this function will be called because
; 4136 :          `num_outstanding_blocks' has just become 0 (only exception is when
; 4137 :          a tile is being closed).  Also sets `released' to true.  If the
; 4138 :          KD_PFLAG_DESEQUENCED flag is false, the function returns without
; 4139 :          modifying the precinct in any other way.
; 4140 :             The `kd_precinct_ref::release' function is called to formally
; 4141 :          release the precinct's resources (this might not unload them from
; 4142 :          memory) if the codestream mode is non-persistent or if the precinct
; 4143 :          is addressable.  In the latter case, the precinct's contents can
; 4144 :          be reloaded from the compressed source if necessary.
; 4145 :             This function shall not be used with codestream objects
; 4146 :          opened for output or for interchange (no compressed data source and
; 4147 :          no compressed data target). */
; 4148 :       {
; 4149 :         assert(resolution->codestream->in != NULL);
; 4150 :         num_outstanding_blocks = 0;
; 4151 :         flags |= KD_PFLAG_RELEASED;
; 4152 :           // released = true;
; 4153 :         if ((flags & KD_PFLAG_ADDRESSABLE) ||
; 4154 :             ((flags & KD_PFLAG_DESEQUENCED) &&
; 4155 :                 // if (addressable ||
; 4156 :                 //     (desequenced &&
; 4157 :              !resolution->codestream->persistent))
; 4158 :           ref->release(); // May unload us from memory!
; 4159 :       }
; 4160 :     void finished_desequencing()
; 4161 :       /* Called once we can be sure that no more packets will be available
; 4162 :          for this precinct.  In practice, the function is called when the
; 4163 :          last packet has been desequenced or when the containing tile has
; 4164 :          been completely read.  If no packets at all have been desequenced for
; 4165 :          the precinct when this function is called (must have been invoked
; 4166 :          from within `kd_tile::finished_reading'), the precinct is marked
; 4167 :          as addressable, with an address of 0.  This is because it is safe
; 4168 :          to unload such a precinct and then reload it again regardless of
; 4169 :          the services offered by the compressed data source -- there is no
; 4170 :          data actually available from the compressed source for the
; 4171 :          precinct anyway, so reloading is a no-op.
; 4172 :             It should be noted that this function may unload the precinct
; 4173 :          from memory if it is determined that all code-blocks in the
; 4174 :          region of interest (there may be none) have already been consumed. */
; 4175 :       {
; 4176 :         if (flags & KD_PFLAG_DESEQUENCED)
; 4177 :           return;
; 4178 :         flags |= KD_PFLAG_DESEQUENCED;
; 4179 :           // desequenced = true;
; 4180 :         if (next_layer_idx == 0)
; 4181 :           {
; 4182 :             flags |= KD_PFLAG_ADDRESSABLE;
; 4183 :               // addressable = true;
; 4184 :             unique_address = 0;
; 4185 :           }
; 4186 :         if (num_outstanding_blocks == 0)
; 4187 :           release();
; 4188 :       }
; 4189 :     bool desequence_packet()
; 4190 :       /* This function should be called when a non-NULL `kd_precinct_ref'
; 4191 :          pointer is returned by `kd_packet_sequencer::next_in_sequence' and
; 4192 :          its `kd_precinct_ref::is_sequenced' function returns false.
; 4193 :          The function invokes `read_packet' and, if successful, increments
; 4194 :          the precinct's `next_layer_idx' field and the containing tile's
; 4195 :          `num_sequenced_packets' field.
; 4196 :             The function returns false if `read_packet' returns false,
; 4197 :          in which case, more tile-parts must be read (if there are any) to
; 4198 :          recover the information required to desequence the packet.
; 4199 :             Before returning true, the function checks to see whether all
; 4200 :          packets for the tile have been sequenced.  If so, the tile's
; 4201 :          `finished_reading' function is called. */
; 4202 :       {
; 4203 :         kd_tile *tile = resolution->tile_comp->tile;
; 4204 :         assert(!(flags & (KD_PFLAG_DESEQUENCED | KD_PFLAG_ADDRESSABLE)));
; 4205 :         if (!read_packet()) return false;
; 4206 :         next_layer_idx++;
; 4207 :         if (next_layer_idx == tile->num_layers)
; 4208 :           finished_desequencing();
; 4209 :         tile->next_input_packet_num++;
; 4210 :         if ((flags & KD_PFLAG_RELEVANT) &&
; 4211 :             (next_layer_idx <= tile->max_relevant_layers))
; 4212 :           {
; 4213 :             tile->sequenced_relevant_packets++;
; 4214 :             if (tile->sequenced_relevant_packets==tile->max_relevant_packets)
; 4215 :               tile->finished_reading();
; 4216 :           }
; 4217 :         return true;
; 4218 :       }
; 4219 :     void load_required_packets()
; 4220 :       /* If the precinct is addressable, this function uses its
; 4221 :          `unique_address' to position the compressed data source at the
; 4222 :          beginning of the precinct's first packet; it then loads all required
; 4223 :          packets from the compressed source.  Otherwise, the function does
; 4224 :          nothing at all -- reading is presumed to have occurred during packet
; 4225 :          desequencing. */
; 4226 :       {
; 4227 :         if ((!(flags & KD_PFLAG_ADDRESSABLE)) ||
; 4228 :             (unique_address == 0) || (num_packets_read != 0))
; 4229 :           return;
; 4230 :         assert((flags & KD_PFLAG_DESEQUENCED) &&
; 4231 :                (next_layer_idx >= required_layers));
; 4232 :         resolution->codestream->in->seek(unique_address);
; 4233 :         while (num_packets_read < required_layers)
; 4234 :           if (!read_packet())
; 4235 :             break;
; 4236 :       }
; 4237 :     kdu_long simulate_packet(kdu_long &header_bytes,
; 4238 :                              int layer_idx, kdu_uint16 slope_threshold,
; 4239 :                              bool finalize_layer, bool last_layer,
; 4240 :                              kdu_long max_bytes=KDU_LONG_HUGE,
; 4241 :                              bool trim_to_limit=false);
; 4242 :       /* Implements the functionality of `kd_codestream::simulate_output'
; 4243 :          for a single precinct.  Note that the total number of packet bytes
; 4244 :          is left behind in the internal `layer_bytes' array.  This allows the
; 4245 :          determination of tile-part length fields later on when we come to
; 4246 :          construct the code-stream.  The function returns this total number
; 4247 :          of bytes.  It also returns the number of packet header bytes via
; 4248 :          `header_bytes' (the function return value includes the cost of these
; 4249 :          header bytes).
; 4250 :             If the `max_bytes' limit is exceeded, the function may return
; 4251 :          prematurely, without having completed the simulation.  This is
; 4252 :          unacceptable when finalizing a layer, so you must be sure that
; 4253 :          `max_bytes' is sufficient in that case.
; 4254 :             If `trim_to_limit' is true, `finalize_layer' and `last_layer'
; 4255 :          must also both be true.  The function then trims away all coding
; 4256 :          passes from the precinct's code-blocks which are associated with
; 4257 :          slope values of `slope_threshold'+1 or less, until the limit
; 4258 :          associated with `max_bytes' is satisfied.  This functionality is
; 4259 :          used to implement the `sloppy_bytes' capabilities advertised by the
; 4260 :          `kd_codestream::simulate_output' function. */
; 4261 :     kdu_long write_packet(kdu_uint16 slope_threshold, bool empty_packet=false);
; 4262 :       /* Writes out the next packet for this precinct, using the supplied
; 4263 :          distortion-length slope threshold.  Increments the `next_layer_idx'
; 4264 :          field as well as the containing tile's `num_sequenced_packets'
; 4265 :          field when done.  If `empty_packet' is true, an empty packet should
; 4266 :          be issued, having a length of 1 byte, plus the length of any required
; 4267 :          EPH marker (no SOP marker will be attached to empty packets).  The
; 4268 :          function returns the total number of bytes output for the packet. */
; 4269 :   private: // Member functions
; 4270 :     bool read_packet();
; 4271 :       /* Reads a new layer of this precinct sequentially from the
; 4272 :          compressed data source, incrementing the `num_packets_read' member.
; 4273 :          Note that packet reading may be interleaved with acesses to the
; 4274 :          precinct's code-blocks for various reasons.  For example, we
; 4275 :          may initially open a tile with only a limited number of required
; 4276 :          layers, using its code-block data to decompress an approximate
; 4277 :          representation of the image.  We may then find that the additional
; 4278 :          packets need to be loaded in order to advance to other precincts
; 4279 :          in the code-stream.
; 4280 :             The function returns false if an SOT marker (or an EOC marker) is
; 4281 :          encountered.  Note that when an SOT marker is encountered, its
; 4282 :          segment is fully read into the codestream marker service and the
; 4283 :          precinct's tile must be active (otherwise an error message will be
; 4284 :          generated).  Before returning false in this way, the function sets
; 4285 :          the `active_tile' pointer in the codestream object to NULL.  The
; 4286 :          caller may determine the cause of failure by invoking the codestream
; 4287 :          marker service's `get_code' function, which will return one of SOT,
; 4288 :          EOC or 0, where 0 occurs only if the code-stream has been
; 4289 :          exhausted. */
; 4290 :     bool handle_corrupt_packet();
; 4291 :       /* This function implements alternate processing for the `read_packet'
; 4292 :          function in the event that a packet is found to be corrupt.  It is
; 4293 :          called whenever packet corruption is detected, including when the
; 4294 :          precinct is known to have had previously corrupt packets. The function
; 4295 :          manipulates the containing tile's `skipping_to_sop' and
; 4296 :          `next_sop_sequence_num' fields, advancing to the next SOP or SOT
; 4297 :          marker if necessary (the function may be called after detecting an
; 4298 :          SOP marker already, whose sequence number is not as expected).  If
; 4299 :          an SOT marker is encountered, the function renders the current tile
; 4300 :          inactive and returns false (this is the behaviour expected of
; 4301 :          `read_packet').  Otherwise, it updates the precinct and tile state to
; 4302 :          identify the packet as having been read. */
; 4303 :   public: // Public Links and Identification
; 4304 :     kd_resolution *resolution;
; 4305 :     kd_precinct_ref *ref; // Element of `resolution->precinct_refs' array
; 4306 : 
; 4307 :   public: // Mode flags used for decompression and/or interchange
; 4308 :     int flags; // The following flags are defined.
; 4309 :        // KD_PFLAG_GENERATING -- after 1'st call to `kd_precinct::get_packets'
; 4310 :        // KD_PFLAG_CORRUPTED -- if error occurred during packet reading
; 4311 :        // KD_PFLAG_DESEQUENCED -- if all packets have been desequenced
; 4312 :        // KD_PFLAG_ADDRESSABLE -- if seekable, cached or used for interchange
; 4313 :        // KD_PFLAG_RELEASED -- if `activate' must be called to revive state
; 4314 :        // KD_PFLAG_INACTIVE -- if resides on `kd_precict_server's inactive list
; 4315 :        // KD_PFLAG_RELEVANT -- always true if codestream is for non-persistent
; 4316 :        //     input; otherwise, true only if precinct belongs to the relevant
; 4317 :        //     set of precincts of a relevant tile-component-resolution
; 4318 :        // KD_PFLAG_SIGNIFICANT -- if any code-block bytes have been generated
; 4319 :        //     by `kdu_precinct::size_packets' or `kdu_precinct::get_packets'
; 4320 :        // KD_PFLAG_PARSED -- if the precinct was parsed previously and then
; 4321 :        //     unloaded; prevents multiple accumulation of packet length stats
; 4322 :   public: // State variables
; 4323 :     int required_layers; /* Actual number of layers for output codestream;
; 4324 :                 max apparent layers for input or interchange codestream. */
; 4325 :     int next_layer_idx; // Next layer to be sequenced or generated.
; 4326 :     union { // First field used for input; second interchange; third for output
; 4327 :         int num_packets_read; // Incremented when packets read or interchanged
; 4328 :         int cumulative_bytes; // Size of all packets generated so far.
; 4329 :         int saved_next_layer_idx; // Used by "kd_packet_sequencer::save_state"
; 4330 :       };
; 4331 : 
; 4332 :   public: // Activation state variables
; 4333 :     int num_outstanding_blocks; // See notes below.
; 4334 :     union { // First field used only in reading; second only in writing.
; 4335 :         kdu_long unique_address; // See below
; 4336 :         kdu_long *packet_bytes; // Lengths generated during simulated output
; 4337 :       };
; 4338 :   public: // code-block containers
; 4339 :     kd_precinct_band *subbands; // In practice, this member points into the
; 4340 :        // same block of memory which is allocated to hold the precinct so
; 4341 :        // as to encourage memory locality and allow for manipulation of all
; 4342 :        // aspects of a precinct, including all of its code-blocks, via a
; 4343 :        // single heap block.  Note that the number of entries in this array
; 4344 :        // is given by `resolution->num_subbands'.
; 4345 : 
; 4346 :   public: // See below for an explanation of these links
; 4347 :     kd_precinct *next; // Next in free, inactive or generated list
; 4348 :     kd_precinct *prev; // Previous in inactive or generated list
; 4349 :     kd_precinct_size_class *size_class; // For correctly releasing storage
; 4350 :   };
; 4351 :   /* Notes:
; 4352 :         `unique_address' is valid if and only if the precinct is marked as
; 4353 :      addressable, meaning that the precinct has a unique address from which it
; 4354 :      may be loaded (for input codestream objects) or identified (for
; 4355 :      interchange codestream objects).  If addressable, the `unique_address'
; 4356 :      will be 0 if and only if the precinct is known to be empty, meaning that
; 4357 :      reloading the precinct does not require any actual data transfers from a
; 4358 :      compressed data source.
; 4359 :         Except as described above, when used with seekable compressed data
; 4360 :      sources, the `unique_address' member holds a positive quantity which
; 4361 :      identifies an offset into the code-stream at which the precinct's
; 4362 :      packets may be found.  In the case of cached sources (those advertising
; 4363 :      the KDU_SOURCE_CAP_CACHED capability) or codestream objects created for
; 4364 :      interchange (no compressed data source or target), the `unique_address'
; 4365 :      will be negative and -(1+`unique_address') is the precinct's unique
; 4366 :      identifier, as passed to the `kdu_compressed_source::set_precinct_scope'
; 4367 :      function, or returned by the `kdu_precinct::get_unique_id' function.
; 4368 :         The `num_outstanding_blocks' member is used to monitor the number of
; 4369 :      code-blocks from the application's region of interest which have still
; 4370 :      to be consumed (input codestreams) or the number of code-blocks which
; 4371 :      have still to be written in order to complete the precinct (output
; 4372 :      and interchange codestreams).
; 4373 :         The `next' and `prev' links may be used to manage the precinct's
; 4374 :      location in one of three different lists.  The first list is the
; 4375 :      singly-linked free list maintained by `kd_precinct_size_class', from
; 4376 :      which the `kd_precinct_server' object re-issues previously released
; 4377 :      resources.
; 4378 :         The second list on which this structure may find itself is the
; 4379 :      doubly-linked list of currently inactive precincts, which is managed by
; 4380 :      the `kd_precinct_server' object.  Precincts which find themselves on this
; 4381 :      list have been released, but their resources have not yet been recycled.
; 4382 :      They may be successfully re-activated, if their resources have not been
; 4383 :      re-issued to another precinct.  Precincts on this list may be identified
; 4384 :      by the `inactive' flag.  Every inactive precinct necessarily also has
; 4385 :      its `released' member set to true, but the converse is not necessarily
; 4386 :      true.  This is because precincts which have been partially parsed
; 4387 :      in a context for which they were not directly relevant, will be marked
; 4388 :      as released, even though they are not inactive.
; 4389 :         The third list on which this structure may find itself is the
; 4390 :      doubly-linked list of generated precincts managed by the
; 4391 :      `kd_global_rescomp' structure.  This list contains all precincts
; 4392 :      from a given resolution of a given image component, across all tiles,
; 4393 :      which have been fully generated, but not yet flushed out to the
; 4394 :      code-stream.   The list is used to manage incremental rate allocation
; 4395 :      when processing large images.  Elements on this list have not yet
; 4396 :      been closed. */
; 4397 : 
; 4398 : /*****************************************************************************/
; 4399 : /*                         kd_precinct_size_class                            */
; 4400 : /*****************************************************************************/
; 4401 : 
; 4402 :   /* For an explanation of the role played by precinct size classes, see
; 4403 :      the discussion appearing below the declaration of `kd_precinct_server'. */
; 4404 : 
; 4405 : class kd_precinct_size_class {
; 4406 :   public: // Member functions
; 4407 :     kd_precinct_size_class(int max_blocks, int num_subbands,
; 4408 :                            kd_precinct_server *server,
; 4409 :                            kd_buf_server *buf_server)
; 4410 :       {
; 4411 :         this->max_blocks = max_blocks;
; 4412 :         this->num_subbands = num_subbands;
; 4413 :         this->server = server;  this->buf_server = buf_server;
; 4414 :         total_precincts = 0; free_list = NULL; next = NULL;
; 4415 :         alloc_bytes = (int) sizeof(kd_precinct);
; 4416 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4417 :         alloc_bytes += num_subbands * (int) sizeof(kd_precinct_band);
; 4418 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4419 :         alloc_bytes += 4 + max_blocks * (int) sizeof(kd_block);
; 4420 :       }
; 4421 :     ~kd_precinct_size_class()
; 4422 :       { kd_precinct *tmp;
; 4423 :         while ((tmp=free_list) != NULL)
; 4424 :           { free_list = tmp->next; free(tmp); total_precincts--; }
; 4425 :         assert(total_precincts == 0);
; 4426 :       }
; 4427 :     kd_precinct *get()
; 4428 :       {
; 4429 :         if (free_list == NULL)
; 4430 :           augment_free_list();
; 4431 :         kd_precinct *result = free_list; free_list = free_list->next;
; 4432 :         result->next = result->prev = NULL;
; 4433 :         buf_server->augment_structure_bytes(alloc_bytes);
; 4434 :         return result;
; 4435 :       }
; 4436 :     void release(kd_precinct *precinct)
; 4437 :       {
; 4438 :         if (precinct->flags & KD_PFLAG_INACTIVE)

	test	BYTE PTR [esi+8], 32			; 00000020H

; 4676 :       precinct->size_class->release(precinct);

	mov	ebx, DWORD PTR [esi+52]

; 283  :       }
; 284  :     kdu_long augment_cache_threshold(kdu_long increment)
; 285  :       { // Use to adjust the cache threshold either up or down
; 286  :         return (cache_threshold_bytes += increment);
; 287  :       }
; 288  :     bool cache_threshold_exceeded()
; 289  :       { return (cache_threshold_bytes <
; 290  :                 (structure_bytes + num_allocated_pages *
; 291  :                  (KD_CODE_BUFFER_LEN*KDU_CODE_BUFFERS_PER_PAGE))); }
; 292  :       /* This function is called from the `kd_precinct_server::get' function
; 293  :          before it serves up a new precinct container, whenever one or more
; 294  :          precincts are currently on its inactive list.  The function returns
; 295  :          true if the cache threshold has been exceeded, meaning that one or
; 296  :          more inactive precincts should be closed (unloaded from
; 297  :          memory, along with all their associated code buffers).  For more
; 298  :          on this, consult the comments appearing below the declaration of
; 299  :          the `kd_precinct_server' class.
; 300  :             The function is also called whenever a new tile-part is started,
; 301  :          to determine whether there are unloadable tiles which should be
; 302  :          unloaded to bring memory consumption below the cache threshold. */
; 303  :     void attach_thread_buf_server(kd_thread_buf_server *tbs);
; 304  :     void detach_thread_buf_server(kd_thread_buf_server *tbs);
; 305  :       /* The above two functions may be called only with the
; 306  :          `KD_THREADLOCK_GENERAL' mutex already locked by the caller.  They
; 307  :          are used only in multi-threading applications. */
; 308  :   private: // Definitions
; 309  :       struct kd_code_alloc {
; 310  :           kd_code_alloc *next;
; 311  :           kdu_byte block[1]; // Actual structure is allocated to be a much
; 312  :                              // larger memory block, from which aligned
; 313  :                              // virtual cache pages are extracted.
; 314  :         };
; 315  :   private: // Helper functions
; 316  :     void alloc_pages();
; 317  :       /* This function is called when there is insufficient remaining
; 318  :          storage on the free list. */
; 319  :   private: // Data
; 320  :     kd_code_alloc *alloc; // Linked list of allocated memory blocks
; 321  :     kd_code_buffer *free_head;
; 322  :     kdu_long total_pages;
; 323  :     kdu_long num_allocated_pages; // Number of fully allocated pages
; 324  :     kdu_long peak_allocated_pages;
; 325  :     kdu_long structure_bytes; // Bytes in tile/comp/subband/precinct structures
; 326  :     kdu_long peak_structure_bytes;
; 327  :     kdu_long cache_threshold_bytes;
; 328  :     int num_users; // Number of users currently sharing the object.
; 329  :     kd_thread_buf_server *attached_thread_buf_servers;
; 330  :   };
; 331  : 
; 332  : /*****************************************************************************/
; 333  : /*                           kd_thread_buf_server                            */
; 334  : /*****************************************************************************/
; 335  : 
; 336  : #define KD_THREAD_PEAK_STORE_FAC 4
; 337  : 
; 338  : class kd_thread_buf_server {
; 339  :   public: // Member functions
; 340  :     void init(kd_thread_env *env) { this->env=env; reset(); }
; 341  :     void set_codestream_buf_server(kd_buf_server *buf_server);
; 342  :       /* This function is used to nominate a particular codestream's
; 343  :          `kd_buf_server' object as the ultimate source of all future
; 344  :          buffers served by the present object.  If we are already
; 345  :          attached to a different codestream `buf_server', we must
; 346  :          first detach, releasing any buffers in our local store to
; 347  :          the codestream `buf_server' from which they came.  These
; 348  :          operations are all guarded by the KD_THREADLOCK_GENERAL mutex,
; 349  :          but the present function is always invoked from a context in
; 350  :          which the mutex is not locked.  If `buf_server' is NULL, the
; 351  :          function simply detaches us from any codestream `buf_server'
; 352  :          to which we might presently be attached. */
; 353  :     bool is_attached() { return (ultimate_buf_server != NULL); }
; 354  :       /* Returns true if the last call to `set_codestream_buf_server'
; 355  :          specified a non-NULL codestream `buf_server'. */
; 356  :     void detach_while_holding_general_lock()
; 357  :       { /* Called by `discard_all', so we don't have to unlock and then
; 358  :            relock the `KD_THREADLOCK_GENERAL' mutex. */
; 359  :         if (ultimate_buf_server != NULL)
; 360  :           ultimate_buf_server->detach_thread_buf_server(this);
; 361  :       }
; 362  :     kd_code_buffer *get()
; 363  :       { /* Behaves like `kd_buf_server::get', but allocates initially
; 364  :            from the thread's local buffer store, getting extra data from the
; 365  :            codestream specified in the most recent call to
; 366  :            `set_codestream_buf_server' where required.  This function must
; 367  :            not be called while holding any lock, since it may need to
; 368  :            temporarily instantiate a lock to get extra storage from the
; 369  :            underlying codestream. */
; 370  :         if (head == NULL) augment_local_store(false);
; 371  :         kd_code_buffer *result = head;
; 372  :         if ((head = result->next) == NULL)
; 373  :           tail = NULL;
; 374  :         result->next = NULL;
; 375  :         num_available_buffers--;
; 376  :         return result;
; 377  :       }
; 378  :     void adjust_peak_buffers();
; 379  :       /* This function is called from within `kd_thread_env::flush' to
; 380  :          adjust the value of `peak_buffers', which records the maximum
; 381  :          number of buffers we would like to make available locally
; 382  :          in this thread buffer server.  The calculation uses the fact that
; 383  :          `ref_available_buffers'-`num_available_buffers' equals the number
; 384  :          of buffers which have been obtained via `get', since the last call
; 385  :          to this function.  This quantity is multiplied by a factor
; 386  :          `KD_THREAD_PEAK_STORE_FAC' to obtain a reasonable value for
; 387  :          `peak_buffer', the value of which is adjusted only ever upwards. */
; 388  :     void augment_local_store(bool general_lock_held);
; 389  :       /* This function is used to allocate new buffers from the underlying
; 390  :          codestream, specified in the last call to `set_codestream'.
; 391  :          If `adjust_peak_buffers' has never been called, the
; 392  :          function allocates `KD_THREAD_PEAK_STORE_FAC' times the number of
; 393  :          buffers which have already been served via `get'.  Otherwise, it
; 394  :          allocates exactly `peak_buffers' new buffers.
; 395  :             If `general_lock_held' is false, the `KD_THREADLOCK_GENERAL'
; 396  :          lock is not currently held and must be acquired prior to actually
; 397  :          allocating any new buffers (and released again before returning,
; 398  :          of course).  The function is called in this way only when a call
; 399  :          to `get' finds that the local store of buffers has been
; 400  :          completely exhausted.
; 401  :             The function is called with `general_lock_held' equal to true
; 402  :          from within `kd_thread_env::flush' to take advantage of the fact
; 403  :          that the general lock is already held for other reasons -- i.e.,
; 404  :          to piggy-back the activity of refilling the local buffer store
; 405  :          onto other activities which required the lock. */
; 406  :   private: // Helper functions
; 407  :     friend class kd_buf_server;
; 408  :     void reset()
; 409  :       { // Called by `kd_buf_server::detach_thread_buf_server' after removing
; 410  :         // us from its attached thread buffer list.  This function is also
; 411  :         // used to do most of the work of our own constructor.
; 412  :         ultimate_buf_server = NULL;
; 413  :         next_attached = prev_attached = NULL;
; 414  :         ref_available_buffers = 0;
; 415  :         peak_buffers = 0;
; 416  :         num_available_buffers = 0;
; 417  :         head = tail = NULL;
; 418  :       }
; 419  :   private: // Data
; 420  :     kd_thread_env *env;
; 421  :     int peak_buffers; // See the `adjust_peak_buffers' function.
; 422  :     int num_available_buffers; // Number of buffers on the `head' list.
; 423  :     int ref_available_buffers; // Adjusted so that `ref_available_buffers' -
; 424  :          // `num_available_buffers' is always equal to the number of buffers
; 425  :          // allocated via `get' since the last call to `adjust_peak_buffers'.
; 426  :     kd_code_buffer *head;
; 427  :     kd_code_buffer *tail;
; 428  :     kd_buf_server *ultimate_buf_server; // All buffers are allocated from here
; 429  :     kd_thread_buf_server *next_attached; // Used to build a doubly linked list
; 430  :     kd_thread_buf_server *prev_attached; // of objects which are all attached
; 431  :                      // to the same `ultimate_buf_server'.
; 432  :   };
; 433  : 
; 434  : /*****************************************************************************/
; 435  : /*                             kd_compressed_output                          */
; 436  : /*****************************************************************************/
; 437  : 
; 438  : class kd_compressed_output : public kdu_output {
; 439  :   public: // Member functions
; 440  :     kd_compressed_output(kdu_compressed_target *target)
; 441  :       { this->target=target; flushed_bytes = 0; }
; 442  :     virtual ~kd_compressed_output()
; 443  :       { flush_buf(); }
; 444  :     kdu_compressed_target *access_tgt()
; 445  :       { /* You may call this function to access the underlying `target'
; 446  :            object, but you should never manipulate that object if you
; 447  :            have written anything to the present object, without re-accessing
; 448  :            it. */
; 449  :            flush_buf();  return target;
; 450  :       }
; 451  :     kdu_long get_bytes_written()
; 452  :       { return (flushed_bytes + (next_buf-buffer)); }
; 453  :     void flush()
; 454  :       { flush_buf(); }
; 455  :   protected: // Virtual functions which implement required services.
; 456  :     virtual void flush_buf()
; 457  :       {
; 458  :         if (next_buf > buffer)
; 459  :           target->write(buffer,(int)(next_buf-buffer));
; 460  :         flushed_bytes += next_buf - buffer;
; 461  :         next_buf = buffer;
; 462  :       }
; 463  :   private: // Data
; 464  :     kdu_compressed_target *target;
; 465  :     kdu_long flushed_bytes;
; 466  :   };
; 467  : 
; 468  : /*****************************************************************************/
; 469  : /*                                kd_input                                   */
; 470  : /*****************************************************************************/
; 471  : 
; 472  : #define KD_IBUF_SIZE 512
; 473  : #define KD_IBUF_PUTBACK 6 // Maximum number of bytes you can put back.
; 474  : 
; 475  : class kd_input {
; 476  :   /* This abstract base class must be derived to construct meaningful
; 477  :      input devices.  Currently, we have two derived classes in mind: one
; 478  :      for reading from the code-stream and one for recovering packet
; 479  :      headers from PPM or PPT markers.  Since there may be many low level
; 480  :      byte-oriented transactions, we emphasize efficiency for such
; 481  :      transactions. */
; 482  :   public: // Member functions
; 483  :     kd_input()
; 484  :       { first_unread = first_unwritten = buffer+KD_IBUF_PUTBACK;
; 485  :         exhausted = fully_buffered = throw_markers = false; }
; 486  :     virtual ~kd_input() { return; }
; 487  :     bool is_fully_buffered() { return fully_buffered; }
; 488  :     void enable_marker_throwing(bool reject_all=false)
; 489  :       { /* If `reject_all' is false, subsequent reads will throw an exception
; 490  :            if a bona fide SOP or SOT marker is found. In this case, the
; 491  :            function will check to make sure that the length field is correct,
; 492  :            putting the length field and marker code bytes back to the source
; 493  :            before throwing the exception, so that the catch statement can read
; 494  :            them again.
; 495  :               If `reject_all' is true, subsequent reads will throw an
; 496  :            exception if any marker code in the range FF90 to FFFF is found.
; 497  :            Again, the marker code itself is put back onto the stream before
; 498  :            throwing the exception.
; 499  :               Marker throwing is disabled before throwing an exception for
; 500  :            either of the above reasons.
; 501  :               Note that code-stream reading may be slowed down
; 502  :            when this marker throwing is enabled.  For this reason, the
; 503  :            capability is best used only when error resilience or error
; 504  :            detection capabilities are required. */
; 505  :         this->reject_all = reject_all; throw_markers = true; have_FF = false;
; 506  :       }
; 507  :     bool disable_marker_throwing()
; 508  :       { /* Disable marker exception throwing.  Returns true unless the
; 509  :            last byte which was read was an FF, in which case the function
; 510  :            returns false.  This allows the caller to catch markers which
; 511  :            were partially read.  Any code-stream segment which is not
; 512  :            permitted to contain a marker code in the range FF90 through FFFF
; 513  :            is also not permitted to terminate with an FF. */
; 514  :         if (!throw_markers) return true;
; 515  :         throw_markers = false; // Must not touch `reject_all' here.
; 516  :         if (exhausted) have_FF = false;
; 517  :         return !have_FF;
; 518  :       }
; 519  :     void terminate_prematurely()
; 520  :       { /* This function may be called in non-resilient mode if an EOC marker
; 521  :            is encountered before the stream physically ends. */
; 522  :         exhausted = true;
; 523  :       }
; 524  :     bool failed()
; 525  :       { /* Returns true if any of the input functions, `get', `read' or
; 526  :            `ignore' failed to completely fulfill its objective due to
; 527  :            exhaustion of the relevant source. */
; 528  :         return exhausted;
; 529  :       }
; 530  :     bool get(kdu_byte &byte) // throws (kdu_uint16 code): unexpected marker
; 531  :       { /* Access a single byte, returning false if and only if the source is
; 532  :            exhausted, in which case future calls to `failed' return true. */
; 533  :         if (exhausted || ((first_unread==first_unwritten) && !load_buf()))
; 534  :           return false; // If `load_buf' fails it sets `exhausted' for us.
; 535  :         byte = *(first_unread++);
; 536  :         if (throw_markers)
; 537  :           {
; 538  :             if (have_FF && (byte > 0x8F))
; 539  :               process_unexpected_marker(byte);
; 540  :             have_FF = (byte==0xFF);
; 541  :           }
; 542  :         return true;
; 543  :       }
; 544  :     void putback(kdu_byte byte)
; 545  :       { /* You may put back more than 1 byte, but you may not call this
; 546  :            function if a previous read has ever failed.  It is also illegal
; 547  :            to call this function while marker throwing is enabled. */
; 548  :         assert(!exhausted);
; 549  :         assert(!throw_markers);
; 550  :         first_unread--;
; 551  :         if (!fully_buffered)
; 552  :           {
; 553  :             assert(first_unread >= buffer);
; 554  :             *first_unread = byte;
; 555  :           }
; 556  :       }
; 557  :     void putback(kdu_uint16 code)
; 558  :       { /* This function is designed to improve the readability of code
; 559  :            which puts marker codes back to the input object from which they
; 560  :            were read. */
; 561  :         assert(!exhausted);
; 562  :         assert(!throw_markers);
; 563  :         first_unread-=2;
; 564  :         if (!fully_buffered)
; 565  :           {
; 566  :             assert(first_unread >= buffer);
; 567  :             first_unread[0] = (kdu_byte)(code>>8);
; 568  :             first_unread[1] = (kdu_byte) code;
; 569  :           }
; 570  :       }
; 571  :     int pseudo_read(kdu_byte * &addr, int count)
; 572  :       { /* This function should be called only for `fully_buffered' sources.
; 573  :            It behaves like `read', except that it does not actually read
; 574  :            any bytes.  Instead, it puts the address of the block of data
; 575  :            that would have been read into the variable referenced by the
; 576  :            `addr' argument. */
; 577  :         assert(fully_buffered);
; 578  :         addr = first_unread;
; 579  :         if (throw_markers)
; 580  :           return read(addr,count); // Slower path, looks for markers
; 581  :         first_unread += count;
; 582  :         if (first_unread > first_unwritten)
; 583  :           {
; 584  :             count -= (int)(first_unread - first_unwritten);
; 585  :             first_unread = first_unwritten; exhausted = true;
; 586  :           }
; 587  :         return count;
; 588  :       }
; 589  :     int read(kdu_byte *buf, int count);
; 590  :       /* More efficient than `get' when the number of bytes to be read is
; 591  :          more than 2 or 3.  Returns the number of bytes actually read.  If
; 592  :          less than `count', future calls to `failed' will return true.  Note
; 593  :          that this function is less efficient if marker throwing is enabled. */
; 594  :     int read(kd_code_buffer * &cbuf, kdu_byte &buf_pos,
; 595  :              kd_buf_server *buf_server, int length);
; 596  :       /* Same as the above function, except that the requested bytes are
; 597  :          written to a linked list of `kd_code_buffer' buffers, headed by
; 598  :          `cbuf', where the `buf_pos' indicates the next free byte in the
; 599  :          `cbuf' buffer.  The function automatically grows the linked list
; 600  :          of buffers, as required, using `buf_server->get()'.  Upon return,
; 601  :          the `cbuf' and `buf_pos' variables are advanced to refer to the
; 602  :          most recently written `kd_code_buffer' object and the already
; 603  :          written prefix of that object, respectively.  The function
; 604  :          returns the actual number of bytes transferred in this way, which
; 605  :          is equal to `length' unless the ultimate source of data ran dry. */
; 606  :     virtual kdu_long ignore(kdu_long count);
; 607  :       /* Skips over the indicated number of bytes, returning the number of
; 608  :          bytes actually skipped.  If less than `count', future calls to
; 609  :          `failed' will return true.  The function may be overridden by
; 610  :          derived classes which support seeking. */
; 611  :   protected: // Data and functions used for buffer management.
; 612  :     virtual bool load_buf() = 0;
; 613  :       /* Returns false and sets `exhausted' to true if the source is unable
; 614  :          to provide any more data.  Otherwise, augments the internal buffer
; 615  :          and returns true.  Buffer manipulation must conform to the following
; 616  :          conventions.  The `first_unread' pointer should be set to
; 617  :          `buffer'+KD_IBUF_PUTBACK and then bytes should be loaded into the
; 618  :          remaining KD_IBUF_SIZE bytes of the `buffer' array. The
; 619  :          `first_unwritten' pointer should then be set to point just beyond
; 620  :          the last byte actually written into the buffer.  The only exception
; 621  :          to the above conventions is for fully buffered sources, in which
; 622  :          the entire data source lies in a contiguous external memory buffer.
; 623  :          In this case, the internal `buffer' is not used; the first call to
; 624  :          `load_buf' sets `first_unread' to point to the start of the external
; 625  :          memory buffer and `first_unwritten' to point just beyond the external
; 626  :          memory buffer.  In this case, the `fully_buffered' flag should be
; 627  :          set to true, which signals to the `putback' functions that it is
; 628  :          sufficient for them to adjust the `first_unread' pointer, without
; 629  :          actually writing anything. */
; 630  :     kdu_byte buffer[KD_IBUF_SIZE+KD_IBUF_PUTBACK];
; 631  :     kdu_byte *first_unread; // Points to next byte to retrieve from buffer.
; 632  :     kdu_byte *first_unwritten; // Points beyond last available byte in buffer
; 633  :     bool fully_buffered;
; 634  :     bool exhausted;
; 635  :     bool throw_markers; // If true, must look for unexpected markers.
; 636  :   private: // Functions
; 637  :     void process_unexpected_marker(kdu_byte last_byte);
; 638  :       /* This function is called when marker throwing is enabled and a
; 639  :          marker code in the range FF90 through FFFF has been found.  The
; 640  :          least significant byte of the marker code is supplied as the
; 641  :          `last_byte' argument.  The function determines whether to throw
; 642  :          the exception or not.  If not, reading continues unaffected. */
; 643  :   private: // Data
; 644  :     bool have_FF; // Valid only with `throw_markers'. Means last byte was FF.
; 645  :     bool reject_all; // If `false' marker throwing is only for SOP's and SOT's
; 646  :   };
; 647  :   
; 648  : /*****************************************************************************/
; 649  : /*                             kd_compressed_input                           */
; 650  : /*****************************************************************************/
; 651  : 
; 652  : class kd_compressed_input : public kd_input {
; 653  :   public: // Member functions
; 654  :     kd_compressed_input(kdu_compressed_source *source);
; 655  :     int get_capabilities()
; 656  :       { return source->get_capabilities(); }
; 657  :     bool set_tileheader_scope(int tnum, int num_tiles);
; 658  :       /* Generates an error through `kdu_error' if the embedded source does
; 659  :          not support the `KDU_SOURCE_CAP_CACHED' capability.  This function
; 660  :          simply calls the source's own `set_tileheader_scope' function and
; 661  :          clears the internal state variables (especially, the `exhausted'
; 662  :          member) so that subsequent reads will recover bytes from the indicated
; 663  :          tile's header.  For more information, refer to the comments appearing
; 664  :          with `kdu_compressed_source::set_tileheader_scope'. */
; 665  :     kdu_long get_offset()
; 666  :       { /* Returns the address of the next byte which will be returned by the
; 667  :            base object's `get' function.  If seeking is enabled, the source
; 668  :            may be repositioned to this point by supplying this address as the
; 669  :            `unique_address' argument to `seek'.  Even if seeking is not
; 670  :            enabled, `get_offset' will return the correct address and this may
; 671  :            be used to determine appropriate arguments for the `ignore' member
; 672  :            function declared below.  May not be called if the source is in
; 673  :            anything other than code-stream scope. */
; 674  :         assert(!special_scope);
; 675  :         return cur_offset + last_loaded_bytes - (first_unwritten-first_unread);
; 676  :       }
; 677  :     void seek(kdu_long unique_address);
; 678  :       /* If `unique_address' is non-negative, it is treated as a code-stream
; 679  :          offset and the function seeks to a point `unique_address' bytes past
; 680  :          the beginning of the code-stream (SOC marker), using the embedded
; 681  :          `kdu_compressed_source' object's `seek' function.  In this case,
; 682  :          a terminal error is generated if the source does not
; 683  :          offer the KDU_SOURCE_CAP_SEEKABLE capability.
; 684  :             If `unique_address' is negative, the function treats
; 685  :          -(1+`unique_address') as the unique identifier associated with a
; 686  :          cached precinct, supplying this identifier to the embedded
; 687  :          `kdu_compressed_source' object's `set_precinct_scope' function.  In
; 688  :          this case, a terminal error is generated if the source does not
; 689  :          offer the KDU_SOURCE_CAP_CACHEABLE capability.
; 690  :             In either case, the function may clear or set the "exhausted"
; 691  :          state, so that the base object's `failed' member function may return
; 692  :          false, having previously returned true, or vice-versa. */
; 693  :     kdu_long ignore(kdu_long count); // Overrides `kd_input::ignore'.
; 694  :     void set_max_bytes(kdu_long limit);
; 695  :       /* No effect except when reading in code-stream scope. */
; 696  :     kdu_long get_bytes_read();
; 697  :       /* Returns the smallest initial prefix of the source stream which
; 698  :          contains all of the bytes consumed from `kd_input'.  Note that more
; 699  :          bytes may have been read from the compressed data source and
; 700  :          buffered internally, without having been actually used.
; 701  :             For cached sources (those advertising the KDU_SOURCE_CAP_CACHED
; 702  :          capability), the function's return value will be 0, unless we
; 703  :          are still reading the main header. */
; 704  :     kdu_long get_suspended_bytes();
; 705  :       /* Returns the total number of bytes which have been read in the
; 706  :          suspended state.  The returned value may be subtracted from
; 707  :          the value returned by `get_bytes_read' to determine the total
; 708  :          number of bytes which have been read in a non-suspended state.
; 709  :          Byte limits apply only to non-suspended reads. */
; 710  :     void set_suspend(bool state)
; 711  :       {
; 712  :         if (special_scope) return;
; 713  :         if ((suspend_ptr == NULL) && state)
; 714  :           { // Enter suspended mode
; 715  :             suspend_ptr = first_unread;
; 716  :             if (alt_first_unwritten != NULL)
; 717  :               {
; 718  :                 assert(alt_first_unwritten > first_unwritten);
; 719  :                 last_loaded_bytes += alt_first_unwritten - first_unwritten;
; 720  :                 first_unwritten = alt_first_unwritten;
; 721  :                 alt_first_unwritten = NULL;
; 722  :               }
; 723  :           }
; 724  :         else if ((suspend_ptr != NULL) && !state)
; 725  :           { // Leave suspended mode
; 726  :             suspended_bytes += first_unread-suspend_ptr;  suspend_ptr = NULL;
; 727  :             kdu_long limit = suspended_bytes + max_bytes_allowed - cur_offset;
; 728  :             if (limit < last_loaded_bytes)
; 729  :               { // We have already loaded the buffer with too many bytes
; 730  :                 alt_first_unwritten = first_unwritten;
; 731  :                 first_unwritten -= (last_loaded_bytes - limit);
; 732  :                 last_loaded_bytes = limit;
; 733  :                 if (first_unwritten < first_unread)
; 734  :                   { // We have already read past the end.
; 735  :                     exhausted = true;
; 736  :                     suspended_bytes -= (first_unread-first_unwritten);
; 737  :                     first_unwritten = first_unread;
; 738  :                     alt_first_unwritten = NULL;
; 739  :                   }
; 740  :               }
; 741  :           }
; 742  :       }
; 743  :   protected: // Virtual functions which implement required services.
; 744  :     virtual bool load_buf();
; 745  :   private: // Data
; 746  :     kdu_compressed_source *source;
; 747  :     kdu_long cur_offset; // Offset from start of code-stream
; 748  :     kdu_long max_bytes_allowed; // Source may have fewer bytes than this
; 749  :     kdu_long max_address_read; // Address of last byte read from base object.
; 750  :     kdu_long suspended_bytes; // Bytes read while in suspended mode.
; 751  :     kdu_long last_loaded_bytes; // Num bytes added by last call to `load_buf'
; 752  :     kdu_byte *suspend_ptr; // Points into the buffer
; 753  :     kdu_byte *alt_first_unwritten; // See below
; 754  :     bool special_scope; // True for anything other than code-stream scope.
; 755  :   };
; 756  :   /* Notes:
; 757  :         The `cur_offset' member holds the offset from the start of the
; 758  :      code-stream to the first nominal byte in the input buffer; i.e., the
; 759  :      byte at kd_input::buffer + KD_IBUF_PUTBACK.  The actual number of bytes
; 760  :      which have been read from `source' is larger by the amount
; 761  :      `kd_input::first_unwritten' - (`kd_input::buffer'+KD_IBUF_PUTBACK).
; 762  :         The object may be placed in a suspended mode while reading data
; 763  :      which belongs to code-stream packets which lie outside the current
; 764  :      resolution, components or layers of interest.  This allows the
; 765  :      application to set a byte limit which applies only to the relevant
; 766  :      data which would be left if the irrelevant data were first parsed
; 767  :      out of the code-stream.  The object is in suspended mode if and only
; 768  :      if `suspend_ptr' is non-NULL.  In this case, `suspend_ptr' holds the
; 769  :      value of `kd_input::first_unread' immediately prior to the point at
; 770  :      which the object entered the suspended mode.  The total number of
; 771  :      bytes consumed while in the suspended mode is maintained by the
; 772  :      `suspended_bytes' member, but use the function, `get_suspended_bytes'
; 773  :      to evaluate a reliable count of the number of suspended bytes, which
; 774  :      takes into account activity within the `kd_input' object of which
; 775  :      the derived object might not be aware.
; 776  :         The `alt_first_unwritten' member is used to keep track of bytes in
; 777  :      the buffer which may be inaccessible while in the regular (non-suspended)
; 778  :      mode, which may need to be made accessible while the object is in the
; 779  :      suspended mode.  This member holds NULL until exiting the suspended mode
; 780  :      requires `first_unwritten' to be truncated to account for a byte limit.
; 781  :      At that point, it is set to the value of the `first_unwritten' member
; 782  :      prior to truncation.  When the object enters the suspended mode, any
; 783  :      non-NULL `alt_first_unwritten' value is copied to `first_unwritten'. */
; 784  : 
; 785  : /*****************************************************************************/
; 786  : /*                               kd_pph_input                                */
; 787  : /*****************************************************************************/
; 788  : 
; 789  : class kd_pph_input : public kd_input {
; 790  :   /* Alternate input for packet header bytes, which is used in conjunction
; 791  :      with the PPM and PPT marker segments. */
; 792  :   public: // Member functions
; 793  :     kd_pph_input(kd_buf_server *server)
; 794  :       { buf_server = server; first_buf = read_buf = write_buf = NULL; }
; 795  :     virtual ~kd_pph_input();
; 796  :     void add_bytes(kdu_byte *data, int num_bytes);
; 797  :       /* This function is called when unpacking a PPM or PPT marker, to
; 798  :          augment the current object. */
; 799  :   protected: // Virtual functions which implement required services.
; 800  :     virtual bool load_buf();
; 801  :   private: // Data
; 802  :     kd_code_buffer *first_buf;
; 803  :     kd_code_buffer *read_buf, *write_buf;
; 804  :     int read_pos, write_pos;
; 805  :     kd_buf_server *buf_server;
; 806  :   };
; 807  :   /* Notes:
; 808  :         `first_buf' points to the first in a linked list of buffers used to
; 809  :      temporarily store PPM or PPT marker segment bytes.
; 810  :         `read_buf' points to the element in the linked list of code buffers
; 811  :      which is currently being read; `read_pos' points to the next element of
; 812  :      the current buffer which will be read. This may be equal to
; 813  :      KD_CODE_BUFFER_LEN, in which case the next element in the code buffer
; 814  :      list must be accessed when the next read attempt occurs.
; 815  :         `write_buf' points to the last element in the linked list of code
; 816  :      buffers and `write_pos' identifies the first unwritten byte in this
; 817  :      element.  `write_pos' may equal KD_CODE_BUFFER_LEN, in which case a
; 818  :      new element will need to be added before further data can be written.
; 819  :         `buf_server' points to the object which is used to add and release
; 820  :      code buffer elements.  This is a shared resource. */
; 821  : 
; 822  : /*****************************************************************************/
; 823  : /*                                kd_marker                                  */
; 824  : /*****************************************************************************/
; 825  : 
; 826  : class kd_marker {
; 827  :   /* Objects of this class are used to read and store code-stream marker
; 828  :      segments. The most efficient way to use the class is to construct a
; 829  :      single serving object which is used to read the markers one by one and
; 830  :      then copy any markers which need to be preserved into new instances of
; 831  :      the class, using the copy constructor.  This concentrates wasted buffer
; 832  :      space in the one server marker which actually reads from the input
; 833  :      code-stream. */
; 834  :   public: // Member functions
; 835  :     kd_marker(kd_input *input, kd_codestream *cs)
; 836  :       { this->source = input; this->codestream = cs;
; 837  :         code = 0; length = 0; max_length = 0; buf = NULL;
; 838  :         encountered_skip_code = false; }
; 839  :     kd_marker(const kd_marker &orig);
; 840  :       /* Copies any marker segment stored in `orig'. Note that the `source'
; 841  :          pointer is not copied, meaning that the `read' member function may
; 842  :          not be invoked on the copy. */
; 843  :     ~kd_marker() { if (buf != NULL) delete[] buf; }
; 844  :     kd_marker *move(kd_input *input, kd_codestream *cs)
; 845  :       { this->source = input; this->codestream = cs; return this; }
; 846  :         /* This function is used when a `kd_marker' object must be moved
; 847  :          to a different codestream, or to work with a different source of
; 848  :          data. */
; 849  :     void print_current_code(kdu_message &out)
; 850  :       { /* Prints a text string identifying the current marker code. */
; 851  :         print_marker_code(this->code,out);
; 852  :       }
; 853  :     bool read(bool exclude_stuff_bytes=false, bool skip_to_marker=false);
; 854  :       /* Reads a new marker (or marker segment) from the `kd_input' object
; 855  :          supplied during construction.
; 856  :              Returns true if successful.  Causes of failure may be: 1) the
; 857  :          code-stream source is exhausted; 2) a valid marker code was not found;
; 858  :          or 3) an SOP or SOT marker code was found, but followed by an invalid
; 859  :          length field.  This third cause of failure is important since it
; 860  :          prevents the function from attempting to consume an invalid SOP or
; 861  :          SOT marker segment, in the process of which it might consume any
; 862  :          number of useful packets, having their own SOP markers.
; 863  :               A valid marker code must commence with an FF.  If
; 864  :          `exclude_stuff_bytes' is true then the second byte of a valid marker
; 865  :          code must be strictly greater than 0x8F.  Otherwise, the second byte
; 866  :          is arbitrary.  If `skip_to_marker' is true, the function consumes
; 867  :          bytes indefinitely, until the source is exhausted or a valid marker
; 868  :          code is found.  In this case, the function returns false only if the
; 869  :          source is exhausted. Otherwise, the function expects to find a valid
; 870  :          marker code immediately.
; 871  :              As a convenience feature, the function automatically skips over
; 872  :          any EOC marker it encounters.  This has two advantages: 1) we can
; 873  :          detect the end of the code-stream without having to explicitly check
; 874  :          for an EOC marker; 2) we should not be overly troubled by EOC
; 875  :          markers which arise due to corruption of the code-stream (this has
; 876  :          quite a high likelihood of occurring if the code-stream is subject
; 877  :          to corruption).
; 878  :              In the event that the source is not exhausted but a valid
; 879  :          marker code is not found, the function puts back any bytes it consumed
; 880  :          before returning false.  This allows the caller to continue reading
; 881  :          from the point where the function was first called. */
; 882  :     kdu_uint16 get_code() { return code; }
; 883  :       /* Returns 0 if no actual marker is available yet. */
; 884  :     int get_length() { return length; }
; 885  :       /* Returns length of marker segment (not including the length specifier).
; 886  :          Returns 0 if no actual marker available, or if the marker is a
; 887  :          delimiter (no segment). */
; 888  :     kdu_byte *get_bytes() { return buf; }
; 889  :       /* Returns pointer to marker segment bytes immediately following the
; 890  :          length specifier. */
; 891  :     void clear() { code = 0; length = 0; encountered_skip_code = false; }
; 892  :       /* Erase internal state so that not marker is advertised.  This is
; 893  :          useful if the marker has already been inspected and found to be
; 894  :          not useful. */
; 895  :   private: // Data
; 896  :     kd_input *source; // If NULL, `read' may not be used.
; 897  :     kd_codestream *codestream;
; 898  :     kdu_uint16 code;
; 899  :     int length;
; 900  :     int max_length; // Number of bytes which the buffer can store.
; 901  :     kdu_byte *buf;
; 902  :     bool encountered_skip_code;
; 903  :   };
; 904  : 
; 905  : /*****************************************************************************/
; 906  : /*                                 kd_pp_markers                             */
; 907  : /*****************************************************************************/
; 908  : 
; 909  : class kd_pp_markers {
; 910  :   public: // Member functions
; 911  :     kd_pp_markers()
; 912  :       { list = NULL; }
; 913  :     ~kd_pp_markers();
; 914  :     void add_marker(kd_marker &copy_source); 
; 915  :       /* Copies the `kd_marker' object into a new `kd_pp_marker_list'
; 916  :          element, inserting it into the evolving list on the basis of its
; 917  :          Zppm or Zppt index.  Markers need not be added in order. */
; 918  :     void transfer_tpart(kd_pph_input *pph_input);
; 919  :       /* Transfers an entire tile-part of packed packet header data from
; 920  :          the internal marker list to the `pph_input' object, which may
; 921  :          then be used as a source object for packet header reading.  If the
; 922  :          object is managing a list of PPM markers, the function expects to
; 923  :          find the total number of bytes associated with the next tile-part
; 924  :          embedded in the current marker segment.  Otherwise, all marker
; 925  :          segments are dumped into the `pph_input' object.  Marker segments
; 926  :          whose data have been consumed are deleted automatically. */
; 927  :     void ignore_tpart();
; 928  :       /* Same as `transfer_tpart' except that the data are simply discarded.
; 929  :          This is useful when discarding a tile for which PPM marker information
; 930  :          has been provided. */
; 931  :   private: // Definitions
; 932  : 
; 933  :       class kd_pp_marker_list : public kd_marker {
; 934  :         public: // Member functions
; 935  :           kd_pp_marker_list(kd_marker &copy_source) : kd_marker(copy_source)
; 936  :             { next = NULL; }
; 937  :         public: // Data
; 938  :           kd_pp_marker_list *next;
; 939  :           int znum;
; 940  :           int bytes_read;
; 941  :         };
; 942  : 
; 943  :   private: // Convenience functions
; 944  :     void advance_list();
; 945  :   private: // Data
; 946  :     bool is_ppm; // Otherwise, list contains PPT markers.
; 947  :     kd_pp_marker_list *list;
; 948  :   };
; 949  : 
; 950  : /*****************************************************************************/
; 951  : /*                            kd_tpart_pointer                               */
; 952  : /*****************************************************************************/
; 953  : 
; 954  : struct kd_tpart_pointer {
; 955  :     kdu_long address; // Offset relative to the start of the code-stream.
; 956  :     kd_tpart_pointer *next; // For building linked lists.
; 957  :   };
; 958  : 
; 959  : /*****************************************************************************/
; 960  : /*                               kd_tile_ref                                 */
; 961  : /*****************************************************************************/
; 962  : 
; 963  : struct kd_tile_ref {
; 964  :     kd_tpart_pointer *tpart_head;
; 965  :     kd_tpart_pointer *tpart_tail;
; 966  :     kd_tile *tile;
; 967  :   };
; 968  :   /* Notes:
; 969  :        This structure is used to build an array of references to each tile
; 970  :        in the code-stream.  The array is allocated when the codestream is
; 971  :        constructed, but the actual `kd_tile' objects are only instantiated
; 972  :        when needed and destroyed as soon as possible.
; 973  :           The `tpart_head' and `tpart_tail' members manage a list of
; 974  :        addresses to tile-parts of the tile.  The list may be constructed
; 975  :        by reading TLM marker segments in the main code-stream header, or it
; 976  :        may be constructed dynamically as tile-parts are encountered within
; 977  :        the code-stream, enabling them to be re-opened at a later point if
; 978  :        the compressed data-source supports seeking.  The list should be
; 979  :        empty if the source does not support seeking.
; 980  :           Once we are sure that all tile-part addresses have been found
; 981  :        for the tile, the `tpart_tail' member is set to NULL.
; 982  :           Once a tile has been opened and destroyed in non-persistent mode,
; 983  :        the `tile' pointer value is set to KD_EXPIRED_TILE, marking it
; 984  :        as unusable. */
; 985  : 
; 986  : /*****************************************************************************/
; 987  : /*                              kd_tlm_generator                             */
; 988  : /*****************************************************************************/
; 989  : 
; 990  : class kd_tlm_generator {
; 991  :   public: // Member functions
; 992  :     kd_tlm_generator()
; 993  :       {
; 994  :         num_tiles = max_tparts = num_elts = 0; elts = NULL;
; 995  :         tile_data_bytes=0;
; 996  :       }
; 997  :     ~kd_tlm_generator() { if (elts != NULL) delete[] elts; }
; 998  :     bool init(int num_tiles, int max_tparts);
; 999  :       /* Call this function after construction or `clear' in order to
; 1000 :          initialize the object in preparation for generating TLM marker
; 1001 :          segments.  If the number of tiles or tile-parts identified here
; 1002 :          cannot be accommodated by a legal set of TLM marker segments, the
; 1003 :          function returns false and `exists' will continue to return false.
; 1004 :          Otherwise, the object is initialized and subsequent calls to
; 1005 :          `exists' will return true.  Note that the number of tiles given
; 1006 :          here is the total number in the entire code-stream.  This might
; 1007 :          be more than the number of tiles being compressed in the
; 1008 :          current fragment, in which case the `elts' array will not be
; 1009 :          full by the time `write_tlms' is called. */
; 1010 :     bool exists() { return (num_tiles > 0); }
; 1011 :     bool operator!() { return (num_tiles == 0); }
; 1012 :     void clear()
; 1013 :       {
; 1014 :         num_tiles = max_tparts = num_elts = 0;
; 1015 :         tile_data_bytes = 0;
; 1016 :         if (elts != NULL)
; 1017 :           { delete[] elts; elts = NULL; }
; 1018 :       }
; 1019 :     int get_max_tparts() { return max_tparts; }
; 1020 :       /* Returns the parameter recorded with the `ORGgen_tlm' parameter
; 1021 :          attribute, which triggered the creation of this object.  The
; 1022 :          value returned here is guaranteed to lie in the range 1 to 255. */
; 1023 :     int get_tlm_bytes() { return tlm_bytes; }
; 1024 :       /* Returns the total number of bytes occupied by TLM marker segments.
; 1025 :          This value is computed immediately by the object's constructor; it
; 1026 :          does not depend on the actual tile-part length values added later
; 1027 :          via `add_tpart_length'. */
; 1028 :     void write_dummy_tlms(kd_compressed_output *out);
; 1029 :       /* Writes a properly sized set of TLM marker segments to the `out'
; 1030 :          object, except that all tile-part lengths are set equal to 0.  It
; 1031 :          is most important that the TLM marker segments appear at the very
; 1032 :          end of the main codestream header, since a pointer to the start
; 1033 :          of the TLM data will later be generated on the basis of the
; 1034 :          amount of tile-data which has been written, plus the size of the
; 1035 :          TLM data. */
; 1036 :     void add_tpart_length(int tnum, kdu_long length);
; 1037 :       /* Call this function as the tile-part length information becomes
; 1038 :          available while generating the code-stream.  The actual marker
; 1039 :          TLM marker segments can be written only once all tile-part lengths
; 1040 :          have been added. */
; 1041 :     void write_tlms(kdu_compressed_target *tgt,
; 1042 :                     int prev_tiles_written, kdu_long prev_tile_bytes_written);
; 1043 :       /* This function writes the final TLM marker segments.  The `tgt'
; 1044 :          object's `start_rewrite' and `end_rewrite' functions are used to
; 1045 :          reposition the output stream over the previously written dummy
; 1046 :          TLM marker segments and rewrite them with valid tile-part length
; 1047 :          values.  The `prev_tiles_written' and `prev_tile_bytes_written'
; 1048 :          arguments are identical to the values originally supplied to
; 1049 :          `kdu_codestream::create'.  They are used to determine the
; 1050 :          location of the TLM marker information which must be written,
; 1051 :          since some of it may have previously been written when compressing
; 1052 :          different codestream fragments. */
; 1053 :   private: // Structures
; 1054 :       struct kd_tlm_elt {
; 1055 :           kdu_uint16 tnum;
; 1056 :           kdu_uint32 length;
; 1057 :         };
; 1058 :   private: // Data
; 1059 :     int num_tiles;
; 1060 :     int max_tparts;
; 1061 :     int tlm_bytes; // Total number of bytes occupied by TLM marker segments
; 1062 :     int num_elts; // num_tiles * max_tparts
; 1063 :     int elt_ctr; // Pointer to next unfilled entry in `elts'
; 1064 :     kdu_long tile_data_bytes; // sum of all the tile-part lengths added so far
; 1065 :     kd_tlm_elt *elts; // One element for each tile-part, in sequence.
; 1066 :   };
; 1067 : 
; 1068 : /*****************************************************************************/
; 1069 : /*                         kd_tpart_pointer_server                           */
; 1070 : /*****************************************************************************/
; 1071 : 
; 1072 : class kd_tpart_pointer_server {
; 1073 :   public: // Member functions
; 1074 :     kd_tpart_pointer_server()
; 1075 :       {
; 1076 :         groups = NULL; free_list = NULL; tlm_markers = NULL;
; 1077 :         translated_tlm_markers = false;
; 1078 :       }
; 1079 :     ~kd_tpart_pointer_server();
; 1080 :     bool using_tlm_info() { return translated_tlm_markers; }
; 1081 :       /* Returns true if TLM data was used to construct tile-part
; 1082 :          address lists in the most recent call to `translate_markers'. */
; 1083 :     void add_tlm_marker(kd_marker &marker);
; 1084 :       /* Call this function whenever a TLM marker segment is encountered,
; 1085 :          while parsing the main header. */
; 1086 :     void translate_markers(kdu_long first_sot_address,
; 1087 :                            int num_tiles, kd_tile_ref *tile_refs);
; 1088 :       /* Call this function when the main header has been completely read,
; 1089 :          passing in the seek position associated with the first byte of
; 1090 :          the first SOT marker in the code-stream.  This is the location of
; 1091 :          the SOT marker, relative to the start of the code-stream.  It is
; 1092 :          used to convert tile-part lengths into absolute addresses for
; 1093 :          each tile-part.  If no TLM marker segments have been read, the
; 1094 :          function does nothing.  Otherwise, it fills in the tile-part
; 1095 :          address list in each of the `num_tiles' entries of the
; 1096 :          `tile_refs' array.  If the available TLM information is
; 1097 :          insufficient to fully initialize the addresses of all tile-parts
; 1098 :          of each tile, the function issues a warning (since is is strictly
; 1099 :          illegal to have only partial TLM information). */
; 1100 :     void add_tpart(kd_tile_ref *tile_ref, kdu_long sot_address);
; 1101 :       /* Call this function when a new tile-part is encountered in a
; 1102 :          persistent seekable compressed data source, where the tile-part
; 1103 :          address was not already in the list of known tile-part addresses
; 1104 :          for the tile.  This allows the tile to be loaded or reloaded at
; 1105 :          a later time without reparsing the entire code-stream. */
; 1106 :   private: // Definitions
; 1107 : 
; 1108 : #     define KD_POINTER_GROUP_SIZE 32
; 1109 :       struct kd_pointer_group {
; 1110 :           kd_tpart_pointer elements[KD_POINTER_GROUP_SIZE];
; 1111 :           kd_pointer_group *next;
; 1112 :         };
; 1113 :         /* The purpose of this structure is to avoid an unnecessarily large
; 1114 :            number of calls to `new' and `delete'. */
; 1115 : 
; 1116 :       class kd_tlm_marker_list : public kd_marker {
; 1117 :         public: // Member functions
; 1118 :           kd_tlm_marker_list(kd_marker &copy_source) : kd_marker(copy_source)
; 1119 :             { next = NULL; }
; 1120 :         public: // Data
; 1121 :           kd_tlm_marker_list *next;
; 1122 :           int znum; // TLM sequence number used for concatenating info.
; 1123 :         };
; 1124 :         /* Objects of this class are used to store TLM marker segments in
; 1125 :            a list, so that they can be correctly ordered and their contents
; 1126 :            extracted. */
; 1127 : 
; 1128 :   private: // Data
; 1129 :     kd_tlm_marker_list *tlm_markers; // List of TLM marker segments.
; 1130 :     kd_pointer_group *groups; // List of pointer record groups allocated.
; 1131 :     kd_tpart_pointer *free_list; // List of empty pointer records not yet used
; 1132 :     bool translated_tlm_markers;
; 1133 :   };
; 1134 :   /* Notes:
; 1135 :        This object serves two roles: 1) it collects, resequences and
; 1136 :        translates TLM marker segments from the code-stream's main header;
; 1137 :        and 2) it manages the allocation of tile-part address lists, so as
; 1138 :        to avoid excessive memory fragmentation.  The storage for these
; 1139 :        lists is deallocated only when the present object is destroyed. */
; 1140 : 
; 1141 : /*****************************************************************************/
; 1142 : /*                          kd_precinct_pointer_server                       */
; 1143 : /*****************************************************************************/
; 1144 : 
; 1145 : class kd_precinct_pointer_server {
; 1146 :   public: // Member functions
; 1147 :     kd_precinct_pointer_server()
; 1148 :       { buf_server = NULL; }
; 1149 :     ~kd_precinct_pointer_server()
; 1150 :       { disable(); }
; 1151 :     void restart()
; 1152 :       { disable(); } // Called if the code-stream is restarted.
; 1153 :     bool is_active()
; 1154 :       { return (buf_server != NULL); }
; 1155 :     void initialize(kd_buf_server *buf_server)
; 1156 :       /* Call this function when constructing the tile to which the
; 1157 :          object is attached, unless the code-stream is being read from
; 1158 :          a non-seekable source, in which case you should leave the object
; 1159 :          uninitialized and none of the other functions will have any effect. */
; 1160 :       { assert(this->buf_server == NULL); this->buf_server = buf_server;
; 1161 :         head = tail = NULL; head_pos = tail_pos = available_addresses = 0;
; 1162 :         next_address = 0; tpart_bytes_left = 0; num_layers = 0;
; 1163 :         something_served = final_tpart_with_unknown_length = false;
; 1164 :         next_znum = 0; packets_left_in_precinct=0; }
; 1165 :     void add_plt_marker(kd_marker &marker, kdu_params *cod_params,
; 1166 :                         kdu_params *poc_params);
; 1167 :       /* Call this function whenever a PLT marker segment is encountered,
; 1168 :          while parsing a tile-part header.  The `cod_params' and `poc_params'
; 1169 :          arguments must point to the relevant tile's COD and POC parameter
; 1170 :          objects.  The function uses these to determine whether or not the
; 1171 :          pointer information can be used.  In particular, it is used only
; 1172 :          if the current progression order sequences all packets of any
; 1173 :          given precinct together and if the POC object indicates that there
; 1174 :          will be no progression order changes.  These conditions are checked
; 1175 :          again after each tile-part header has been loaded (see the
; 1176 :          `start_tpart_body' member function).  The reason for the conditions
; 1177 :          is that at most one seek address can be maintained for any given
; 1178 :          precinct. */
; 1179 :     void start_tpart_body(kdu_long start_address, kdu_uint32 tpart_body_length,
; 1180 :                           kdu_params *cod_params, kdu_params *poc_params,
; 1181 :                           bool packed_headers,
; 1182 :                           bool final_tpart_with_unknown_length);
; 1183 :       /* This function must be called before addresses can be recovered for
; 1184 :          precincts whose packets appear in the current tile-part.  The
; 1185 :          `start_address' and `tpart_body_length' arguments identify the
; 1186 :          absolute seeking address of the first byte in the body of the
; 1187 :          tile-part and the total number of body bytes in the tile-part.
; 1188 :          These will be used to determine which packets belong to the
; 1189 :          tile-part.  If this is the last tile-part of the tile and its
; 1190 :          length is unknown, the `final_tpart_with_unknown_length' argument
; 1191 :          should be true, and `tpart_body_length' is ignored.
; 1192 :             This function may determine that precinct address information
; 1193 :          cannot be served up for the current tile, for one of a number of
; 1194 :          This is generally because the packets of each precinct are found
; 1195 :          not to be contiguous within the tile-part, or because the presence
; 1196 :          of POC information renders this a likely problem.  If the
; 1197 :          number of quality layers is found to have changed from the point
; 1198 :          when packet length information was first converted into precinct
; 1199 :          lengths and addresses, we must also conclude that address information
; 1200 :          is not available.  A further reason for discarding packet length
; 1201 :          information is if packet headers have been packed into marker
; 1202 :          segments, since this requires that the packets be processed in order
; 1203 :          and once one by one.  If any such determination is made before any
; 1204 :          precinct addresses have been served up, the object is simply
; 1205 :          disabled so that calls to `get_precinct_address' will return 0.
; 1206 :          Otherwise, a terminal error is generated.  In this event, the
; 1207 :          code-stream might need to be opened again with seeking disabled
; 1208 :          so that the present object will never be initialized. */
; 1209 :     kdu_long get_precinct_address()
; 1210 :       { return ((buf_server==NULL)?((kdu_long) 0):pop_address()); }
; 1211 :       /* Returns the address of the next precinct (in the sequence determined
; 1212 :          by the current progression order) in the tile.  This address may be
; 1213 :          used to seek to the relevant location when reading the precinct's
; 1214 :          packets.
; 1215 :             The function returns 0 if seeking is not possible, if
; 1216 :          packet length information cannot be found in the code-stream,
; 1217 :          or if packet length information is not usable for one of a number
; 1218 :          of reasons.  As explained above, packet length information is usable
; 1219 :          only if the packets of a precinct all appear consecutively so that
; 1220 :          each precinct is characterized by only one seeking address.
; 1221 :             The function returns -1 if seeking is possible, but the first
; 1222 :          packet of the precinct belongs to a tile-part which has not yet been
; 1223 :          opened.  In this event, the `kd_tile::read_tile_part_header' member
; 1224 :          function will have to be called until the information becomes
; 1225 :          available. */
; 1226 :   private: // Helper functions
; 1227 :     kdu_long pop_address();
; 1228 :       /* Does all the work of `get_precinct_address'. */
; 1229 :     void disable()
; 1230 :       { // Call to discard contents and cease recording new PLT info.
; 1231 :         if (buf_server == NULL) return;
; 1232 :         while ((tail=head) != NULL)
; 1233 :           { head = tail->next; buf_server->release(tail); }
; 1234 :         buf_server = NULL;
; 1235 :       }
; 1236 :     void initialize_recording()
; 1237 :       { // Call before parsing the first PLT marker segment.
; 1238 :         assert((buf_server != NULL) && (head == NULL));
; 1239 :         head = tail = buf_server->get();
; 1240 :       }
; 1241 :     void record_byte(kdu_byte val)
; 1242 :       { // Call to record a byte of encoded precinct length info.
; 1243 :         assert(tail != NULL);
; 1244 :         if (tail_pos == KD_CODE_BUFFER_LEN)
; 1245 :           { tail=tail->next=buf_server->get(); tail_pos = 0; }
; 1246 :         tail->buf[tail_pos++] = val;
; 1247 :       }
; 1248 :     kdu_byte retrieve_byte()
; 1249 :       { // Call to retrieve a byte of encoded precinct length info.
; 1250 :         assert((head != tail) || (head_pos < tail_pos));
; 1251 :         if (head_pos == KD_CODE_BUFFER_LEN)
; 1252 :           { kd_code_buffer *tmp = head; head=head->next; head_pos = 0;
; 1253 :             buf_server->release(tmp); }
; 1254 :         return head->buf[head_pos++];
; 1255 :       }
; 1256 :   private: // Data
; 1257 :     kd_buf_server *buf_server;
; 1258 :     kd_code_buffer *head, *tail;
; 1259 :     int head_pos; // First valid byte in the `head' buffer (for retrieving)
; 1260 :     int tail_pos; // First unused byte in the `tail' buffer (for recording)
; 1261 :     int available_addresses; // Precinct addresses recorded, but not retrieved
; 1262 :     kdu_long next_address; // Address of the next precinct in current tile-part
; 1263 :     kdu_uint32 tpart_bytes_left; // Bytes left in the current tile-part
; 1264 :     bool final_tpart_with_unknown_length; // If true, previous member ignored
; 1265 :     int num_layers; // Packets/precinct assumption used to parse PLT info
; 1266 :     bool something_served; // False until the first valid address is served
; 1267 :     kdu_byte next_znum; // PLT markers must appear in sequence
; 1268 :     kdu_long precinct_length; // Accumulator for lengths of packets
; 1269 :     int packets_left_in_precinct;
; 1270 :   };
; 1271 : 
; 1272 : /*****************************************************************************/
; 1273 : /*                             kd_compressed_stats                           */
; 1274 : /*****************************************************************************/
; 1275 : 
; 1276 : class kd_compressed_stats {
; 1277 :   /* An object of this class is used to monitor statistics of the compression
; 1278 :      process.  One application of these statistics is the provision of feedback
; 1279 :      to the block encoder concerning a conservative lower bound to the
; 1280 :      distortion-length slope threshold which will be found by the PCRD-opt
; 1281 :      rate allocation algorithm when the image has been fully compressed.  This
; 1282 :      allows the encoder to skip coding passes which are almost certain to be
; 1283 :      discarded.
; 1284 :         The current very simple implementation makes the naive assumption
; 1285 :      that the compressibility of all subband samples is the same, regardless
; 1286 :      of the subband or resolution level.  This is OK if the number of samples
; 1287 :      which have been processed for each subband is proportional to the
; 1288 :      size of the subband, since then the average compressibility is a good
; 1289 :      measure to use in predicting rate control properties.  In practice,
; 1290 :      though, delay through the wavelet transform means that the percentage
; 1291 :      of samples seen for higher resolution subbands is generally higher than
; 1292 :      that seen for lower frequency subbands, until everything has been
; 1293 :      compressed. Since the higher frequency subbands are almost invariably
; 1294 :      more compressible, the predicted compressibility of the source is
; 1295 :      estimated too high and so the predicted rate-distortion slope threshold
; 1296 :      passes considerably more bits than the final rate allocation will.  This
; 1297 :      renders the prediction excessively conservative for most images.  A
; 1298 :      good fix for this would be to keep track of the percentage of subband
; 1299 :      samples which have been compressed in each resolution level and use this
; 1300 :      information to form a more reliable predictor.  This improvement might
; 1301 :      be included in a future version. */
; 1302 :   public: // Member functions
; 1303 :     kd_compressed_stats() { init(); }
; 1304 :     kd_compressed_stats(kdu_long total_samples, kdu_long target_bytes,
; 1305 :                         bool enable_trimming)
; 1306 :       {
; 1307 :         init();
; 1308 :         this->total_samples = total_samples;
; 1309 :         next_trim = (total_samples+7) >> 3;
; 1310 :         conservative_extra_samples = 4096 + (total_samples>>4);
; 1311 :         target_rate =
; 1312 :           (total_samples==0)?1.0:(((double) target_bytes)/total_samples);
; 1313 :         this->trimming_enabled = enable_trimming;
; 1314 :       }
; 1315 :     void init()
; 1316 :       {
; 1317 :         total_samples=num_coded_samples=conservative_extra_samples=next_trim=0;
; 1318 :         target_rate = 0.0;
; 1319 :         min_quant_slope = 4095; max_quant_slope = 0;
; 1320 :         block_slope_threshold = remaining_slope_threshold = 0;
; 1321 :         for (int n=0; n < 4096; n++)
; 1322 :           quant_slope_rates[n] = 0;
; 1323 :         trimming_enabled = false;
; 1324 :       }
; 1325 :     bool is_empty() { return (num_coded_samples == 0); }
; 1326 :       /* Returns true if some information has been entered via the
; 1327 :          `update_stats' function. */
; 1328 :     bool update_stats(kdu_block *block)
; 1329 :       { /* Invoked by "kdu_subband::close_block".  If the function returns
; 1330 :            true, it is recommended that the compressed data be trimmed back
; 1331 :            to a size consistent with the target compressed length at this
; 1332 :            point.  Remember to invoke `update_quant_slope_thresholds' once
; 1333 :            this function returns. */
; 1334 :         num_coded_samples += block->size.x*block->size.y;
; 1335 :         int quant_slope, length = 0;
; 1336 :         for (int n=0; n < block->num_passes; n++)
; 1337 :           {
; 1338 :             length += block->pass_lengths[n];
; 1339 :             if (block->pass_slopes[n] == 0)
; 1340 :               continue;
; 1341 :             quant_slope = block->pass_slopes[n] >> 4;
; 1342 :             if (quant_slope < min_quant_slope) min_quant_slope = quant_slope;
; 1343 :             if (quant_slope > max_quant_slope) max_quant_slope = quant_slope;
; 1344 :             quant_slope_rates[quant_slope] += length;
; 1345 :             length = 0;
; 1346 :           }
; 1347 :         if (trimming_enabled && (num_coded_samples > next_trim))
; 1348 :           { next_trim += (total_samples+7)>>4; return true; }
; 1349 :         return false;
; 1350 :       }
; 1351 :     bool update_stats(kd_compressed_stats &src)
; 1352 :       { /* Similar to the first version of the `update_stats' function, except
; 1353 :            that the information is copied from the `src' object, returning it
; 1354 :            to the empty state. */
; 1355 :         num_coded_samples += src.num_coded_samples;  src.num_coded_samples = 0;
; 1356 :         if (src.min_quant_slope < this->min_quant_slope)
; 1357 :           this->min_quant_slope = src.min_quant_slope;
; 1358 :         if (src.max_quant_slope > this->max_quant_slope)
; 1359 :           this->max_quant_slope = src.max_quant_slope;
; 1360 :         for (int n=src.min_quant_slope; n <= src.max_quant_slope; n++)
; 1361 :           { quant_slope_rates[n] += src.quant_slope_rates[n];
; 1362 :             src.quant_slope_rates[n] = 0; }
; 1363 :         src.min_quant_slope = 4095;  src.max_quant_slope = 0;
; 1364 :         if (trimming_enabled && (num_coded_samples > next_trim))
; 1365 :           { next_trim += (total_samples+7)>>4; return true; }
; 1366 :         return false;
; 1367 :       }
; 1368 :     void update_quant_slope_thresholds()
; 1369 :       { /* This function should be called after `update_stats' to ensure that
; 1370 :            the most up-to-date slope threshold is available for return via
; 1371 :            `get_conservative_slope_threshold'.  If desired, multiple calls
; 1372 :            to `update_stats' may precede the call to this function, which
; 1373 :            may improve efficiency.  The reason for computing the slope
; 1374 :            threshold here, rather than in `get_conservative_slope_threshold'
; 1375 :            is that the latter function may be invoked asynchronously by any
; 1376 :            number of threads of execution, whereas the present function is
; 1377 :            always invoked while holding the `KD_THREADLOCK_STATS' mutex
; 1378 :            (in multi-threaded applications) so that other threads cannot
; 1379 :            modify the statistics while this function is in progress. */
; 1380 :         int n;  kdu_long max_bytes, cumulative_bytes;
; 1381 :         // Adjust `block_slope_threshold'
; 1382 :         max_bytes = num_coded_samples + conservative_extra_samples;
; 1383 :         max_bytes = 1 + (kdu_long)(max_bytes * target_rate);
; 1384 :         for (cumulative_bytes=0, n=max_quant_slope; n >= min_quant_slope; n--)
; 1385 :           if ((cumulative_bytes += quant_slope_rates[n]) >= max_bytes)
; 1386 :             break;
; 1387 :         block_slope_threshold = n;
; 1388 :         // Adjust `remaining_slope_threshold'
; 1389 :         max_bytes = total_samples;
; 1390 :         max_bytes = 1 + (kdu_long)(max_bytes * target_rate);
; 1391 :         for (cumulative_bytes=0, n=max_quant_slope; n >= min_quant_slope; n--)
; 1392 :           if ((cumulative_bytes += quant_slope_rates[n]) >= max_bytes)
; 1393 :             break;
; 1394 :         remaining_slope_threshold = n;
; 1395 :       }
; 1396 :     kdu_uint16 get_conservative_slope_threshold(bool assume_all_coded=false)
; 1397 :       { /* The slope threshold generated by PCRD-opt is unlikely to be
; 1398 :            smaller than that returned here -- remember that smaller thresholds
; 1399 :            mean that more compressed data are included in the code-stream.
; 1400 :            If `assume_all_coded' is true, the slope threshold is based on the
; 1401 :            assumption that no bytes will be generated for any further samples.
; 1402 :            Otherwise, the assumption is that future samples will have the
; 1403 :            same average compressibility as those already coded.  Note that
; 1404 :            since compressors tend to output a higher proportion of high
; 1405 :            frequency subband samples than low frequency subband samples at
; 1406 :            any point up to the end of the image, the actual compressibility
; 1407 :            of future samples can be expected to be lower on average, making
; 1408 :            our estimate more conservative. */
; 1409 :         int val =
; 1410 :           (assume_all_coded)?remaining_slope_threshold:block_slope_threshold;
; 1411 :         val = (val<<4)-1;
; 1412 :         return (kdu_uint16)((val>0)?val:1);
; 1413 :       }
; 1414 :   private: // Data
; 1415 :     double target_rate; // Expressed in bytes per sample, not bits per sample
; 1416 :     kdu_long total_samples; // Total number of subband sample in entire image
; 1417 :     kdu_long next_trim; // Num samples at which memory should next be trimmed
; 1418 :     kdu_long conservative_extra_samples; // Add to coded samples to be safe
; 1419 :     kdu_long num_coded_samples; // Number of samples already coded
; 1420 :     kdu_long quant_slope_rates[4096]; // See below
; 1421 :     int min_quant_slope, max_quant_slope;
; 1422 :     int block_slope_threshold; // See below
; 1423 :     int remaining_slope_threshold; // See below
; 1424 :     bool trimming_enabled;
; 1425 :   };
; 1426 :   /* Notes:
; 1427 :         The `quant_slope_rates' array holds the total number of coded
; 1428 :      bytes which belong to each of a set of 4096 quantized distortion-length
; 1429 :      slope bins.  The original distortion-length slopes have a 16-bit unsigned
; 1430 :      logarithmic representation (see discussion of the "pass_slopes" member
; 1431 :      array in the "kdu_block" structure).  The index of the bin to which a
; 1432 :      given slope, lambda, belongs is given by
; 1433 :          bin = floor(lambda/16).
; 1434 :      Rounding down means that 16*bin is the smallest slope consistent with the
; 1435 :      bin so that summing the entries from bin to 4095 yields the maximum number
; 1436 :      of code-block bytes which could be contributed to the compressed image
; 1437 :      if the PCRD-opt algorithm selected a slope threshold of 16*bin.  Note,
; 1438 :      however, that bin 0 represents only those slopes in the range 1 to 15,
; 1439 :      since 0 is not a valid slope threshold.
; 1440 :         The `block_slope_threshold' member essentially gives the current
; 1441 :      conservative slope threshold to be used during block coding -- this
; 1442 :      is the slope we want when calling `get_conservative_slope_threshold'
; 1443 :      with the `assume_all_coded' argument set to false.  More specifically,
; 1444 :      `block_slope_threshold' is the smallest index into the `quant_slope_rates'
; 1445 :      array such that the cumulative number of bytes represented by that
; 1446 :      entry and all higher entries is strictly less than the target rate
; 1447 :      multiplied by the number of samples coded so far (plus some
; 1448 :      conservative extra samples).  The corresponding slope threshold is
; 1449 :      obtained by multiplying this value by 16 and subtracting 1.
; 1450 :         The `remaining_slope_threshold' member plays the same role as
; 1451 :      `block_slope_threshold', except that it is based upon the total number
; 1452 :      of samples in the entire image, rather than just the total number of
; 1453 :      samples coded so far.  In this way, it essentially provides a
; 1454 :      conservative distortion-length slope threshold, which can safely be
; 1455 :      used to trim already generated coding passes from their respective
; 1456 :      code-blocks.  This value is used to generate the return value from
; 1457 :      `get_conservative_slope_threshold' when its `assume_all_coded' argument
; 1458 :      is set to true. */
; 1459 : 
; 1460 : /*****************************************************************************/
; 1461 : /*                            kd_codestream_comment                          */
; 1462 : /*****************************************************************************/
; 1463 : 
; 1464 : class kd_codestream_comment {
; 1465 :   public: // Member functions
; 1466 :     kd_codestream_comment()
; 1467 :       { readonly=false; max_chars=num_chars=0; text_buf=NULL; next=NULL; }
; 1468 :     ~kd_codestream_comment()
; 1469 :       { if (text_buf != NULL) delete[] text_buf; }
; 1470 :     void set_text(int length, kdu_byte *data);
; 1471 :       /* This function is used only when parsing comment markers from a
; 1472 :          code-stream, where the comment marker indicates that it contains
; 1473 :          text.  The `data' array contains `length' characters, starting from
; 1474 :          the first byte in the body of the comment marker.  The array of
; 1475 :          characters may or may not be terminated with a null character.  If
; 1476 :          not, a null character is automatically appended to the internal
; 1477 :          representation.
; 1478 :             This function leaves the object in the `read-only' state.
; 1479 :       */
; 1480 :     int write_marker(kdu_output *out, int force_length=0);
; 1481 :       /* If `out' is NULL, the marker segment is ony simulated.  In
; 1482 :          any event, the function returns the total number of bytes consumed
; 1483 :          by the comment marker segment, from the marker code to the
; 1484 :          last segment byte.
; 1485 :             If `force_length' is not 0, the marker segment will be forced
; 1486 :          to occupy an exact number of bytes.  If necessary, the text body of
; 1487 :          the marker segment will be truncated, or padded to the specified
; 1488 :          length.  A non-zero `force_length' value may not be less than 6,
; 1489 :          which is the length of the comment marker header.
; 1490 :             This function leaves the object in the `read-only' state.
; 1491 :       */
; 1492 :   private: // Data
; 1493 :     friend class kdu_codestream_comment;
; 1494 :     bool readonly; // True if you are not allowed to write to the text buffer
; 1495 :     int max_chars; // `text_buf' can hold this many chars, plus a null
; 1496 :     int num_chars; // Number of characters written to `text_buf'.
; 1497 :     char *text_buf; // Holds comment text.
; 1498 :   public: // Links
; 1499 :     kd_codestream_comment *next;
; 1500 :   };
; 1501 : 
; 1502 : /*****************************************************************************/
; 1503 : /*                             kd_packet_sequencer                           */
; 1504 : /*****************************************************************************/
; 1505 : 
; 1506 : class kd_packet_sequencer {
; 1507 :   public: // Member functions
; 1508 :     kd_packet_sequencer(kd_tile *tile)
; 1509 :       {
; 1510 :         this->tile = tile;
; 1511 :         init();
; 1512 :       }
; 1513 :     void init();
; 1514 :       /* Called when the containing tile is re-initialized for processing a
; 1515 :          new code-stream with exactly the same structural properties as the
; 1516 :          previous one. */
; 1517 :     void save_state();
; 1518 :       /* Saves all quantities associated with packet sequencing, both within
; 1519 :          this object and in the associated tile and its constituent precincts,
; 1520 :          so that they can be later restored to resume sequencing from where
; 1521 :          we left off. */
; 1522 :     void restore_state();
; 1523 :       /* Restores the state saved by the `save_state' member function. */
; 1524 :     kd_precinct_ref *next_in_sequence(kd_resolution* &res, kdu_coords &idx);
; 1525 :       /* This function returns a pointer to the `kd_precinct_ref' object
; 1526 :          which manages the precinct associated with the next packet in the
; 1527 :          relevant tile's packet sequence (see below for the possibility of
; 1528 :          a NULL return value).  The function also returns a
; 1529 :          pointer to the `kd_resolution' object which manages the returned
; 1530 :          precinct and the horizontal and vertical coordinates of the
; 1531 :          precinct within that resolution.  The precinct itself may be
; 1532 :          opened, if required, by passing `res' and `idx' directly into the
; 1533 :          `kd_precinct_ref::open' function -- see description of that
; 1534 :          function for more information.
; 1535 :             When desequencing packets from an input code-stream, the caller
; 1536 :          should first invoke the returned reference's
; 1537 :          `kd_precinct_ref::is_desequenced' member function to determine
; 1538 :          whether or not the present function has done all of the required
; 1539 :          desequencing for the precinct itself.  This happens if the
; 1540 :          precinct is directly addressable via a seek address recovered from
; 1541 :          the relevant tile's `kd_precinct_pointer_server' object.  If
; 1542 :          `kd_precinct_ref::is_desequenced' returns false, the caller should
; 1543 :          proceed to open the precinct with `kd_precinct_ref::open' and
; 1544 :          parse the next packet using `kd_precinct::desequence_packet'.  This
; 1545 :          has the effect of updating the precinct state so that the next
; 1546 :          call to `next_in_sequence' can move on to the next packet in
; 1547 :          sequence.
; 1548 :             When sequencing packets for an output code-stream, the caller
; 1549 :          should usually open the precinct and then call
; 1550 :          `kd_precinct::write_packet'.  Again, this enables the next call
; 1551 :          to `next_in_sequence' to move on to the next packet in sequence.
; 1552 :             If the caller does not actually take steps to desequence the
; 1553 :          next input packet or to write the next output packet, subsequent
; 1554 :          calls to this function will return exactly with exactly the same
; 1555 :          precinct reference.  This allows the caller to delay its packet
; 1556 :          parsing or generation activities.
; 1557 :              For both input and output codestreams, this function may return
; 1558 :          NULL.   In either case, a NULL return value means that
; 1559 :          no further packets can be sequenced based on the information
; 1560 :          available for the current tile-part.  For output codestreams, a
; 1561 :          NULL return value means that the caller must write another tile-part
; 1562 :          (or simulate such an activity).  After such an activity, the
; 1563 :          next call to this function will have access to the packet sequencing
; 1564 :          specifications in a new POC marker segment (if this were not possible
; 1565 :          the function would have generated a terminal error instead of
; 1566 :          returning NULL).  For input codestreams, a NULL return value means
; 1567 :          that the caller must advance to a new tile-part.  There are two
; 1568 :          possible reasons for this: 1) a new POC marker segment may be
; 1569 :          required to obtain sequencing specifications for the next packet;
; 1570 :          or 2) the `kd_precinct_pointer_server::get_precinct_address' function
; 1571 :          might have returned -1, meaning that precincts are addressable, but
; 1572 :          the first packet of the next precinct belongs to the tile's next
; 1573 :          tile-part.
; 1574 :              The function also returns NULL if all packets have been
; 1575 :          transferred to or from the code-stream. This event may be detected
; 1576 :          by checking the tile's `num_sequenced_packets' field; the value
; 1577 :          of that field is advanced by `kd_precinct::desequence_packet' when
; 1578 :          it is called or from within the present function if the precinct
; 1579 :          is addressable (this is the condition under which the returned
; 1580 :          reference's `kd_precinct_ref::is_desequenced' returns true
; 1581 :          immediately). */
; 1582 :   private: // Member functions
; 1583 :     bool next_progression();
; 1584 :       /* Sets up the next progression (or the very first progression).
; 1585 :          Returns false, if no further progressions are available without
; 1586 :          starting a new tile-part. */
; 1587 :     kd_precinct_ref *next_in_lrcp(kd_resolution* &res, kdu_coords &idx);
; 1588 :     kd_precinct_ref *next_in_rlcp(kd_resolution* &res, kdu_coords &idx);
; 1589 :     kd_precinct_ref *next_in_rpcl(kd_resolution* &res, kdu_coords &idx);
; 1590 :     kd_precinct_ref *next_in_pcrl(kd_resolution* &res, kdu_coords &idx);
; 1591 :     kd_precinct_ref *next_in_cprl(kd_resolution* &res, kdu_coords &idx);
; 1592 :        // These functions do most of the work of `next_in_sequence'.  They
; 1593 :        // return NULL if there are no more packets to sequence within the
; 1594 :        // current progression order.
; 1595 :   private: // Declarations
; 1596 :       struct kd_packet_sequencer_state {
; 1597 :         public: // Current sequencing bounds
; 1598 :           int order; // One of the orders defined in the scope of `cod_params'
; 1599 :           int res_min, comp_min; // Lower bounds (inclusive) for loops
; 1600 :           int layer_lim, res_lim, comp_lim; // Exclusive upper bounds for loops
; 1601 :         public: // Current looping state.
; 1602 :           int layer_idx; // Current layer index
; 1603 :           int comp_idx; // Current component index
; 1604 :           int res_idx; // Current resolution level index
; 1605 :           kdu_coords pos; // Precinct position indices in current tile-comp-res
; 1606 :         public: // Spatial sequencing parameters.
; 1607 :           kdu_coords grid_min; // Common grid start for spatial loops
; 1608 :           kdu_coords grid_inc; // Common grid increments for spatial loops
; 1609 :           kdu_coords grid_loc; // Common grid location for spatial loops
; 1610 :         public: // POC access parameters
; 1611 :           kdu_params *poc; // NULL unless POC-based sequencing
; 1612 :           int next_poc_record; // Index of next order record in current POC
; 1613 :         };
; 1614 :   private: // Data
; 1615 :     kd_tile *tile;
; 1616 :     int max_dwt_levels; // Over all components.
; 1617 :     bool common_grids; // True if all components have power-of-2 sub-sampling.
; 1618 :     kdu_coords grid_lim; // Point just beyond tile on the canvas
; 1619 :     bool state_saved;
; 1620 :     kd_packet_sequencer_state state;
; 1621 :     kd_packet_sequencer_state saved_state; // Used by `save_state' member.
; 1622 :   };
; 1623 : 
; 1624 : /*****************************************************************************/
; 1625 : /*                          kd_reslength_checker                             */
; 1626 : /*****************************************************************************/
; 1627 : 
; 1628 : class kd_reslength_checker {
; 1629 :   public: // Member functions
; 1630 :     kd_reslength_checker() { memset(this,0,sizeof(*this)); }
; 1631 :     ~kd_reslength_checker() { if (specs != NULL) delete[] specs; }
; 1632 :     bool init(cod_params *cod);
; 1633 :       /* Initializes the contents of the object based on any `Creslength'
; 1634 :          parameter attribute found within `cod'.  In practice, `cod'
; 1635 :          is the relevant global, tile-specific, component-specific, or
; 1636 :          tile-component specific object retrieved by a call to
; 1637 :          `kdu_params::access_unique' with the appropriate tile and component
; 1638 :          indices; it may well be NULL, in which case the object is initialize
; 1639 :          with no constraints.  The function returns true if and only if
; 1640 :          an appropriate `Creslength' attribute was found. */
; 1641 :     void set_layer(int layer_idx);
; 1642 :       /* Use this function to walk thorugh the quality layers.  The object's
; 1643 :          `max_bytes' and `num_bytes' arrays maintain state for only a current
; 1644 :          quality layer.  If `layer_idx' is non-zero, it must be either the
; 1645 :          same or one more than the value of `layer_idx' which was last
; 1646 :          supplied to the function, so that the `prev_layer_bytes' array
; 1647 :          can be used to correctly initialize the `num_bytes' entries
; 1648 :          internally. */
; 1649 :     bool check_packet(kdu_long packet_bytes, int depth)
; 1650 :       /* Updates internal records of the number of bytes associated with
; 1651 :          the given resolution (highest resolution corresponds to `depth'=0)
; 1652 :          and all higher resolutions (smaller depths).  Checks for violation
; 1653 :          of constraints, returning false if any constraints is violated. */
; 1654 :       {
; 1655 :         assert((depth >= 0) && (depth <= 32));
; 1656 :         if ((current_layer_idx < 0) || (specs == NULL)) return true;
; 1657 :         kdu_long lim;
; 1658 :         for (int d=0; (d <= depth) && ((lim=max_bytes[d]) > 0); d++)
; 1659 :           if ((num_bytes[d] += packet_bytes) > lim) return false;
; 1660 :         return true;
; 1661 :       }
; 1662 :   private: // Member variables
; 1663 :     int num_specs;
; 1664 :     kdu_long *specs;
; 1665 :     int current_layer_idx; // -1 if no call to `set_layer' yet.
; 1666 :     kdu_long max_bytes[33]; // Limit for this resolution
; 1667 :     kdu_long num_bytes[33]; // Accumulated number of bytes; see below
; 1668 :     kdu_long prev_layer_bytes[33];
; 1669 :   };
; 1670 :   /* This object manages a single collection of resolution length constraints,
; 1671 :      as provided via the `Creslength' coding parameter attribute.  There
; 1672 :      are potentially (1+T)*(1+C) of these objects in a codestream, where T
; 1673 :      is the number of tiles and C is the number of image components.  These
; 1674 :      correspond to one global form, C component-specific forms, T
; 1675 :      tile-specific forms and C*T tile-component-specific forms.
; 1676 :         `num_specs' and `specs' together hold the parameter values actually
; 1677 :      extracted from the relevant `Creslength' attribute, via the `init'
; 1678 :      function.  These together represent a collection of limits on the
; 1679 :      number of bytes at one or more resolutions, potentially for more than
; 1680 :      one quality layer.  Quality layers are separated by 0's in the
; 1681 :      `specs' array.
; 1682 :         `max_bytes' holds one limit for each potential resolution, starting
; 1683 :      from the full resolution and working down.  The entries in this array
; 1684 :      are derived from the `specs' array, for the quality layer whose index
; 1685 :      is passed to `set_layer'.
; 1686 :         `num_bytes[d]' holds the cumulative number of bytes for all packets
; 1687 :      whose lengths have been passed to `check_packet' so far, for packets
; 1688 :      at depth d or deeper.  This value is compared with `max_bytes[d]' to
; 1689 :      determine whether the resolution length constraint at depth d has been
; 1690 :      violated.
; 1691 :         `prev_layer_bytes' is used to initialize the `num_bytes' entries
; 1692 :      at the start of each new quality layer, based on the total number of
; 1693 :      bytes accumulated by `check_packet' in the previous layer, if any. */
; 1694 : 
; 1695 : /*****************************************************************************/
; 1696 : /*                           kd_global_rescomp                               */
; 1697 : /*****************************************************************************/
; 1698 : 
; 1699 : struct kd_global_rescomp {
; 1700 :   public: // Member functions
; 1701 :     kd_global_rescomp()
; 1702 :       {
; 1703 :         codestream = NULL; depth = comp_idx = 0;
; 1704 :         total_area = area_used_by_tiles = area_covered_by_tiles = 0;
; 1705 :         remaining_area = ready_area = 0;
; 1706 :         ready_fraction = reciprocal_fraction = -1.0;
; 1707 :         first_ready = last_ready = NULL;
; 1708 :       }
; 1709 :     ~kd_global_rescomp() { close_all(); }
; 1710 :     void close_all();
; 1711 :       /* Closes all precincts currently stored on the ready list. */
; 1712 :     void initialize(kd_codestream *codestream, int depth, int comp_idx);
; 1713 :       /* Call this function upon creation or restart of an output
; 1714 :          `kdu_codestream' object.  Releases any existing precincts and
; 1715 :          initializes all counters. */
; 1716 :     void notify_tile_status(kdu_dims tile_dims, bool uses_this_resolution);
; 1717 :       /* Call this function when each tile is opened, to indicate whether or
; 1718 :          not this resolution level exists within each component of that tile.
; 1719 :          This updates internal counters used for incremental rate control and
; 1720 :          slope prediction. */
; 1721 :     void add_ready_precinct(kd_precinct *precinct);
; 1722 :     void close_ready_precinct(kd_precinct *precinct);
; 1723 :       /* Extracts the precinct from the list and releases all of its resources.
; 1724 :          This function is called from `write_packet'. */
; 1725 :   public: // Data
; 1726 :     kd_codestream *codestream;
; 1727 :     int depth, comp_idx;
; 1728 :     kdu_long total_area;
; 1729 :     kdu_long area_used_by_tiles;
; 1730 :     kdu_long area_covered_by_tiles;
; 1731 :     kdu_long remaining_area;
; 1732 :     kd_precinct *first_ready;
; 1733 :     kd_precinct *last_ready;
; 1734 :     kdu_long ready_area;
; 1735 :     double ready_fraction;
; 1736 :     double reciprocal_fraction; // 1/ready_fraction.
; 1737 :   };
; 1738 :   /* Notes:
; 1739 :         `depth' is 0 for the highest resolution level, increasing from there.
; 1740 :         `total_area' is the total area of this component-resolution.
; 1741 :         `area_used_by_tiles' is the area associated with the portion of this
; 1742 :      component-resolution covered by tiles which have already been opened and
; 1743 :      have precincts which contribute to the component-resolution.
; 1744 :         `area_covered_by_tiles' is the area associated with the portion of this
; 1745 :      component-resolution covered by tiles which have already been opened,
; 1746 :      regardless of whether those tiles have precincts which contribute to the
; 1747 :      component-resolution or not.  The ratio between `area_used_by_tiles' and
; 1748 :      `area_covered_by_tiles' is used to estimate the proportion of the
; 1749 :      remaining area which is likely to contribute precincts.
; 1750 :         `remaining_area' is the maximum area for which precincts must still
; 1751 :      be written to the code-stream.  This is equal to `total_area' minus
; 1752 :      `area_unused_by_tiles' minus the total area associated with all precincts
; 1753 :      in this component-resolution for which at least one packet has already
; 1754 :      been written out to the code-stream.
; 1755 :         `ready_area' is the area associated with all precincts in the
; 1756 :      ready list headed by `first_ready'.  The ready precincts have been fully
; 1757 :      generated, but none of their packets have yet been written to the
; 1758 :      code-stream.  Whenever it is done, rate allocation is performed on these
; 1759 :      precincts.
; 1760 :         `ready_fraction' holds a quantity in the range 0 to 1, representing
; 1761 :      the expected fraction of the remaining area which is represented by the
; 1762 :      ready precincts.  A negative value means that this quantity has not
; 1763 :      yet been computed, or it needs to be recomputed.  The value is computed
; 1764 :      from
; 1765 :         F = `ready_area' / A
; 1766 :      where A is given by
; 1767 :         A = (`remaining_area'-T)
; 1768 :           + T * (`area_used_by_tiles'/`area_covered_by_tiles')
; 1769 :      and
; 1770 :         T = `total_area' - `area_covered_by_tiles'
; 1771 :   */
; 1772 : 
; 1773 : /*****************************************************************************/
; 1774 : /*                              kd_comp_info                                 */
; 1775 : /*****************************************************************************/
; 1776 : 
; 1777 : struct kd_comp_info {
; 1778 :   public: // Data
; 1779 :     kdu_coords sub_sampling; // Component sub-sampling factors.
; 1780 :     float crg_x, crg_y; // Component registration offsets.
; 1781 :     int precision; // Original component bit-depths.
; 1782 :     bool is_signed; // Signed/unsigned nature of original components
; 1783 :     kdu_byte hor_depth[33];
; 1784 :     kdu_byte vert_depth[33];
; 1785 :     int apparent_idx; // See below
; 1786 :     kd_comp_info *from_apparent; // See below
; 1787 :   };
; 1788 :   /* Notes:
; 1789 :        This structure holds codestream-wide information for a single image
; 1790 :        component.
; 1791 :           The `hor_depth' and `vert_depth' arrays contain information which
; 1792 :        might be affected by DFS marker segments in the codestream's main
; 1793 :        header.  The values of `hor_depth'[d] and `vert_depth'[d] identify
; 1794 :        the total number of horizontal and vertical low-pass filtering and
; 1795 :        downsampling stages which are involved in creating the resolution
; 1796 :        level which is `d' levels below the original full image resolution.
; 1797 :        Neither value may exceed d.  Thus, `hor_depth'[0] and `vert_depth'[0]
; 1798 :        are guaranteed to equal zero -- these entries exist only to make the
; 1799 :        implementation more regular.  Codestreams conforming to JPEG2000
; 1800 :        Part-1 must have `hor_depth'[d] = `vert_depth'[d] = d for all d.
; 1801 :        Part-2 codestreams, however, may have custom downsampling factor
; 1802 :        styles (represented by DFS marker segments in the main header).
; 1803 :           The `apparent_idx' and `from_apparent' members are provided
; 1804 :        because the `kdu_codestream' interface (and its descendants) might
; 1805 :        be limited to exposing only a subset of the actual image components
; 1806 :        which are available.  This subset is selected via
; 1807 :        `kdu_codestream::apply_input_restrictions'.  The `apparent_idx'
; 1808 :        member identifies the index (starting from 0) of the present
; 1809 :        codestream image component, as it appears to the external API.  This
; 1810 :        value will be 0 if the component is not visible across the API.  The
; 1811 :        `from_apparent' member is used to translate apparent component
; 1812 :        indices into true codestream component indices.  Specifically, the
; 1813 :        `kd_codestream::comp_info[c].from_apparent' member points to the
; 1814 :        particular entry in the `kd_codestream::comp_info' array which
; 1815 :        represents the true codestream image component whose apparent index is
; 1816 :        c.  This is NULL if c >= `kd_codestream::num_apparent_components'. */
; 1817 : 
; 1818 : /*****************************************************************************/
; 1819 : /*                           kd_output_comp_info                             */
; 1820 : /*****************************************************************************/
; 1821 : 
; 1822 : struct kd_output_comp_info {
; 1823 :   public: // Member functions
; 1824 :     kd_output_comp_info()
; 1825 :       {
; 1826 :         precision=0; is_signed=false; subsampling_ref = NULL;
; 1827 :         apparent_idx=-1; from_apparent=0;
; 1828 :         block=NULL; block_comp_idx=0; apparent_block_comp_idx=0;
; 1829 :         is_of_interest=false; ss_tmp=0.0F;
; 1830 :       }
; 1831 :   public: // Data
; 1832 :     int precision;
; 1833 :     bool is_signed;
; 1834 :     kd_comp_info *subsampling_ref;
; 1835 :     int apparent_idx;
; 1836 :     int from_apparent;
; 1837 :     kd_mct_block *block;
; 1838 :     int block_comp_idx;
; 1839 :     int apparent_block_comp_idx;
; 1840 :     bool is_of_interest; // See below
; 1841 :     float ss_tmp; // Temporary storage used in sensitivity calculations;
; 1842 :                   // see `kd_mct_block::analyze_sensitivity'.
; 1843 :   };
; 1844 :   /* Notes:
; 1845 :         This structure is used to describe the image components produced at
; 1846 :      the output of any given MCT transform (synthesis) stage.  It is
; 1847 :      also used to describe the image components at the output of the
; 1848 :      multi-component transform from a global perspective.  The `is_signed'
; 1849 :      and `precision' members are meaningful only where this record is
; 1850 :      found at the output of the last MCT stage in the inverse multi-component
; 1851 :      transform, or in the global `output_comp_info' array managed by
; 1852 :      `kd_codestream'.
; 1853 :         If the inverse multi-component transform does not produce any data for
; 1854 :      this output component, its `subsampling_ref' member is NULL.  Otherwise
; 1855 :      `subsampling_ref' points to the `kd_comp_info' structure which describes
; 1856 :      any of the codestream image components which is involved in
; 1857 :      reconstructing this output component -- it does not matter which one.
; 1858 :      The purpose of this reference is to facilitate the determination of the
; 1859 :      dimensions and sub-sampling attributes of the relevant output component.
; 1860 :      All codestream image components involved in the reconstruction of
; 1861 :      any given MCT output component must have identical dimensions, so it
; 1862 :      is sufficient to reference only one of them.
; 1863 :         The `apparent_idx' and `from_apparent' members work in exactly the
; 1864 :      same way as their namesakes in `kd_comp_info' to facilitate translation
; 1865 :      between true image component indices and apparent image component
; 1866 :      indices, as presented to the application.  The only difference is
; 1867 :      that `from_apparent' is the index (rather than the address) of the
; 1868 :      true output image component which appears to have the index of the
; 1869 :      current component.  The apparent component indices are influenced by
; 1870 :      calls to the second form of the `kdu_codestream::change_appearance'
; 1871 :      function.
; 1872 :         The last four members are used only when the object is found in
; 1873 :      the `output_comp_info' array of a `kd_mct_stage' object.  In this case,
; 1874 :      `block' points to the MCT transform block which is used to produce this
; 1875 :      component within the relevant stage, while `block_comp_idx' indicates
; 1876 :      which of the output components from that transform stage corresponds
; 1877 :      to the current component.  The `apparent_block_comp_idx' member
; 1878 :      identifies the apparent index of this output component within the
; 1879 :      referenced transform block, which may be smaller than `block_comp_idx'
; 1880 :      if some earlier output components from the transform block are not
; 1881 :      apparent.  This value is guaranteed to lie between 0 and
; 1882 :      `block->num_apparent_outputs'-1.  `is_of_interest' is set to false
; 1883 :      if and only if `apparent_idx' is negative, except in the final
; 1884 :      transform stage, where it is also set to false if the corresponding
; 1885 :      component is not of interest to the application, as identified by
; 1886 :      calls to `kdu_tile::set_components_of_interest'.
; 1887 :         If the object is found in `kd_codestream::output_comp_info',
; 1888 :      the `block' member will be NULL and `block_comp_idx',
; 1889 :      `apparent_block_idx' and `is_of_interest' have no meaning. */
; 1890 : 
; 1891 : /*****************************************************************************/
; 1892 : /*                            kd_mct_ss_model                                */
; 1893 : /*****************************************************************************/
; 1894 : 
; 1895 : struct kd_mct_ss_model {
; 1896 :   public: // Member functions
; 1897 :     kd_mct_ss_model()  { ss_vals = ss_handle = NULL; }
; 1898 :     ~kd_mct_ss_model() { if (ss_handle != NULL) delete[] ss_handle; }
; 1899 :   public: // Data
; 1900 :     kdu_int16 range_min;
; 1901 :     kdu_int16 range_len;
; 1902 :     float *ss_vals;
; 1903 :     float *ss_handle;
; 1904 :   };
; 1905 :   /* See the discussion of `kd_mct_block::ss_models' for an explanation of
; 1906 :      this structure. */
; 1907 : 
; 1908 : /*****************************************************************************/
; 1909 : /*                              kd_mct_block                                 */
; 1910 : /*****************************************************************************/
; 1911 : 
; 1912 : struct kd_mct_block {
; 1913 :   public: // Member functions
; 1914 :     kd_mct_block() { memset(this,0,sizeof(*this)); }
; 1915 :     ~kd_mct_block()
; 1916 :       {
; 1917 :         if (input_indices != NULL) delete[] input_indices;
; 1918 :         if (inputs_required != NULL) delete[] inputs_required;
; 1919 :         if (output_indices != NULL) delete[] output_indices;
; 1920 :         if (dwt_step_info != NULL) delete[] dwt_step_info;
; 1921 :         if (dwt_coefficients != NULL) delete[] dwt_coefficients;
; 1922 :         if (scratch != NULL) delete[] scratch;
; 1923 :         if (ss_models != NULL) delete[] ss_models;
; 1924 :       }
; 1925 :     void analyze_sensitivity(int which_input, float input_weight,
; 1926 :                              int &min_output_idx, int &max_output_idx,
; 1927 :                              bool restrict_to_interest);
; 1928 :       /* This function plays a central role in the calculation of energy
; 1929 :          weights.  It determines the contribution of the block input
; 1930 :          component identified by `which_input' to the set of stage output
; 1931 :          components for the MCT stage in which the block resides,
; 1932 :          multiplying the contribution by `input_weight' and adding it into
; 1933 :          the `kd_output_comp_info::ss_tmp' members of all affected stage
; 1934 :          outputs.  The `which_input' argument must lie in the range 0 to
; 1935 :          `num_inputs'-1, where `num_inputs' is the number of inputs for
; 1936 :          this block.
; 1937 :             The `min_output_idx' and `max_output_idx' arguments
; 1938 :          play a key role in minimizing the complexity of sensitivity
; 1939 :          calculations for multi-component transforms which involve large
; 1940 :          numbers of image components.  On entry, these identify the range
; 1941 :          of stage output components whose `kd_output_comp_info::ss_tmp'
; 1942 :          members have already been affected by sensitivity calculations
; 1943 :          for other transform blocks in the same stage; if this is the first
; 1944 :          stage, the `min_output_idx' value supplied on entry should be
; 1945 :          strictly greater than the `max_output_idx' value, to indicate that
; 1946 :          the range of affected stage outputs is empty so far.  On exit,
; 1947 :          the `min_output_idx' and `max_output_idx' arguments represent the
; 1948 :          augmented range of affected outputs.  Whenever this range grows,
; 1949 :          the function first initialized the affected `ss_tmp' members to 0,
; 1950 :          so there is no need to explicitly initialize all `ss_tmp' members
; 1951 :          in the `kd_mct_stage::output_comp_info' array.  This can also save
; 1952 :          quite a bit of wasted effort when there are a very large number
; 1953 :          of components.
; 1954 :             If `restrict_to_interest' is true, the sensitivity analysis is
; 1955 :          restricted to include only those output components for which
; 1956 :          `kd_output_comp_info::is_of_interest' is true. */
; 1957 :   private: // Helper functions
; 1958 :     void create_matrix_ss_model();
; 1959 :     void create_rxform_ss_model();
; 1960 :     void create_old_rxform_ss_model();
; 1961 :     void create_dependency_ss_model();
; 1962 :     void create_dwt_ss_model();
; 1963 :   public: // Data
; 1964 :     kd_mct_stage *stage;
; 1965 :     int num_inputs;
; 1966 :     int num_required_inputs;
; 1967 :     int *input_indices;
; 1968 :     bool *inputs_required;
; 1969 :     int num_outputs;
; 1970 :     int num_apparent_outputs;
; 1971 :     int *output_indices;
; 1972 :     kd_mct_ss_model *ss_models;
; 1973 :     bool is_reversible;
; 1974 :     bool is_null_transform;
; 1975 :     kdu_params *offset_params;
; 1976 :     kdu_params *matrix_params;
; 1977 :     kdu_params *old_mat_params; // For compatibility with versions before v6.0
; 1978 :     kdu_params *triang_params;
; 1979 :     int dwt_num_steps, dwt_num_levels, dwt_canvas_origin;
; 1980 :     bool dwt_symmetric, dwt_symmetric_extension;
; 1981 :     kdu_kernel_step_info *dwt_step_info;
; 1982 :     float *dwt_coefficients;
; 1983 :     int dwt_low_synth_min, dwt_low_synth_max;
; 1984 :     int dwt_high_synth_min, dwt_high_synth_max;
; 1985 :     float dwt_synth_gains[2]; // Subband gains applied before synthesis lifting
; 1986 :     float *scratch; // Contains `num_inputs' entries if allocated
; 1987 :   };
; 1988 :   /* Notes:
; 1989 :         This structure manages a single transform block within a stage of the
; 1990 :      multi-component transform.  Most types of transform blocks have an
; 1991 :      identical number of input and output components, but irreversible
; 1992 :      decorrelation transforms can have more or less output components than
; 1993 :      input components.
; 1994 :         The `input_indices' array provides the indices of the stage input
; 1995 :      components which are used by this block.  These must lie in the range
; 1996 :      0 to `stage->num_input_components'-1.  Moreover, if this is not the
; 1997 :      first stage, these same indices may be used to address the
; 1998 :      `stage->prev_stage->output_comp_info' array, to discover how the input
; 1999 :      components are produced.
; 2000 :         The output_indices' array provides the indices of the stage output
; 2001 :      components which are produced by this block.  These indices may be
; 2002 :      used to address the `stage->output_comp_info' array to discover whether
; 2003 :      each output component is apparent or not, amongst other things.
; 2004 :         The `ss_models' array is created and manipulated by calls to the
; 2005 :      `analyze_sensitivity' function.  If non-NULL, the array contains
; 2006 :      `num_inputs' entries, each of which identifies the linearized
; 2007 :      contribution of a unit change in the corresponding input to the
; 2008 :      block's output components.  For reasons of efficiency, each input
; 2009 :      identifies the range of block output indices which it affects, via the
; 2010 :      corresponding `kd_mct_ss_model::range_min' and
; 2011 :      `kd_mct_ss_model::range_len' members.  The contribution of each input
; 2012 :      to the affected block outputs is given by its `kd_mct_ss_model::ss_vals'
; 2013 :      array, with length `kd_mct_ss_model::range_len'.  This array is created
; 2014 :      (set to a non-NULL value) only on demand.  Note also that the
; 2015 :      `kd_mct_ss_model::ss_vals' arrays can be allocated in a variety of
; 2016 :      ways and can be shared between different input models, wherever this
; 2017 :      allows for improved efficiency.  This is achieved by separately
; 2018 :      keeping track of actual allocated memory blocks via the
; 2019 :      `kd_mct_ss_model::ss_handle' members.
; 2020 :         Each transform block notionally has an offset vector, whose
; 2021 :      elements are to be added to the output component samples as the final
; 2022 :      step in the transform process.  If `offset_params' is non-NULL, the
; 2023 :      offsets are derived from its `Mvector' attribute.  Otherwise, the
; 2024 :      offsets are all 0.
; 2025 :         If `matrix_params', `triang_params' and `dwt_step_info' are all NULL,
; 2026 :      the transform block does nothing else.  We refer to blocks of this form
; 2027 :      as "NULL blocks".  NULL blocks map their i'th input component to their
; 2028 :      i'th output component, with the possible addition of an offset from
; 2029 :      `offset_params'.  NULL blocks are useful primarily as a tool for
; 2030 :      discarding certain input components, since only the first
; 2031 :      `num_outputs' components find their way through the block.  They are
; 2032 :      also useful for introducing permutations and offsets.  The JPEG2000
; 2033 :      standard, Part 2, refers to NULL transform blocks in this same sense,
; 2034 :      although the text in the standard is potentially unclear.
; 2035 :         For NULL transform blocks, the `is_reversible' flag will be false.
; 2036 :      For all other types of transform blocks, the `is_reversible' flag plays
; 2037 :      an important role in determining how the transformation is implemented.
; 2038 :         Apart from NULL transform blocks, there are four other types of
; 2039 :      transforms:
; 2040 :      [>>] Irreversible decorrelation transforms are described by a matrix,
; 2041 :           whose coefficients are provided by the `Mmatrix' attribute
; 2042 :           managed by `matrix_params'.  This type of transform is used if
; 2043 :           `matrix_params' is non-NULL and `is_reversible' is false.
; 2044 :      [>>] Reversible decorrelation transforms are described by a matrix
; 2045 :           of SERM factorization coefficients.  In this case, `is_reversible'
; 2046 :           is true and the value of `num_outputs' must equal `num_inputs'.
; 2047 :           Codestreams generated prior to v6.0 will have `old_mat_xforms'
; 2048 :           non-NULL, in which case the corresponding matrix coefficients
; 2049 :           have an organization with `num_outputs' rows and `num_outputs'+1
; 2050 :           columns, where the columns represent successive lifting steps.
; 2051 :           Codestreams generated from v6.0 onwards have `matrix_xforms'
; 2052 :           non-NULL, in which case the matrix coefficients have an organization
; 2053 :           with `num_outputs'+1 rows and `num_outputs' columns, where the
; 2054 :           rows represent successive lifting steps.  This matrix organization
; 2055 :           is transposed in answering calls to `kdu_tile::get_mct_rxform_info'.
; 2056 :      [>>] Reversible or irreversible dependency transform.  In this case,
; 2057 :           the `triang_params' member is non-NULL and its `Mtriang'
; 2058 :           attribute is used to access the transform coefficients.
; 2059 :      [>>] Reversible or irreversible DWT (Discrete Wavelet Transform).  In
; 2060 :           this case, `dwt_step_info' is non-NULL.  The DWT transform kernel
; 2061 :           is described by the `dwt_step_info', `dwt_num_steps',
; 2062 :           `dwt_symmetric', `dwt_symmetric_extension' and `dwt_coefficients'
; 2063 :           members.  The number of DWT levels to be applied is described by
; 2064 :           the `dwt_num_levels' member, and the canvas origin which defines
; 2065 :           the coordinate system for the DWT is given by `dwt_canvas_origin'.
; 2066 :           The regions of support occupied by each of the synthesis filters
; 2067 :           are identified by the `dwt_low_synth_min' through
; 2068 :           `dwt_high_synth_max' members.
; 2069 :      
; 2070 :         All transform coefficients and offsets are represented using the
; 2071 :      normalization conventions of the JPEG2000 marker segments from which
; 2072 :      they are derived.  This convention means that the supplied coefficients
; 2073 :      would produce the correct output image component samples, at their
; 2074 :      declared bit-depths, if applied to codestream image components which
; 2075 :      are also expressed at their declared bit-depths. */
; 2076 : 
; 2077 : /*****************************************************************************/
; 2078 : /*                              kd_mct_stage                                 */
; 2079 : /*****************************************************************************/
; 2080 : 
; 2081 : struct kd_mct_stage {
; 2082 :   public : // Static member function
; 2083 :     static void
; 2084 :       create_stages(kd_mct_stage * &result_head,
; 2085 :                     kd_mct_stage * &result_tail,
; 2086 :                     kdu_params *params_root, int tile_num,
; 2087 :                     int num_codestream_components,
; 2088 :                     kd_comp_info *codestream_component_info,
; 2089 :                     int num_output_components,
; 2090 :                     kd_output_comp_info *output_component_info);
; 2091 :       /* This function is used to create a linked list of `kd_mct_stage'
; 2092 :          objects, which describe the inverse multi-component transform for
; 2093 :          a particular tile, identified by the `tile_num' argument.  The list
; 2094 :          of MCT stages is created from the descriptions found in the
; 2095 :          coding parameter sub-system, whose root is given by `params_root'.
; 2096 :          The remaining arguments describe the input and output image
; 2097 :          components associated with the transform.  The contents of these
; 2098 :          arrays are not modified, but they are used to contribute to the
; 2099 :          initialization of the stage contents.  Note that the
; 2100 :          `kd_output_comp_info::ref_subsampling' member of the
; 2101 :          `output_component_info' array is ignored by this function.  The
; 2102 :          caller may later use the corresponding member of the internal
; 2103 :          `output_comp_info' member array to check for dimensional
; 2104 :          consistency with the corresponding global value.
; 2105 :             The head and tail of the created list are both returned via
; 2106 :          `result_head' and `result_tail'.  A number of conditions could
; 2107 :          cause this function to fail through `kdu_error'.  In many
; 2108 :          applications this causes an exception to be thrown, after
; 2109 :          which any partially created list of transform stages should be
; 2110 :          cleaned up.  The easiest way to do this is for the function to
; 2111 :          grow the list inside an object which will persist beyond any
; 2112 :          such exception -- in practice, this is the `kd_codestream' or
; 2113 :          `kd_tile' object, both of which maintain head/tail member
; 2114 :          variables for MCT stage lists.
; 2115 :             If `tile_num' is negative, this function is being used to create
; 2116 :          the `global_mct_head' & `global_mct_tail' members of
; 2117 :          `kd_codestream' based only on information in the main codestream
; 2118 :          header.  Strictly speaking, it is possible that insufficient
; 2119 :          marker segments might be found in the main header to do this
; 2120 :          successfully in a legal Part 2 codestream.  However, without
; 2121 :          this information it is not possible to know the dimensions of
; 2122 :          the output components ahead of time, which is an accidental oversight
; 2123 :          by the committee which defined JPEG2000 Part2.  For this reason,
; 2124 :          we shall treat such codestreams as illegal, but we shall not
; 2125 :          insist that any of the transform coefficients (linear coefficients
; 2126 :          or offsets) be available from the main codestream header; only
; 2127 :          the structure is required (MCO and MCT marker segments).  In
; 2128 :          particular, this means that the present function leaves all but
; 2129 :          the first 6 member fields of each `kd_mct_block' equal to 0
; 2130 :          (i.e., as if each transform block was a null transform) when
; 2131 :          invoked with a negative `tile_num' argument. */
; 2132 :   public: // Member functions
; 2133 :     kd_mct_stage() { memset(this,0,sizeof(*this)); }
; 2134 :     ~kd_mct_stage()
; 2135 :       {
; 2136 :         if (input_required_indices != NULL)
; 2137 :           delete[] input_required_indices;
; 2138 :         if (output_comp_info != NULL) delete[] output_comp_info;
; 2139 :         if (blocks != NULL) delete[] blocks;
; 2140 :       }
; 2141 :     void apply_output_restrictions(kd_output_comp_info *output_comp_info,
; 2142 :                                    int num_components_of_interest=0,
; 2143 :                                    const int *components_of_interest=NULL);
; 2144 :       /* This function should be directly invoked on the last stage in a
; 2145 :          list of `kd_mct_stage' objects (i.e., on the object whose
; 2146 :          `next_stage' member is NULL).  It converts the restrictions on
; 2147 :          the set of required output components, as identified by the
; 2148 :          `kd_output_comp_info::apparent_idx' values in the supplied
; 2149 :          `output_comp_info' argument (this should be the global
; 2150 :          `kd_codestream::output_comp_info' array), into a set of required
; 2151 :          input components for each stage.  Specifically, it starts
; 2152 :          by reflecting the output component requirements to the final stage
; 2153 :          in the list.  It then works backward through the stages until it
; 2154 :          arrives at the first stage, at which point the set of required
; 2155 :          codestream components is known.  In each stage, the function sets
; 2156 :          the `input_required_indices' array entries, the `apparent_idx',
; 2157 :          `from_apparent' and `apparent_block_comp_idx' members of each
; 2158 :          `output_comp_info' array, the `kd_mct_stage::num_apparent_outputs'
; 2159 :          and the `kd_mct_block::num_apparent_outputs' values.
; 2160 :             The `num_components' of interest and `components_of_interest'
; 2161 :          arguments have the same interpretation as their namesakes in the
; 2162 :          `kdu_tile::set_components_of_interest' function. */
; 2163 :   public: // Data
; 2164 :     int num_inputs;
; 2165 :     int num_required_inputs;
; 2166 :     int *input_required_indices;
; 2167 :     int num_outputs;
; 2168 :     int num_apparent_outputs;
; 2169 :     kd_output_comp_info *output_comp_info;
; 2170 :     int num_blocks;
; 2171 :     kd_mct_block *blocks;
; 2172 :     kd_mct_stage *prev_stage; // Closer to the codestream image components
; 2173 :     kd_mct_stage *next_stage; // Closer to the output image components
; 2174 :   };
; 2175 :   /* Notes:
; 2176 :        Each stage of the multi-component transform has a well-defined
; 2177 :      contiguous set of input and output components, even if not all of the
; 2178 :      components in this range are fully used or defined.  The stages appear
; 2179 :      in the order required for inverse transformation (synthesis) during
; 2180 :      decompression.  For this reason, the first `num_inputs'
; 2181 :      member for the first MCT stage is guaranteed to be equal to the
; 2182 :      number of codestream image components.
; 2183 :         In order to satisfy the constraints described by IS 15444-2,
; 2184 :      the `num_inputs' value of any one stage must not be less
; 2185 :      than the `num_outputs' value of the previous stage.  Also,
; 2186 :      every one of the `num_inputs' must be "touched" by one or
; 2187 :      another MCT block.  However, not all of the `num_outputs'
; 2188 :      need to be explicitly generated by any MCT block.  Those which are
; 2189 :      not are known as NULL components -- they are defined to be identically
; 2190 :      equal to 0.
; 2191 :         Once the list of stages has been created, the `num_outputs' value
; 2192 :      from one stage is augmented (if necessary) to the `num_inputs' value
; 2193 :      of the next stage.  This is done only to simplify the way in which
; 2194 :      stages are manipulated.
; 2195 :         The `input_required_indices' array contains one entry for each
; 2196 :      of the input components.  The k'th entry is non-negative if and only
; 2197 :      if input component k is "required", meaning that it contributes to at
; 2198 :      least one of the output components which are apparent and of interest
; 2199 :      to the application, as identified by the
; 2200 :      `kd_output_comp_info::is_of_interest' values in the
; 2201 :      `output_comp_info' array.  Moreover, non-negative indices in the
; 2202 :      `input_required_indices' array identify the ordinal position
; 2203 :      occupied by the corresponding component, in the set of all required
; 2204 :      components.  For non-initial stages, this ordinal position is the same
; 2205 :      as the apparent index of the previous stage's output component.
; 2206 :         It may not always be easy (or expedient) to determine
; 2207 :      precisely whether an input component actually contributes to the
; 2208 :      output produced by a transform block, so it is possible that the
; 2209 :      set of input components which are marked as "required" contains
; 2210 :      some components which could potentially be ignored.  Nevertheless,
; 2211 :      reasonable efforts are made to limit the set of required input
; 2212 :      components, based on the set of required output components.
; 2213 :         The `num_required_inputs' member holds the total number of
; 2214 :      non-negative entries in the `input_required_indices' array.
; 2215 :         The `prev_stage' member is NULL if this is the first stage in
; 2216 :      the inverse (synthesis) multi-component transform, meaning that the
; 2217 :      stage's input components are the codestream image components.
; 2218 :         The `next_stage' member is NULL if this is the last stage in the
; 2219 :      inverse (synthesis) multi-component transform, meaning that the stage's
; 2220 :      output components are the final output image components produced by
; 2221 :      the decompression process. */
; 2222 : 
; 2223 : /*****************************************************************************/
; 2224 : /*                              kd_codestream                                */
; 2225 : /*****************************************************************************/
; 2226 : 
; 2227 : struct kd_codestream { // State structure for the "kdu_codestream" interface
; 2228 :   public: // Member functions
; 2229 :     kd_codestream()
; 2230 :       { // We will be relying on all fields starting out as 0.
; 2231 :         memset(this,0,sizeof(*this));
; 2232 :         max_unloadable_tiles = 64; // A reasonable default value
; 2233 :       }
; 2234 :     ~kd_codestream();
; 2235 :     void construct_common();
; 2236 :       /* Called from within `kdu_codestream::create' after some initial
; 2237 :          construction work to set the thing up for input or output. */
; 2238 :     void construct_output_comp_info();
; 2239 :       /* Called if `output_comp_info' is NULL, but before (or if
; 2240 :          necessary inside) `finalize_construction'.  During reading, this
; 2241 :          function may not be called until all main header information
; 2242 :          has been parsed, since the information in `siz' is not
; 2243 :          complete until both the SIZ and CBD marker segments have been
; 2244 :          parsed.  For codestreams created for writing or for interchange,
; 2245 :          this function is called from within `construct_common'. */
; 2246 :     void finalize_construction();
; 2247 :       /* For input codestreams, this function is called immediately after
; 2248 :          the main header has been read.  For output codestreams, the
; 2249 :          call is deferred so as to give the caller an opportunity to
; 2250 :          modify coding parameters and call `kdu_params::finalize_all'.  It
; 2251 :          is invoked when information from those coding parameters is
; 2252 :          first required, which will be no later than the first call to
; 2253 :          `kdu_codestream::open_tile'. */
; 2254 :     void restrict_to_fragment(kdu_dims fragment_region,
; 2255 :                               int fragment_tiles_generated,
; 2256 :                               kdu_long fragment_tile_bytes_generated);
; 2257 :       /* This function is called immediately after `construct_common'
; 2258 :          if the `kdu_codestream::create' function supplied a non-NULL
; 2259 :          `fragment_region'. */
; 2260 :     void restart();
; 2261 :       /* Called from within `kdu_codestream::restart' to perform common
; 2262 :          re-initialization steps for an existing code-stream. */
; 2263 :     kd_tile *create_tile(kdu_coords idx);
; 2264 :       /* Creates and completely initializes a new tile, installing it in the
; 2265 :          internal array of tile references and returning a pointer to the
; 2266 :          new tile.  The pointer returned may be equal to KD_EXPIRED_TILE if
; 2267 :          the tile was found not to belong to the current region of interest.
; 2268 :          Note that this function might reclaim previously released tiles
; 2269 :          from a cache of released typical tiles, managed by the
; 2270 :          `typical_tile_cache' member.  The `idx' argument holds the absolute
; 2271 :          index of the tile, which must lie within the range represented by
; 2272 :          the `tile_indices' region member. */
; 2273 :     void trim_compressed_data();
; 2274 :       /* This function may be called periodically to trim away the storage
; 2275 :          associated with compressed data bytes which will never be included
; 2276 :          in the final compressed representation.  The function can do nothing
; 2277 :          unless `kdu_codestream::set_max_bytes' has been called to establish
; 2278 :          a target compressed length. */
; 2279 :     void calculate_min_header_cost();
; 2280 :       /* Estimates the minimum total number of header bytes required by
; 2281 :          mandatory code-stream headers, recording the results in the member
; 2282 :          variables, `min_fixed_header_size' and `min_layer_header_size'.
; 2283 :          The minimum header cost for the first k quality layers is equal to
; 2284 :          `min_fixed_header_size' + `min_layer_header_size'*k.  The initial
; 2285 :          cost includes the main header, any tile-part headers and the EOC
; 2286 :          marker.  The per-layer cost includes 1 byte for every precinct, plus
; 2287 :          an additional 2 bytes per precinct if EPH markers are used and an
; 2288 :          additional 6 bytes per precinct if SOP marker segments are used.  The
; 2289 :          costs reported here deliberately exclude the cost of any optional PLT
; 2290 :          or TLM pointer marker segments and may underestimate the cost of
; 2291 :          tile-part headers under some conditions. */
; 2292 :     kdu_long simulate_output(kdu_long &header_bytes,
; 2293 :                              int layer_idx, kdu_uint16 slope_threshold,
; 2294 :                              bool finalize_layer, bool last_layer,
; 2295 :                              kdu_long max_bytes=KDU_LONG_HUGE,
; 2296 :                              kdu_long *sloppy_bytes=NULL);
; 2297 :       /* This function plays a critical role in rate control and preparing
; 2298 :          for code-stream generation.  It may be used in applications which
; 2299 :          generate the entire code-stream once all precinct data has been
; 2300 :          generated, but it may also be used in applications which generate
; 2301 :          the code-stream incrementally, periodically sizing and generating
; 2302 :          whatever portion of the code-stream can be written, given the
; 2303 :          code-blocks which have been encoded so far.
; 2304 :             To understand the operation of this function, it is helpful to
; 2305 :          know that whenever a precinct's code-blocks have been encoded, the
; 2306 :          precinct is entered onto a "ready" list.  When the present function
; 2307 :          is called, it simulates the process of generating final code-stream
; 2308 :          output for a single quality layer of all such "ready" precincts.
; 2309 :          If the "ready" precincts are not sufficient to generate the
; 2310 :          full code-stream, their size is automatically scaled, using an
; 2311 :          algorithm which attempts to estimate the number of bytes which
; 2312 :          would be occupied by all packets belonging to the indicated layer
; 2313 :          which have not yet been written to the code-stream.  For this reason,
; 2314 :          the `max_bytes' value supplied to this function should represent
; 2315 :          the maximum number of bytes which are allowed for all packets
; 2316 :          belonging to the indicated layer, minus the number of bytes which
; 2317 :          have already been written for packets belonging to that layer.
; 2318 :             The simulation process is driven by the supplied distortion-length
; 2319 :          slope threshold.  A slope threshold of 0 yields the largest possible
; 2320 :          output size and 0xFFFF yielding the smallest possible output size
; 2321 :          (all code-block bytes discarded).
; 2322 :             The number of bytes returned includes the extra cost of tile and
; 2323 :          packet headers.  The number of such header bytes is also separately
; 2324 :          returned via the `header_bytes' argument.  The function deliberately
; 2325 :          does not count the cost of PLT or TLM marker segments.  Also,
; 2326 :          certain combinations of the ORGtparts and Porder code-stream
; 2327 :          parameter attributes can lead to minor inaccuracies in the simulated
; 2328 :          lengths due to difficulties in anticipating the number of tile-parts
; 2329 :          which will need to be written.  Both the return value and the
; 2330 :          `header_bytes' value are scaled to represent the expected cost over
; 2331 :          all packets of the indicated layer which have not yet been written
; 2332 :          to the code-stream.
; 2333 :             The `finalize_layer' argument should be true if this is the last
; 2334 :          call to this function with the current layer index.  This causes the
; 2335 :          packet header state information to be saved to a place from which
; 2336 :          it will be restored in each simulation attempt for the next layer.
; 2337 :          Also, it is mandatory to finalize the layers during simulation
; 2338 :          before actually generating packet data.
; 2339 :             The `last_layer' argument should be true if this is the final
; 2340 :          layer for which any information will be generated.  If any tile
; 2341 :          contains more layers, their contribution will be included at this
; 2342 :          point as empty packets (i.e., the empty packet bit is set to 0).
; 2343 :          Any such empty packet is never assigned an SOP marker.
; 2344 :             The `max_bytes' argument may be used to supply an upper bound on
; 2345 :          the total number of bytes which are allowed to be generated here.
; 2346 :          This allows the simulation process to stop as soon as this limit
; 2347 :          is exceeded.  In this case, the returned byte count may not be a
; 2348 :          true reflection of the full cost of generating the layer, but it
; 2349 :          is guaranteed to exceed the `max_bytes' limit.
; 2350 :             When the function is called with `finalize_layer' true, the
; 2351 :          `max_bytes' limit must not, under any circumstances be exceeded.
; 2352 :          The assumption is that the caller has already done the work of
; 2353 :          figuring out a slope threshold which will satisfy the relevant
; 2354 :          rate constraint -- if not, `max_bytes' can be set to
; 2355 :          KDU_LONG_HUGE (the default).  Note that KDU_LONG_HUGE is a
; 2356 :          very large "kdu_long" value which can be represented exactly as a
; 2357 :          double precision floating point quantity; it may be less than
; 2358 :          KDU_LONG_MAX.
; 2359 :             A non-NULL `sloppy_bytes' argument may be supplied only when
; 2360 :          finalizing the last layer, once all code-blocks in the entire
; 2361 :          code-stream have been generated.  In this case, the caller must be
; 2362 :          certain that a slope threshold of `slope_threshold'+1 can satisfy
; 2363 :          the limit imposed by `max_bytes'.  The function first runs the low
; 2364 :          level packet-oriented simulation tools with this value of
; 2365 :          `slope_threshold'+1 and then runs them again (this time finalizing)
; 2366 :          with `slope_threshold'.  On the second run, any additional coding
; 2367 :          passes which would be contributed due to the reduced threshold are
; 2368 :          trimmed away from the relevant code-blocks (they cannot be recovered
; 2369 :          later on) until the number of additional bytes is less than the value
; 2370 :          of *`sloppy_bytes'.  The *`sloppy_bytes' is progressively decremented,
; 2371 :          so that upon return the caller may determine the total number of
; 2372 :          available bytes which could not be used up.  The caller should then
; 2373 :          generate packet data using the supplied slope threshold.
; 2374 :             This `sloppy_bytes' option slows down the rate control process and
; 2375 :          is recommended primarily when you can expect quite a few code-block
; 2376 :          passes to have the same length-distortion slope value.  This happens
; 2377 :          during transcoding, where the only slope information available comes
; 2378 :          from the indices of the quality layers to which the coding passes
; 2379 :          originally contributed.  It may also happen if the block encoder
; 2380 :          does not collect a rich set of length-distortion statistics, simply
; 2381 :          estimating a rough prioritization instead. */
; 2382 :     void pcrd_opt(bool trim_to_rate, double tolerance);
; 2383 :       /* Runs the PCRD-opt algorithm to find the slope thresholds for each
; 2384 :          of the `num_sized_layers' quality layers for which an entry appears
; 2385 :          in the `layer_targets', `layer_sizes' and `layer_thresholds' arrays.
; 2386 :          Upon return, the `layer_thresholds' array holds the distortion-length
; 2387 :          slope thresholds for each quality layer, which are found to achieve
; 2388 :          the cumulative layer sizes specified in the `layer_targets' array, as
; 2389 :          closely as possible.
; 2390 :             Non-zero entries in the `layer_targets' array are not altered by
; 2391 :          this function.  Any entry which is found to be zero is replaced by
; 2392 :          a suitable non-zero target size, based on the following principles:
; 2393 :          1) Cumulative layer target sizes are to be spaced logarithmically.
; 2394 :             This policy allows target sizes to be assigned to any layer which
; 2395 :             falls between layers having known target sizes.
; 2396 :          2) If the last quality layer has an unknown size, all remaining
; 2397 :             coded data will be included in that layer and its entry in the
; 2398 :             `layer_targets' array will be set equal to the actual cumulative
; 2399 :             number of bytes allocated to all quality layers.
; 2400 :          3) If one or more initial layer have an unknown target size, their
; 2401 :             target sizes will be assigned logarithmically following the
; 2402 :             convention that each layer should increase the cumulative size
; 2403 :             by a factor of sqrt(2).
; 2404 :                The function is designed to work under both single flush and
; 2405 :          incremental flushing conditions.  When incremental flushing is used,
; 2406 :          the function will be called multiple times.  Each call determines a
; 2407 :          suitable set of slope thresholds for incremental code-stream, after
; 2408 :          which the caller performs the incremental code-stream generation.
; 2409 :          This latter activity updates entries in the `layer_sizes' array
; 2410 :          which keeps track of the total size of each quality layer, excluding
; 2411 :          optional pointer information.  The `layer_targets' values refer to
; 2412 :          the cumulative size at each layer, spread over the entire code-stream.
; 2413 :          The present function finds slope thresholds which, if applied to
; 2414 :          all code-blocks not yet written to the code-stream, would be expected
; 2415 :          to produce a number of bytes equal to the relevant `layer_targets'
; 2416 :          value minus the corresponding `layer_sizes' value.
; 2417 :                The `trim_to_rate' argument has the same interpretation as it
; 2418 :          does in the `kdu_codestream::flush' function.  You should not use this
; 2419 :          option unless all code-blocks have already been encoded, meaning that
; 2420 :          this is the last call to this function prior to complete generation
; 2421 :          of the code-stream.
; 2422 :                The `tolerance' argument also has the same interpretation as it
; 2423 :          does in the `kdu_codestream::flush' function.  There is no restriction
; 2424 :          on its use.
; 2425 :     */
; 2426 :     bool generate_codestream(int max_layers);
; 2427 :       /* Generates as much of the final code-stream as possible, given the
; 2428 :          packet progression order which has been selected and the precincts
; 2429 :          which have actually been finalized.  Returns true if the code-stream
; 2430 :          has been completely generated after this function finishes its
; 2431 :          work; in this case, the EOC marker is also written.
; 2432 :          Returns false otherwise.
; 2433 :             The contents of each quality layer are determined from the
; 2434 :          distortion-length slope thresholds recorded in the `layer_thresholds'
; 2435 :          member array.  The number of available thresholds must not be less
; 2436 :          than `max_layers'.  If `max_layers' is less than the number of actual
; 2437 :          quality layers in any tile, the additional quality layers will all
; 2438 :          be assigned empty packets.
; 2439 :             The "prcr_opt" member function will normally be used first to find
; 2440 :          distortion-length slope thresholds for the various quality layers.
; 2441 :          In any event, some simulation must have been performed to set up the
; 2442 :          packet size information required to determine tile-part header sizes,
; 2443 :          which are required for writing SOT marker segments.  This function
; 2444 :          always creates at least one new tile-part for every tile.  If
; 2445 :          requested, PLT marker segments are written into the tile-part headers
; 2446 :          to identify the lengths of packets generated in this call. */
; 2447 :     void set_reserved_layer_info_bytes(int num_layers);
; 2448 :       /* Sets aside a certain number of bytes for writing a comment marker
; 2449 :          containing a text description of the size and distortion-length slope
; 2450 :          associated with each layer.  The actual marker must be written by
; 2451 :          a subsequent call to `gen_layer_info_comment'. */
; 2452 :     void gen_layer_info_comment(int num_layers, kdu_long *layer_bytes,
; 2453 :                                 kdu_uint16 *thresholds);
; 2454 :       /* Writes the comment marker identified above in connection with
; 2455 :          `set_reserved_layer_info_bytes'. */
; 2456 :     void unload_tiles_to_cache_threshold();
; 2457 :       /* Releases unloadable tiles until the memory cache and/or unloadable
; 2458 :          tile count threshold is reached.  The function first tries to
; 2459 :          release those unloadable tiles which do not lie in the current
; 2460 :          region of interest.  If one or both thresholds are still exceeded,
; 2461 :          the function continues to release unloadable tiles, even if they
; 2462 :          do belong to the current region of interest. */
; 2463 :   private: // Helper functions
; 2464 :     void read_main_header();
; 2465 :       /* Only for input objects.  Reads all main header marker segments
; 2466 :          (starting just after the SIZ marker segment) up to and
; 2467 :          including the first SOT marker.  This function is shared
; 2468 :          by both `construct_common' and `restart'. */
; 2469 :     void freeze_comments();
; 2470 :       /* Called right before any generation or simulation tasks for code-stream
; 2471 :          generation. */
; 2472 :   public: // Links to Other Objects
; 2473 :     kdu_message *textualize_out; // NULL unless params to be textualized
; 2474 : 
; 2475 :   public: // Owned Resources
; 2476 :     kd_compressed_input *in; // NULL unless an input codestream object.
; 2477 :     kd_compressed_output *out; // NULL unless an output codestream object.
; 2478 :     siz_params *siz;
; 2479 :     kd_marker *marker; // General marker reading service. NULL if `in' is NULL
; 2480 :     kd_pp_markers *ppm_markers; // NULL unless PPM markers are used.
; 2481 :     kd_buf_server *buf_server; // Serves resources to buffer compressed data
; 2482 :     kdu_block *block; // Shared resource, used by non-threaded applications
; 2483 :     kd_compressed_stats *stats; // NULL unless rate prediction is being used.
; 2484 :     kd_tpart_pointer_server *tpart_ptr_server; // NULL if not keeping addresses
; 2485 :     kd_precinct_server *precinct_server; // Always active
; 2486 :     kd_codestream_comment *comhead, *comtail; // Linked list of comments
; 2487 :     kd_tlm_generator tlm_generator; // Not initialized until the first
; 2488 :                  // call to `generate_codestream', and then only if required.
; 2489 :     kd_mct_stage *global_mct_head; // Provided for robust cleanup if error
; 2490 :     kd_mct_stage *global_mct_tail; // occurs while constructing MCT stage list.
; 2491 : 
; 2492 :   public: // Dimensions and Parameters
; 2493 :     int profile; // 0 thru 5.  Adjusted if a violation is detected.
; 2494 :     bool uses_mct; // If the `Sextensions_MCT' flag is present in SIZ.
; 2495 :     int num_components; // Number of codestream image components.
; 2496 :     int num_apparent_components; // Codestream components visible acrosss API
; 2497 :     int num_output_components; // Same as `num_components' unless MCT is used
; 2498 :     int num_apparent_output_components; // =`num_apparent_components' if no MCT
; 2499 :     kdu_component_access_mode component_access_mode; // See below
; 2500 :     kdu_dims canvas; // Holds the image origin and dimensions; this is
; 2501 :                      // affected by fragment regions
; 2502 :     kdu_dims tile_partition; // Holds the tiling origin and dimensions; this
; 2503 :                              // is not affected by fragment regions
; 2504 :     kdu_coords tile_span; // Tiles across and down the entire codestream
; 2505 :     kdu_dims tile_indices; // Range of tile indices in `tile_refs' array
; 2506 :     int discard_levels, min_dwt_levels, max_apparent_layers;
; 2507 :     int max_tile_layers; // Max layers in any tile opened so far.
; 2508 :     int num_open_tiles; // Number of tiles opened, but not yet closed.
; 2509 :     kdu_dims region; // Current region of interest; often identical to `canvas'
; 2510 :     bool cannot_flip; // If true, codestream not compatible with view flipping
; 2511 :     bool initial_fragment; // These are both true, except possibly when
; 2512 :     bool final_fragment; // generating fragmented codestreams
; 2513 :     double fragment_area_fraction; // Fraction of image in current fragment
; 2514 :     int prev_tiles_written;           // These two parameters are zero, except
; 2515 :     kdu_long prev_tile_bytes_written; // when `initial_fragment' is false.
; 2516 : 
; 2517 :   public: // Arrays
; 2518 :     kd_comp_info *comp_info; // Array with `num_components' members
; 2519 :     kd_output_comp_info *output_comp_info; // `num_output_components' members
; 2520 :     kd_tile_ref *tile_refs; // One for each tile, in raster order
; 2521 : 
; 2522 :   public: // Information used for code-stream generation and rate control
; 2523 :     kd_tile *tiles_in_progress_head; // Head & tail for list of tiles which
; 2524 :     kd_tile *tiles_in_progress_tail; // have been opened, but not yet flushed
; 2525 :     kd_global_rescomp *global_rescomps; // Manages precincts ready for output
; 2526 :     int num_incomplete_tiles; // Number of tiles for which one or more
; 2527 :                               // packets have yet to be generated.
; 2528 :     int num_sized_layers; // Number of elements in each of the following arrays
; 2529 :     kdu_long *layer_sizes; // Bytes written to each layer; non-cumulative
; 2530 :     kdu_long *layer_targets; // Target sizes for each layer; cumulative
; 2531 :       // maintain state between multiple invocations of `kdu_codestream::flush'
; 2532 :     kdu_uint16 *layer_thresholds; // Used by `kdu_codestream::flush' to store
; 2533 :       // slope thresholds between code-stream sizing and generation.
; 2534 :     kdu_long min_fixed_header_size; // See description of the function,
; 2535 :     kdu_long min_layer_header_size; // `calculate_min_header_cost'.
; 2536 :     bool reslength_constraints_used; // If reslength constraints used anywhere 
; 2537 :     bool reslength_constraints_violated; // If any reslength constraint failed
; 2538 :     bool reslength_warning_issued; // If using together with incremental flush
; 2539 :     kd_reslength_checker *reslength_checkers; // 1+`num_components' entries;
; 2540 :         // first entry holds global reslength checker; then one per component.
; 2541 :   
; 2542 :   public: // Flags and other State Variables
; 2543 :     bool allow_restart; // True if `kdu_codestream::restart' is allowed
; 2544 :     bool transpose, vflip, hflip; // Geometric manipulation parameters
; 2545 :     bool resilient; // If true, error resilience is maximized.
; 2546 :     bool expect_ubiquitous_sops; // See declaration of "set_resilient" function
; 2547 :     bool fussy; // If true, sensitivity to correctness is maximized.
; 2548 :     bool interchange; // True if `in' and `out' are both NULL.
; 2549 :     bool simulate_parsing_while_counting_bytes; // See `set_max_bytes'
; 2550 :     bool persistent; // If `interchange' is true or if an input object's
; 2551 :                      // `kdu_codestream::set_persistent' function was called
; 2552 :     bool cached; // True if compressed source advertises KDU_SOURCE_CAP_CACHED
; 2553 :     bool in_memory_source; // True if `in' offers `KDU_SOURCE_CAP_IN_MEMORY'
; 2554 :     bool tiles_accessed; // Becomes false after first tile access
; 2555 :     bool construction_finalized; // True once `finalize_construction' is called
; 2556 :     bool comments_frozen; // True after header sizing has started
; 2557 :     bool header_generated; // True once main header has been written.
; 2558 :     kdu_int32 block_truncation_factor;// Used only by `kdu_subband::open_block'
; 2559 :     kdu_long header_length; // Num bytes written to main header
; 2560 :     int reserved_layer_info_bytes; // Bytes reserved for layer info COM segment
; 2561 :     kd_tile *active_tile; // NULL unless we are in the middle of reading a tile
; 2562 :     kdu_long next_sot_address; // For seeking to the next unread tile-part.
; 2563 :     int next_tnum; // Negative, except while scanning 1'st tparts in Profile-0
; 2564 :     int num_completed_tparts; // Number of tile-parts actually read or written.
; 2565 :     kdu_uint16 min_slope_threshold; // 0 until `set_min_slope_threshold' called
; 2566 :     clock_t start_time; // Used by `report_cpu_time'.
; 2567 : 
; 2568 :   public: // Tile cache management
; 2569 :     kd_tile *unloadable_tiles_head;
; 2570 :     kd_tile *unloadable_tiles_tail; // Tiles enter list from the tail
; 2571 :     kd_tile *unloadable_tile_scan; // Points to next tile in the list, to be
; 2572 :         // checked by `unload_tiles_to_cache_threshold' to see if it belongs
; 2573 :         // to the current region of interest.  Becomes NULL if all tiles in
; 2574 :         // the unloadable list belong to the region of interest.
; 2575 :     int num_unloadable_tiles; // Number of tiles in unloadable list
; 2576 :     int max_unloadable_tiles; // Limits the length of the unloadable tiles
; 2577 :         // list to avoid long searches for tiles which belong to the current
; 2578 :         // region of interest.
; 2579 :     kd_tile *typical_tile_cache; // List of released typical tiles, all of
; 2580 :                                  // which have `kd_tile::tile_ref'=NULL.
; 2581 :   };
; 2582 :   /* Notes:
; 2583 :          The `num_tparts_used' count does not include tiles which we skipped
; 2584 :      over since they had no intersection with the region of interest.
; 2585 :          The `active_tile' member is used during code-stream parsing to keep
; 2586 :      track of the tile whose tile-part is being actively parsed.  If `cached'
; 2587 :      is true, the compressed data is managed by a cache and there is no
; 2588 :      parsing as such.  In this case, `active_tile' is always NULL and
; 2589 :      `tpart_ptr_server' should remain NULL.
; 2590 :          The `global_rescomps' array contains 33*num_components entries.
; 2591 :      The entry at location d*num_components+c is used to manage precincts
; 2592 :      which are ready for rate-control simulation, belonging to component c
; 2593 :      at resolution depth d.  Depth 0 corresponds to the highest resolution
; 2594 :      level of each tile of component c.
; 2595 :          Information is maintained for two different types of image
; 2596 :      components here.  Most of the machinery is concerned with so-called
; 2597 :      "codestream image components".  These are the ones which are subjected
; 2598 :      to spatial DWT, quantization and block coding processes.  Consequently,
; 2599 :      we commonly refer to these simply as the components.  The image
; 2600 :      components, however, are often subjected to subsequent inverse
; 2601 :      colour or multi-component transformation processes in order to
; 2602 :      reconstruct a final image.  We refer to the components (or planes) of
; 2603 :      the final reconstructed image as "output image components".  The
; 2604 :      output components are described by the `num_output_components',
; 2605 :      `num_apparent_output_components' and `output_comp_info' members.
; 2606 :          As discussed extensively in the comments appearing with the second
; 2607 :      form of the `kdu_codestream::apply_input_restrictions' function, the
; 2608 :      set of visible (or apparent) output components may be different to
; 2609 :      the set of visible (or apparent) codestream components.  In fact, only
; 2610 :      one of these two sets of components may be restricted at any given
; 2611 :      time, depending on the state of the `component_access_mode' member.
; 2612 :         If `component_access_mode' is set to `KDU_WANT_CODESTREAM_COMPONENTS',
; 2613 :      the set of codestream components may be restricted or permuted via the
; 2614 :      `num_apparent_components' member, working in conjunction with
; 2615 :      `kd_comp_info::apparent_idx' and `kd_comp_info::from_apparent'.  In this
; 2616 :      case, however, information about output components will not be made
; 2617 :      available over the API -- output components will be treated as synonymous
; 2618 :      with codestream components.
; 2619 :         If `component_access_mode' is set to `KDU_WANT_OUTPUT_COMPONENTS', the
; 2620 :      set of output components may be restricted or permuted via the
; 2621 :      `num_apparent_output_components' member, working in conjunction with
; 2622 :      `kd_output_comp_info::apparent_idx' and
; 2623 :      `kd_output_comp_info::from_apparent'.  In this case, all codestream
; 2624 :      components are visible across the API in their original form, except
; 2625 :      that applications will not be able to access a non-empty
; 2626 :      `kdu_tile_comp' interface for any tile-component which is not
; 2627 :      involved in the reconstruction of any visible output components within
; 2628 :      the relevant tile (this may vary from tile to tile). */
; 2629 : 
; 2630 : /*****************************************************************************/
; 2631 : /*                                kd_tile                                    */
; 2632 : /*****************************************************************************/
; 2633 : 
; 2634 : #define KD_EXPIRED_TILE ((kd_tile *)(-1))
; 2635 : 
; 2636 : struct kd_tile { // State structure for the "kdu_tile" interface
; 2637 :   public: // Member functions
; 2638 :     kd_tile(kd_codestream *codestream, kd_tile_ref *tref,
; 2639 :             kdu_coords idx, kdu_dims tile_dims);
; 2640 :       /* Sets up only enough information for the tile to locate itself
; 2641 :          within the codestream canvas.  `idx' holds the absolute index of
; 2642 :          the tile, but this must lie within the range identified by
; 2643 :          `codestream->tile_indices'. */
; 2644 :     ~kd_tile();
; 2645 :       /* Note that this function also detaches the tile object from the
; 2646 :          codestream object which references it, replacing the pointer with
; 2647 :          the special illegal value, KD_EXPIRED_TILE. */
; 2648 :     void release();
; 2649 :       /* This function serves a similar role to the destructor, except that
; 2650 :          it reserves the option to move the object onto a list of cached
; 2651 :          "typical" tiles managed by the `kd_codestream' object.  This is
; 2652 :          done if the tile has its `is_typical' member set to true and if the
; 2653 :          codestream is open for reading.  The cached typical tile's structure
; 2654 :          can be reused in the future, without rebuilding it from scratch,
; 2655 :          subject to appropriate conditions.  If the function chooses not to
; 2656 :          move the tile onto the typical list, the destructor will be invoked,
; 2657 :          so this is a self-efacing function. */
; 2658 :     void initialize();
; 2659 :       /* Called immediately after a successful construction.  Builds all
; 2660 :          subordinate structures and fills in all fields.   If the codestream
; 2661 :          object has the persistent mode (applies to persistent input objects
; 2662 :          and all interchange objects), the region of interest members
; 2663 :          in the tile and all of its subordinate structures will be set to
; 2664 :          empty regions. Otherwise, the `set_elements_of_interest' function
; 2665 :          will be called immediately. */
; 2666 :     void recycle(kd_tile_ref *tref, kdu_coords idx, kdu_dims tile_dims);
; 2667 :       /* This function is similar to `initialize', but works on a previously
; 2668 :          constructed (typical) tile, rather than a tile which has been
; 2669 :          freshly created using the constructor.  If possible, the function
; 2670 :          will reuse the previously constructed structures (this is generally
; 2671 :          possible if the new tile is also a typical one).  Otherwise, it
; 2672 :          will delete those structures and invoke `initialize' to start over
; 2673 :          again.  The function is called only from `kd_codestream::create_tile'
; 2674 :          and only on tiles which were previously added to the typical tile
; 2675 :          cache by `kd_tile::release'. */
; 2676 :     void restart();
; 2677 :       /* Called from within `kdu_codestream::restart', so as to recycle all
; 2678 :          resources as early as possible and reset state variables in
; 2679 :          preparation for re-use.  Sets the `needs_reinit' flag, since
; 2680 :          the `reinitialize' function must be called to complete the restart
; 2681 :          operation -- this is deferred until the tile is first accessed
; 2682 :          (opened, or accessed for parsing). */
; 2683 :     void reinitialize();
; 2684 :       /* Called when a tile is first accessed in any way, after a previous
; 2685 :          call to `restart' (i.e., after a code-stream restart). */
; 2686 :     void open();
; 2687 :       /* Called by `kdu_codestream::open_tile' after the tile has been
; 2688 :          constructed and initialized (if necessary).  The function marks
; 2689 :          the tile as open until it is subsequently closed.  If the codestream
; 2690 :          object has the persistent mode (applies to persistent and all
; 2691 :          interchange objects), the tile's region of interest fields will
; 2692 :          all be set up here. */
; 2693 :     bool read_tile_part_header();
; 2694 :       /* Returns false, if the code-stream source was exhausted before a
; 2695 :          new tile-part header could be completely read (up to and including
; 2696 :          the SOD marker).  Except in this event, the current tile become's
; 2697 :          the codestream object's active tile upon return. */
; 2698 :     bool finished_reading();
; 2699 :       /* This function may be called as soon as we can be sure that no more
; 2700 :          information can be read for the tile.  When this happens, the tile
; 2701 :          is marked as `exhausted' and a search is conducted to see if we can
; 2702 :          destroy any precincts whose existence serves only to allow the parsing
; 2703 :          of packet headers.
; 2704 :             It can happen that the tile deletes itself inside this function,
; 2705 :          if the tile's resources are no longer needed by the application.  In
; 2706 :          this case, the function returns true, indicating to the caller that
; 2707 :          no further attempt should be made to reference the tile.  In all
; 2708 :          other circumstances, the function returns false. */
; 2709 :     kdu_long generate_tile_part(int max_layers, kdu_uint16 slope_thresholds[]);
; 2710 :       /* If all packets for the tile have already been transferred, the
; 2711 :          function does nothing and returns 0.  Otherwise, it generates the
; 2712 :          next tile-part header and all packets for that tile-part, using the
; 2713 :          packet sequencer to determine both the order of packets and the
; 2714 :          number of packets which belong to this tile-part.  The number
; 2715 :          of packets generated may be limited by the number of precincts
; 2716 :          for which code-block data is currently available.  The function
; 2717 :          returns the total number of bytes in the tile-part, including all
; 2718 :          marker codes and segments.
; 2719 :             The `max_layers' argument indicates the number of quality layers
; 2720 :          for which rate allocation information is available in the
; 2721 :          `slope_thresholds' array.  If the tile contains additional layers,
; 2722 :          the corresponding packets are assigned the special empty packet code,
; 2723 :          occupying only a single byte.
; 2724 :             If this function completes the generation of all the tile data,
; 2725 :          it may release the tile itself, unless its continued existence is
; 2726 :          otherwise required (e.g., it may be open for access by the
; 2727 :          application).  Also, if the maximum number of tile-parts advertised
; 2728 :          by a `codestream->tlm_generator' object exceeds the number of
; 2729 :          tile-parts actually generated when the tile data has all been
; 2730 :          written, the function writes extra empty tile-parts as required.
; 2731 :          The empty tile-parts are each 14 bytes long, but the function
; 2732 :          returns only the size of the last non-empty tile-part which was
; 2733 :          generated. */
; 2734 :     void remove_from_in_progress_list();
; 2735 :       /* This function is called after the last tile-part of a tile has been
; 2736 :          generated.  It is also called when destroying or restarting a tile,
; 2737 :          just to be on the safe side, although it should have been removed
; 2738 :          from the in-progress list previously.  See the notes below for a
; 2739 :          discussion of "in-progress" tiles. */
; 2740 :     void adjust_unloadability()
; 2741 :       { // Called when any of the conditions described in the notes below
; 2742 :         // associated with tile unloadability might have changed.
; 2743 :         if ((!codestream->persistent) ||
; 2744 :             ((codestream->tpart_ptr_server==NULL) && !codestream->cached))
; 2745 :           { assert(!is_unloadable); return; }
; 2746 :         if (is_open || (this==codestream->active_tile))
; 2747 :           { // Should not be on the unloadable list
; 2748 :             if (is_unloadable)
; 2749 :               withdraw_from_unloadable_list();
; 2750 :           }
; 2751 :         else
; 2752 :           { // Should be on the unloadable list
; 2753 :             if (!is_unloadable)
; 2754 :               add_to_unloadable_list();
; 2755 :           }
; 2756 :       }
; 2757 :   private: // Helper functions
; 2758 :     friend class kdu_tile;
; 2759 :     void set_elements_of_interest();
; 2760 :       /* Called from within `kd_tile::open' and/or `kd_tile::initialize'
; 2761 :          to mark each component, resolution, subband, precinct and
; 2762 :          precinct-band with the current region of interest, resolution of
; 2763 :          interest, components of interest and layers of interest.  If the
; 2764 :          codestream mode is "persistent" (applies to input objects and all
; 2765 :          interchange objects), this function is delayed until the tile is
; 2766 :          opened (an event which may occur any number of times, with different
; 2767 :          regions, resolutions, components and layers of interest).  Otherwise,
; 2768 :          the function is called only once, when the tile is initialized.  This
; 2769 :          is important, since non-persistent input objects' resources will be
; 2770 :          cleaned up as soon as they are known not to be
; 2771 :          required.  To do this, region of interest information must be made
; 2772 :          available during parsing, which may occur prior to the point at which
; 2773 :          a tile is actually opened. */
; 2774 :     void withdraw_from_unloadable_list();
; 2775 :       /* Removes a tile, whose `is_unloadable' member is true, from the
; 2776 :          unloadable tiles list managed by `kd_codestream', leaving
; 2777 :          `is_unloadable' equal to false. */
; 2778 :     void add_to_unloadable_list();
; 2779 :       /* Adds a tile, whose `is_unloadable' member is false, to the
; 2780 :          unloadable tiles list managed by `kd_codestream', leaving
; 2781 :          `is_unloadable' equal to true. */
; 2782 :     float find_multicomponent_energy_gain(int comp_idx,
; 2783 :                                           bool restrict_to_interest);
; 2784 :       /* Finds the energy gain factor associated with the contribution of
; 2785 :          the indicated codestream image component to the output image
; 2786 :          components.  For this purpose, an impulsive distortion in codestream
; 2787 :          component `comp_idx' is considered, having magnitude equal to the
; 2788 :          component's nominal range.  The impact of this impulsive distortion
; 2789 :          is evaluated at the outputs of any multi-component transform, or
; 2790 :          Part-1 colour transform.  The resulting output distortion is
; 2791 :          expressed relative to each output component's nominal range and
; 2792 :          the sum of these squared normalized quantities is taken and returned.
; 2793 :          If `restrict_to_interest' is true, output distortion contributions
; 2794 :          are ignored if they are not currently of interest to the
; 2795 :          application. */
; 2796 :   public: // Links and Identification
; 2797 :     kd_codestream *codestream;
; 2798 :     int t_num; // Absolute tile-number, as used by parameter sub-system
; 2799 :     kdu_coords t_idx; // Absolute 2D tile-index
; 2800 :     kd_tile_ref *tile_ref; // Points to entry in `kd_codestream::tile_refs'
; 2801 :                            // which points to us, or NULL if we are not there.
; 2802 :     kd_tpart_pointer *tpart_ptrs; // Pointers for seekable sources
; 2803 :     kd_tile *in_progress_next, *in_progress_prev; // See below
; 2804 :     kd_tile *unloadable_next, *unloadable_prev; // See below
; 2805 :     kd_tile *typical_next; // Used to build a list of released typical tiles.
; 2806 :                            // Tiles on this list have `tile_ref'=NULL
; 2807 : 
; 2808 :   public: // Owned Resources
; 2809 :     kd_pp_markers *ppt_markers; // NULL except possibly in tpart header reading
; 2810 :     kd_pph_input *packed_headers; // NULL unless tile has packed packet headers
; 2811 :     kd_packet_sequencer *sequencer;
; 2812 :     kd_precinct_pointer_server precinct_pointer_server;
; 2813 :     kd_reslength_checker *reslength_checkers; // 1+`num_components' entries;
; 2814 :       // same structure as `kd_codestream::reslength_checkers' but for
; 2815 :       // tile-specific reslength constraints.
; 2816 :   
; 2817 :   public: // Dimensions and Parameters
; 2818 :     bool is_typical; // All typical tiles have the same structure & transform
; 2819 :     bool fully_typical; // All fully typical tiles have identical coding params
; 2820 :     int num_components; // Number of tile-components
; 2821 :     int num_layers;
; 2822 :     int num_apparent_layers;
; 2823 :     int max_relevant_layers; // See below
; 2824 :     kdu_long total_precincts; // Used only during code-stream generation
; 2825 :     kdu_long max_relevant_packets; // See below
; 2826 :     kdu_dims dims; // Region occupied by the tile on the canvas
; 2827 :     kdu_dims region; // Region of interest within tile.
; 2828 :     kdu_coords coding_origin;
; 2829 : 
; 2830 :   public: // Arrays and Lists
; 2831 :     kd_mct_stage *mct_head; // Linked list of MCT stages, starting from the one
; 2832 :     kd_mct_stage *mct_tail; // whose input components are the tile-components
; 2833 :     kd_tile_comp *comps;
; 2834 :     kdu_long structure_bytes; // Total bytes contained in all embedded
; 2835 :         // structures, excepting only precincts and code-block bit-stream
; 2836 :         // buffers.  Whenever this value changes, the changes should also be
; 2837 :         // reflected in the `codestream->buf_server' object, so that the total
; 2838 :         // memory load associated with tile data structures can be included in
; 2839 :         // cache threshold calculations.  This enables precinct and tile
; 2840 :         // unloading decisions to be made in a wholistic way, based on
; 2841 :         // total memory consumption.
; 2842 : 
; 2843 :   public: // Flags and other State Variables
; 2844 :     bool use_sop, use_eph, use_ycc;
; 2845 :     bool empty_shell; // True if tile header was not available when opened.
; 2846 :     bool is_in_progress; // See `in_progress_next' and `in_progress_prev'
; 2847 :     bool is_open;
; 2848 :     bool is_unloadable; // See below
; 2849 :     bool is_addressable; // See below
; 2850 :     bool closed; // Once closed, the tile may no longer be accessed.
; 2851 :                  // Persistent tiles are never marked as closed.
; 2852 :     bool initialized; // Fields below here are valid only once initialized
; 2853 :     bool needs_reinit; // Set inside `reset' to indicate the need for
; 2854 :                        // reinitialization when the tile is first accessed.
; 2855 :     bool insert_plt_segments; // If true, PLT marker segs introduced
; 2856 :     bool resolution_tparts; // Start new tile-part at resolution boundaries
; 2857 :     bool component_tparts; // Start new tile-part at component boundaries
; 2858 :     bool layer_tparts; // Start new tile-part at layer boundaries
; 2859 :     int num_tparts; // Zero if number of tile-parts unknown.
; 2860 :     int next_tpart; // Index of next tile-part to be read or written.
; 2861 :     int sequenced_relevant_packets; // See below
; 2862 :     int next_input_packet_num;
; 2863 :     bool skipping_to_sop; // See notes below.
; 2864 :     int next_sop_sequence_num; // Valid only if `skipping_to_sop' is true.
; 2865 :     int saved_num_sequenced_packets;// For "kdu_packet_sequencer::save_state"
; 2866 :     bool exhausted; // True if no more tile-parts are available for this tile.
; 2867 :   };
; 2868 :   /* Notes:
; 2869 :         The `max_relevant_layers' member indicates the maximum number of
; 2870 :      layers from the current tile which can ever be relevant to the
; 2871 :      application.  It holds the same value as `num_layers', unless the
; 2872 :      code-stream was created for reading and is non-persistent, in which
; 2873 :      case it holds the value of `num_apparent_layers'.  This member is used
; 2874 :      to avoid parsing any more packets than we have to when reading
; 2875 :      non-persistent code-streams.
; 2876 :         The `max_relevant_packets' member is equal to the total number of
; 2877 :      packets in the tile, unless the code-stream was created for reading,
; 2878 :      is non-persistent, and `kdu_codestream::apply_input_restrictions' has
; 2879 :      been used to reduce the spatial region of interest, or to identify one
; 2880 :      or more resolutions, components or layers as irrelevant to the
; 2881 :      application.  In that case it holds the product of the number of the
; 2882 :      `max_relevant_layers' value and the number of precincts which are
; 2883 :      actually relevant to the identify spatial region, resolution and
; 2884 :      components.
; 2885 :         Similarly, `sequenced_relevant_packets' counts the number of packets
; 2886 :      which have been sequenced (either written or read, as appropriate) so
; 2887 :      far, skipping only those packets which are deemed to be irrelevant to
; 2888 :      the application.  As for `max_relevant_packets', all packets are
; 2889 :      considered relevant if the code-stream was not created for reading, or
; 2890 :      if the code-stream is persistent, regardless of any calls to
; 2891 :      `kdu_codestream::apply_input_restrictions'.  When this value reaches
; 2892 :      the value of `max_relevant_packets', there is no need to parse any
; 2893 :      further contents from the tile.
; 2894 :         If `skipping_to_sop' is true, packets are automatically discarded
; 2895 :      (this is a pseudo-transfer which leaves the packet empty) until one is
; 2896 :      reached whose packet number agrees with the value of
; 2897 :      `next_sop_sequence_num'.  To assist this operation, the
; 2898 :      `next_input_packet_num' counter keeps track of the zero-based index
; 2899 :      of the next packet to be parsed.  Note that we need a separate counter,
; 2900 :      in addition to `sequenced_relevant_packets', since not all packets
; 2901 :      which are parsed need necessarily be relevant to the application.
; 2902 :         A tile is said to be "unloadable" once the following conditions have
; 2903 :      been satisfied:
; 2904 :      1) the codestream is in persistent mode;
; 2905 :      2) the compressed data source is seekable or a cache;
; 2906 :      3) this tile is not currently open;
; 2907 :      4) this tile is not the one referenced by `kd_codestream::active';
; 2908 :      Such tiles are enterered on a list managed by the `unloadable_next'
; 2909 :      and `unloadable_prev' members, and have their `is_unloadable' flag set
; 2910 :      to true.  When an unloadable tile is deleted, the corresponding
; 2911 :      `kd_tile_ref::tile' entry is set to NULL rather than `KD_EXPIRED_TILE'.
; 2912 :      This ensures that the tile can be re-parsed from the compressed data
; 2913 :      source if required again at a later point.  Tiles on the unloadable
; 2914 :      list may be deleted automatically, according to a tile memory management
; 2915 :      policy.
; 2916 :         A tile is said to be "addressable" if the following conditions hold:
; 2917 :      1) the codestream is in input (reading) mode;
; 2918 :      2) the compressed data source is not a cache;
; 2919 :      3) the compressed data source is seekable; and
; 2920 :      4) the current tile-part contains usable precinct pointer information.
; 2921 :      Such tiles are identified by the `is_addressable' flag.  This flag is
; 2922 :      set on each call to `read_tile_part_header'.  All that actually
; 2923 :      matters is that we correctly identify when the codestream has an
; 2924 :      active tile which is not addressable; in that case, the tile's
; 2925 :      packets must be desequenced up until the end of the tile-part before
; 2926 :      any seeking on the compressed data source can be allowed.
; 2927 :         A tile is said to be "in-progress" if the following conditions
; 2928 :      apply:
; 2929 :      1) the codestream was created for output;
; 2930 :      2) the tile has already been opened -- it may or may not have been closed;
; 2931 :      3) the tile's contents have not yet been fully flushed to the codestream.
; 2932 :      In-progress tiles are entered onto a doubly-linked list managed by the
; 2933 :      `in_progress_next' and `in_progress_prev' pointers.  The head and
; 2934 :      tail of this list are managed by `kd_codestream::tiles_in_progress_head'
; 2935 :      and `kd_codestream::tiles_in_progress_tail'. */ 
; 2936 : 
; 2937 : /*****************************************************************************/
; 2938 : /*                              kd_tile_comp                                 */
; 2939 : /*****************************************************************************/
; 2940 : 
; 2941 : struct kd_tile_comp { // State structure for the "kdu_tile_comp" interface
; 2942 :   public: // Member functions
; 2943 :     kd_tile_comp()
; 2944 :       { // We will be relying on all fields starting out as 0.
; 2945 :         memset(this,0,sizeof(*this));
; 2946 :         G_tc = G_tc_restricted = -1.0F;
; 2947 :       }
; 2948 :     ~kd_tile_comp();
; 2949 :     void initialize_kernel_parameters(int atk_idx, kdu_kernels &kernels);
; 2950 :       /* On entry, the `kernel_id' member is valid.  On exit, the
; 2951 :          other `kernel_xxx' parameters are valid.  The `atk_idx' value is
; 2952 :          used only if `kernel_id' is equal to `Ckernels_ATK'.  The
; 2953 :          function leaves `kernels' initialized with the relevant transform
; 2954 :          kernel, for further use by the caller if desired. */
; 2955 :     void reset_layer_stats()
; 2956 :       {
; 2957 :         if (layer_stats != NULL)
; 2958 :           {
; 2959 :             int num_entries = ((1+dwt_levels)*tile->num_layers)<<1;
; 2960 :             memset(layer_stats,0,(size_t)(sizeof(kdu_long)*num_entries));
; 2961 :           }
; 2962 :       }
; 2963 :   public: // Links and Identification
; 2964 :     kd_codestream *codestream;
; 2965 :     kd_tile *tile;
; 2966 :     kd_comp_info *comp_info; // Ptr to relevant `codestream->comp_info' entry
; 2967 :     int cnum;
; 2968 : 
; 2969 :   public: // Dimensions and Parameters
; 2970 :     kdu_coords sub_sampling;
; 2971 :     kdu_dims dims;
; 2972 :     kdu_dims region;
; 2973 :     int dwt_levels, apparent_dwt_levels;
; 2974 :     bool reversible;
; 2975 :     int kernel_id; // Ckernels_W5X3, Ckernels_W9X7 or Ckernels_ATK
; 2976 :     bool kernel_symmetric, kernel_symmetric_extension;
; 2977 :     int kernel_num_steps;
; 2978 :     kdu_kernel_step_info *kernel_step_info, *kernel_step_info_flipped;
; 2979 :     float *kernel_coefficients, *kernel_coefficients_flipped;
; 2980 :     float kernel_low_scale; // Amount to scale low-pass lifting analysis output
; 2981 :     float kernel_high_scale; // Amount to scale hi-pass lifting analysis output
; 2982 :     int low_support_min, low_support_max; // low-pass synthesis impulse support
; 2983 :     int high_support_min, high_support_max; // high-pass synth impulse support
; 2984 :     float G_tc; // Global multi-component energy gain term; -ve if not known
; 2985 :     float G_tc_restricted; // Multi-component energy gain term based only on
; 2986 :             // those output components currently of interest; -ve if not known
; 2987 :     int recommended_extra_bits;
; 2988 :     kdu_coords blk; // Nominal code-block dimensions.
; 2989 :     int modes; // Block coder modes.  Flags defined in scope `cod_params'
; 2990 : 
; 2991 :   public: // Arrays
; 2992 :     kd_resolution *resolutions; // Contains 1+`dwt_levels' entries.
; 2993 :     kdu_long *layer_stats; // Contains `num_layers' pairs per resolution,
; 2994 :       // starting from the lowest resolution (`res_level'=0); each pair holds
; 2995 :       // number of parsed packets for the layer-resolution, followed by
; 2996 :       // number of parsed packet bytes for the layer-resolution.  Available
; 2997 :       // only for input codestreams; populated by `kd_precinct::read_packet'.
; 2998 : 
; 2999 :   public: // Flags and Other State Variables
; 3000 :     bool enabled; // See below
; 3001 :     bool is_of_interest; // See below
; 3002 :     kdu_coords grid_min; // These fields are used by "kd_packet_sequencer"
; 3003 :     kdu_coords grid_inc; // for spatially oriented progressions.
; 3004 :     kdu_coords saved_grid_min; // For "kd_packet_sequencer::save_state"
; 3005 :     kdu_coords saved_grid_inc; // For "kd_packet_sequencer::save_state"
; 3006 :   };
; 3007 :   /* Notes:
; 3008 :         `recommended_extra_bits' may be added to the sample bit-depth
; 3009 :      (precision) for this component to determine an appropriate number
; 3010 :      of bits for internal representations associated with the data
; 3011 :      processing path.
; 3012 :         In the reversible path, the value is set to the maximum bit-depth
; 3013 :      expansion factor, as reported in Table 17.4 of the book by Taubman and
; 3014 :      Marcellin, adding an extra 1 bit if the RCT has been used -- note that it
; 3015 :      is not desirable for luminance and chrominance components to have
; 3016 :      different numeric representations, since that would significantly
; 3017 :      complicate the colour transform procedure.
; 3018 :         In the irreversible path, the value is set to 7, which means
; 3019 :      that 16-bit representations are judged sufficient for 9 bit
; 3020 :      imagery or less.  Of course, the impact of selecting a reduced
; 3021 :      representation precision is only reduced accuracy in the
; 3022 :      irreversible processing path.
; 3023 :         The `enabled' flag is used to efficiently identify the tile-components
; 3024 :      which are enabled.  Remember that a tile-component may be disabled,
; 3025 :      either because the corresponding codestream image component is not
; 3026 :      apparent (only when the `kd_codestream::component_access_mode' is
; 3027 :      `KDU_WANT_CODESTREAM_COMPONENTS'), or because the tile-component
; 3028 :      is not involved in the construction of an apparent output image
; 3029 :      component (when the `kd_codestream::component_access_mode' is
; 3030 :      `KDU_WANT_OUTPUT_COMPONENTS').  In the latter case, all codestream
; 3031 :      image components are apparent, but disabled ones cannot be
; 3032 :      accessed -- this is important, since in the latter case the set
; 3033 :      of enabled components may vary from tile to tile.
; 3034 :         The `is_of_interest' flag is used to store the identify of components
; 3035 :      which are marked as being of interest, by calls to
; 3036 :      `kdu_tile::set_components_of_interest'.  This is done only when the
; 3037 :      component access mode is `KDU_WANT_CODESTREAM_COMPONENTS' or the
; 3038 :      `mct_head' member is NULL.  Otherwise, the components of interest are
; 3039 :      passed directly to the `kd_mct_stage::apply_output_restrictions'
; 3040 :      function.  Note that the `is_of_interest' flags do not generally
; 3041 :      belong to the component in which they are stored.  They are just
; 3042 :      copies of the information supplied to
; 3043 :      `kdu_tile::set_components_of_interest', without any attempt to apply
; 3044 :      any component index permutations which might be relevant. */
; 3045 : 
; 3046 : /*****************************************************************************/
; 3047 : /*                            kd_precinct_ref                                */
; 3048 : /*****************************************************************************/
; 3049 : 
; 3050 :   /* Objects of this class provide the vehicle through which precincts
; 3051 :      references are instantiated and removed from the array of precinct
; 3052 :      references maintained by the `kd_resolution' object.  It is important
; 3053 :      that the state information be small.  In particular, it has the same
; 3054 :      size as `kdu_long', which should never be smaller than the size of
; 3055 :      a memory pointer, but may be larger -- see the declaration of
; 3056 :      `kdu_long' in "elementary.h".  For precincts whose seek addresses are
; 3057 :      deduced from PLT marker segments in the code-stream, or precincts which
; 3058 :      are maintained by a caching data source, or precincts which are used by
; 3059 :      codestream objects created for interchange, this object provides
; 3060 :      facilities for recycling a disused precinct's resources while keeping its
; 3061 :      unique address around for rapid reloading in the event that it
; 3062 :      is required at a later point. */
; 3063 : 
; 3064 : class kd_precinct_ref {
; 3065 :   public: // Member functions
; 3066 :     kd_precinct_ref()
; 3067 :       { state = 0; }
; 3068 :     ~kd_precinct_ref()
; 3069 :       { if (!((state == 0) || (state & 1))) close(); }
; 3070 :     bool parsed_and_unloaded()
; 3071 :       { return ((state & 3) == 3) && (state != 3); }
; 3072 :       /* Returns true if the precinct is addressable (i.e., dynamically
; 3073 :          loadable) and it has been parsed and subsequently unloaded from
; 3074 :          memory. */
; 3075 :     kd_precinct *deref()
; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }
; 3077 :       /* Returns NULL unless the reference identifies a valid `kd_precinct'
; 3078 :          object, which is already loaded in memory. */
; 3079 :     kd_precinct *active_deref();
; 3080 :       /* Returns NULL unless the reference identifies a valid `kd_precinct'
; 3081 :          object, which is already loaded in memory and is in the active
; 3082 :          state. */
; 3083 :     kd_precinct *open(kd_resolution *res, kdu_coords pos_idx,
; 3084 :                       bool need_activate);
; 3085 :       /* Attempts to open the precinct at the indicated position within the
; 3086 :          array of precincts maintained by the indicated resolution object.
; 3087 :          `pos_idx' holds the horizontal and vertical position of the
; 3088 :          precinct (starting from 0) within the array of precincts for
; 3089 :          the given resolution.  That is, `pos_idx' holds a relative, not
; 3090 :          an absolute precinct index.
; 3091 :             If the precinct is known to be unloadable (this happens if the
; 3092 :          precinct has previously been opened and has then been permanently
; 3093 :          closed), the function returns NULL.
; 3094 :             If the precinct currently exists in memory (the `state' variable
; 3095 :          contains a valid pointer to the precinct), the function returns a
; 3096 :          pointer to that precinct; however, if `need_activate' is true
; 3097 :          and the precincts's `released' flag is true, `kd_precinct::activate'
; 3098 :          is called before returning the `kd_precinct' pointer.  When the
; 3099 :          codestream object was created for input or for interchange, the
; 3100 :          `need_activate' argument should be set to true only when the
; 3101 :          precinct is being opened in order to access code-block data.  In
; 3102 :          that case, the precinct must belong to an open tile and lie within
; 3103 :          the application's current region of interest, meaning that it will
; 3104 :          be released again when the tile is closed.  For codestream objects
; 3105 :          created for output, the argument should have no effect, since
; 3106 :          output precincts are not actually released.
; 3107 :             Otherwise, the function obtains a new `kd_precinct' object from
; 3108 :          the code-stream's precinct server and calls its `initialize'
; 3109 :          function.  If the `state' variable held the precinct's unique
; 3110 :          address value on entry, that address is written into the newly
; 3111 :          instantiated `kd_precinct' object's `unique_address' field, and
; 3112 :          the P bit (see notes on `state' below) is copied to the precinct's
; 3113 :          KD_PFLAG_PARSED flag.  If compressed data comes from a cached source,
; 3114 :          or the codestream object was created for interchange (no compressed
; 3115 :          data sources or targets), the newly created precinct is automatically
; 3116 :          marked as addressable, with its `unique_address' set to the
; 3117 :          precinct's unique identifier, as described in the comments appearing
; 3118 :          with the declaration of `kd_precinct::unique_address'.  For
; 3119 :          precincts which can be addressed using a seek address (for seekable
; 3120 :          compressed data sources), the seek address is installed using
; 3121 :          `set_address' from within the `kd_packet_sequencer::next_in_sequence'
; 3122 :          function.
; 3123 :             It is worth noting that this function may cause other precincts
; 3124 :          to be unloaded from memory, in order to conserve memory resources.
; 3125 :          If this happens, only precincts which have been released and
; 3126 :          which do not intersect with the current region of interest will be
; 3127 :          unloaded. */
; 3128 :     void close();
; 3129 :       /* Closes the active `kd_precinct' object whose pointer is in
; 3130 :          `state', calling its `closing' member function and recycling its
; 3131 :          storage.  If the precinct is marked as addressable, its
; 3132 :          `unique_address' member and KD_PFLAG_PARSED flag are recorded in
; 3133 :          `state' using the convention outlined in the notes below, allowing
; 3134 :          the precinct to be re-opened at a later point.
; 3135 :             In many cases, you are better off calling the `release' member
; 3136 :          function instead of `close' (see below).
; 3137 :             Note that this function may be safely invoked even when the
; 3138 :          precinct is not currently active -- it does nothing unless `state'
; 3139 :          holds a valid precinct address. */
; 3140 :     void close_and_reset();
; 3141 :       /* This function is used only by `kdu_tile::parse_all_relevant_packets'
; 3142 :          and then only if it is asked to parse everything from scratch.  The
; 3143 :          behaviour is similar to calling `close', except that the internal
; 3144 :          `state' record is left with its P flag reset, so that when the
; 3145 :          precinct is reloaded, its packet statistics will be entered into
; 3146 :          the `kd_tile_comp::layer_stats' array -- the caller invariably
; 3147 :          resets this array. */
; 3148 :     void release();
; 3149 :       /* This function should be called once a precinct is no longer
; 3150 :          required, in preference to the `close' function.  If the system is
; 3151 :          running low on resources, the function may unload the precinct from
; 3152 :          memory to recycle its resources.  Alternatively, the function is at
; 3153 :          liberty to leave the precinct in memory, moving it to a list of
; 3154 :          inactive precincts which are subject to unloading at some point in
; 3155 :          the future, when resources may be running low.  Non-addressable or
; 3156 :          cached precincts are unloaded immediately, since they are
; 3157 :          guaranteed never to be re-opened once `release' has been called. */
; 3158 :     void clear();
; 3159 :       /* This function recycles the storage associated with any existing
; 3160 :          precinct and sets the internal `state' variable to 0.  It is called
; 3161 :          when the code-stream management machinery is restarted. */
; 3162 :     bool is_desequenced();
; 3163 :       /* This function is intended for use within
; 3164 :          `kd_packet_sequencer::next_in_sequence', for checking whether
; 3165 :          or not the precinct which is returned by that function needs
; 3166 :          to have its contents read from a compressed data source in
; 3167 :          order to desequence a new packet.  Opening precincts can be a time
; 3168 :          consuming task, especially when there are an enormous number of
; 3169 :          precincts (this can happen when working with huge untiled images,
; 3170 :          especially in geospatial applications).  This function takes
; 3171 :          advantage of the fact that there is no need to actually open a
; 3172 :          precinct which is not already loaded into memory.  The fact that this
; 3173 :          function is called first by the packet desequencer, allows a precinct
; 3174 :          which has already been fully generated to be closed immediately
; 3175 :          during packet generation mode.
; 3176 :             The function works as follows.  If the precinct is already loaded
; 3177 :          in memory, its `sequenced' flag is accessed directly.   Otherwise,
; 3178 :          if the reference `state' variable identifies a valid unique
; 3179 :          address for the precinct, it is known to be addressable and
; 3180 :          therefore must have already been fully desequenced.  Also, if the
; 3181 :          `state' variable indicates that the precinct is unloadable, or that
; 3182 :          it has been closed in packet generation mode, it is interpreted as
; 3183 :          sequenced, in the sense that the application cannot sequence further
; 3184 :          packets for the precinct.  Otherwise, the `state' variable must hold
; 3185 :          0 (see below), from which we deduce that the precinct has not yet
; 3186 :          been sequenced. */
; 3187 :     bool set_address(kd_resolution *res, kdu_coords pos_idx,
; 3188 :                      kdu_long seek_address);
; 3189 :       /* Called from within `kd_packet_sequencer::next_in_sequence', this
; 3190 :          function installs a seek address for a precinct whose packets are
; 3191 :          contiguous within the code-stream and have valid pointer information
; 3192 :          stored in PLT marker segments.  Subsequent calls to `is_sequenced'
; 3193 :          will return true.  The precinct itself may either be open or closed
; 3194 :          when this function is called.  The `pos_idx' argument is provided
; 3195 :          for computing the relevance of this precinct to the application.  It
; 3196 :          holds a relative precinct index, having the same interpretation as
; 3197 :          that passed to `kd_precinct::initialize' and `kdu_precinct_ref::open'.
; 3198 :             It can happen that this function causes the tile, and hence the
; 3199 :          precinct reference, to be destroyed.  This happens if the call to
; 3200 :          this function renders the resolution or tile completely parsed,
; 3201 :          and it is known that the application has no need for any further
; 3202 :          access to the tile.  In this case, and only in this case, the
; 3203 :          function returns false, meaning that the caller must not make
; 3204 :          any further attempt to access the tile or any of its resources. */
; 3205 :   private: // Utility functions
; 3206 :     kd_precinct *instantiate_precinct(kd_resolution *res, kdu_coords pos_idx);
; 3207 :       /* Called from `open' if the `kd_precinct' object is not in memory at
; 3208 :          the time and can legitimately be created at this point. */
; 3209 :   private: // Data
; 3210 :     kdu_long state;
; 3211 :   };
; 3212 :   /* Notes:
; 3213 :         `state' holds 0 if no information is yet available concerning the
; 3214 :      precinct associated with this reference.
; 3215 :         If the precinct is currently active in memory, `state' holds the
; 3216 :      address in memory (pointer) of the `kd_precinct' structure.
; 3217 :         If the precinct is known to be addressable, `state' holds an odd
; 3218 :      integer, equal to 4*A + 2*P + 1, where A is the precinct's
; 3219 :      `unique_address' value and P is a flag, equal to 1 if the precinct
; 3220 :      has been loaded and parsed previously.
; 3221 :         The `unique_address' value has the same definition as the
; 3222 :      corresponding data member in `kd_precinct'.
; 3223 :         This P flag plays the same role as the KD_PFLAG_PARSED bit in
; 3224 :      `kd_precinct::flags'.  It is used to avoid collecting layer size
; 3225 :      statistics twice for the same precinct which could otherwise happen
; 3226 :      when precincts get swapped in and out of memory on demand.
; 3227 :         A value of `state'=1 means that the precinct can be re-instantiated,
; 3228 :      but that it is known to contain no packets whatsoever.
; 3229 :         If a previously active precinct's resources have been recycled and
; 3230 :      re-loading is not possible, `state' is assigned the special value of 3. */
; 3231 : 
; 3232 : /*****************************************************************************/
; 3233 : /*                               kd_leaf_node                                */
; 3234 : /*****************************************************************************/
; 3235 : 
; 3236 : struct kd_leaf_node {
; 3237 :     public: // Data
; 3238 :       kd_node *parent; // Every leaf node has a non-leaf parent node
; 3239 :       kd_resolution *resolution; // Always points to the owning resolution
; 3240 :       kdu_dims dims; // Dimensions & location of the image at this node
; 3241 :       kdu_dims region; // See below
; 3242 :       kdu_byte branch_x, branch_y; // See below
; 3243 :       bool is_leaf; // False if this object is the base of `kd_node'
; 3244 :   };
; 3245 :   /* Notes:
; 3246 :         This structure is the base of the richer `kd_node' structure.  The
; 3247 :      key difference is that leaf nodes have no children, so we do not waste
; 3248 :      storage recording pointers to them.
; 3249 :         The `branch_x' and `branch_y' members describe how this node is
; 3250 :      derived from its parent node, if any.  `branch_x' holds 0 if horizontal
; 3251 :      low-pass filtering and decimation were used to obtain the node from its
; 3252 :      parent; it holds 1 if horizontal high-pass filtering and decimation were
; 3253 :      used; it holds 2 if no filtering or decimation were involved in the
; 3254 :      horizontal direction.  `branch_y' plays a similar role in describing the
; 3255 :      vertical filtering and decimation processes.  If `parent' is NULL,
; 3256 :      the `branch_x' and `branch_y' members have no meaning.
; 3257 :         This structure manages two different, yet related regions
; 3258 :      (location, plus dimensions) which deserve some explanation here.
; 3259 :      * The `dims' member serves the usual role of identifying the location and
; 3260 :        dimensions of the image, as it appears on entry into this node,
; 3261 :        during forward transformation (analysis).  For primary nodes,
; 3262 :        these are the dimensions and location of the tile-component-resolution
; 3263 :        within its canvas.
; 3264 :      * `region' identifies a subset of the `dims' region, containing
; 3265 :        all of the node's samples which are involved in the synthesis of the
; 3266 :        current region of interest, as specified in the most recent call to
; 3267 :        `kdu_codestream::apply_input_restrictions'. */
; 3268 : 
; 3269 : /*****************************************************************************/
; 3270 : /*                                 kd_node                                   */
; 3271 : /*****************************************************************************/
; 3272 : 
; 3273 : struct kd_node : public kd_leaf_node {
; 3274 :     public: // Member functions
; 3275 :       void adjust_cover(kdu_dims child_cover,
; 3276 :                         int child_branch_x, int child_branch_y);
; 3277 :         /* This function is used to find the `region_cover' members.  In
; 3278 :            a downward sweep through the decomposition branches associated
; 3279 :            with a given resolution level, the `region_cover' members are all
; 3280 :            set to empty regions.  We then assign each leaf node (subband)
; 3281 :            a region cover (not actually recorded in the leaf node) equal to
; 3282 :            its region of interest and work back up the tree from the
; 3283 :            leaves to the primary node of the resolution in question, calling
; 3284 :            this function to grow the region cover so as to encompass the
; 3285 :            smallest region which covers each of its children. */
; 3286 :     public: // Data
; 3287 :       kdu_dims region_cover; // See below
; 3288 :       kdu_dims prec_dims; // Temp storage for calculating precinct dimensions
; 3289 :       kd_leaf_node *children[4]; // Indexed by `LL_BAND' through `HH_BAND'
; 3290 :       kdu_byte num_hor_steps, num_vert_steps; // See below
; 3291 :       kdu_uint16 num_descendant_nodes;
; 3292 :       kdu_uint16 num_descendant_leaves;
; 3293 :       float *bibo_gains; // See below
; 3294 :   };
; 3295 :   /* Notes:
; 3296 :         This object is used to construct descriptions of all non-leaf
; 3297 :      nodes in the DWT decomposition structure.  Each node in the structure
; 3298 :      may be decomposed horizontally, vertically or both.  If it is decomposed
; 3299 :      in the horizontal direction, `children[HL_BAND]' will be non-NULL.  If it
; 3300 :      is decomposed in the vertical direction, `children[LH_BAND]' will be
; 3301 :      non-NULL.  If it is decomposed in both directions, `children[HH_BAND]'
; 3302 :      will also be non-NULL.  If it is decomposed at all, `children[LL_BAND]'
; 3303 :      will always be non-NULL.
; 3304 :         The decomposition structure consists of a collection of primary
; 3305 :      nodes, each of which is embedded within a `kd_resolution' object.
; 3306 :      In the case of the simple Mallat structure, each primary node has
; 3307 :      4 children, with the LL child embedded within the next lower
; 3308 :      resolution object and the remaining children embedded within
; 3309 :      `kd_subband' objects.  In wavelet packet decomposition structures,
; 3310 :      detail subbands produced by a primary node may, themselves, be
; 3311 :      decomposed further into subbands.
; 3312 :         The actual object pointed to by each non-NULL member of the `children'
; 3313 :      array may need to be cast to type `kd_node', rather than `kd_leaf_node'
; 3314 :      if the `kd_leaf_node::is_leaf' member is false.
; 3315 :         The `children[LL_BAND]' entry of a primary node always points to
; 3316 :      the node which is embedded within the next lower resolution
; 3317 :      `kd_resolution' object, except at the lowest resolution of all.
; 3318 :      The lowest `kd_resolution' object's embedded node has only one
; 3319 :      child, with `children[LL_BAND]' pointing to the single (LL) subband
; 3320 :      belonging to that resolution.
; 3321 :         The `num_hor_steps' and `num_vert_steps' members identify the number
; 3322 :      of horizontal and vertical lifting steps associated with the horizontal
; 3323 :      and vertical transform operations applied at this node to produce its
; 3324 :      children.  One or both of these may be 0, either because the transform
; 3325 :      is trivial (lazy wavelet) or because the node is split only in the
; 3326 :      horizontal direction, only in the vertical direction, or is not split
; 3327 :      at all.
; 3328 :         The `num_descendant_nodes' member holds a count of the total number
; 3329 :      of nodes (leaf nodes and non-leaf nodes) which may be reached via the
; 3330 :      `children' array.  The `num_descendant_leaves' member holds a count of
; 3331 :      the number of these descendant nodes which are leaves.  Neither of these
; 3332 :      counts includes the current node.  Clearly there is no need to
; 3333 :      maintain this information with leaf nodes, since the counts would both
; 3334 :      be 0 in this case.
; 3335 :         The `bibo_gains' member point to an array with
; 3336 :      2+`num_hor_steps'+`num_vert_steps' entries.  The first 1+`num_hor_steps'
; 3337 :      entries describe BIBO gains for the horizontal transform performed
; 3338 :      at this node.  The remaining `+`num_vert_steps' entries describe BIBO
; 3339 :      gains for the vertical transform performed at this node.  Within each
; 3340 :      of these 2 sets of BIBO gains the first entry holds the BIBO gain from
; 3341 :      the original input image to the image which is presented at the input
; 3342 :      to this node.  Subsequent entries hold the BIBO gains from the original
; 3343 :      input image to the image which is presented at the output of each
; 3344 :      successive analysis lifting step.  Al BIBO gains are assessed relative to
; 3345 :      the nominal transform normalization, in which reversible lifting steps
; 3346 :      are applied as-is, while irreversible lifting steps are followed by the
; 3347 :      relevant `kd_tile_comp::low_scale' and `kd_tile_comp::high_scale' values.
; 3348 :         The interpretation of `region_cover' is similar to that of
; 3349 :      `kd_leaf_node::region', with a subtle, yet important twist.  In order to
; 3350 :      reconstruct each sample in `region', it is necessary to decode a
; 3351 :      particular set of samples from the subbands which are associated with
; 3352 :      this node.  Each of these subband samples has a mapping onto the
; 3353 :      coordinate system associated with the node, following the usual rules of
; 3354 :      the canvas coordinate system.  `res_cover' holds the smallest region
; 3355 :      which contains all of these mapped subband sample locations, except that
; 3356 :      the LL subband branch is included only if this is not a primary node.
; 3357 :      This ensures that the primary node embedded inside each `kd_resolution'
; 3358 :      object will have a `region_cover' which spans the nominal locations of
; 3359 :      all subband samples of interest, which are represented by codestream
; 3360 :      packets associated with that resolution. */
; 3361 : 
; 3362 : /*****************************************************************************/
; 3363 : /*                                kd_subband                                 */
; 3364 : /*****************************************************************************/
; 3365 : 
; 3366 : struct kd_subband : public kd_leaf_node {
; 3367 :     // State structure for the "kdu_subband" interface
; 3368 :   public: // Identification
; 3369 :     kdu_int16 descriptor; // See `cod_params::expand_decomp_bands'
; 3370 :     kdu_byte orientation; // One of LL_BAND, HL_BAND, LH_BAND or HH_BAND.
; 3371 :                      // This is the orientation of the primary subband from
; 3372 :                      // which we are derived within the same resolution level.
; 3373 :     kdu_byte sequence_idx; // Index within the `kd_resolution::subbands' array
; 3374 :                      // This is also the order in which subbands contribute
; 3375 :                      // code-blocks to codestream packets.
; 3376 :     kdu_byte transpose_sequence_idx; // Index of the real subband which appears
; 3377 :                       // to have this `sequence_idx' value when
; 3378 :                       // `kdu_codestream::change_appearance' has been used to
; 3379 :                       // transpose the codestream's appearance.
; 3380 :   public: // Dimensions and Parameters
; 3381 :     kdu_byte epsilon; // Ranging parameter.
; 3382 :     kdu_byte K_max; // Maximum magnitude bit-planes, not including ROI upshift
; 3383 :     kdu_byte K_max_prime; // Max magnitude bit-planes, including ROI upshift
; 3384 :     float delta; // Step size, normalized for image data range of -0.5 to 0.5
; 3385 :     float G_b; // Subband energy gain factor.
; 3386 :     float W_b; // Subband amplitude weight; needs squaring to get energy weight
; 3387 :     float roi_weight; // Extra amplitude weight for ROI foreground blocks.
; 3388 :     kdu_dims block_partition; // Holds the coding origin and dimensions.
; 3389 :     kdu_dims block_indices; // Holds the range of valid block indices.
; 3390 :     kdu_dims region_indices;  // Same as `block_indices', but restricted to
; 3391 :                               // blocks which overlap the region of interest.
; 3392 :     kdu_coords blocks_per_precinct; // precinct size / block size
; 3393 :     kdu_coords log2_blocks_per_precinct; // log2 of precinct size/block size
; 3394 :   };
; 3395 :   /* Notes:
; 3396 :         It may come as a surprise to notice that this object has no
; 3397 :      direct connection to code-blocks.  To access a code-block, the object
; 3398 :      first determines the precinct to which it belongs, creating that
; 3399 :      precinct if necessary; this, in turn, creates its precinct-bands and
; 3400 :      the associated code-blocks.  In this way, no memory whatsoever need be
; 3401 :      dedicated to code-blocks which lie in unaccessed precincts. */
; 3402 : 
; 3403 : /*****************************************************************************/
; 3404 : /*                              kd_resolution                                */
; 3405 : /*****************************************************************************/
; 3406 : 
; 3407 : struct kd_resolution { // State structure for the "kdu_resolution" interface
; 3408 :   public: // Member functions
; 3409 :     kd_resolution()
; 3410 :       {
; 3411 :         codestream = NULL; tile_comp = NULL; rescomp = NULL;
; 3412 :         precinct_refs = NULL; subbands = subband_handle = NULL; num_subbands=0;
; 3413 :         num_intermediate_nodes = 0; intermediate_nodes = NULL;
; 3414 :         can_flip = true;  node.bibo_gains = NULL;
; 3415 :       }
; 3416 :     ~kd_resolution()
; 3417 :       {
; 3418 :         if (node.bibo_gains != NULL) delete[] node.bibo_gains;
; 3419 :         for (int n=0; n < (int) num_intermediate_nodes; n++)
; 3420 :           if (intermediate_nodes[n].bibo_gains != NULL)
; 3421 :             delete[] intermediate_nodes[n].bibo_gains;
; 3422 :         if (precinct_refs != NULL) delete[] precinct_refs;
; 3423 :         if (subband_handle != NULL) delete[] subband_handle;
; 3424 :         if (intermediate_nodes != NULL) delete[] intermediate_nodes;
; 3425 :       }
; 3426 :     void build_decomposition_structure(kdu_params *coc, kdu_kernels &kernels);
; 3427 :       /* This function creates the `subbands' and `intermediate_nodes'
; 3428 :          arrays and fills in all the relevant pointers.  It uses `kernels'
; 3429 :          to create and fill in the `kdu_node::hor_bibo_gains' and
; 3430 :          `kdu_node::vert_bibo_gains' arrays, where required. */
; 3431 :     void complete_initialization();
; 3432 :       /* Called from within `kd_tile::initialize' to finish the initialization
; 3433 :          process, after all of the key parameters have been set.  Currently,
; 3434 :          the only task performed here is the initialization of the
; 3435 :          `max_blocks_per_precinct' member. */
; 3436 :   public: // Links and Identification
; 3437 :     kd_codestream *codestream;
; 3438 :     kd_tile_comp *tile_comp;
; 3439 :     kd_global_rescomp *rescomp;
; 3440 :     kdu_byte res_level; // Runs from 0 (LL band) to `num_dwt_levels'
; 3441 :     kdu_byte dwt_level; // Runs from `num_dwt_levels' (res level 0 and 1) to 1
; 3442 :     kdu_byte hor_depth; // From relevant entry of `kd_comp_info::hor_depth'
; 3443 :     kdu_byte vert_depth; // From relevant entry of `kd_comp_info::vert_depth'
; 3444 : 
; 3445 :   public: // Embedded node
; 3446 :     kd_node node; // Each resolution is a primary node in the decomposition
; 3447 : 
; 3448 :   public: // Dimensions and Parameters
; 3449 :     kdu_dims precinct_partition; // Holds the coding origin and dimensions.
; 3450 :     kdu_dims precinct_indices; // Holds the range of valid precinct indices.
; 3451 :     kdu_dims region_indices; // Holds range of indices for precincts whose
; 3452 :                              // code-blocks contribute to region of interest.
; 3453 :   public: // Derived quantities
; 3454 :     int max_blocks_per_precinct; // See discussion under `kd_precinct_band'
; 3455 :     bool propagate_roi; // True if ROI masks to be propagated to descendants
; 3456 : 
; 3457 :     bool can_flip; // Set to false if this level contains subband decomposition
; 3458 :                    // styles which are incompatible with view flipping.
; 3459 : 
; 3460 :   public: // Arrays
; 3461 :     kdu_byte num_subbands; // Excludes the LL band unless `res_level'=0
; 3462 :     kdu_byte num_intermediate_nodes; // Enough for all non-leaf nodes descended
; 3463 :                                  // from the primary node in this object.
; 3464 :     kd_node *intermediate_nodes; // Array with `num_intermediate_nodes' entries
; 3465 :     kd_precinct_ref *precinct_refs;
; 3466 :     kd_subband *subbands; // Points to `subband_store' or `subband_handle'.
; 3467 :     kd_subband *subband_handle; // For dynamically allocated subbands
; 3468 :     kd_subband subband_store[3]; // Avoid dynamic allocation for common case
; 3469 : 
; 3470 :   public: // Flags and Other State Variables
; 3471 :     kdu_coords current_sequencer_pos; // Used by `kd_packet_sequencer'.
; 3472 :     kdu_coords saved_current_sequencer_pos; // For saving the sequencer state
; 3473 :   };
; 3474 :   /* Notes:
; 3475 :         The `current_sequencer_pos' coordinates are used to sequence
; 3476 :      spatially oriented packet progressions.  They maintain the
; 3477 :      indices (starting from [0,0], rather than `precinct_indices.pos')
; 3478 :      of the precinct which is currently being sequenced.
; 3479 :         The `region_indices' member holds the smallest range of precinct
; 3480 :      indices, such that the code-blocks contained within these precincts
; 3481 :      are sufficient to reconstruct all samples inside `node.region'.
; 3482 :      Equivalently, the range in `precinct_indices' yields the set of
; 3483 :      precincts which intersect with `node.region_cover'.
; 3484 :         It is worth noting that the area of intersection between each
; 3485 :      precinct's region on the resolution and the `node.region_cover' region
; 3486 :      is used to compute the information returned by
; 3487 :      `kdu_resolution::get_precinct_relevance'. */
; 3488 : 
; 3489 : /*****************************************************************************/
; 3490 : /*                             kd_header_in                                  */
; 3491 : /*****************************************************************************/
; 3492 : 
; 3493 : class kd_header_in {
; 3494 :   /* Manages the reading of packet header bytes from the code-stream, along
; 3495 :      with bit stuffing and unpacking. */
; 3496 :   public: // Member functions
; 3497 :     kd_header_in(kd_input *source)
; 3498 :       { this->source = source; bits_left=0; byte=0; header_bytes=0; }
; 3499 :     int get_bit() // throws its own "this" pointer if the source is exhausted.
; 3500 :       {
; 3501 :         if (bits_left==0)
; 3502 :           {
; 3503 :             bits_left = (byte==0xFF)?7:8;
; 3504 :             if (!source->get(byte))
; 3505 :               { bits_left = 0; throw this; }
; 3506 :             header_bytes++;
; 3507 :           }
; 3508 :         bits_left--;
; 3509 :         return (byte >> bits_left) & 1;
; 3510 :       }
; 3511 :     kdu_uint32 get_bits(int num_bits) // thorws(kd_header_in *)
; 3512 :       { kdu_uint32 result = 0;
; 3513 :         while (num_bits > 0)
; 3514 :           {
; 3515 :             if (bits_left==0)
; 3516 :               {
; 3517 :                 bits_left = (byte==0xFF)?7:8;
; 3518 :                 if (!source->get(byte))
; 3519 :                   { bits_left = 0; throw this; }
; 3520 :                 header_bytes++;
; 3521 :               }
; 3522 :             int xfer_bits = (num_bits<bits_left)?num_bits:bits_left;
; 3523 :             bits_left -= xfer_bits;
; 3524 :             num_bits -= xfer_bits;
; 3525 :             result <<= xfer_bits;
; 3526 :             result |= ((byte >> bits_left) & ~(0xFF << xfer_bits));
; 3527 :           }
; 3528 :         return result;
; 3529 :       }
; 3530 :     int finish()
; 3531 :       { // Call this when the header is all read, to consume any stuffing byte
; 3532 :         // Returns total header length
; 3533 :         if ((bits_left == 0) && (byte == 0xFF))
; 3534 :           {
; 3535 :             bits_left = 7;
; 3536 :             if (!source->get(byte))
; 3537 :               throw this;
; 3538 :             header_bytes++;
; 3539 :           }
; 3540 :         return header_bytes;
; 3541 :       }
; 3542 :   private: // Data
; 3543 :     kd_input *source; // Provides the input mechanism.
; 3544 :     kdu_byte byte;
; 3545 :     int bits_left;
; 3546 :     int header_bytes;
; 3547 :   };
; 3548 : 
; 3549 : /*****************************************************************************/
; 3550 : /*                                kd_header_out                              */
; 3551 : /*****************************************************************************/
; 3552 : 
; 3553 : class kd_header_out {
; 3554 :   /* Manages the simulated and real output of packet header bytes. */
; 3555 :   public: // Member functions
; 3556 :     kd_header_out(kdu_output *out=NULL) // Null for simulating header
; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }
; 3558 :     void put_bit(int bit)
; 3559 :       { // Output a header bit
; 3560 :         assert(bit == (bit & 1));
; 3561 :         if (bits_left == 0)
; 3562 :           { if (out != NULL) out->put(byte);
; 3563 :             completed_bytes++;
; 3564 :             bits_left = (byte==0xFF)?7:8;
; 3565 :             byte = 0; }
; 3566 :         byte += byte + bit;
; 3567 :         bits_left--;
; 3568 :       }
; 3569 :     void put_bits(kdu_int32 val, int num_bits)
; 3570 :       { // Output the least significant `num_bits' of `val'
; 3571 :         while (num_bits > 0)
; 3572 :           put_bit((val >> (--num_bits)) & 1);
; 3573 :       }
; 3574 :     int finish()
; 3575 :       { // Returns the total number of bytes consumed by the packet header.
; 3576 :         if (bits_left < 8)
; 3577 :           {
; 3578 :             byte <<= bits_left;
; 3579 :             if (out != NULL)
; 3580 :               out->put(byte);
; 3581 :             completed_bytes++;
; 3582 :             if (byte == 0xFF)
; 3583 :               { // Need the stuffing byte.
; 3584 :                 if (out != NULL)
; 3585 :                   out->put((kdu_byte) 0);
; 3586 :                 completed_bytes++;
; 3587 :               }
; 3588 :           }
; 3589 :         return completed_bytes;
; 3590 :       }
; 3591 :   private: // Data
; 3592 :     kdu_byte byte;
; 3593 :     int bits_left;
; 3594 :     int completed_bytes;
; 3595 :     kdu_output *out;
; 3596 :   };
; 3597 : 
; 3598 : /*****************************************************************************/
; 3599 : /*                                 kd_block                                  */
; 3600 : /*****************************************************************************/
; 3601 : 
; 3602 : class kd_block {
; 3603 :   /* For a very small size (only 24 bytes on 32-bit machines), this class
; 3604 :      defines a lot of member functions!. */
; 3605 :   // --------------------------------------------------------------------------
; 3606 :   public: // Lifecycle member functions
; 3607 :     void cleanup(kd_buf_server *buf_server)
; 3608 :       {
; 3609 :         while ((current_buf=first_buf) != NULL)
; 3610 :           { first_buf=current_buf->next;  buf_server->release(current_buf); }
; 3611 :         set_discard(); // Discard from any packets parsed in the future
; 3612 :       }
; 3613 :     kd_code_buffer *cleanup()
; 3614 :       { // As above, but returns the linked list of buffers
; 3615 :         kd_code_buffer *result = first_buf;  first_buf = current_buf = NULL;
; 3616 :         set_discard();
; 3617 :         return result;
; 3618 :       }
; 3619 : 
; 3620 :   // --------------------------------------------------------------------------
; 3621 :   public: // Packet manipulation member functions
; 3622 :     int parse_packet_header(kd_header_in &head, kd_buf_server *buf_server,
; 3623 :                             int layer_idx); // Throws (kdu_uint16 code)
; 3624 :       /* Parses bits in the packet header corresponding to the current
; 3625 :          block for the current layer (this must be the next layer for which
; 3626 :          information has not yet been parsed).  The function returns the
; 3627 :          number of new body bytes contributed by the code-block in this layer
; 3628 :          and also stores this value internally to be used in subsequent calls
; 3629 :          to the `read_body_bytes' member function.
; 3630 :             The `kd_header_in' object may throw an exception if the packet
; 3631 :          data terminates unexpectedly.  Moreover, to assist in locating and
; 3632 :          possibly recovering from errors, the present function may throw a
; 3633 :          16-bit unsigned integer exception code, which is either the value of
; 3634 :          an illegal marker code encountered in the packet header, or one of
; 3635 :          the special exception codes, KDU_EXCEPTION_PRECISION or
; 3636 :          KDU_EXCEPTION_ILLEGAL_LAYER. */
; 3637 :     void read_body_bytes(kd_input *source, kd_buf_server *buf_server,
; 3638 :                          bool in_memory_source)
; 3639 :       { /* This function should be called after parsing the header of a
; 3640 :            packet.  It reads the code-bytes contributed by the code-block to
; 3641 :            this packet.  If `in_memory_source' is true, only the address of
; 3642 :            the code-bytes is recorded, and then only if the length of the
; 3643 :            code-byte segment is non-zero. */
; 3644 :         if (this->temp_length > 0)
; 3645 :           {
; 3646 :             if (num_passes == 255)
; 3647 :               { // Read and discard the code-bytes.
; 3648 :                 assert(first_buf == NULL);  source->ignore(this->temp_length);
; 3649 :               }
; 3650 :             else if (in_memory_source)
; 3651 :               {
; 3652 :                 kdu_byte *addr;
; 3653 :                 this->num_bytes += source->pseudo_read(addr,this->temp_length);
; 3654 :                 put_address(addr,buf_server);
; 3655 :               }
; 3656 :             else
; 3657 :               this->num_bytes +=
; 3658 :                 source->read(current_buf,buf_pos,buf_server,this->temp_length);
; 3659 :             this->temp_length = 0;
; 3660 :           }
; 3661 :       }
; 3662 :     void retrieve_data(kdu_block *block, int max_layers, int discard_passes,
; 3663 :                        bool in_memory_source);
; 3664 :       /* Retrieves compressed code-bytes, number of coding passes and codeword
; 3665 :          segment lengths from the current code-block and stores them in the
; 3666 :          `block' object.  All fields which are common for compression and
; 3667 :          decompression have already been filled out by the caller.  The
; 3668 :          byte buffer is allocated so as to be large enough to allow a
; 3669 :          2 byte marker code to be appended to the compressed data,
; 3670 :          if desired -- see declaration of "kdu_subband::open_block".
; 3671 :             The `max_layers' argument identifies the maximum number of
; 3672 :          quality layers for which code-block contributions are to be
; 3673 :          retrieved.
; 3674 :             The `discard_passes' argument indicates the number of additional
; 3675 :          coding passes to be removed, if any.
; 3676 :             If `in_memory_source' is true, the layer code bytes are not
; 3677 :          stored in the `kd_code_buffer' list embedded inside `block'.  Instead,
; 3678 :          the `kd_code_buffer' list stores only the header information for
; 3679 :          each layer, along with the address of the code bytes, which reside
; 3680 :          in the memory block managed by an in-memory compressed data source
; 3681 :          (one which offers the `KDU_SOURCE_CAP_IN_MEMORY') capability.  In
; 3682 :          this case, we retrieve the address and then perform a simple memory
; 3683 :          block copy operation to efficiently retrieve the code bytes for
; 3684 :          each layer. */
; 3685 :     void store_data(kdu_block *block, kd_buf_server *buf_server);
; 3686 :       /* Stores compressed code-bytes, pass length and pass slope information
; 3687 :          from the `block' object into the current code-block.  This function
; 3688 :          is invoked by "kdu_subband::close_block" when the containing
; 3689 :          codestream object was not constructed for input.  Also reflects
; 3690 :          the `msbs_w' value into higher nodes in the tag tree. */
; 3691 :     void store_data(kdu_block *block, kd_thread_buf_server *thread_buf_server);
; 3692 :       /* Same as the above function, but uses `kd_thread_buf_server::get'
; 3693 :          rather than `kd_buf_server::get' to get new code buffers.  This
; 3694 :          version is used to save code-block state in multi-threaded
; 3695 :          environments so as to minimize cache coherency bottlenecks and the
; 3696 :          need to lock shared resources. */
; 3697 :     void transfer_data(kd_block &src)
; 3698 :       { /* Like `store_data', but gets results from another block.  Exploits
; 3699 :            the layout of the object to copy only whole pointers or whole
; 3700 :            32-bit words, even where these represent multiple fields. */
; 3701 :         current_buf = first_buf = src.first_buf;
; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);
; 3703 :         src.current_buf = src.first_buf = NULL;
; 3704 :       }
; 3705 :     bool trim_data(kdu_uint16 slope_threshold, kd_buf_server *buf_server);
; 3706 :       /* This function serves two purposes: it helps reduce the amount of
; 3707 :          compressed data which must be buffered in memory while compressing
; 3708 :          an image; and it allows individual block contributions to be
; 3709 :          discarded during packet construction in order to tightly fit the
; 3710 :          generated bit-rate to the target compressed bit-rate.
; 3711 :             The function sets all coding pass slopes which are less than or
; 3712 :          equal to the supplied slope threshold to 0 and then discards all
; 3713 :          code bytes which could not possibly be included in the final
; 3714 :          code-stream, as a result of this modification.
; 3715 :             If anything was discarded, the function returns true.  Otherwise,
; 3716 :          it returns false. */
; 3717 :     int start_packet(int layer_idx, kdu_uint16 slope_threshold);
; 3718 :       /* Call this function only during rate allocation or packet generation.
; 3719 :          Before the first call to this function, you must reset the tag tree
; 3720 :          (see the "reset_output_tree" member function).  If you are calling
; 3721 :          the function multiple times with the same layer for rate allocation
; 3722 :          purposes, you must use "save_output_tree" and "restore_output_tree"
; 3723 :          as described below.
; 3724 :             The function leaves behind information about the number of new
; 3725 :          coding passes and the number of new code bytes which would be
; 3726 :          contributed by this code-block if the supplied threshold were actually
; 3727 :          used.  The final contributing coding pass must have a non-zero
; 3728 :          distortion-length slope which is strictly greater than the slope
; 3729 :          threshold.  It also updates the tag tree structure to reflect any
; 3730 :          new knowledge about the first layer to which this code-block would
; 3731 :          contribute.  This information is picked up by "write_packet_header".
; 3732 :             The function's return value is the total number of new code-bytes
; 3733 :          contributed by the block.  This allows the PCRD-opt algorithm to
; 3734 :          determine roughly the right slope threshold before committing to the
; 3735 :          work of simulating packet header generation. */
; 3736 :     void write_packet_header(kd_header_out &head, int layer_idx,
; 3737 :                              bool simulate);
; 3738 :       /* Call this function only after a `start_packet' call.  It writes
; 3739 :          (or simulates the writing of) packet header information corresponding
; 3740 :          to the code-block inclusion information set up by `start_packet'.
; 3741 :          If `simulate' is true, some internal state adjustments are delayed
; 3742 :          until the next call to "save_output_tree", so multiple calls to
; 3743 :          "start_packet" and "write_packet_header" may be issued with the same
; 3744 :          layer index to determine an optimal slope threshold.  Otherwise,
; 3745 :          if `simulate' is false, the internal state information is fully
; 3746 :          updated and the "save_output_tree" and "restore_output_tree" functions
; 3747 :          need not and should not be called. */
; 3748 :     void write_body_bytes(kdu_output *dest);
; 3749 :       /* This function should be called after a non-simulated
; 3750 :          "write_packet_header" call to output the newly included body bytes.
; 3751 :          The actual number of bytes to be written was left behind by
; 3752 :          the preceding "start_packet" call in the `temp_length' field. */
; 3753 :   // --------------------------------------------------------------------------
; 3754 :   public: // Static functions used to operate on tag-trees built from kd_block
; 3755 :     static kd_block *build_tree(kdu_coords size, kdu_byte * &mem_block);
; 3756 :       /* Builds a full tag tree returning a pointer to the upper left hand
; 3757 :          corner leaf node.  Apart from the `up_down' navigation pointers,
; 3758 :          all fields are initialized to 0.  This is appropriate for tag tree
; 3759 :          decoding, but encoders will need to call "reset_output_tree" and
; 3760 :          use "start_packet" to install appropriate node values.
; 3761 :             The tag tree is not allocated from the heap.  Instead, it is
; 3762 :          allocated from an existing memory block, identified by the `mem_block'
; 3763 :          argument.  This memory block is assumed to be large enough to hold
; 3764 :          the array of `kd_block' structures.  Upon return, the `mem_block'
; 3765 :          value is advanced by an amount equal to the size of the tag tree
; 3766 :          array. */
; 3767 :     static void reset_output_tree(kd_block *tree, kdu_coords size);
; 3768 :       /* Call this function immediately before simulating or actually
; 3769 :          generating any packet data for the relevant code-blocks.  Once
; 3770 :          the PCRD-opt algorithm has completed, you should call this function
; 3771 :          a second time to prepare for actual packet output.  The function
; 3772 :          initializes the threshold state variables, `layer_w_bar' and
; 3773 :          `msbs_w_bar' to 0, and the value state variables, `layer_w' and
; 3774 :          `msbs_w' to their maximum representable values.  The succession of
; 3775 :          "start_packet" calls will update the value variables `layer_w'
; 3776 :          and `msbs_w' in such a way that the tag tree coding process runs
; 3777 :          correctly in each subsequent call to "write_packet_header". */
; 3778 :     static void save_output_tree(kd_block *tree, kdu_coords size);
; 3779 :       /* Call this only during rate allocation, before moving on to a new
; 3780 :          layer.  The function saves the current state (`msbs_wbar' and
; 3781 :          `layer_wbar') of each node in the tag tree.  For leaf nodes, it also
; 3782 :          commits the number of new coding passes found in the last call to
; 3783 :          "start_packet". */
; 3784 :     static void restore_output_tree(kd_block *tree, kdu_coords size);
; 3785 :       /* Call this during rate allocation before supplying a new slope
; 3786 :          threshold for the same layer index, in a new "start_packet" call.
; 3787 :          The function restores the `msbs_w_bar' and `layer_w_bar' values
; 3788 :          previously saved by "save_output_tree". */
; 3789 :   // --------------------------------------------------------------------------
; 3790 :   public: // State identification functions
; 3791 :     void set_discard()
; 3792 :       { /* Use this function only with input-oriented operations.  It informs
; 3793 :            the object that none of the code-blocks associated with this
; 3794 :            block will ever be accessed, so that it is free to skip over them
; 3795 :            when reading a packet.  This can save a lot of memory if you have
; 3796 :            a defined region of interest for decompression. */
; 3797 :         num_passes = 255;
; 3798 :       }
; 3799 :     bool empty()
; 3800 :       { // Returns true if the block has no code-bytes yet.
; 3801 :         return first_buf == NULL;
; 3802 :       }
; 3803 :     void set_modes(int modes)
; 3804 :       {
; 3805 :         assert(modes == (modes & 0xFF));
; 3806 :         this->modes = (kdu_byte) modes;
; 3807 :       }
; 3808 :   // --------------------------------------------------------------------------
; 3809 :   private: // Convenience functions for transferring data to/from code buffers.
; 3810 :     void start_buffering(kd_buf_server *buf_server) // Call before `put_byte'
; 3811 :       { assert(first_buf == NULL);
; 3812 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3813 :     void start_buffering(kd_thread_buf_server *buf_server)
; 3814 :       { assert(first_buf == NULL);
; 3815 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3816 :     void put_byte(kdu_byte val, kd_buf_server *buf_server)
; 3817 :       {
; 3818 :         assert(current_buf != NULL);
; 3819 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3820 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3821 :         current_buf->buf[buf_pos++] = val;
; 3822 :       }
; 3823 :     void put_word(int val, kd_buf_server *buf_server)
; 3824 :       {
; 3825 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3826 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))
; 3827 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3828 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;
; 3829 :         buf_pos += 2;
; 3830 :       }
; 3831 :     void put_address(kdu_byte *addr, kd_buf_server *buf_server)
; 3832 :       {
; 3833 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3834 :         if (buf_pos > (KD_CODE_BUFFER_LEN-KDU_POINTER_BYTES))
; 3835 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3836 : 
; 3837 :         ((kdu_byte **)(current_buf->buf+buf_pos))[0] = addr;
; 3838 :         buf_pos += KDU_POINTER_BYTES;
; 3839 :       }
; 3840 :     void put_byte(kdu_byte val, kd_thread_buf_server *buf_server)
; 3841 :       {
; 3842 :         assert(current_buf != NULL);
; 3843 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3844 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3845 :         current_buf->buf[buf_pos++] = val;
; 3846 :       }
; 3847 :     void put_word(int val, kd_thread_buf_server *buf_server)
; 3848 :       {
; 3849 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3850 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))
; 3851 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3852 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;
; 3853 :         buf_pos += 2;
; 3854 :       }
; 3855 :     void put_address(kdu_byte *addr, kd_thread_buf_server *buf_server)
; 3856 :       {
; 3857 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3858 :         if (buf_pos > (KD_CODE_BUFFER_LEN-KDU_POINTER_BYTES))
; 3859 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3860 : 
; 3861 :         ((kdu_byte **)(current_buf->buf+buf_pos))[0] = addr;
; 3862 :         buf_pos += KDU_POINTER_BYTES;
; 3863 :       }
; 3864 :     kdu_byte get_byte()
; 3865 :       {
; 3866 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3867 :           { buf_pos=0; current_buf=current_buf->next;
; 3868 :             assert(current_buf != NULL); }
; 3869 :         return current_buf->buf[buf_pos++];
; 3870 :       }
; 3871 :     int get_word()
; 3872 :       {
; 3873 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3874 :         buf_pos += 2; // Advance the buffer pointer
; 3875 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3876 :           { buf_pos=2; current_buf=current_buf->next;
; 3877 :             assert(current_buf != NULL); }
; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];
; 3879 :       }
; 3880 :     kdu_byte *get_address()
; 3881 :       {
; 3882 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3883 :         buf_pos += KDU_POINTER_BYTES; // Advance the buffer pointer
; 3884 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3885 :           { buf_pos=KDU_POINTER_BYTES; current_buf=current_buf->next;
; 3886 :             assert(current_buf != NULL); }
; 3887 :         return ((kdu_byte **)(current_buf->buf+buf_pos))[-1];
; 3888 :       }
; 3889 :     void skip_word()
; 3890 :       {
; 3891 :         buf_pos += 2 + (buf_pos & 1); // Align and advance the buffer pointer
; 3892 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3893 :           { buf_pos=2; current_buf=current_buf->next;
; 3894 :             assert(current_buf != NULL); }
; 3895 :       }
; 3896 :     void skip_address()
; 3897 :       {
; 3898 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3899 :         buf_pos += KDU_POINTER_BYTES; // Advance the buffer pointer
; 3900 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3901 :           { buf_pos=KDU_POINTER_BYTES; current_buf=current_buf->next;
; 3902 :             assert(current_buf != NULL); }
; 3903 :       }
; 3904 :   // --------------------------------------------------------------------------
; 3905 :   private: // Data (lots of unions to make it as small as possible!)
; 3906 :     union {
; 3907 :       kd_code_buffer *first_buf;
; 3908 :       kdu_uint16 save_layer_w; // Used for saving non-leaf node state
; 3909 :       };
; 3910 :     union {
; 3911 :       kd_code_buffer *current_buf;
; 3912 :       kdu_uint16 save_layer_wbar; // Used for saving_non-leaf node state
; 3913 :       };
; 3914 :     union {
; 3915 :       kdu_byte buf_pos; // Location of next read/write byte in `current_buf'.
; 3916 :       kdu_byte save_msbs_wbar; // Used for saving non-leaf node state
; 3917 :       };
; 3918 :     kdu_byte msbs_w;
; 3919 :     kdu_byte num_passes;
; 3920 :     kdu_byte pass_idx;
; 3921 :     union {
; 3922 :       kdu_uint16 layer_w; // Used only when `pass_idx'=0
; 3923 :       kdu_uint16 body_bytes_offset; // Used in packet output if `pass_idx' > 0
; 3924 :       kdu_byte save_beta; // Used during output simulation if `pass_idx' > 0
; 3925 :       };
; 3926 :     union {
; 3927 :       kdu_uint16 layer_wbar;
; 3928 :       kdu_uint16 num_bytes; // Used only for input operations
; 3929 :       kdu_byte pending_new_passes; // Used only for output operations
; 3930 :       };
; 3931 :     union {
; 3932 :       kdu_byte msbs_wbar;
; 3933 :       kdu_byte beta;
; 3934 :       };
; 3935 :     kdu_byte modes;
; 3936 :     kdu_uint16 temp_length; // Temporary storage of length quantities.
; 3937 :     kd_block *up_down;
; 3938 :   };
; 3939 :   /* Notes:
; 3940 :         This structure has been designed to provide sufficient state
; 3941 :      information for each code-block to perform packet header parsing as
; 3942 :      well as block encoding and decoding.  For coding purposes, the information
; 3943 :      represented by the structure is generally transferred to or from a
; 3944 :      much less tightly packed representation for speed of execution of the
; 3945 :      block coding routines.  As it stands, the total size of this structure
; 3946 :      should be 24 bytes on a 32-bit architecture. An array of code-blocks is
; 3947 :      maintained by each precinct-band.  The array contains one entry for
; 3948 :      every block in the relevant precinct-band, but also contains additional
; 3949 :      entries to be used as tag-tree nodes.  The total number of such extra
; 3950 :      nodes is about 1/3 the number of code-blocks and should not be a
; 3951 :      significant cause of concern for overall memory consumption. There is
; 3952 :      also substantial benefit to be had by locating the tag tree nodes in
; 3953 :      the same contiguous memory block.  Notice that the structure contains
; 3954 :      no reference back to the precinct-band to which it belongs.  When
; 3955 :      necessary, this reference must be supplied separately to interested
; 3956 :      functions. One consequence of this memory saving step is that the
; 3957 :      object's destructor cannot do anything useful.  It only checks to make
; 3958 :      sure that the explicit `cleanup' function has already been called.
; 3959 :         If a block is to be discarded (since it does not intersect with a
; 3960 :      user-specified region of interest), the `num_passes' field will hold
; 3961 :      the otherwise impossible value, 255.
; 3962 :         The `first_buf', `current_buf' and `buf_pos' fields constitute the
; 3963 :      compressed data buffer management mechanism, which is used to store all
; 3964 :      quantities whose length is unpredictable a priori. In particular, a
; 3965 :      linked list of `kd_code_buffer' structures is provided, which grows on
; 3966 :      demand through access to the codestream object's embedded `buffering'
; 3967 :      object.  Data is stored in these buffers in the following formats:
; 3968 :            * Input Format -- [<layer #> (<#bytes> <#passes> ...)] data [<...
; 3969 :              That is, for each layer to which the code-block makes a non-empty
; 3970 :              contribution, we record first the layer number (2 bytes) and
; 3971 :              then one or more #bytes/#passes pairs.  #bytes is represented
; 3972 :              using 2 bytes, while #passes is represented using only 1 byte.
; 3973 :              There is one such 3 byte pair for each layer and one additional
; 3974 :              3 byte pair for each codeword segment terminating pass which
; 3975 :              is not the final pass contributed in the layer.  In this way,
; 3976 :              sufficient information is provided to recover all termination
; 3977 :              lengths, as well as to build layer associations.  The most
; 3978 :              significant bit of the #bytes field is used as a marker to
; 3979 :              indicate whether or not this is the last such field prior to
; 3980 :              the appearance of the code bytes contributed by that layer.  A
; 3981 :              1 means that there are more fields to go before the code bytes
; 3982 :              appear.
; 3983 :            * In-memory Format --[<layer #>(<#bytes> <#passes>...)] <addr> [<...
; 3984 :              This format is used as an alternative to the Input Format above,
; 3985 :              in the special case when the compressed data source supports the
; 3986 :              `KDU_SOURCE_CAP_IN_MEMORY' capability, so that
; 3987 :              `kd_codestream::in_memory_source' is true.  In this case, the
; 3988 :              "data" field is replaced by the address where the data can be
; 3989 :              found in the memory block managed by the compressed data source.
; 3990 :              Moreover, if the number of code-bytes associated with a layer
; 3991 :              is zero, the <addr> field is missing.
; 3992 :            * Output Format -- [<RD slope> <#bytes>] ... [<RD ...] data
; 3993 :              That is, all of the header information for all coding passes
; 3994 :              appears up front, followed by all of the code bytes associated
; 3995 :              with those coding passes.  The reason for putting all the
; 3996 :              header information up front is that it facilitates the
; 3997 :              identification of appropriate layer contributions by the
; 3998 :              rate control algorithm.  Each coding pass has a 4 byte header,
; 3999 :              with 2 bytes for the distortion-length slope value and 2 bytes
; 4000 :              for the number of code-bytes for the pass.
; 4001 :      The particular format which is used to store data depends upon the
; 4002 :      member functions which are used, since these implicitly determine
; 4003 :      whether the codestream object is being used for input or output.
; 4004 :         The `modes' field holds the block coder mode fields.  Some of these
; 4005 :      are required even for correct packet header parsing, regardless of whether
; 4006 :      the block is to be actually decoded.
; 4007 :         `msbs_w' and `msbs_wbar' are the state information required
; 4008 :      for tag-tree coding of the number of missing MSB's for a code-block
; 4009 :      which is about to make its first non-empty contribution to the
; 4010 :      code-stream. Similarly, `layer_w' and `layer_wbar' hold the state
; 4011 :      information required for tag-tree coding of the layer index in which a
; 4012 :      code-block first contributes to the code-stream.  The operation of
; 4013 :      tag-tree coding and the `w' and `wbar' terminology are explained in
; 4014 :      Section 8.4 of the book by Taubman and Marcellin.
; 4015 :         The `beta' field shares storage with `msbs_wbar'.  This is not
; 4016 :      required until the number of missing MSB's has been encoded or decoded,
; 4017 :      at which point we initialize `beta' to 3 (see the JPEG2000 standard or
; 4018 :      Section 12.5.4 of the book by Taubman and Marcellin).  A useful
; 4019 :      consequence of this behaviour is that `beta' may be tested at any
; 4020 :      point of the packet header encoding or decoding process to determine
; 4021 :      whether or not the code-block has yet contributed to the code-stream
; 4022 :      -- the value will be non-zero if and only if it has done so.
; 4023 :         The `num_bytes' field shares storage with `layer_wbar'.  It
; 4024 :      identifies the total number of bytes included by the code-block in
; 4025 :      all packets read or written so far.  The value is taken to be 0 if
; 4026 :      the code-block has not yet contributed to any packets (`beta'=0),
; 4027 :      during which time the `layer_wbar' state variable is in use.
; 4028 :         The `up_down' field is used to efficiently navigate the tag-tree
; 4029 :      structure.  When the tag tree is not actually being navigated, the
; 4030 :      field points up to the current node's parent in the tag tree.  The
; 4031 :      root mode is readily identified by the fact that it has a NULL `up_down'
; 4032 :      pointer. During navigation, the tag-tree coder first walks from a
; 4033 :      leaf node up to the root, modifying the `up_down' pointers as it goes
; 4034 :      so that each successive parent's `up_down' field points bacl down to the
; 4035 :      child from which the parent was reached.  The coder then walks back down
; 4036 :      from the root to the original leaf node, restoring the `up_down' fields to
; 4037 :      their original `up' state. */
; 4038 : 
; 4039 : /*****************************************************************************/
; 4040 : /*                             kd_precinct_band                              */
; 4041 : /*****************************************************************************/
; 4042 : 
; 4043 : struct kd_precinct_band {
; 4044 :   /* Used to store state information for an element of the precinct partition
; 4045 :      within a single subband.  Once we get down to precincts and ultimately
; 4046 :      code-blocks, we have to be careful not to waste too much memory, since
; 4047 :      an image may have a very large number of these.  Moreover, it may be
; 4048 :      necessary to maintain tag-trees and other state information even for
; 4049 :      precincts which do not lie within our region of interest, so that the
; 4050 :      relevant packet headers can be parsed -- otherwise, we may have no way
; 4051 :      of knowing how to skip over packets which are not interesting to us. */
; 4052 :     kd_subband *subband;
; 4053 :     kdu_dims block_indices; /* Range of code-block indices for this precinct.
; 4054 :         This is a subset of the `block_indices' specified by the `subband'. */
; 4055 :     kd_block *blocks;
; 4056 :   };
; 4057 :   /* Notes:
; 4058 :      In order to make the representation of this object as efficient as
; 4059 :      possible, the two tag trees and all additional information required to
; 4060 :      correctly parse packet headers is maintained within the code-block
; 4061 :      array itself.  The `blocks' array consists of one element for each
; 4062 :      code-block, organized in raster fashion, plus additional elements to
; 4063 :      represent higher nodes in the tag-tree structure.  See the comments
; 4064 :      associated with the definition of `kd_block' for more information on
; 4065 :      this.
; 4066 :         In practice, the `blocks' array is not allocated separately on the
; 4067 :      heap.  Instead, the block of memory allocated to hold the `kd_precinct'
; 4068 :      structure is augmented by an amount sufficient to hold all of the
; 4069 :      code-blocks for all of the subbands in the precinct.  This is
; 4070 :      accomplished by the custom `kd_precinct::new' operator, which is
; 4071 :      informed of the maximum number of code-blocks required by any precinct
; 4072 :      within the containing `kd_resolution' object.  This value is maintained
; 4073 :      by the `kd_resolution::max_blocks_per_precinct" data member.  The
; 4074 :      `blocks' fields are initialized to the NULL state by the
; 4075 :      `kd_precinct::initialize' member function and are later set to point
; 4076 :      into appropriate locations in the precinct's memory block during
; 4077 :      tag-tree construction. */
; 4078 : 
; 4079 : /*****************************************************************************/
; 4080 : /*                                kd_precinct                                */
; 4081 : /*****************************************************************************/
; 4082 : 
; 4083 :   /* Precincts and all of their subordinate entities (precinct-bands and
; 4084 :      code-blocks) are maintained by a code-stream wide precinct server
; 4085 :      object, which allows for efficient allocation and recycling of the
; 4086 :      memory resources. The constructor is invoked from within the server,
; 4087 :      while the `initialize' and `release' functions are invoked from
; 4088 :      within the `kd_precinct_ref' class which manages references to
; 4089 :      precincts from within the `kd_resolution' object. */
; 4090 : 
; 4091 : // Interpretation of the following flags is given with the `flags' member:
; 4092 : #define KD_PFLAG_GENERATING  0x0001
; 4093 : #define KD_PFLAG_CORRUPTED   0x0002
; 4094 : #define KD_PFLAG_DESEQUENCED 0x0004
; 4095 : #define KD_PFLAG_ADDRESSABLE 0x0008
; 4096 : #define KD_PFLAG_RELEASED    0x0010
; 4097 : #define KD_PFLAG_INACTIVE    0x0020
; 4098 : #define KD_PFLAG_RELEVANT    0x0040
; 4099 : #define KD_PFLAG_SIGNIFICANT 0x0080
; 4100 : #define KD_PFLAG_PARSED      0x0100
; 4101 : 
; 4102 : struct kd_precinct {
; 4103 :   public: // Member functions
; 4104 :     void initialize(kd_resolution *resolution, kdu_coords pos_idx);
; 4105 :       /* Called from within `kd_precinct_ref::open' to configure a newly
; 4106 :          allocated (or recycled) object.  `pos_idx' holds the horizontal and
; 4107 :          vertical position of the precinct (starting from 0) within the array
; 4108 :          of precincts for the relevant resolution level.  Thus, `pos_idx'
; 4109 :          holds a relative index, rather than an absolute index. */
; 4110 :     void activate();
; 4111 :       /* This function is called from within `kd_precinct_ref::open' to
; 4112 :          re-activate a previously released precinct, which has not actually
; 4113 :          been unloaded from memory.  Substantially less work is required in
; 4114 :          this case, and the function must be careful to respect the current
; 4115 :          contents of the precinct's code-blocks.  The function sets the
; 4116 :          `num_required_layers' field for this activation (may change between
; 4117 :          successive `kd_tile::open' calls) and also sets the
; 4118 :          `num_outstanding_blocks' field to the total number of code-blocks
; 4119 :          which lie within the current region of interest. */
; 4120 :     void closing();
; 4121 :       /* Called from within `kd_precinct_ref::close' immediately prior to
; 4122 :          recycling the storage associated with the precinct, its precinct-bands
; 4123 :          and their code-blocks.  This function should release any resources
; 4124 :          which are specific to this particular precinct.  These resources
; 4125 :          include any non-NULL `layer_bytes' array and any code-byte buffers.
; 4126 :          Note that the `kd_precinct_ref::close' function may be called
; 4127 :          indirectly while opening a different precinct, if the current
; 4128 :          precinct has already been released.  This enables open calls to
; 4129 :          deal with resource limitations by unloading precincts which are not
; 4130 :          currently active. */
; 4131 :     void release()
; 4132 :       /* Used only for input codestream objects, this function is called once
; 4133 :          all code-blocks within the current region of interest have been
; 4134 :          consumed.  The function sets `num_outstanding_blocks' to 0, although
; 4135 :          in most cases this function will be called because
; 4136 :          `num_outstanding_blocks' has just become 0 (only exception is when
; 4137 :          a tile is being closed).  Also sets `released' to true.  If the
; 4138 :          KD_PFLAG_DESEQUENCED flag is false, the function returns without
; 4139 :          modifying the precinct in any other way.
; 4140 :             The `kd_precinct_ref::release' function is called to formally
; 4141 :          release the precinct's resources (this might not unload them from
; 4142 :          memory) if the codestream mode is non-persistent or if the precinct
; 4143 :          is addressable.  In the latter case, the precinct's contents can
; 4144 :          be reloaded from the compressed source if necessary.
; 4145 :             This function shall not be used with codestream objects
; 4146 :          opened for output or for interchange (no compressed data source and
; 4147 :          no compressed data target). */
; 4148 :       {
; 4149 :         assert(resolution->codestream->in != NULL);
; 4150 :         num_outstanding_blocks = 0;
; 4151 :         flags |= KD_PFLAG_RELEASED;
; 4152 :           // released = true;
; 4153 :         if ((flags & KD_PFLAG_ADDRESSABLE) ||
; 4154 :             ((flags & KD_PFLAG_DESEQUENCED) &&
; 4155 :                 // if (addressable ||
; 4156 :                 //     (desequenced &&
; 4157 :              !resolution->codestream->persistent))
; 4158 :           ref->release(); // May unload us from memory!
; 4159 :       }
; 4160 :     void finished_desequencing()
; 4161 :       /* Called once we can be sure that no more packets will be available
; 4162 :          for this precinct.  In practice, the function is called when the
; 4163 :          last packet has been desequenced or when the containing tile has
; 4164 :          been completely read.  If no packets at all have been desequenced for
; 4165 :          the precinct when this function is called (must have been invoked
; 4166 :          from within `kd_tile::finished_reading'), the precinct is marked
; 4167 :          as addressable, with an address of 0.  This is because it is safe
; 4168 :          to unload such a precinct and then reload it again regardless of
; 4169 :          the services offered by the compressed data source -- there is no
; 4170 :          data actually available from the compressed source for the
; 4171 :          precinct anyway, so reloading is a no-op.
; 4172 :             It should be noted that this function may unload the precinct
; 4173 :          from memory if it is determined that all code-blocks in the
; 4174 :          region of interest (there may be none) have already been consumed. */
; 4175 :       {
; 4176 :         if (flags & KD_PFLAG_DESEQUENCED)
; 4177 :           return;
; 4178 :         flags |= KD_PFLAG_DESEQUENCED;
; 4179 :           // desequenced = true;
; 4180 :         if (next_layer_idx == 0)
; 4181 :           {
; 4182 :             flags |= KD_PFLAG_ADDRESSABLE;
; 4183 :               // addressable = true;
; 4184 :             unique_address = 0;
; 4185 :           }
; 4186 :         if (num_outstanding_blocks == 0)
; 4187 :           release();
; 4188 :       }
; 4189 :     bool desequence_packet()
; 4190 :       /* This function should be called when a non-NULL `kd_precinct_ref'
; 4191 :          pointer is returned by `kd_packet_sequencer::next_in_sequence' and
; 4192 :          its `kd_precinct_ref::is_sequenced' function returns false.
; 4193 :          The function invokes `read_packet' and, if successful, increments
; 4194 :          the precinct's `next_layer_idx' field and the containing tile's
; 4195 :          `num_sequenced_packets' field.
; 4196 :             The function returns false if `read_packet' returns false,
; 4197 :          in which case, more tile-parts must be read (if there are any) to
; 4198 :          recover the information required to desequence the packet.
; 4199 :             Before returning true, the function checks to see whether all
; 4200 :          packets for the tile have been sequenced.  If so, the tile's
; 4201 :          `finished_reading' function is called. */
; 4202 :       {
; 4203 :         kd_tile *tile = resolution->tile_comp->tile;
; 4204 :         assert(!(flags & (KD_PFLAG_DESEQUENCED | KD_PFLAG_ADDRESSABLE)));
; 4205 :         if (!read_packet()) return false;
; 4206 :         next_layer_idx++;
; 4207 :         if (next_layer_idx == tile->num_layers)
; 4208 :           finished_desequencing();
; 4209 :         tile->next_input_packet_num++;
; 4210 :         if ((flags & KD_PFLAG_RELEVANT) &&
; 4211 :             (next_layer_idx <= tile->max_relevant_layers))
; 4212 :           {
; 4213 :             tile->sequenced_relevant_packets++;
; 4214 :             if (tile->sequenced_relevant_packets==tile->max_relevant_packets)
; 4215 :               tile->finished_reading();
; 4216 :           }
; 4217 :         return true;
; 4218 :       }
; 4219 :     void load_required_packets()
; 4220 :       /* If the precinct is addressable, this function uses its
; 4221 :          `unique_address' to position the compressed data source at the
; 4222 :          beginning of the precinct's first packet; it then loads all required
; 4223 :          packets from the compressed source.  Otherwise, the function does
; 4224 :          nothing at all -- reading is presumed to have occurred during packet
; 4225 :          desequencing. */
; 4226 :       {
; 4227 :         if ((!(flags & KD_PFLAG_ADDRESSABLE)) ||
; 4228 :             (unique_address == 0) || (num_packets_read != 0))
; 4229 :           return;
; 4230 :         assert((flags & KD_PFLAG_DESEQUENCED) &&
; 4231 :                (next_layer_idx >= required_layers));
; 4232 :         resolution->codestream->in->seek(unique_address);
; 4233 :         while (num_packets_read < required_layers)
; 4234 :           if (!read_packet())
; 4235 :             break;
; 4236 :       }
; 4237 :     kdu_long simulate_packet(kdu_long &header_bytes,
; 4238 :                              int layer_idx, kdu_uint16 slope_threshold,
; 4239 :                              bool finalize_layer, bool last_layer,
; 4240 :                              kdu_long max_bytes=KDU_LONG_HUGE,
; 4241 :                              bool trim_to_limit=false);
; 4242 :       /* Implements the functionality of `kd_codestream::simulate_output'
; 4243 :          for a single precinct.  Note that the total number of packet bytes
; 4244 :          is left behind in the internal `layer_bytes' array.  This allows the
; 4245 :          determination of tile-part length fields later on when we come to
; 4246 :          construct the code-stream.  The function returns this total number
; 4247 :          of bytes.  It also returns the number of packet header bytes via
; 4248 :          `header_bytes' (the function return value includes the cost of these
; 4249 :          header bytes).
; 4250 :             If the `max_bytes' limit is exceeded, the function may return
; 4251 :          prematurely, without having completed the simulation.  This is
; 4252 :          unacceptable when finalizing a layer, so you must be sure that
; 4253 :          `max_bytes' is sufficient in that case.
; 4254 :             If `trim_to_limit' is true, `finalize_layer' and `last_layer'
; 4255 :          must also both be true.  The function then trims away all coding
; 4256 :          passes from the precinct's code-blocks which are associated with
; 4257 :          slope values of `slope_threshold'+1 or less, until the limit
; 4258 :          associated with `max_bytes' is satisfied.  This functionality is
; 4259 :          used to implement the `sloppy_bytes' capabilities advertised by the
; 4260 :          `kd_codestream::simulate_output' function. */
; 4261 :     kdu_long write_packet(kdu_uint16 slope_threshold, bool empty_packet=false);
; 4262 :       /* Writes out the next packet for this precinct, using the supplied
; 4263 :          distortion-length slope threshold.  Increments the `next_layer_idx'
; 4264 :          field as well as the containing tile's `num_sequenced_packets'
; 4265 :          field when done.  If `empty_packet' is true, an empty packet should
; 4266 :          be issued, having a length of 1 byte, plus the length of any required
; 4267 :          EPH marker (no SOP marker will be attached to empty packets).  The
; 4268 :          function returns the total number of bytes output for the packet. */
; 4269 :   private: // Member functions
; 4270 :     bool read_packet();
; 4271 :       /* Reads a new layer of this precinct sequentially from the
; 4272 :          compressed data source, incrementing the `num_packets_read' member.
; 4273 :          Note that packet reading may be interleaved with acesses to the
; 4274 :          precinct's code-blocks for various reasons.  For example, we
; 4275 :          may initially open a tile with only a limited number of required
; 4276 :          layers, using its code-block data to decompress an approximate
; 4277 :          representation of the image.  We may then find that the additional
; 4278 :          packets need to be loaded in order to advance to other precincts
; 4279 :          in the code-stream.
; 4280 :             The function returns false if an SOT marker (or an EOC marker) is
; 4281 :          encountered.  Note that when an SOT marker is encountered, its
; 4282 :          segment is fully read into the codestream marker service and the
; 4283 :          precinct's tile must be active (otherwise an error message will be
; 4284 :          generated).  Before returning false in this way, the function sets
; 4285 :          the `active_tile' pointer in the codestream object to NULL.  The
; 4286 :          caller may determine the cause of failure by invoking the codestream
; 4287 :          marker service's `get_code' function, which will return one of SOT,
; 4288 :          EOC or 0, where 0 occurs only if the code-stream has been
; 4289 :          exhausted. */
; 4290 :     bool handle_corrupt_packet();
; 4291 :       /* This function implements alternate processing for the `read_packet'
; 4292 :          function in the event that a packet is found to be corrupt.  It is
; 4293 :          called whenever packet corruption is detected, including when the
; 4294 :          precinct is known to have had previously corrupt packets. The function
; 4295 :          manipulates the containing tile's `skipping_to_sop' and
; 4296 :          `next_sop_sequence_num' fields, advancing to the next SOP or SOT
; 4297 :          marker if necessary (the function may be called after detecting an
; 4298 :          SOP marker already, whose sequence number is not as expected).  If
; 4299 :          an SOT marker is encountered, the function renders the current tile
; 4300 :          inactive and returns false (this is the behaviour expected of
; 4301 :          `read_packet').  Otherwise, it updates the precinct and tile state to
; 4302 :          identify the packet as having been read. */
; 4303 :   public: // Public Links and Identification
; 4304 :     kd_resolution *resolution;
; 4305 :     kd_precinct_ref *ref; // Element of `resolution->precinct_refs' array
; 4306 : 
; 4307 :   public: // Mode flags used for decompression and/or interchange
; 4308 :     int flags; // The following flags are defined.
; 4309 :        // KD_PFLAG_GENERATING -- after 1'st call to `kd_precinct::get_packets'
; 4310 :        // KD_PFLAG_CORRUPTED -- if error occurred during packet reading
; 4311 :        // KD_PFLAG_DESEQUENCED -- if all packets have been desequenced
; 4312 :        // KD_PFLAG_ADDRESSABLE -- if seekable, cached or used for interchange
; 4313 :        // KD_PFLAG_RELEASED -- if `activate' must be called to revive state
; 4314 :        // KD_PFLAG_INACTIVE -- if resides on `kd_precict_server's inactive list
; 4315 :        // KD_PFLAG_RELEVANT -- always true if codestream is for non-persistent
; 4316 :        //     input; otherwise, true only if precinct belongs to the relevant
; 4317 :        //     set of precincts of a relevant tile-component-resolution
; 4318 :        // KD_PFLAG_SIGNIFICANT -- if any code-block bytes have been generated
; 4319 :        //     by `kdu_precinct::size_packets' or `kdu_precinct::get_packets'
; 4320 :        // KD_PFLAG_PARSED -- if the precinct was parsed previously and then
; 4321 :        //     unloaded; prevents multiple accumulation of packet length stats
; 4322 :   public: // State variables
; 4323 :     int required_layers; /* Actual number of layers for output codestream;
; 4324 :                 max apparent layers for input or interchange codestream. */
; 4325 :     int next_layer_idx; // Next layer to be sequenced or generated.
; 4326 :     union { // First field used for input; second interchange; third for output
; 4327 :         int num_packets_read; // Incremented when packets read or interchanged
; 4328 :         int cumulative_bytes; // Size of all packets generated so far.
; 4329 :         int saved_next_layer_idx; // Used by "kd_packet_sequencer::save_state"
; 4330 :       };
; 4331 : 
; 4332 :   public: // Activation state variables
; 4333 :     int num_outstanding_blocks; // See notes below.
; 4334 :     union { // First field used only in reading; second only in writing.
; 4335 :         kdu_long unique_address; // See below
; 4336 :         kdu_long *packet_bytes; // Lengths generated during simulated output
; 4337 :       };
; 4338 :   public: // code-block containers
; 4339 :     kd_precinct_band *subbands; // In practice, this member points into the
; 4340 :        // same block of memory which is allocated to hold the precinct so
; 4341 :        // as to encourage memory locality and allow for manipulation of all
; 4342 :        // aspects of a precinct, including all of its code-blocks, via a
; 4343 :        // single heap block.  Note that the number of entries in this array
; 4344 :        // is given by `resolution->num_subbands'.
; 4345 : 
; 4346 :   public: // See below for an explanation of these links
; 4347 :     kd_precinct *next; // Next in free, inactive or generated list
; 4348 :     kd_precinct *prev; // Previous in inactive or generated list
; 4349 :     kd_precinct_size_class *size_class; // For correctly releasing storage
; 4350 :   };
; 4351 :   /* Notes:
; 4352 :         `unique_address' is valid if and only if the precinct is marked as
; 4353 :      addressable, meaning that the precinct has a unique address from which it
; 4354 :      may be loaded (for input codestream objects) or identified (for
; 4355 :      interchange codestream objects).  If addressable, the `unique_address'
; 4356 :      will be 0 if and only if the precinct is known to be empty, meaning that
; 4357 :      reloading the precinct does not require any actual data transfers from a
; 4358 :      compressed data source.
; 4359 :         Except as described above, when used with seekable compressed data
; 4360 :      sources, the `unique_address' member holds a positive quantity which
; 4361 :      identifies an offset into the code-stream at which the precinct's
; 4362 :      packets may be found.  In the case of cached sources (those advertising
; 4363 :      the KDU_SOURCE_CAP_CACHED capability) or codestream objects created for
; 4364 :      interchange (no compressed data source or target), the `unique_address'
; 4365 :      will be negative and -(1+`unique_address') is the precinct's unique
; 4366 :      identifier, as passed to the `kdu_compressed_source::set_precinct_scope'
; 4367 :      function, or returned by the `kdu_precinct::get_unique_id' function.
; 4368 :         The `num_outstanding_blocks' member is used to monitor the number of
; 4369 :      code-blocks from the application's region of interest which have still
; 4370 :      to be consumed (input codestreams) or the number of code-blocks which
; 4371 :      have still to be written in order to complete the precinct (output
; 4372 :      and interchange codestreams).
; 4373 :         The `next' and `prev' links may be used to manage the precinct's
; 4374 :      location in one of three different lists.  The first list is the
; 4375 :      singly-linked free list maintained by `kd_precinct_size_class', from
; 4376 :      which the `kd_precinct_server' object re-issues previously released
; 4377 :      resources.
; 4378 :         The second list on which this structure may find itself is the
; 4379 :      doubly-linked list of currently inactive precincts, which is managed by
; 4380 :      the `kd_precinct_server' object.  Precincts which find themselves on this
; 4381 :      list have been released, but their resources have not yet been recycled.
; 4382 :      They may be successfully re-activated, if their resources have not been
; 4383 :      re-issued to another precinct.  Precincts on this list may be identified
; 4384 :      by the `inactive' flag.  Every inactive precinct necessarily also has
; 4385 :      its `released' member set to true, but the converse is not necessarily
; 4386 :      true.  This is because precincts which have been partially parsed
; 4387 :      in a context for which they were not directly relevant, will be marked
; 4388 :      as released, even though they are not inactive.
; 4389 :         The third list on which this structure may find itself is the
; 4390 :      doubly-linked list of generated precincts managed by the
; 4391 :      `kd_global_rescomp' structure.  This list contains all precincts
; 4392 :      from a given resolution of a given image component, across all tiles,
; 4393 :      which have been fully generated, but not yet flushed out to the
; 4394 :      code-stream.   The list is used to manage incremental rate allocation
; 4395 :      when processing large images.  Elements on this list have not yet
; 4396 :      been closed. */
; 4397 : 
; 4398 : /*****************************************************************************/
; 4399 : /*                         kd_precinct_size_class                            */
; 4400 : /*****************************************************************************/
; 4401 : 
; 4402 :   /* For an explanation of the role played by precinct size classes, see
; 4403 :      the discussion appearing below the declaration of `kd_precinct_server'. */
; 4404 : 
; 4405 : class kd_precinct_size_class {
; 4406 :   public: // Member functions
; 4407 :     kd_precinct_size_class(int max_blocks, int num_subbands,
; 4408 :                            kd_precinct_server *server,
; 4409 :                            kd_buf_server *buf_server)
; 4410 :       {
; 4411 :         this->max_blocks = max_blocks;
; 4412 :         this->num_subbands = num_subbands;
; 4413 :         this->server = server;  this->buf_server = buf_server;
; 4414 :         total_precincts = 0; free_list = NULL; next = NULL;
; 4415 :         alloc_bytes = (int) sizeof(kd_precinct);
; 4416 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4417 :         alloc_bytes += num_subbands * (int) sizeof(kd_precinct_band);
; 4418 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4419 :         alloc_bytes += 4 + max_blocks * (int) sizeof(kd_block);
; 4420 :       }
; 4421 :     ~kd_precinct_size_class()
; 4422 :       { kd_precinct *tmp;
; 4423 :         while ((tmp=free_list) != NULL)
; 4424 :           { free_list = tmp->next; free(tmp); total_precincts--; }
; 4425 :         assert(total_precincts == 0);
; 4426 :       }
; 4427 :     kd_precinct *get()
; 4428 :       {
; 4429 :         if (free_list == NULL)
; 4430 :           augment_free_list();
; 4431 :         kd_precinct *result = free_list; free_list = free_list->next;
; 4432 :         result->next = result->prev = NULL;
; 4433 :         buf_server->augment_structure_bytes(alloc_bytes);
; 4434 :         return result;
; 4435 :       }
; 4436 :     void release(kd_precinct *precinct)
; 4437 :       {
; 4438 :         if (precinct->flags & KD_PFLAG_INACTIVE)

	je	SHORT $LN5@clear

; 4439 :           withdraw_from_inactive_list(precinct);

	push	esi
	mov	ecx, ebx
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list
$LN5@clear:

; 4440 :         precinct->next = free_list;

	mov	eax, DWORD PTR [ebx+32]
	mov	DWORD PTR [esi+44], eax

; 4441 :         free_list = precinct;
; 4442 :         buf_server->augment_structure_bytes(-alloc_bytes);

	mov	ecx, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [ebx+32], esi
	neg	eax
	cdq

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	add	DWORD PTR [ecx+32], eax

; 281  :         if (structure_bytes > peak_structure_bytes)

	mov	eax, DWORD PTR [ecx+32]
	adc	DWORD PTR [ecx+36], edx
	mov	edx, DWORD PTR [ecx+36]
	pop	esi
	pop	ebx
	cmp	edx, DWORD PTR [ecx+44]
	jl	SHORT $LN8@clear
	jg	SHORT $LN10@clear
	cmp	eax, DWORD PTR [ecx+40]
	jbe	SHORT $LN8@clear
$LN10@clear:

; 282  :           peak_structure_bytes = structure_bytes;

	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+44], edx
$LN8@clear:

; 4677 :     }
; 4678 :   state = 0;

	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+4], 0
	pop	edi

; 4679 : }

	ret	0
?clear@kd_precinct_ref@@QAEXXZ ENDP			; kd_precinct_ref::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?release@kd_precinct_ref@@QAEXXZ
_TEXT	SEGMENT
?release@kd_precinct_ref@@QAEXXZ PROC			; kd_precinct_ref::release, COMDAT
; _this$ = ecx

; 4702 : {

	mov	edx, ecx

; 4703 :   kd_precinct *precinct = (kd_precinct *) _kdu_long_to_addr(state);

	mov	ecx, DWORD PTR [edx]

; 4704 :   assert((state != 0) && !(state & 1));
; 4705 :   if (precinct->flags & KD_PFLAG_INACTIVE)

	mov	eax, DWORD PTR [ecx+8]
	test	al, 32					; 00000020H
	jne	SHORT $LN4@release

; 4706 :     return; // Already on the inactive list.
; 4707 :   precinct->flags |= KD_PFLAG_RELEASED;

	or	eax, 16					; 00000010H
	mov	DWORD PTR [ecx+8], eax

; 4708 :     // precinct->released = true; // In case not already set.
; 4709 :   if ((precinct->flags & KD_PFLAG_ADDRESSABLE) &&
; 4710 :       (!precinct->resolution->codestream->cached) &&

	test	al, 8
	je	SHORT $LN3@release
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	cmp	BYTE PTR [eax+338], 0
	jne	SHORT $LN3@release
	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN5@release
	cmp	eax, DWORD PTR [ecx+16]
	jne	SHORT $LN3@release
$LN5@release:

; 4711 :       ((precinct->num_packets_read == 0) ||
; 4712 :        (precinct->num_packets_read == precinct->next_layer_idx)))
; 4713 :     precinct->size_class->move_to_inactive_list(precinct);

	push	ecx
	mov	ecx, DWORD PTR [ecx+52]
	call	?move_to_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::move_to_inactive_list
$LN4@release:

; 4716 : }

	ret	0
$LN3@release:

; 4714 :   else
; 4715 :     close();

	mov	ecx, edx
	jmp	?close@kd_precinct_ref@@QAEXXZ		; kd_precinct_ref::close
?release@kd_precinct_ref@@QAEXXZ ENDP			; kd_precinct_ref::release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?close_and_reset@kd_precinct_ref@@QAEXXZ
_TEXT	SEGMENT
?close_and_reset@kd_precinct_ref@@QAEXXZ PROC		; kd_precinct_ref::close_and_reset, COMDAT
; _this$ = ecx

; 4683 : {

	push	esi
	mov	esi, ecx

; 4684 :   if (state & 1)

	mov	ecx, DWORD PTR [esi]
	mov	eax, ecx
	mov	edx, DWORD PTR [esi+4]
	and	eax, 1
	or	eax, 0
	je	SHORT $LN2@close_and_

; 4685 :     {
; 4686 :       if (state != 3)

	cmp	ecx, 3
	jne	SHORT $LN9@close_and_
	test	edx, edx
	je	SHORT $LN6@close_and_
$LN9@close_and_:

; 4687 :         state &= ~((kdu_long) 2);

	and	ecx, -3					; fffffffdH
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi], ecx
	pop	esi

; 4696 :         }
; 4697 :     }
; 4698 : }

	ret	0
$LN2@close_and_:

; 4688 :     }
; 4689 :   else if (state != 0)

	or	ecx, edx
	je	SHORT $LN6@close_and_

; 4690 :     {
; 4691 :       kd_precinct *prec = (kd_precinct *) _kdu_long_to_addr(state);

	mov	eax, DWORD PTR [esi]

; 4692 :       if ((prec->flags & KD_PFLAG_PARSED)||(prec->num_packets_read > 0))

	test	DWORD PTR [eax+8], 256			; 00000100H
	jne	SHORT $LN7@close_and_
	cmp	DWORD PTR [eax+20], 0
	jle	SHORT $LN6@close_and_
$LN7@close_and_:

; 4693 :         {
; 4694 :           close();

	mov	ecx, esi
	call	?close@kd_precinct_ref@@QAEXXZ		; kd_precinct_ref::close

; 4695 :           state &= ~((kdu_long) 2);

	mov	eax, DWORD PTR [esi+4]
	and	DWORD PTR [esi], -3			; fffffffdH
	mov	DWORD PTR [esi+4], eax
$LN6@close_and_:
	pop	esi

; 4696 :         }
; 4697 :     }
; 4698 : }

	ret	0
?close_and_reset@kd_precinct_ref@@QAEXXZ ENDP		; kd_precinct_ref::close_and_reset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?close@kd_precinct_ref@@QAEXXZ
_TEXT	SEGMENT
?close@kd_precinct_ref@@QAEXXZ PROC			; kd_precinct_ref::close, COMDAT
; _this$ = ecx

; 6535 : {

	push	esi
	mov	esi, ecx

; 6536 :   if ((state == 0) || (state & 1))

	mov	ecx, DWORD PTR [esi]
	mov	eax, ecx
	or	eax, DWORD PTR [esi+4]
	je	$LN3@close
	and	ecx, 1
	or	ecx, 0
	jne	$LN3@close

; 6537 :     return; // Nothing to do.
; 6538 :   kd_precinct *precinct = (kd_precinct *) _kdu_long_to_addr(state);

	push	edi
	mov	edi, DWORD PTR [esi]

; 6539 :   assert(precinct->ref == this);
; 6540 :   precinct->ref = NULL; // To satisfy the test in `kd_precinct::closing'.

	mov	DWORD PTR [edi+4], ecx

; 6541 :   precinct->closing();

	mov	ecx, edi
	call	?closing@kd_precinct@@QAEXXZ		; kd_precinct::closing

; 6542 :   if (precinct->flags & KD_PFLAG_ADDRESSABLE)

	test	BYTE PTR [edi+8], 8
	je	SHORT $LN4@close

; 6543 :     {
; 6544 :       state = (precinct->unique_address << 2) + 1;

	mov	eax, DWORD PTR [edi+32]
	mov	ecx, DWORD PTR [edi+36]
	shld	ecx, eax, 2
	shl	eax, 2
	add	eax, 1
	mov	DWORD PTR [esi], eax
	adc	ecx, 0
	mov	DWORD PTR [esi+4], ecx

; 6545 :       if ((precinct->flags & KD_PFLAG_PARSED) ||

	test	DWORD PTR [edi+8], 256			; 00000100H
	jne	SHORT $LN7@close
	cmp	DWORD PTR [edi+20], 0
	je	SHORT $LN5@close
$LN7@close:

; 6546 :           (precinct->num_packets_read != 0))
; 6547 :         state += 2;

	add	DWORD PTR [esi], 2
	adc	DWORD PTR [esi+4], 0

; 6548 :     }
; 6549 :   else

	jmp	SHORT $LN5@close
$LN4@close:

; 6550 :     state = 3; // Mark precinct as permanently unloaded.

	mov	DWORD PTR [esi], 3
	mov	DWORD PTR [esi+4], 0
$LN5@close:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4438 :         if (precinct->flags & KD_PFLAG_INACTIVE)

	test	BYTE PTR [edi+8], 32			; 00000020H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6551 :   precinct->size_class->release(precinct);

	mov	esi, DWORD PTR [edi+52]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4438 :         if (precinct->flags & KD_PFLAG_INACTIVE)

	je	SHORT $LN10@close

; 4439 :           withdraw_from_inactive_list(precinct);

	push	edi
	mov	ecx, esi
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list
$LN10@close:

; 4440 :         precinct->next = free_list;

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [edi+44], eax

; 4441 :         free_list = precinct;
; 4442 :         buf_server->augment_structure_bytes(-alloc_bytes);

	mov	ecx, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [esi+16]
	neg	eax
	mov	DWORD PTR [esi+32], edi
	cdq

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	add	DWORD PTR [ecx+32], eax

; 281  :         if (structure_bytes > peak_structure_bytes)

	mov	eax, DWORD PTR [ecx+32]
	adc	DWORD PTR [ecx+36], edx
	mov	edx, DWORD PTR [ecx+36]
	pop	edi
	cmp	edx, DWORD PTR [ecx+44]
	jl	SHORT $LN3@close
	jg	SHORT $LN15@close
	cmp	eax, DWORD PTR [ecx+40]
	jbe	SHORT $LN3@close
$LN15@close:

; 282  :           peak_structure_bytes = structure_bytes;

	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+44], edx
$LN3@close:
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6552 : }

	ret	0
?close@kd_precinct_ref@@QAEXXZ ENDP			; kd_precinct_ref::close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?open@kd_precinct_ref@@QAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@_N@Z
_TEXT	SEGMENT
_res$ = 8						; size = 4
_pos_idx$ = 12						; size = 8
_need_activate$ = 20					; size = 1
?open@kd_precinct_ref@@QAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@_N@Z PROC ; kd_precinct_ref::open, COMDAT
; _this$ = ecx

; 4721 : {

	push	ebp
	mov	ebp, esp

; 4722 :   if (state == 3)

	mov	edx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR [ecx+4]
	cmp	edx, 3
	jne	SHORT $LN2@open
	test	esi, esi
	jne	SHORT $LN2@open

; 4723 :     return NULL; // Precinct is not currently loaded

	xor	eax, eax
	pop	esi

; 4735 : }

	pop	ebp
	ret	16					; 00000010H
$LN2@open:

; 4724 :   if ((state == 0) || (state & 1))

	mov	eax, edx
	or	eax, esi
	je	SHORT $LN4@open
	and	edx, 1
	or	edx, 0
	jne	SHORT $LN4@open

; 4726 :   kd_precinct *result = (kd_precinct *) _kdu_long_to_addr(state);

	mov	esi, DWORD PTR [ecx]

; 4727 :   if (result->flags & KD_PFLAG_INACTIVE)

	mov	eax, DWORD PTR [esi+8]
	test	al, 32					; 00000020H
	je	SHORT $LN5@open

; 4728 :     { // Must be on the inactive list
; 4729 :       result->size_class->withdraw_from_inactive_list(result);

	mov	ecx, DWORD PTR [esi+52]
	push	esi
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list

; 4733 :     result->activate();

	mov	ecx, esi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate

; 4734 :   return result;

	mov	eax, esi
	pop	esi

; 4735 : }

	pop	ebp
	ret	16					; 00000010H
$LN5@open:

; 4730 :       result->activate();
; 4731 :     }
; 4732 :   else if (need_activate && (result->flags & KD_PFLAG_RELEASED))

	cmp	BYTE PTR _need_activate$[ebp], 0
	je	SHORT $LN7@open
	test	al, 16					; 00000010H
	je	SHORT $LN7@open

; 4733 :     result->activate();

	mov	ecx, esi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate
$LN7@open:

; 4734 :   return result;

	mov	eax, esi
	pop	esi

; 4735 : }

	pop	ebp
	ret	16					; 00000010H
$LN4@open:

; 4725 :     return instantiate_precinct(res,pos_idx);

	push	DWORD PTR _pos_idx$[ebp+4]
	push	DWORD PTR _pos_idx$[ebp]
	push	DWORD PTR _res$[ebp]
	call	?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z ; kd_precinct_ref::instantiate_precinct
	pop	esi

; 4735 : }

	pop	ebp
	ret	16					; 00000010H
?open@kd_precinct_ref@@QAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@_N@Z ENDP ; kd_precinct_ref::open
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?active_deref@kd_precinct_ref@@QAEPAUkd_precinct@@XZ
_TEXT	SEGMENT
?active_deref@kd_precinct_ref@@QAEPAUkd_precinct@@XZ PROC ; kd_precinct_ref::active_deref, COMDAT
; _this$ = ecx

; 4739 : { // This function is often invoked without mutex protection.  It is used to

	mov	edx, ecx
	push	esi

; 4740 :   // determine whether a valid precinct reference exists already or one must
; 4741 :   // be created using `kd_precinct_ref::open', which should be protected in
; 4742 :   // a multi-threading environment.  To avoid possible race conditions, we
; 4743 :   // inform the compiler that the `state' variable should be treated as
; 4744 :   // volatile here.
; 4745 :   volatile kdu_long *state_ref = &state;
; 4746 :   register kdu_long state_val = *state_ref;

	mov	esi, DWORD PTR [edx]

; 4747 :   if ((state_val & 1) || (state_val == 0)) return NULL;

	mov	eax, esi
	mov	ecx, DWORD PTR [edx+4]
	and	eax, 1
	or	eax, 0
	jne	SHORT $LN3@active_der
	mov	eax, esi
	or	eax, ecx
	je	SHORT $LN3@active_der

; 4748 :   kd_precinct *result = (kd_precinct *) _kdu_long_to_addr(state_val);
; 4749 :   if (result->flags & (KD_PFLAG_INACTIVE|KD_PFLAG_RELEASED)) return NULL;

	test	BYTE PTR [esi+8], 48			; 00000030H
	jne	SHORT $LN3@active_der

; 4750 :   return (*state_ref == _addr_to_kdu_long(result))?result:NULL;

	mov	ecx, DWORD PTR [edx]
	mov	eax, esi
	push	edi
	mov	edi, DWORD PTR [edx+4]
	cdq
	cmp	ecx, eax
	jne	SHORT $LN6@active_der
	cmp	edi, edx
	je	SHORT $LN7@active_der
$LN6@active_der:
	xor	esi, esi
$LN7@active_der:
	pop	edi
	mov	eax, esi
	pop	esi

; 4751 :       // Need to be sure that another thread did not activate the precinct
; 4752 :       // object for use with another `kd_precinct_ref' reference, causing
; 4753 :       // the flags test above to succeed, even though the precinct had been
; 4754 :       // in the released state when we accessed the value of `state' on
; 4755 :       // the second line.  The fact that `state_ref' is volatile, forces the
; 4756 :       // compiler to generate code which reloads it to properly confirm that
; 4757 :       // `result' is the precinct which belongs to us.
; 4758 : }

	ret	0
$LN3@active_der:

; 4747 :   if ((state_val & 1) || (state_val == 0)) return NULL;

	xor	eax, eax
	pop	esi

; 4751 :       // Need to be sure that another thread did not activate the precinct
; 4752 :       // object for use with another `kd_precinct_ref' reference, causing
; 4753 :       // the flags test above to succeed, even though the precinct had been
; 4754 :       // in the released state when we accessed the value of `state' on
; 4755 :       // the second line.  The fact that `state_ref' is volatile, forces the
; 4756 :       // compiler to generate code which reloads it to properly confirm that
; 4757 :       // `result' is the precinct which belongs to us.
; 4758 : }

	ret	0
?active_deref@kd_precinct_ref@@QAEPAUkd_precinct@@XZ ENDP ; kd_precinct_ref::active_deref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?deref@kd_precinct_ref@@QAEPAUkd_precinct@@XZ
_TEXT	SEGMENT
?deref@kd_precinct_ref@@QAEPAUkd_precinct@@XZ PROC	; kd_precinct_ref::deref, COMDAT
; _this$ = ecx

; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }

	mov	eax, DWORD PTR [ecx]
	and	eax, 1
	or	eax, 0
	je	SHORT $LN3@deref
	xor	eax, eax
	ret	0
$LN3@deref:
	mov	eax, DWORD PTR [ecx]
	ret	0
?deref@kd_precinct_ref@@QAEPAUkd_precinct@@XZ ENDP	; kd_precinct_ref::deref
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?parsed_and_unloaded@kd_precinct_ref@@QAE_NXZ
_TEXT	SEGMENT
?parsed_and_unloaded@kd_precinct_ref@@QAE_NXZ PROC	; kd_precinct_ref::parsed_and_unloaded, COMDAT
; _this$ = ecx

; 3071 :       { return ((state & 3) == 3) && (state != 3); }

	mov	edx, DWORD PTR [ecx]
	mov	eax, edx
	push	esi
	and	eax, 3
	xor	esi, esi
	cmp	eax, 3
	jne	SHORT $LN3@parsed_and
	test	esi, esi
	jne	SHORT $LN3@parsed_and
	cmp	edx, eax
	jne	SHORT $LN5@parsed_and
	cmp	DWORD PTR [ecx+4], esi
	je	SHORT $LN3@parsed_and
$LN5@parsed_and:
	mov	al, 1
	pop	esi
	ret	0
$LN3@parsed_and:
	xor	al, al
	pop	esi
	ret	0
?parsed_and_unloaded@kd_precinct_ref@@QAE_NXZ ENDP	; kd_precinct_ref::parsed_and_unloaded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_precinct_ref@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kd_precinct_ref@@QAE@XZ PROC				; kd_precinct_ref::~kd_precinct_ref, COMDAT
; _this$ = ecx

; 3069 :       { if (!((state == 0) || (state & 1))) close(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_precinct_ref@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edx, DWORD PTR [ecx]
	mov	eax, edx
	or	eax, DWORD PTR [ecx+4]
	je	SHORT $LN2@kd_precinc
	and	edx, 1
	or	edx, 0
	jne	SHORT $LN2@kd_precinc
	call	?close@kd_precinct_ref@@QAEXXZ		; kd_precinct_ref::close
$LN2@kd_precinc:
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1kd_precinct_ref@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_precinct_ref@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_precinct_ref@@QAE@XZ ENDP				; kd_precinct_ref::~kd_precinct_ref
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_precinct_ref@@QAE@XZ
_TEXT	SEGMENT
??0kd_precinct_ref@@QAE@XZ PROC				; kd_precinct_ref::kd_precinct_ref, COMDAT
; _this$ = ecx

; 3067 :       { state = 0; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0kd_precinct_ref@@QAE@XZ ENDP				; kd_precinct_ref::kd_precinct_ref
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Ekd_tile_comp@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Ekd_tile_comp@@QAEPAXI@Z PROC			; kd_tile_comp::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Ekd_tile_comp@@QAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ebx, DWORD PTR ___flags$[ebp]
	test	bl, 2
	je	SHORT $LN2@vector
	push	OFFSET ??1kd_tile_comp@@QAE@XZ		; kd_tile_comp::~kd_tile_comp
	push	DWORD PTR [esi-4]
	lea	edi, DWORD PTR [esi-4]
	push	188					; 000000bcH
	push	esi
	call	??_M@YGXPAXIIP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN3@vector
	imul	ecx, DWORD PTR [edi], 188
	add	ecx, 4
	push	ecx
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN3@vector:
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@vector:
	call	??1kd_tile_comp@@QAE@XZ			; kd_tile_comp::~kd_tile_comp
	test	bl, 1
	je	SHORT $LN4@vector
	push	188					; 000000bcH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@vector:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Ekd_tile_comp@@QAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Ekd_tile_comp@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Ekd_tile_comp@@QAEPAXI@Z ENDP			; kd_tile_comp::`vector deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?reset_layer_stats@kd_tile_comp@@QAEXXZ
_TEXT	SEGMENT
?reset_layer_stats@kd_tile_comp@@QAEXXZ PROC		; kd_tile_comp::reset_layer_stats, COMDAT
; _this$ = ecx

; 2957 :         if (layer_stats != NULL)

	mov	edx, DWORD PTR [ecx+148]
	test	edx, edx
	je	SHORT $LN2@reset_laye

; 2958 :           {
; 2959 :             int num_entries = ((1+dwt_levels)*tile->num_layers)<<1;
; 2960 :             memset(layer_stats,0,(size_t)(sizeof(kdu_long)*num_entries));

	mov	eax, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+56]
	inc	ecx
	imul	ecx, DWORD PTR [eax+132]
	shl	ecx, 4
	push	ecx
	push	0
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN2@reset_laye:

; 2961 :           }
; 2962 :       }

	ret	0
?reset_layer_stats@kd_tile_comp@@QAEXXZ ENDP		; kd_tile_comp::reset_layer_stats
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?initialize_kernel_parameters@kd_tile_comp@@QAEXHAAVkdu_kernels@@@Z
_TEXT	SEGMENT
_high_hlen$ = -32					; size = 4
_low_hlen$ = -28					; size = 4
_n$1$ = -24						; size = 4
tv1180 = -20						; size = 4
_s$1$ = -16						; size = 4
tv1184 = -12						; size = 4
_Ls$1$ = -8						; size = 4
_kernel_rev$ = -1					; size = 1
_c$2$ = 8						; size = 4
$T1 = 8							; size = 4
$T2 = 8							; size = 4
_atk_idx$ = 8						; size = 4
_kernels$ = 12						; size = 4
?initialize_kernel_parameters@kd_tile_comp@@QAEXHAAVkdu_kernels@@@Z PROC ; kd_tile_comp::initialize_kernel_parameters, COMDAT
; _this$ = ecx

; 3841 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	push	esi
	push	edi
	mov	edi, ecx

; 3842 :   bool kernel_rev = reversible;

	mov	al, BYTE PTR [edi+64]

; 3843 :   kd_create_dwt_description(kernel_id,atk_idx,codestream->siz,tile->t_num,

	lea	ebx, DWORD PTR [edi+88]
	push	ebx
	mov	BYTE PTR _kernel_rev$[ebp], al
	lea	esi, DWORD PTR [edi+76]
	lea	eax, DWORD PTR [edi+80]
	push	eax
	push	esi
	lea	edx, DWORD PTR [edi+73]
	push	edx
	lea	ecx, DWORD PTR [edi+72]
	push	ecx
	lea	eax, DWORD PTR _kernel_rev$[ebp]
	push	eax
	mov	eax, DWORD PTR [edi+4]
	push	DWORD PTR [eax+4]
	mov	eax, DWORD PTR [edi]
	push	DWORD PTR [eax+12]
	push	DWORD PTR _atk_idx$[ebp]
	push	DWORD PTR [edi+68]
	call	?kd_create_dwt_description@@YAXHHPAVkdu_params@@HAA_N11AAHAAPAUkdu_kernel_step_info@@AAPAM@Z ; kd_create_dwt_description
	add	esp, 40					; 00000028H

; 3844 :                             kernel_rev,kernel_symmetric,
; 3845 :                             kernel_symmetric_extension,kernel_num_steps,
; 3846 :                             kernel_step_info,kernel_coefficients);
; 3847 :   assert(reversible == kernel_rev);
; 3848 :   if (kernel_symmetric)

	cmp	BYTE PTR [edi+72], 0
	je	SHORT $LN11@initialize

; 3849 :     {
; 3850 :       kernel_step_info_flipped = kernel_step_info;

	mov	eax, DWORD PTR [edi+80]
	mov	DWORD PTR [edi+84], eax

; 3851 :       kernel_coefficients_flipped = kernel_coefficients;

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [edi+92], eax

; 3852 :     }
; 3853 :   else

	jmp	$LN6@initialize
$LN11@initialize:

; 3856 :       kernel_step_info_flipped = new kdu_kernel_step_info[kernel_num_steps];

	mov	esi, DWORD PTR [esi]
	xor	ecx, ecx
	mov	eax, esi
	mov	DWORD PTR $T2[ebp], esi
	mov	edx, 16					; 00000010H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T1[ebp], eax
	test	eax, eax
	je	SHORT $LN14@initialize
	test	esi, esi
	je	SHORT $LN15@initialize
	lea	ecx, DWORD PTR [eax+12]
$LL18@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 101  :       { support_length = support_min = 0;  downshift = rounding_offset = 0; }

	mov	DWORD PTR [ecx-8], 0
	lea	ecx, DWORD PTR [ecx+16]
	mov	DWORD PTR [ecx-28], 0
	mov	DWORD PTR [ecx-16], 0
	mov	DWORD PTR [ecx-20], 0
	sub	esi, 1
	jne	SHORT $LL18@initialize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3856 :       kernel_step_info_flipped = new kdu_kernel_step_info[kernel_num_steps];

	jmp	SHORT $LN15@initialize
$LN14@initialize:
	xor	eax, eax
$LN15@initialize:

; 3857 :       for (c=s=0; s < kernel_num_steps; s++)

	mov	edx, DWORD PTR [edi+76]
	lea	esi, DWORD PTR [edi+76]
	mov	DWORD PTR [edi+84], eax
	xor	eax, eax
	test	edx, edx
	jle	SHORT $LN3@initialize

; 3858 :         c += kernel_step_info[s].support_length;

	mov	ecx, DWORD PTR [edi+80]
$LL4@initialize:
	add	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+16]
	sub	edx, 1
	jne	SHORT $LL4@initialize
$LN3@initialize:

; 3859 :       kernel_coefficients_flipped = new float[c];

	xor	ecx, ecx
	mov	edx, 4
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	DWORD PTR [edi+92], eax
	add	esp, 4

; 3860 :       for (c=s=0; s < kernel_num_steps; s++)

	xor	eax, eax
	mov	DWORD PTR _s$1$[ebp], eax
	mov	DWORD PTR _c$2$[ebp], eax
	cmp	DWORD PTR [esi], eax
	jle	$LN6@initialize

; 3859 :       kernel_coefficients_flipped = new float[c];

	xor	esi, esi
	mov	DWORD PTR tv1180[ebp], esi
	npad	5
$LL7@initialize:

; 3861 :         {
; 3862 :           kdu_kernel_step_info *sp = kernel_step_info + s;

	mov	edx, DWORD PTR [edi+80]

; 3863 :           kdu_kernel_step_info *dp = kernel_step_info_flipped + s;
; 3864 :           int Ls = dp->support_length = sp->support_length;
; 3865 :           dp->support_min = -(sp->support_min + Ls - 1) + 1-2*(s&1);

	and	eax, 1
	mov	ecx, DWORD PTR [edi+84]
	add	edx, esi
	add	ecx, esi
	neg	eax
	add	eax, eax
	mov	esi, DWORD PTR [edx]
	mov	DWORD PTR [ecx], esi
	sub	eax, DWORD PTR [edx+4]
	sub	eax, esi
	mov	DWORD PTR _Ls$1$[ebp], esi
	add	eax, 2
	mov	DWORD PTR [ecx+4], eax

; 3866 :           dp->downshift = sp->downshift;

	mov	eax, DWORD PTR [edx+8]
	mov	DWORD PTR [ecx+8], eax

; 3867 :           dp->rounding_offset = sp->rounding_offset;

	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [ecx+12], eax

; 3868 :           for (n=0; n < Ls; n++)

	xor	ecx, ecx
	cmp	esi, 4
	jl	SHORT $LC39@initialize

; 3861 :         {
; 3862 :           kdu_kernel_step_info *sp = kernel_step_info + s;

	mov	eax, DWORD PTR _c$2$[ebp]
	lea	edx, DWORD PTR [eax*4]
	add	eax, esi
	lea	esi, DWORD PTR [eax*4-12]
	mov	eax, DWORD PTR _Ls$1$[ebp]
	add	eax, -4					; fffffffcH
	shr	eax, 2
	inc	eax
	mov	DWORD PTR tv1184[ebp], eax
	shl	eax, 2
	mov	DWORD PTR _n$1$[ebp], eax
	npad	4

; 3868 :           for (n=0; n < Ls; n++)

$LL40@initialize:

; 3869 :             kernel_coefficients_flipped[c+n] = kernel_coefficients[c+Ls-1-n];

	sub	DWORD PTR tv1184[ebp], 1
	lea	edx, DWORD PTR [edx+16]
	mov	eax, DWORD PTR [ebx]
	lea	esi, DWORD PTR [esi-16]
	mov	ecx, DWORD PTR [edi+92]
	mov	eax, DWORD PTR [esi+eax+24]
	mov	DWORD PTR [edx+ecx-16], eax
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [edi+92]
	mov	eax, DWORD PTR [esi+eax+20]
	mov	DWORD PTR [edx+ecx-12], eax
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [edi+92]
	mov	eax, DWORD PTR [esi+eax+16]
	mov	DWORD PTR [edx+ecx-8], eax
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [edi+92]
	mov	eax, DWORD PTR [esi+eax+12]
	mov	DWORD PTR [edx+ecx-4], eax
	jne	SHORT $LL40@initialize
	mov	esi, DWORD PTR _Ls$1$[ebp]
	mov	ecx, DWORD PTR _n$1$[ebp]
$LC39@initialize:

; 3868 :           for (n=0; n < Ls; n++)

	cmp	ecx, esi
	jge	SHORT $LN38@initialize
	mov	eax, DWORD PTR _c$2$[ebp]
	mov	ebx, esi
	sub	ebx, ecx
	lea	edx, DWORD PTR [ecx+eax]
	lea	esi, DWORD PTR [ebx+eax]
	shl	edx, 2
	shl	esi, 2
	npad	3
$LC10@initialize:

; 3869 :             kernel_coefficients_flipped[c+n] = kernel_coefficients[c+Ls-1-n];

	mov	eax, DWORD PTR [edi+88]
	lea	edx, DWORD PTR [edx+4]
	mov	ecx, DWORD PTR [edi+92]
	lea	esi, DWORD PTR [esi-4]
	mov	eax, DWORD PTR [eax+esi]
	mov	DWORD PTR [edx+ecx-4], eax
	sub	ebx, 1
	jne	SHORT $LC10@initialize
	mov	esi, DWORD PTR _Ls$1$[ebp]
	lea	ebx, DWORD PTR [edi+88]
$LN38@initialize:

; 3870 :           c += Ls;

	add	DWORD PTR _c$2$[ebp], esi
	mov	eax, DWORD PTR _s$1$[ebp]
	mov	esi, DWORD PTR tv1180[ebp]
	inc	eax
	add	esi, 16					; 00000010H
	mov	DWORD PTR _s$1$[ebp], eax
	mov	DWORD PTR tv1180[ebp], esi
	cmp	eax, DWORD PTR [edi+76]
	jl	$LL7@initialize
	lea	esi, DWORD PTR [edi+76]
$LN6@initialize:

; 3871 :         }
; 3872 :     }
; 3873 :   kernels.init(kernel_num_steps,kernel_step_info,

	movzx	eax, BYTE PTR [edi+64]
	push	eax
	movzx	eax, BYTE PTR [edi+73]
	push	eax
	movzx	eax, BYTE PTR [edi+72]
	push	eax
	push	DWORD PTR [ebx]
	push	DWORD PTR [edi+80]
	push	DWORD PTR [esi]
	mov	esi, DWORD PTR _kernels$[ebp]
	mov	ecx, esi
	call	?init@kdu_kernels@@QAEXHPBUkdu_kernel_step_info@@PBM_N22@Z ; kdu_kernels::init

; 3874 :                kernel_coefficients,kernel_symmetric,
; 3875 :                kernel_symmetric_extension,reversible);
; 3876 :   int low_hlen, high_hlen;
; 3877 :   kernels.get_impulse_response(KDU_SYNTHESIS_LOW,low_hlen,

	lea	eax, DWORD PTR [edi+108]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR [edi+104]
	push	eax
	lea	eax, DWORD PTR _low_hlen$[ebp]
	push	eax
	push	2
	call	?get_impulse_response@kdu_kernels@@QAEPAMW4kdu_kernel_type@@AAHPAH2@Z ; kdu_kernels::get_impulse_response

; 3878 :                                &low_support_min,&low_support_max);
; 3879 :   kernels.get_impulse_response(KDU_SYNTHESIS_HIGH,high_hlen,

	lea	eax, DWORD PTR [edi+116]
	mov	ecx, esi
	push	eax
	lea	eax, DWORD PTR [edi+112]
	push	eax
	lea	eax, DWORD PTR _high_hlen$[ebp]
	push	eax
	push	3
	call	?get_impulse_response@kdu_kernels@@QAEPAMW4kdu_kernel_type@@AAHPAH2@Z ; kdu_kernels::get_impulse_response
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 247  :           num_steps = this->num_steps; dc_scale = this->low_scale;

	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [edi+96], eax

; 248  :           nyq_scale = this->high_scale; return lifting_factors;

	mov	eax, DWORD PTR [esi+28]
	mov	DWORD PTR [edi+100], eax
	pop	edi
	pop	esi
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3888 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?initialize_kernel_parameters@kd_tile_comp@@QAEXHAAVkdu_kernels@@@Z ENDP ; kd_tile_comp::initialize_kernel_parameters
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ??1kd_tile_comp@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kd_tile_comp@@QAE@XZ PROC				; kd_tile_comp::~kd_tile_comp, COMDAT
; _this$ = ecx

; 3818 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_tile_comp@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 3819 :   if (kernel_step_info != NULL)

	mov	eax, DWORD PTR [edi+80]
	test	eax, eax
	je	SHORT $LN2@kd_tile_co

; 3820 :     delete[] kernel_step_info; // Also deletes storage for flipped step info

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@kd_tile_co:

; 3821 :   if ((kernel_step_info_flipped != NULL) &&

	mov	eax, DWORD PTR [edi+84]
	test	eax, eax
	je	SHORT $LN3@kd_tile_co
	cmp	eax, DWORD PTR [edi+80]
	je	SHORT $LN3@kd_tile_co

; 3822 :       (kernel_step_info_flipped != kernel_step_info))
; 3823 :     delete[] kernel_step_info_flipped;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@kd_tile_co:

; 3824 :   if (kernel_coefficients != NULL)

	mov	eax, DWORD PTR [edi+88]
	test	eax, eax
	je	SHORT $LN4@kd_tile_co

; 3825 :     delete[] kernel_coefficients; // Also deletes storage for flipped coeffs

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN4@kd_tile_co:

; 3826 :   if ((kernel_coefficients_flipped != NULL) &&

	mov	eax, DWORD PTR [edi+92]
	test	eax, eax
	je	SHORT $LN5@kd_tile_co
	cmp	eax, DWORD PTR [edi+88]
	je	SHORT $LN5@kd_tile_co

; 3827 :       (kernel_coefficients_flipped != kernel_coefficients))
; 3828 :     delete[] kernel_coefficients_flipped;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@kd_tile_co:

; 3829 :   if (resolutions != NULL)

	mov	eax, DWORD PTR [edi+144]
	test	eax, eax
	je	SHORT $LN14@kd_tile_co
	push	OFFSET ??1kd_resolution@@QAE@XZ		; kd_resolution::~kd_resolution
	push	DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	604					; 0000025cH
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	imul	eax, DWORD PTR [esi], 604
	add	eax, 4
	push	eax
	push	esi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN14@kd_tile_co:

; 3830 :     delete[] resolutions;
; 3831 :   if (layer_stats != NULL)

	mov	eax, DWORD PTR [edi+148]
	test	eax, eax
	je	SHORT $LN7@kd_tile_co

; 3832 :     delete[] layer_stats;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@kd_tile_co:

; 3833 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1kd_tile_comp@@QAE@XZ$0:
	call	___std_terminate
	ret	0
__ehhandler$??1kd_tile_comp@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_tile_comp@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_tile_comp@@QAE@XZ ENDP				; kd_tile_comp::~kd_tile_comp
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_tile_comp@@QAE@XZ
_TEXT	SEGMENT
??0kd_tile_comp@@QAE@XZ PROC				; kd_tile_comp::kd_tile_comp, COMDAT
; _this$ = ecx

; 2943 :     kd_tile_comp()

	push	esi
	mov	esi, ecx

; 2945 :         memset(this,0,sizeof(*this));

	push	188					; 000000bcH
	push	0
	push	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+20], 0
	mov	DWORD PTR [esi+24], 0
	mov	DWORD PTR [esi+28], 0
	mov	DWORD PTR [esi+32], 0
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+40], 0
	mov	DWORD PTR [esi+44], 0
	mov	DWORD PTR [esi+48], 0
	mov	DWORD PTR [esi+52], 0
	mov	DWORD PTR [esi+132], 0
	mov	DWORD PTR [esi+136], 0
	mov	DWORD PTR [esi+156], 0
	mov	DWORD PTR [esi+160], 0
	mov	DWORD PTR [esi+164], 0
	mov	DWORD PTR [esi+168], 0
	mov	DWORD PTR [esi+172], 0
	mov	DWORD PTR [esi+176], 0
	mov	DWORD PTR [esi+180], 0
	mov	DWORD PTR [esi+184], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2945 :         memset(this,0,sizeof(*this));

	call	_memset
	add	esp, 12					; 0000000cH

; 2946 :         G_tc = G_tc_restricted = -1.0F;

	mov	DWORD PTR [esi+124], -1082130432	; bf800000H
	mov	DWORD PTR [esi+120], -1082130432	; bf800000H

; 2947 :       }

	mov	eax, esi
	pop	esi
	ret	0
??0kd_tile_comp@@QAE@XZ ENDP				; kd_tile_comp::kd_tile_comp
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_tile@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_tile@@QAEPAXI@Z PROC				; kd_tile::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_tile@@QAE@XZ			; kd_tile::~kd_tile
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	272					; 00000110H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_tile@@QAEPAXI@Z ENDP				; kd_tile::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?find_multicomponent_energy_gain@kd_tile@@AAEMH_N@Z
_TEXT	SEGMENT
_range_min_in$1$ = -72					; size = 4
_range_max_out$1 = -68					; size = 4
_range_min_out$2 = -64					; size = 4
tv892 = -60						; size = 4
_input_weight$1$ = -56					; size = 4
_result$2$ = -52					; size = 8
_result$ = -52						; size = 8
_this$GSCopy$1$ = -44					; size = 4
_block_idx$1$ = -40					; size = 4
tv909 = -36						; size = 4
_range_max_in$1$ = -36					; size = 4
_stage$1$ = -32						; size = 4
_rgb_gains$3 = -28					; size = 24
__$ArrayPad$ = -4					; size = 4
_comp_idx$ = 8						; size = 4
_restrict_to_interest$ = 12				; size = 1
?find_multicomponent_energy_gain@kd_tile@@AAEMH_N@Z PROC ; kd_tile::find_multicomponent_energy_gain, COMDAT
; _this$ = ecx

; 2677 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	mov	edx, ecx
	xorps	xmm5, xmm5

; 2678 :   int n;
; 2679 :   double result = 0.0;
; 2680 : 
; 2681 :   if (restrict_to_interest)
; 2682 :     assert(codestream->component_access_mode == KDU_WANT_OUTPUT_COMPONENTS);
; 2683 :           // Otherwise, it makes no sense to be trying to compute the
; 2684 :           // impact of multi-component transforms
; 2685 : 
; 2686 :   if (mct_head != NULL)
; 2687 :     {
; 2688 :       kd_mct_stage *stage;
; 2689 :       int range_min_in=comp_idx,  range_max_in=comp_idx;

	mov	ecx, DWORD PTR _comp_idx$[ebp]
	push	ebx
	push	esi
	mov	eax, DWORD PTR [edx+200]
	mov	DWORD PTR _this$GSCopy$1$[ebp], edx
	movsd	QWORD PTR _result$2$[ebp], xmm5
	mov	DWORD PTR _stage$1$[ebp], eax
	push	edi
	mov	edi, 1
	test	eax, eax
	je	$LN18@find_multi

; 2690 :       float input_weight = 1.0F;

	movss	xmm0, DWORD PTR __real@3f800000

; 2691 :       for (stage=mct_head; stage != NULL; stage=stage->next_stage)

	mov	ebx, DWORD PTR _restrict_to_interest$[ebp]
	mov	DWORD PTR _range_min_in$1$[ebp], ecx
	mov	DWORD PTR _range_max_in$1$[ebp], ecx
	movss	DWORD PTR _input_weight$1$[ebp], xmm0
	npad	1
$LL4@find_multi:

; 2692 :         {
; 2693 :           int block_idx;
; 2694 :           int range_min_out=0,  range_max_out=-1; // Empty range to start

	xor	ecx, ecx
	or	edx, -1
	mov	DWORD PTR _range_min_out$2[ebp], ecx
	mov	DWORD PTR _range_max_out$1[ebp], edx

; 2695 :           for (block_idx=0; block_idx < stage->num_blocks; block_idx++)

	mov	DWORD PTR _block_idx$1$[ebp], ecx
	cmp	DWORD PTR [eax+24], ecx
	jle	$LN6@find_multi

; 2692 :         {
; 2693 :           int block_idx;
; 2694 :           int range_min_out=0,  range_max_out=-1; // Empty range to start

	mov	ecx, DWORD PTR _stage$1$[ebp]
	xor	eax, eax
	mov	DWORD PTR tv892[ebp], eax
	mov	edx, eax
$LL7@find_multi:

; 2696 :             {
; 2697 :               kd_mct_block *block = stage->blocks + block_idx;

	mov	edi, DWORD PTR [ecx+28]
	add	edi, eax

; 2698 :               if (restrict_to_interest && (block->num_apparent_outputs == 0))

	test	bl, bl
	je	SHORT $LN20@find_multi
	cmp	DWORD PTR [edi+24], 0
	je	SHORT $LN5@find_multi
$LN20@find_multi:

; 2699 :                 continue;
; 2700 :               for (n=0; n < block->num_inputs; n++)

	xor	esi, esi
	cmp	DWORD PTR [edi+4], esi
	jle	SHORT $LN5@find_multi
$LL10@find_multi:

; 2701 :                 {
; 2702 :                   if (restrict_to_interest && !block->inputs_required[n])

	test	bl, bl
	je	SHORT $LN21@find_multi
	mov	eax, DWORD PTR [edi+16]
	cmp	BYTE PTR [esi+eax], 0
	je	SHORT $LN8@find_multi
$LN21@find_multi:

; 2703 :                     continue;
; 2704 :                   int idx = block->input_indices[n];

	mov	eax, DWORD PTR [edi+12]
	mov	eax, DWORD PTR [eax+esi*4]

; 2705 :                   if ((idx >= range_min_in) && (idx <= range_max_in))

	cmp	eax, DWORD PTR _range_min_in$1$[ebp]
	jl	SHORT $LN8@find_multi
	cmp	eax, DWORD PTR _range_max_in$1$[ebp]
	jg	SHORT $LN8@find_multi

; 2706 :                     {
; 2707 :                       if (stage->prev_stage != NULL)

	mov	edx, DWORD PTR [ecx+32]
	test	edx, edx
	je	SHORT $LN23@find_multi

; 2708 :                         input_weight =

	lea	ecx, DWORD PTR [eax+eax*4]
	mov	eax, DWORD PTR [edx+20]
	movss	xmm0, DWORD PTR [eax+ecx*8+36]
	movss	DWORD PTR _input_weight$1$[ebp], xmm0
$LN23@find_multi:

; 2709 :                           stage->prev_stage->output_comp_info[idx].ss_tmp;
; 2710 :                       block->analyze_sensitivity(n,input_weight,

	push	ebx
	lea	eax, DWORD PTR _range_max_out$1[ebp]
	push	eax
	lea	eax, DWORD PTR _range_min_out$2[ebp]
	push	eax
	push	ecx
	movss	DWORD PTR [esp], xmm0
	mov	ecx, edi
	push	esi
	call	?analyze_sensitivity@kd_mct_block@@QAEXHMAAH0_N@Z ; kd_mct_block::analyze_sensitivity
	movss	xmm0, DWORD PTR _input_weight$1$[ebp]
	mov	ecx, DWORD PTR _stage$1$[ebp]
$LN8@find_multi:

; 2699 :                 continue;
; 2700 :               for (n=0; n < block->num_inputs; n++)

	inc	esi
	cmp	esi, DWORD PTR [edi+4]
	jl	SHORT $LL10@find_multi
	mov	eax, DWORD PTR tv892[ebp]
	mov	edx, DWORD PTR _block_idx$1$[ebp]
$LN5@find_multi:

; 2695 :           for (block_idx=0; block_idx < stage->num_blocks; block_idx++)

	inc	edx
	add	eax, 108				; 0000006cH
	mov	DWORD PTR _block_idx$1$[ebp], edx
	mov	DWORD PTR tv892[ebp], eax
	cmp	edx, DWORD PTR [ecx+24]
	jl	$LL7@find_multi
	mov	ecx, DWORD PTR _range_min_out$2[ebp]
	mov	edx, DWORD PTR _range_max_out$1[ebp]
	mov	eax, DWORD PTR _stage$1$[ebp]
$LN6@find_multi:

; 2711 :                                                  range_min_out,range_max_out,
; 2712 :                                                  restrict_to_interest);
; 2713 :                     }
; 2714 :                 }
; 2715 :             }
; 2716 : 
; 2717 :           range_min_in = range_min_out;

	mov	eax, DWORD PTR [eax+36]
	mov	DWORD PTR _range_min_in$1$[ebp], ecx

; 2718 :           range_max_in = range_max_out;

	mov	DWORD PTR _range_max_in$1$[ebp], edx
	mov	DWORD PTR _stage$1$[ebp], eax
	test	eax, eax
	jne	$LL4@find_multi

; 2719 :         }
; 2720 :       for (n=range_min_in; n <= range_max_in; n++)

	cmp	ecx, edx
	jg	$LN81@find_multi

; 2721 :         {
; 2722 :           kd_output_comp_info *oci = mct_tail->output_comp_info + n;

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	lea	esi, DWORD PTR [ecx+ecx*4]
	sub	edx, ecx
	shl	esi, 3
	inc	edx
	mov	eax, DWORD PTR [eax+204]
	mov	edi, DWORD PTR [eax+20]
$LL55@find_multi:

; 2723 :           if (oci->is_of_interest || !restrict_to_interest)

	cmp	BYTE PTR [esi+edi+32], 0
	jne	SHORT $LN56@find_multi
	test	bl, bl
	jne	SHORT $LN84@find_multi
$LN56@find_multi:

; 2724 :             {
; 2725 :               double val = oci->ss_tmp / (float)(1<<oci->precision);

	mov	ecx, DWORD PTR [esi+edi]
	mov	eax, 1
	movss	xmm1, DWORD PTR [esi+edi+36]
	shl	eax, cl

; 2726 :               result += val*val;

	movsd	xmm5, QWORD PTR _result$2$[ebp]
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	cvtps2pd xmm0, xmm1
	mulsd	xmm0, xmm0
	addsd	xmm5, xmm0
	movsd	QWORD PTR _result$2$[ebp], xmm5
	jmp	SHORT $LN57@find_multi
$LN84@find_multi:
	movsd	xmm5, QWORD PTR _result$2$[ebp]
$LN57@find_multi:

; 2719 :         }
; 2720 :       for (n=range_min_in; n <= range_max_in; n++)

	add	esi, 40					; 00000028H
	sub	edx, 1
	jne	SHORT $LL55@find_multi

; 2727 :             }
; 2728 :         }
; 2729 :     }
; 2730 :   else if (use_ycc && (comp_idx < 3) && (num_components >= 3))

	jmp	$LN86@find_multi
$LN18@find_multi:
	cmp	BYTE PTR [edx+226], 0
	je	$LN26@find_multi
	cmp	ecx, 3
	jge	$LN26@find_multi
	cmp	DWORD PTR [edx+128], 3
	jl	$LN26@find_multi

; 2731 :     { // Calculate energy gain for the Part-1 RCT or ICT transform
; 2732 :       double rgb_gains[3]; // Squared energy contributions
; 2733 :       if (comps[comp_idx].reversible)

	mov	esi, DWORD PTR [edx+208]
	movsd	xmm4, QWORD PTR __real@3ff0000000000000
	imul	eax, ecx, 188
	cmp	BYTE PTR [eax+esi+64], 0
	je	SHORT $LN28@find_multi

; 2734 :         { // All components must be reversible: consider YDbDr to RGB transform
; 2735 :           if (comp_idx == 0)

	test	ecx, ecx
	jne	SHORT $LN30@find_multi

; 2736 :             rgb_gains[0] = rgb_gains[1] = rgb_gains[2] = 1.0;

	movaps	xmm2, xmm4
	movaps	xmm3, xmm4
	movaps	xmm5, xmm4
	jmp	SHORT $LN37@find_multi
$LN30@find_multi:

; 2737 :           else if (comp_idx == 1)

	cmp	ecx, 1
	jne	SHORT $LN32@find_multi

; 2738 :             { // Db component contributes 0.75 to B, 0.25 to R, G
; 2739 :               rgb_gains[0] = rgb_gains[1] = 0.25*0.25;

	movsd	xmm3, QWORD PTR __real@3fb0000000000000

; 2740 :               rgb_gains[2] = 0.75*0.75;

	movsd	xmm2, QWORD PTR __real@3fe2000000000000
	movaps	xmm5, xmm3

; 2741 :             }
; 2742 :           else

	jmp	SHORT $LN37@find_multi
$LN32@find_multi:

; 2743 :             { // Dr component contributes 0.75 to R, 0.25 to G, B
; 2744 :               rgb_gains[0] = 0.75*0.75;
; 2745 :               rgb_gains[1] = rgb_gains[2] = 0.25*0.25;

	movsd	xmm2, QWORD PTR __real@3fb0000000000000
	movsd	xmm5, QWORD PTR __real@3fe2000000000000
	movaps	xmm3, xmm2

; 2746 :             }
; 2747 :         }
; 2748 :       else

	jmp	SHORT $LN37@find_multi
$LN28@find_multi:

; 2749 :         { // All components irreversible: consider YCbCr to RGB transform
; 2750 :           double alpha_R=0.299, alpha_G=0.587, alpha_B=0.114;
; 2751 :           if (comp_idx == 0)

	test	ecx, ecx
	jne	SHORT $LN34@find_multi

; 2752 :             rgb_gains[0] = rgb_gains[1] = rgb_gains[2] = 1.0;

	movaps	xmm2, xmm4
	movaps	xmm3, xmm4
	movaps	xmm5, xmm4
	jmp	SHORT $LN37@find_multi
$LN34@find_multi:

; 2753 :           else if (comp_idx == 1)

	cmp	ecx, 1
	jne	SHORT $LN36@find_multi

; 2754 :             { double f1 = 2.0*(1-alpha_B);
; 2755 :               double f2 = 2.0*alpha_B*(1-alpha_B)/alpha_G;
; 2756 :               rgb_gains[0] = 0.0;  rgb_gains[1] = f2*f2;  rgb_gains[2] = f1*f1;

	movaps	xmm0, XMMWORD PTR __xmm@3fbe516a0eeb824c0000000000000000
	movsd	xmm2, QWORD PTR __real@40091eafee6fb4c4

; 2757 :             }
; 2758 :           else

	jmp	SHORT $LN87@find_multi
$LN36@find_multi:
	movaps	xmm0, XMMWORD PTR __xmm@3fe051d7e177e3e53fff731d2e0e3046

; 2759 :             { double f1 = 2.0*(1-alpha_R);
; 2760 :               double f2 = 2.0*alpha_R*(1-alpha_R)/alpha_G;
; 2761 :               rgb_gains[0] = f1*f1;  rgb_gains[1] = f2*f2;  rgb_gains[2] = 0.0;

	movaps	xmm2, xmm5
$LN87@find_multi:
	movups	XMMWORD PTR _rgb_gains$3[ebp], xmm0
	movsd	xmm5, QWORD PTR _rgb_gains$3[ebp]
	movsd	xmm3, QWORD PTR _rgb_gains$3[ebp+8]
$LN37@find_multi:

; 2762 :             }
; 2763 :         }
; 2764 :       for (n=0; n < 3; n++)
; 2765 :         {
; 2766 :           int apparent_idx;
; 2767 :           kd_output_comp_info *oci = codestream->output_comp_info + n;

	mov	eax, DWORD PTR [edx]

; 2768 :           if (restrict_to_interest &&

	mov	ebx, DWORD PTR _restrict_to_interest$[ebp]
	mov	edx, DWORD PTR [eax+260]
	test	bl, bl
	je	SHORT $LN38@find_multi
	mov	eax, DWORD PTR [edx+12]
	test	eax, eax
	js	SHORT $LN83@find_multi
	imul	eax, eax, 188
	cmp	BYTE PTR [eax+esi+153], 0
	je	SHORT $LN83@find_multi
$LN38@find_multi:

; 2769 :               (((apparent_idx = oci->apparent_idx) < 0) ||
; 2770 :                !comps[apparent_idx].is_of_interest))
; 2771 :             continue;
; 2772 :           double scale = 1.0 / (float)(1<<oci->precision);

	mov	ecx, DWORD PTR [edx]
	mov	eax, edi
	shl	eax, cl
	movaps	xmm1, xmm4
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	cvtps2pd xmm0, xmm0
	divsd	xmm1, xmm0

; 2773 :           result += rgb_gains[n] * scale*scale;

	mulsd	xmm5, xmm1
	mulsd	xmm5, xmm1
	addsd	xmm5, QWORD PTR __real@0000000000000000
	jmp	SHORT $LN14@find_multi
$LN83@find_multi:
	xorps	xmm5, xmm5
$LN14@find_multi:

; 2768 :           if (restrict_to_interest &&

	test	bl, bl
	je	SHORT $LN71@find_multi
	mov	eax, DWORD PTR [edx+52]
	test	eax, eax
	js	SHORT $LN72@find_multi
	imul	eax, eax, 188
	cmp	BYTE PTR [eax+esi+153], 0
	je	SHORT $LN72@find_multi
$LN71@find_multi:

; 2769 :               (((apparent_idx = oci->apparent_idx) < 0) ||
; 2770 :                !comps[apparent_idx].is_of_interest))
; 2771 :             continue;
; 2772 :           double scale = 1.0 / (float)(1<<oci->precision);

	mov	ecx, DWORD PTR [edx+40]
	mov	eax, edi
	shl	eax, cl
	movaps	xmm1, xmm4
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	cvtps2pd xmm0, xmm0
	divsd	xmm1, xmm0

; 2773 :           result += rgb_gains[n] * scale*scale;

	mulsd	xmm3, xmm1
	mulsd	xmm3, xmm1
	addsd	xmm5, xmm3
$LN72@find_multi:

; 2768 :           if (restrict_to_interest &&

	test	bl, bl
	je	SHORT $LN75@find_multi
	mov	eax, DWORD PTR [edx+92]
	test	eax, eax
	js	$LN41@find_multi
	imul	eax, eax, 188
	cmp	BYTE PTR [eax+esi+153], 0
	je	$LN41@find_multi
$LN75@find_multi:

; 2769 :               (((apparent_idx = oci->apparent_idx) < 0) ||
; 2770 :                !comps[apparent_idx].is_of_interest))
; 2771 :             continue;
; 2772 :           double scale = 1.0 / (float)(1<<oci->precision);

	mov	ecx, DWORD PTR [edx+80]
	mov	eax, edi
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	cvtps2pd xmm0, xmm0
	divsd	xmm4, xmm0

; 2773 :           result += rgb_gains[n] * scale*scale;

	mulsd	xmm2, xmm4
	mulsd	xmm2, xmm4
	addsd	xmm5, xmm2

; 2774 :         }
; 2775 :     }
; 2776 :   else

	jmp	SHORT $LN41@find_multi
$LN26@find_multi:

; 2777 :     { // Component is just passed straight through
; 2778 :       int apparent_idx;
; 2779 :       kd_output_comp_info *oci = codestream->output_comp_info + comp_idx;
; 2780 :       if (restrict_to_interest &&

	cmp	BYTE PTR _restrict_to_interest$[ebp], 0
	mov	eax, DWORD PTR [edx]
	lea	edx, DWORD PTR [ecx+ecx*4]
	mov	esi, DWORD PTR [eax+260]
	je	SHORT $LN40@find_multi
	mov	eax, DWORD PTR [esi+edx*8+12]
	test	eax, eax
	js	SHORT $LN41@find_multi
	imul	ecx, eax, 188
	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax+208]
	cmp	BYTE PTR [eax+ecx+153], 0
	je	SHORT $LN41@find_multi
$LN40@find_multi:

; 2781 :           (((apparent_idx = oci->apparent_idx) < 0) ||
; 2782 :            !comps[apparent_idx].is_of_interest))
; 2783 :         result = 0.0; // This really should not happen, since we would not be
; 2784 :                       // asking for the component's energy gain factor if it
; 2785 :                       // was not of interest.
; 2786 :       else
; 2787 :         {
; 2788 :           result = 1.0 / (float)(1<<oci->precision);

	mov	ecx, DWORD PTR [esi+edx*8]
	mov	eax, edi
	movsd	xmm5, QWORD PTR __real@3ff0000000000000
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	cvtps2pd xmm0, xmm0
	divsd	xmm5, xmm0

; 2789 :           result *= result;

	mulsd	xmm5, xmm5
	jmp	SHORT $LN41@find_multi
$LN81@find_multi:
	xorps	xmm5, xmm5
$LN86@find_multi:
	mov	edi, 1
$LN41@find_multi:

; 2790 :         }
; 2791 :     }
; 2792 : 
; 2793 :   double comp_range = (double)(1<<codestream->comp_info[comp_idx].precision);

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]

; 2794 :   result *= comp_range*comp_range;
; 2795 : 
; 2796 :   if (result < 0.0001)

	movsd	xmm1, QWORD PTR __real@3f1a36e2eb1c432d
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _comp_idx$[ebp]
	mov	ecx, DWORD PTR [ecx+256]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 5
	mov	ecx, DWORD PTR [ecx+eax+16]
	shl	edi, cl
	movd	xmm0, edi
	cvtdq2pd xmm0, xmm0
	pop	edi
	pop	esi
	pop	ebx
	mulsd	xmm0, xmm0
	mulsd	xmm0, xmm5
	comisd	xmm1, xmm0
	movsd	QWORD PTR _result$[ebp], xmm0
	jbe	SHORT $LN43@find_multi

; 2797 :     result = 0.0001; // Avoid excessively small weights, which could cause

	movsd	QWORD PTR _result$[ebp], xmm1
$LN43@find_multi:

; 2798 :                      // numerical problems in certain parts of the system; we
; 2799 :                      // really should not be asking for the energy gain of
; 2800 :                      // components which have no impact on the outputs of
; 2801 :                      // interest anyway -- during decompression this means that
; 2802 :                      // the algorithm which tells the application what
; 2803 :                      // codestream components are required has failed to do its
; 2804 :                      // job properly; during compression, this means that we
; 2805 :                      // have no path from available image data to this
; 2806 :                      // codestream component, which can be used to deduce its
; 2807 :                      // values.
; 2808 :   return (float) result;

	fld	QWORD PTR _result$[ebp]

; 2809 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	fstp	DWORD PTR tv909[ebp]
	fld	DWORD PTR tv909[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
?find_multicomponent_energy_gain@kd_tile@@AAEMH_N@Z ENDP ; kd_tile::find_multicomponent_energy_gain
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?add_to_unloadable_list@kd_tile@@AAEXXZ
_TEXT	SEGMENT
?add_to_unloadable_list@kd_tile@@AAEXXZ PROC		; kd_tile::add_to_unloadable_list, COMDAT
; _this$ = ecx

; 1967 : {

	push	esi
	mov	esi, ecx
	push	edi

; 1968 :   assert(!is_unloadable);
; 1969 :   unloadable_prev = codestream->unloadable_tiles_tail;

	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [ecx+396]
	mov	DWORD PTR [esi+36], eax

; 1970 :   unloadable_next = NULL;

	mov	DWORD PTR [esi+32], 0

; 1971 :   if (unloadable_prev == NULL)

	test	eax, eax
	jne	SHORT $LN2@add_to_unl

; 1972 :     {
; 1973 :       assert(codestream->unloadable_tiles_head == NULL);
; 1974 :       codestream->unloadable_tiles_head = this;

	mov	DWORD PTR [ecx+392], esi

; 1975 :     }
; 1976 :   else

	jmp	SHORT $LN3@add_to_unl
$LN2@add_to_unl:

; 1977 :     unloadable_prev->unloadable_next = this;

	mov	DWORD PTR [eax+32], esi
$LN3@add_to_unl:

; 1978 :   codestream->unloadable_tiles_tail = this;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [eax+396], esi

; 1979 :   codestream->num_unloadable_tiles++;

	mov	eax, DWORD PTR [esi]
	inc	DWORD PTR [eax+404]

; 1980 :   is_unloadable = true;
; 1981 :   if ((codestream->unloadable_tile_scan == NULL) &&

	mov	edi, DWORD PTR [esi]
	mov	BYTE PTR [esi+230], 1
	cmp	DWORD PTR [edi+400], 0
	jne	SHORT $LN4@add_to_unl
	lea	eax, DWORD PTR [edi+208]
	push	eax
	lea	ecx, DWORD PTR [esi+160]
	call	?intersects@kdu_dims@@QAE_NAAU1@@Z	; kdu_dims::intersects
	test	al, al
	jne	SHORT $LN4@add_to_unl

; 1982 :       !dims.intersects(codestream->region))
; 1983 :     codestream->unloadable_tile_scan = this;

	mov	DWORD PTR [edi+400], esi
$LN4@add_to_unl:
	pop	edi
	pop	esi

; 1984 : }

	ret	0
?add_to_unloadable_list@kd_tile@@AAEXXZ ENDP		; kd_tile::add_to_unloadable_list
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?withdraw_from_unloadable_list@kd_tile@@AAEXXZ
_TEXT	SEGMENT
?withdraw_from_unloadable_list@kd_tile@@AAEXXZ PROC	; kd_tile::withdraw_from_unloadable_list, COMDAT
; _this$ = ecx

; 1936 : {

	push	esi
	mov	esi, ecx

; 1937 :   assert(is_unloadable);
; 1938 :   if (unloadable_prev == NULL)

	mov	ecx, DWORD PTR [esi+36]

; 1939 :     {
; 1940 :       assert(codestream->unloadable_tiles_head == this);
; 1941 :       codestream->unloadable_tiles_head = unloadable_next;

	mov	eax, DWORD PTR [esi+32]
	test	ecx, ecx
	jne	SHORT $LN2@withdraw_f
	mov	edx, DWORD PTR [esi]
	mov	DWORD PTR [edx+392], eax

; 1942 :     }
; 1943 :   else

	jmp	SHORT $LN3@withdraw_f
$LN2@withdraw_f:

; 1944 :     unloadable_prev->unloadable_next = unloadable_next;

	mov	DWORD PTR [ecx+32], eax
$LN3@withdraw_f:

; 1945 : 
; 1946 :   if (unloadable_next == NULL)

	mov	ecx, DWORD PTR [esi+32]

; 1947 :     {
; 1948 :       assert(codestream->unloadable_tiles_tail == this);
; 1949 :       codestream->unloadable_tiles_tail = unloadable_prev;

	mov	eax, DWORD PTR [esi+36]
	test	ecx, ecx
	jne	SHORT $LN4@withdraw_f
	mov	ecx, DWORD PTR [esi]
	mov	DWORD PTR [ecx+396], eax

; 1950 :     }
; 1951 :   else

	jmp	SHORT $LN5@withdraw_f
$LN4@withdraw_f:

; 1952 :     unloadable_next->unloadable_prev = unloadable_prev;

	mov	DWORD PTR [ecx+36], eax
$LN5@withdraw_f:

; 1953 :   if (codestream->unloadable_tile_scan == this)

	mov	ecx, DWORD PTR [esi]
	cmp	DWORD PTR [ecx+400], esi
	jne	SHORT $LN6@withdraw_f

; 1954 :     codestream->unloadable_tile_scan = unloadable_next;

	mov	eax, DWORD PTR [esi+32]
	mov	DWORD PTR [ecx+400], eax
$LN6@withdraw_f:

; 1955 :   unloadable_next = unloadable_prev = NULL;
; 1956 :   codestream->num_unloadable_tiles--;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [esi+36], 0
	mov	DWORD PTR [esi+32], 0
	dec	DWORD PTR [eax+404]

; 1957 :   assert(codestream->num_unloadable_tiles >= 0);
; 1958 :   is_unloadable = false;

	mov	BYTE PTR [esi+230], 0
	pop	esi

; 1959 : }

	ret	0
?withdraw_from_unloadable_list@kd_tile@@AAEXXZ ENDP	; kd_tile::withdraw_from_unloadable_list
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?set_elements_of_interest@kd_tile@@AAEXXZ
_TEXT	SEGMENT
$T1 = -160						; size = 16
$T2 = -144						; size = 16
$T3 = -128						; size = 16
$T4 = -112						; size = 16
$T5 = -96						; size = 16
$T6 = -96						; size = 16
$T7 = -80						; size = 16
$T8 = -80						; size = 16
_c$1$ = -64						; size = 4
tv2247 = -60						; size = 4
_r$1$ = -56						; size = 4
_res$1$ = -52						; size = 4
_high_support_min$1$ = -48				; size = 4
_low_support_min$1$ = -48				; size = 4
_high_support_max$1$ = -44				; size = 4
_b$2$ = -44						; size = 4
_low_support_max$1$ = -40				; size = 4
tv2249 = -40						; size = 4
_tc$1$ = -36						; size = 4
_high_support_max$1$ = -32				; size = 4
_b$1$ = -32						; size = 4
tv2304 = -32						; size = 4
_low_support_min$1$ = -28				; size = 4
_high_support_min$1$ = -28				; size = 4
tv2294 = -28						; size = 4
_this$1$ = -24						; size = 4
$T9 = -20						; size = 4
$T10 = -20						; size = 4
$T11 = -16						; size = 4
_low_support_max$1$ = -16				; size = 4
tv2284 = -16						; size = 4
tv2278 = -16						; size = 4
tv2250 = -16						; size = 4
_branch_y$1$ = -12					; size = 4
_branch_y$1$ = -12					; size = 4
_parse_only_relevant_packets$1$ = -5			; size = 1
$T12 = -4						; size = 4
$T13 = -4						; size = 4
_branch_x$1$ = -4					; size = 4
_branch_x$1$ = -4					; size = 4
_min$2$ = -4						; size = 4
?set_elements_of_interest@kd_tile@@AAEXXZ PROC		; kd_tile::set_elements_of_interest, COMDAT
; _this$ = ecx

; 1784 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 160				; 000000a0H
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi
	mov	DWORD PTR _this$1$[ebp], esi

; 1785 :   // Inherit appearance parameters from parent object
; 1786 :   if ((mct_head != NULL) && (codestream->out == NULL) &&

	cmp	DWORD PTR [esi+200], 0
	je	SHORT $LN20@set_elemen
	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+8], 0
	jne	SHORT $LN20@set_elemen
	cmp	DWORD PTR [eax+128], 0
	jne	SHORT $LN20@set_elemen

; 1787 :       (codestream->component_access_mode == KDU_WANT_OUTPUT_COMPONENTS))
; 1788 :     mct_tail->apply_output_restrictions(codestream->output_comp_info);

	mov	ecx, DWORD PTR [esi+204]
	push	0
	push	0
	push	DWORD PTR [eax+260]
	call	?apply_output_restrictions@kd_mct_stage@@QAEXPAUkd_output_comp_info@@HPBH@Z ; kd_mct_stage::apply_output_restrictions
$LN20@set_elemen:

; 1789 :   num_apparent_layers = codestream->max_apparent_layers;

	mov	edx, DWORD PTR [esi]

; 1790 :   if (num_apparent_layers > num_layers)

	mov	eax, DWORD PTR [esi+132]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 333  :       { kdu_dims result = *this; result &= rhs; return result; }

	movups	xmm0, XMMWORD PTR [esi+160]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1789 :   num_apparent_layers = codestream->max_apparent_layers;

	mov	ecx, DWORD PTR [edx+196]

; 1790 :   if (num_apparent_layers > num_layers)

	cmp	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 333  :       { kdu_dims result = *this; result &= rhs; return result; }

	movups	XMMWORD PTR $T8[ebp], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1790 :   if (num_apparent_layers > num_layers)

	cmovg	ecx, eax

; 1792 :   region = dims & codestream->region;

	lea	eax, DWORD PTR [edx+208]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 333  :       { kdu_dims result = *this; result &= rhs; return result; }

	push	eax
	lea	eax, DWORD PTR $T5[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1790 :   if (num_apparent_layers > num_layers)

	mov	DWORD PTR [esi+136], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 333  :       { kdu_dims result = *this; result &= rhs; return result; }

	push	eax
	lea	ecx, DWORD PTR $T8[ebp]
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1792 :   region = dims & codestream->region;

	movups	xmm0, XMMWORD PTR $T8[ebp]

; 1793 : 
; 1794 :   bool parse_only_relevant_packets =
; 1795 :     ((codestream->in != NULL) && !codestream->persistent);

	mov	eax, DWORD PTR [esi]
	movups	XMMWORD PTR [esi+176], xmm0
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN44@set_elemen
	cmp	BYTE PTR [eax+337], 0
	jne	SHORT $LN44@set_elemen

; 1796 :   if (parse_only_relevant_packets)
; 1797 :     {
; 1798 :       max_relevant_layers = num_apparent_layers;

	mov	eax, DWORD PTR [esi+136]
	mov	BYTE PTR _parse_only_relevant_packets$1$[ebp], 1
	mov	DWORD PTR [esi+140], eax

; 1799 :       max_relevant_packets = 0; // Accumulate relevant packets in code below

	mov	DWORD PTR [esi+152], 0
	mov	DWORD PTR [esi+156], 0
	jmp	SHORT $LN22@set_elemen
$LN44@set_elemen:

; 1793 : 
; 1794 :   bool parse_only_relevant_packets =
; 1795 :     ((codestream->in != NULL) && !codestream->persistent);

	mov	BYTE PTR _parse_only_relevant_packets$1$[ebp], 0
$LN22@set_elemen:

; 1800 :     }
; 1801 : 
; 1802 :   // Walk through the components
; 1803 :   int c;
; 1804 :   if (comps == NULL)

	cmp	DWORD PTR [esi+208], 0
	jne	SHORT $LN23@set_elemen

; 1805 :     { // This condition should never happen, unless somebody is trying to
; 1806 :       // continue using a codestream which has already generated a fatal error
; 1807 :       // through `kdu_error', which may have thrown a caught exception.
; 1808 :       // Nevertheless, we might as well at least mark the tile as empty so that
; 1809 :       // fatal crashes are less likely (at least here).
; 1810 :       num_components = 0;

	mov	DWORD PTR [esi+128], 0

; 1927 :     }
; 1928 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN23@set_elemen:

; 1811 :       return;
; 1812 :     }
; 1813 :   for (c=0; c < num_components; c++)

	xor	edx, edx
	mov	DWORD PTR _c$1$[ebp], edx
	cmp	DWORD PTR [esi+128], edx
	jle	$LN3@set_elemen
	npad	8
$LL4@set_elemen:

; 1814 :     {
; 1815 :       kd_tile_comp *tc = comps + c;

	imul	ebx, edx, 188
	add	ebx, DWORD PTR [esi+208]
	mov	DWORD PTR _tc$1$[ebp], ebx

; 1816 :       tc->is_of_interest = true;

	mov	BYTE PTR [ebx+153], 1

; 1817 :       tc->G_tc_restricted = -1.0F; // Need to regenerate this if needed

	mov	DWORD PTR [ebx+124], -1082130432	; bf800000H

; 1818 :       if (codestream->out != NULL)

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN24@set_elemen

; 1819 :         tc->enabled = true;

	mov	BYTE PTR [ebx+152], 1
	jmp	$LN31@set_elemen
$LN24@set_elemen:

; 1820 :       else if (codestream->component_access_mode ==

	cmp	DWORD PTR [eax+128], 1
	jne	SHORT $LN26@set_elemen

; 1821 :                KDU_WANT_CODESTREAM_COMPONENTS)
; 1822 :         tc->enabled = (codestream->comp_info[c].apparent_idx >= 0);

	mov	eax, DWORD PTR [eax+256]
	lea	ecx, DWORD PTR [edx+edx*2]
	shl	ecx, 5
	cmp	DWORD PTR [eax+ecx+88], 0
	setge	al

; 1823 :       else

	jmp	$LN47@set_elemen
$LN26@set_elemen:

; 1824 :         {
; 1825 :           if (mct_head != NULL)

	mov	ecx, DWORD PTR [esi+200]
	test	ecx, ecx
	je	SHORT $LN28@set_elemen

; 1826 :             tc->enabled = (mct_head->input_required_indices[c] >= 0);

	mov	eax, DWORD PTR [ecx+8]
	cmp	DWORD PTR [eax+edx*4], 0
	setge	al

; 1827 :           else

	jmp	SHORT $LN47@set_elemen
$LN28@set_elemen:

; 1828 :             { // In this case, output components are in one-to-one
; 1829 :               // correspondence with codestream components
; 1830 :               if (use_ycc && (c < 3))

	cmp	BYTE PTR [esi+226], 0
	je	SHORT $LN30@set_elemen
	cmp	edx, 3
	jge	SHORT $LN30@set_elemen

; 1831 :                 {
; 1832 :                   tc->enabled = false;

	mov	BYTE PTR [ebx+152], 0

; 1833 :                   for (int d=0; d < 3; d++)

	xor	edx, edx

; 1834 :                     if ((d < codestream->num_output_components) &&

	mov	esi, DWORD PTR [esi]
	xor	ecx, ecx
	mov	edi, DWORD PTR [esi+120]
$LL7@set_elemen:
	cmp	edx, edi
	jge	SHORT $LN5@set_elemen
	mov	eax, DWORD PTR [esi+260]
	cmp	DWORD PTR [ecx+eax+12], 0
	jge	SHORT $LN214@set_elemen
$LN5@set_elemen:

; 1833 :                   for (int d=0; d < 3; d++)

	add	ecx, 40					; 00000028H
	inc	edx
	cmp	ecx, 120				; 00000078H
	jl	SHORT $LL7@set_elemen

; 1835 :                         (codestream->output_comp_info[d].apparent_idx >= 0))
; 1836 :                       { tc->enabled = true; break; }
; 1837 :                 }
; 1838 :               else

	mov	esi, DWORD PTR _this$1$[ebp]
	jmp	SHORT $LN31@set_elemen
$LN214@set_elemen:
	mov	esi, DWORD PTR _this$1$[ebp]
	mov	BYTE PTR [ebx+152], 1
	jmp	SHORT $LN31@set_elemen
$LN30@set_elemen:

; 1839 :                 tc->enabled =

	cmp	edx, DWORD PTR [eax+120]
	jge	SHORT $LN46@set_elemen
	mov	eax, DWORD PTR [eax+260]
	lea	ecx, DWORD PTR [edx+edx*4]
	cmp	DWORD PTR [eax+ecx*8+12], 0
	jl	SHORT $LN46@set_elemen
	mov	eax, 1
	jmp	SHORT $LN47@set_elemen
$LN46@set_elemen:
	xor	eax, eax
$LN47@set_elemen:
	mov	BYTE PTR [ebx+152], al
$LN31@set_elemen:

; 1846 :       kdu_coords min, lim;
; 1847 : 
; 1848 :       min = region.pos; lim = min + region.size;

	mov	eax, DWORD PTR [esi+180]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	esi, DWORD PTR [esi+184]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1845 :       kdu_coords subs = tc->sub_sampling;

	mov	edi, DWORD PTR [ebx+20]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	esi, DWORD PTR [ecx+176]
	mov	ecx, DWORD PTR [ecx+188]
	add	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	eax, eax
	jg	SHORT $LN59@set_elemen

; 180  :     return -((-num)/den);

	cdq
	idiv	edi
	jmp	SHORT $LN240@set_elemen
$LN59@set_elemen:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	edi
	inc	eax
$LN240@set_elemen:
	mov	DWORD PTR _min$2$[ebp], eax

; 179  :   if (num <= 0)

	test	ecx, ecx
	jg	SHORT $LN63@set_elemen

; 180  :     return -((-num)/den);

	mov	eax, ecx
	cdq
	idiv	edi
	mov	ecx, eax
	jmp	SHORT $LN64@set_elemen
$LN63@set_elemen:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ecx-1]
	cdq
	idiv	edi
	lea	ecx, DWORD PTR [eax+1]
$LN64@set_elemen:

; 179  :   if (num <= 0)

	mov	edx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [edx+176]
	test	eax, eax
	jg	SHORT $LN67@set_elemen

; 180  :     return -((-num)/den);

	cdq
	idiv	DWORD PTR [ebx+16]
	mov	edi, eax
	jmp	SHORT $LN68@set_elemen
$LN67@set_elemen:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	DWORD PTR [ebx+16]
	lea	edi, DWORD PTR [eax+1]
$LN68@set_elemen:

; 179  :   if (num <= 0)

	test	esi, esi
	jg	SHORT $LN71@set_elemen

; 180  :     return -((-num)/den);

	mov	eax, esi
	cdq
	idiv	DWORD PTR [ebx+16]
	jmp	SHORT $LN72@set_elemen
$LN71@set_elemen:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [esi-1]
	cdq
	idiv	DWORD PTR [ebx+16]
	inc	eax
$LN72@set_elemen:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1851 :       tc->region.pos = min; tc->region.size = lim - min;

	mov	edx, DWORD PTR _min$2$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	eax, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1853 :       tc->apparent_dwt_levels = tc->dwt_levels - codestream->discard_levels;

	mov	esi, DWORD PTR _this$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ecx, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1851 :       tc->region.pos = min; tc->region.size = lim - min;

	mov	DWORD PTR [ebx+44], edx

; 1853 :       tc->apparent_dwt_levels = tc->dwt_levels - codestream->discard_levels;

	mov	edx, DWORD PTR [ebx+56]
	mov	DWORD PTR [ebx+52], ecx
	mov	ecx, edx
	mov	DWORD PTR [ebx+40], edi
	mov	DWORD PTR [ebx+48], eax
	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR _r$1$[ebp], edx
	sub	ecx, DWORD PTR [eax+188]
	mov	DWORD PTR [ebx+60], ecx

; 1854 :       if (tc->apparent_dwt_levels < 0)

	js	$LN2@set_elemen

; 1855 :         continue; // Any attempt to access resolution levels will generate an
; 1856 :                   // error, but it is not helpful to generate an error here.
; 1857 : 
; 1858 :       // Now work through the resolution levels.
; 1859 :       int r, b;
; 1860 :       for (r=tc->dwt_levels; r >= 0; r--)

	test	edx, edx
	js	$LN2@set_elemen
	imul	eax, edx, 604
	mov	DWORD PTR tv2247[ebp], eax
	npad	2
$LL10@set_elemen:

; 1861 :         {
; 1862 :           kd_resolution *res = tc->resolutions + r;

	mov	edi, DWORD PTR [ebx+144]
	add	edi, eax
	mov	DWORD PTR _res$1$[ebp], edi

; 1863 :           if (res->node.parent == NULL)

	mov	ecx, DWORD PTR [edi+16]
	test	ecx, ecx
	jne	SHORT $LN34@set_elemen

; 1864 :             res->node.region = tc->region;

	movups	xmm0, XMMWORD PTR [ebx+40]
	jmp	SHORT $LN241@set_elemen
$LN34@set_elemen:

; 1865 :           else if (r >= tc->apparent_dwt_levels)
; 1866 :             res->node.region =

	movzx	eax, BYTE PTR [edi+57]
	movups	xmm0, XMMWORD PTR [ecx+24]
	cmp	edx, DWORD PTR [ebx+60]
	jl	SHORT $LN36@set_elemen
	push	0
	push	0
	push	0
	push	0
	push	eax
	movzx	eax, BYTE PTR [edi+56]
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, esp
	movups	XMMWORD PTR [eax], xmm0
	lea	eax, DWORD PTR $T4[ebp]

; 1867 :               get_child_dims(res->node.parent->region,
; 1868 :                              res->node.branch_x,res->node.branch_y);
; 1869 :           else

	jmp	SHORT $LN242@set_elemen
$LN36@set_elemen:

; 1870 :             res->node.region =

	push	DWORD PTR [ebx+116]
	push	DWORD PTR [ebx+112]
	push	DWORD PTR [ebx+108]
	push	DWORD PTR [ebx+104]
	push	eax
	movzx	eax, BYTE PTR [edi+56]
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, esp
	movups	XMMWORD PTR [eax], xmm0
	lea	eax, DWORD PTR $T3[ebp]
$LN242@set_elemen:
	push	eax
	call	?get_child_dims@@YA?AUkdu_dims@@U1@HHHHHH@Z ; get_child_dims
	add	esp, 44					; 0000002cH
	movups	xmm0, XMMWORD PTR [eax]
$LN241@set_elemen:
	movups	XMMWORD PTR [edi+40], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	eax, DWORD PTR [edi+48]
	add	eax, DWORD PTR [edi+40]
	mov	esi, DWORD PTR [edi+52]
	add	esi, DWORD PTR [edi+44]
	mov	ecx, DWORD PTR [edi+24]
	add	ecx, DWORD PTR [edi+32]
	mov	DWORD PTR $T11[ebp], eax
	mov	eax, DWORD PTR [edi+36]
	add	eax, DWORD PTR [edi+28]

; 334  :       /* [SYNOPSIS]
; 335  :            Returns the intersection of the region represented by `rhs' with
; 336  :            that represented by the current object.
; 337  :       */
; 338  :     kdu_dims intersection(kdu_dims &rhs)
; 339  :       { /* [SYNOPSIS] Same as `operator&', but more appropriate for
; 340  :                       some language bindings. */
; 341  :         return (*this) & rhs;
; 342  :       }
; 343  :     kdu_dims operator&=(kdu_dims &rhs) // Returns intersection of operands
; 344  :       {
; 345  :       /* [SYNOPSIS]
; 346  :            Intersects the region represented by `rhs' with that  represented
; 347  :            by the current object.
; 348  :       */
; 349  :         kdu_coords lim = pos+size;
; 350  :         kdu_coords rhs_lim = rhs.pos + rhs.size;
; 351  :         if (lim.x > rhs_lim.x) lim.x = rhs_lim.x;

	cmp	esi, eax
	cmovg	esi, eax

; 352  :         if (lim.y > rhs_lim.y) lim.y  = rhs_lim.y;

	mov	eax, DWORD PTR $T11[ebp]
	cmp	eax, ecx
	cmovg	eax, ecx

; 353  :         if (pos.x < rhs.pos.x) pos.x = rhs.pos.x;

	mov	ecx, DWORD PTR [edi+28]
	cmp	DWORD PTR [edi+44], ecx
	jge	SHORT $LN81@set_elemen
	mov	DWORD PTR [edi+44], ecx
$LN81@set_elemen:

; 354  :         if (pos.y < rhs.pos.y) pos.y = rhs.pos.y;

	mov	ecx, DWORD PTR [edi+24]
	cmp	DWORD PTR [edi+40], ecx
	jge	SHORT $LN82@set_elemen
	mov	DWORD PTR [edi+40], ecx
$LN82@set_elemen:

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	esi, DWORD PTR [edi+44]
	sub	eax, DWORD PTR [edi+40]

; 355  :         size = lim-pos;

	mov	DWORD PTR [edi+48], eax
	mov	DWORD PTR [edi+52], esi

; 356  :         if (size.x < 0) size.x = 0;

	test	esi, esi
	jge	SHORT $LN83@set_elemen
	mov	DWORD PTR [edi+52], 0
$LN83@set_elemen:

; 357  :         if (size.y < 0) size.y = 0;

	test	eax, eax
	jge	SHORT $LN84@set_elemen
	mov	DWORD PTR [edi+48], 0
$LN84@set_elemen:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1878 :           if ((r > tc->apparent_dwt_levels) || !tc->enabled)

	mov	edx, DWORD PTR _r$1$[ebp]
	xor	ecx, ecx
	xor	eax, eax
	mov	DWORD PTR [edi+68], ecx
	mov	DWORD PTR [edi+72], eax
	mov	DWORD PTR [edi+60], ecx
	mov	DWORD PTR [edi+64], eax
	cmp	edx, DWORD PTR [ebx+60]
	jg	$LN39@set_elemen
	cmp	BYTE PTR [ebx+152], al
	je	$LN39@set_elemen

; 1884 :           for (b=0; b < (int) res->num_intermediate_nodes; b++)

	mov	DWORD PTR _b$1$[ebp], eax
	cmp	BYTE PTR [edi+175], al
	jbe	$LN12@set_elemen
	xor	edx, edx
	mov	DWORD PTR tv2250[ebp], edx
	npad	7
$LL13@set_elemen:

; 1885 :             {
; 1886 :               kd_node *node = res->intermediate_nodes + b;
; 1887 :               node->region =

	mov	eax, DWORD PTR [ebx+116]
	mov	esi, DWORD PTR [edi+176]
	mov	DWORD PTR _high_support_max$1$[ebp], eax
	add	esi, edx
	mov	eax, DWORD PTR [ebx+112]
	mov	DWORD PTR _high_support_min$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+108]
	mov	DWORD PTR _low_support_max$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+104]
	mov	DWORD PTR _low_support_min$1$[ebp], eax
	movzx	eax, BYTE PTR [esi+41]
	mov	DWORD PTR _branch_y$1$[ebp], eax
	movzx	eax, BYTE PTR [esi+40]
	mov	DWORD PTR _branch_x$1$[ebp], eax
	mov	eax, DWORD PTR [esi]
	movups	xmm1, XMMWORD PTR [eax+24]

; 122  :   kdu_coords min = parent_dims.pos;

	movaps	xmm0, xmm1
	movd	ecx, xmm1
	psrldq	xmm0, 4
	movd	ebx, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	psrldq	xmm1, 8
	movd	eax, xmm0
	movd	edx, xmm1
	add	eax, ebx
	add	edx, ecx
	mov	DWORD PTR $T10[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 125  :   if ((branch_x & ~1) == 0)

	test	DWORD PTR _branch_x$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN237@set_elemen

; 126  :     { // Parent node is split horizontally
; 127  :       min.x -= (branch_x)?high_support_max:low_support_max;

	mov	edi, DWORD PTR _branch_x$1$[ebp]
	test	edi, edi
	mov	eax, DWORD PTR _low_support_max$1$[ebp]
	cmovne	eax, DWORD PTR _high_support_max$1$[ebp]

; 128  :       lim.x -= (branch_x)?high_support_min:low_support_min;
; 129  :       min.x = (min.x + 1 - branch_x) >> 1;

	sub	ebx, eax
	mov	eax, DWORD PTR _low_support_min$1$[ebp]
	sub	ebx, edi
	inc	ebx
	sar	ebx, 1
	test	edi, edi
	cmovne	eax, DWORD PTR _high_support_min$1$[ebp]

; 130  :       lim.x = (lim.x + 1 - branch_x) >> 1;

	sub	DWORD PTR $T10[ebp], eax
	mov	eax, DWORD PTR $T10[ebp]
	sub	eax, edi
	mov	edi, DWORD PTR _res$1$[ebp]
	inc	eax
	sar	eax, 1
	jmp	SHORT $LN101@set_elemen
$LN237@set_elemen:
	mov	eax, DWORD PTR $T10[ebp]
$LN101@set_elemen:

; 131  :     }
; 132  : 
; 133  :   if ((branch_y & ~1) == 0)

	test	DWORD PTR _branch_y$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN102@set_elemen

; 134  :     { // Parent node is split vertically
; 135  :       min.y -= (branch_y)?high_support_max:low_support_max;

	cmp	DWORD PTR _branch_y$1$[ebp], 0
	mov	edi, DWORD PTR _low_support_max$1$[ebp]
	cmovne	edi, DWORD PTR _high_support_max$1$[ebp]

; 136  :       lim.y -= (branch_y)?high_support_min:low_support_min;
; 137  :       min.y = (min.y + 1 - branch_y) >> 1;

	sub	ecx, edi
	mov	edi, DWORD PTR _low_support_min$1$[ebp]
	sub	ecx, DWORD PTR _branch_y$1$[ebp]
	inc	ecx
	sar	ecx, 1
	cmp	DWORD PTR _branch_y$1$[ebp], 0
	cmovne	edi, DWORD PTR _high_support_min$1$[ebp]

; 138  :       lim.y = (lim.y + 1 - branch_y) >> 1;

	sub	edx, edi
	mov	edi, DWORD PTR _res$1$[ebp]
	sub	edx, DWORD PTR _branch_y$1$[ebp]
	inc	edx
	sar	edx, 1
$LN102@set_elemen:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	eax, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 142  :   result.pos = min;

	mov	DWORD PTR $T6[ebp+4], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	edx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 143  :   result.size = lim-min;

	mov	DWORD PTR $T6[ebp+12], eax
	mov	DWORD PTR $T6[ebp], ecx
	mov	DWORD PTR $T6[ebp+8], edx

; 1885 :             {
; 1886 :               kd_node *node = res->intermediate_nodes + b;
; 1887 :               node->region =

	movups	xmm0, XMMWORD PTR $T6[ebp]
	movups	XMMWORD PTR [esi+24], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	eax, DWORD PTR [esi+24]
	add	eax, DWORD PTR [esi+32]
	mov	ebx, DWORD PTR [esi+36]
	add	ebx, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+16]
	add	ecx, DWORD PTR [esi+8]
	mov	DWORD PTR $T13[ebp], eax
	mov	eax, DWORD PTR [esi+20]
	add	eax, DWORD PTR [esi+12]

; 334  :       /* [SYNOPSIS]
; 335  :            Returns the intersection of the region represented by `rhs' with
; 336  :            that represented by the current object.
; 337  :       */
; 338  :     kdu_dims intersection(kdu_dims &rhs)
; 339  :       { /* [SYNOPSIS] Same as `operator&', but more appropriate for
; 340  :                       some language bindings. */
; 341  :         return (*this) & rhs;
; 342  :       }
; 343  :     kdu_dims operator&=(kdu_dims &rhs) // Returns intersection of operands
; 344  :       {
; 345  :       /* [SYNOPSIS]
; 346  :            Intersects the region represented by `rhs' with that  represented
; 347  :            by the current object.
; 348  :       */
; 349  :         kdu_coords lim = pos+size;
; 350  :         kdu_coords rhs_lim = rhs.pos + rhs.size;
; 351  :         if (lim.x > rhs_lim.x) lim.x = rhs_lim.x;

	cmp	ebx, eax
	cmovg	ebx, eax

; 352  :         if (lim.y > rhs_lim.y) lim.y  = rhs_lim.y;

	mov	eax, DWORD PTR $T13[ebp]
	cmp	eax, ecx
	cmovg	eax, ecx
	mov	DWORD PTR $T13[ebp], eax

; 353  :         if (pos.x < rhs.pos.x) pos.x = rhs.pos.x;

	mov	eax, DWORD PTR [esi+12]
	cmp	DWORD PTR [esi+28], eax
	jge	SHORT $LN121@set_elemen
	mov	DWORD PTR [esi+28], eax
$LN121@set_elemen:

; 354  :         if (pos.y < rhs.pos.y) pos.y = rhs.pos.y;

	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [esi+24], eax
	jge	SHORT $LN122@set_elemen
	mov	DWORD PTR [esi+24], eax
$LN122@set_elemen:

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ebx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR $T13[ebp]
	sub	eax, DWORD PTR [esi+24]

; 355  :         size = lim-pos;

	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+36], ebx

; 356  :         if (size.x < 0) size.x = 0;

	test	ebx, ebx
	jge	SHORT $LN123@set_elemen
	mov	DWORD PTR [esi+36], 0
$LN123@set_elemen:

; 357  :         if (size.y < 0) size.y = 0;

	test	eax, eax
	jge	SHORT $LN124@set_elemen
	mov	DWORD PTR [esi+32], 0
$LN124@set_elemen:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1884 :           for (b=0; b < (int) res->num_intermediate_nodes; b++)

	mov	edx, DWORD PTR tv2250[ebp]

; 1888 :                 get_child_dims(node->parent->region,
; 1889 :                                node->branch_x,node->branch_y,
; 1890 :                                tc->low_support_min,tc->low_support_max,
; 1891 :                                tc->high_support_min,tc->high_support_max);
; 1892 :               node->region &= node->dims;
; 1893 :               node->region_cover.pos =

	xor	ecx, ecx
	mov	ebx, DWORD PTR _tc$1$[ebp]
	xor	eax, eax
	mov	DWORD PTR [esi+52], ecx
	add	edx, 104				; 00000068H
	mov	DWORD PTR [esi+44], ecx
	mov	ecx, DWORD PTR _b$1$[ebp]
	mov	DWORD PTR [esi+56], eax
	inc	ecx
	mov	DWORD PTR [esi+48], eax
	movzx	eax, BYTE PTR [edi+175]
	mov	DWORD PTR _b$1$[ebp], ecx
	mov	DWORD PTR tv2250[ebp], edx
	cmp	ecx, eax
	jl	$LL13@set_elemen
$LN12@set_elemen:

; 1894 :                 node->region_cover.size = kdu_coords(0,0);
; 1895 :             }
; 1896 :           for (b=0; b < (int) res->num_subbands; b++)

	cmp	BYTE PTR [edi+174], 0
	mov	DWORD PTR _b$2$[ebp], 0
	jbe	$LN15@set_elemen
	xor	edx, edx
	mov	DWORD PTR tv2249[ebp], edx
$LL16@set_elemen:

; 1897 :             {
; 1898 :               kd_subband *band = res->subbands + b;
; 1899 :               band->region =

	mov	eax, DWORD PTR [ebx+116]
	mov	esi, DWORD PTR [edi+184]
	mov	DWORD PTR _high_support_max$1$[ebp], eax
	add	esi, edx
	mov	eax, DWORD PTR [ebx+112]
	mov	DWORD PTR _high_support_min$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+108]
	mov	DWORD PTR _low_support_max$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+104]
	mov	DWORD PTR _low_support_min$1$[ebp], eax
	movzx	eax, BYTE PTR [esi+41]
	mov	DWORD PTR _branch_y$1$[ebp], eax
	movzx	eax, BYTE PTR [esi+40]
	mov	DWORD PTR _branch_x$1$[ebp], eax
	mov	eax, DWORD PTR [esi]
	movups	xmm1, XMMWORD PTR [eax+24]

; 122  :   kdu_coords min = parent_dims.pos;

	movaps	xmm0, xmm1
	movd	ecx, xmm1
	psrldq	xmm0, 4
	movd	ebx, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	psrldq	xmm1, 8
	movd	eax, xmm0
	movd	edx, xmm1
	add	eax, ebx
	add	edx, ecx
	mov	DWORD PTR $T9[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 125  :   if ((branch_x & ~1) == 0)

	test	DWORD PTR _branch_x$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN238@set_elemen

; 126  :     { // Parent node is split horizontally
; 127  :       min.x -= (branch_x)?high_support_max:low_support_max;

	mov	edi, DWORD PTR _branch_x$1$[ebp]
	test	edi, edi
	mov	eax, DWORD PTR _low_support_max$1$[ebp]
	cmovne	eax, DWORD PTR _high_support_max$1$[ebp]

; 128  :       lim.x -= (branch_x)?high_support_min:low_support_min;
; 129  :       min.x = (min.x + 1 - branch_x) >> 1;

	sub	ebx, eax
	mov	eax, DWORD PTR _low_support_min$1$[ebp]
	sub	ebx, edi
	inc	ebx
	sar	ebx, 1
	test	edi, edi
	cmovne	eax, DWORD PTR _high_support_min$1$[ebp]

; 130  :       lim.x = (lim.x + 1 - branch_x) >> 1;

	sub	DWORD PTR $T9[ebp], eax
	mov	eax, DWORD PTR $T9[ebp]
	sub	eax, edi
	mov	edi, DWORD PTR _res$1$[ebp]
	inc	eax
	sar	eax, 1
	jmp	SHORT $LN141@set_elemen
$LN238@set_elemen:
	mov	eax, DWORD PTR $T9[ebp]
$LN141@set_elemen:

; 131  :     }
; 132  : 
; 133  :   if ((branch_y & ~1) == 0)

	test	DWORD PTR _branch_y$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN142@set_elemen

; 134  :     { // Parent node is split vertically
; 135  :       min.y -= (branch_y)?high_support_max:low_support_max;

	cmp	DWORD PTR _branch_y$1$[ebp], 0
	mov	edi, DWORD PTR _low_support_max$1$[ebp]
	cmovne	edi, DWORD PTR _high_support_max$1$[ebp]

; 136  :       lim.y -= (branch_y)?high_support_min:low_support_min;
; 137  :       min.y = (min.y + 1 - branch_y) >> 1;

	sub	ecx, edi
	mov	edi, DWORD PTR _low_support_min$1$[ebp]
	sub	ecx, DWORD PTR _branch_y$1$[ebp]
	inc	ecx
	sar	ecx, 1
	cmp	DWORD PTR _branch_y$1$[ebp], 0
	cmovne	edi, DWORD PTR _high_support_min$1$[ebp]

; 138  :       lim.y = (lim.y + 1 - branch_y) >> 1;

	sub	edx, edi
	mov	edi, DWORD PTR _res$1$[ebp]
	sub	edx, DWORD PTR _branch_y$1$[ebp]
	inc	edx
	sar	edx, 1
$LN142@set_elemen:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	eax, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 142  :   result.pos = min;

	mov	DWORD PTR $T7[ebp+4], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	edx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 143  :   result.size = lim-min;

	mov	DWORD PTR $T7[ebp+12], eax
	mov	DWORD PTR $T7[ebp], ecx
	mov	DWORD PTR $T7[ebp+8], edx

; 1897 :             {
; 1898 :               kd_subband *band = res->subbands + b;
; 1899 :               band->region =

	movups	xmm0, XMMWORD PTR $T7[ebp]
	movups	XMMWORD PTR [esi+24], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	eax, DWORD PTR [esi+24]
	add	eax, DWORD PTR [esi+32]
	mov	ebx, DWORD PTR [esi+36]
	add	ebx, DWORD PTR [esi+28]
	mov	ecx, DWORD PTR [esi+8]
	add	ecx, DWORD PTR [esi+16]
	mov	DWORD PTR $T12[ebp], eax
	mov	eax, DWORD PTR [esi+20]
	add	eax, DWORD PTR [esi+12]

; 334  :       /* [SYNOPSIS]
; 335  :            Returns the intersection of the region represented by `rhs' with
; 336  :            that represented by the current object.
; 337  :       */
; 338  :     kdu_dims intersection(kdu_dims &rhs)
; 339  :       { /* [SYNOPSIS] Same as `operator&', but more appropriate for
; 340  :                       some language bindings. */
; 341  :         return (*this) & rhs;
; 342  :       }
; 343  :     kdu_dims operator&=(kdu_dims &rhs) // Returns intersection of operands
; 344  :       {
; 345  :       /* [SYNOPSIS]
; 346  :            Intersects the region represented by `rhs' with that  represented
; 347  :            by the current object.
; 348  :       */
; 349  :         kdu_coords lim = pos+size;
; 350  :         kdu_coords rhs_lim = rhs.pos + rhs.size;
; 351  :         if (lim.x > rhs_lim.x) lim.x = rhs_lim.x;

	cmp	ebx, eax
	cmovg	ebx, eax

; 352  :         if (lim.y > rhs_lim.y) lim.y  = rhs_lim.y;

	mov	eax, DWORD PTR $T12[ebp]
	cmp	eax, ecx
	cmovg	eax, ecx
	mov	DWORD PTR $T12[ebp], eax

; 353  :         if (pos.x < rhs.pos.x) pos.x = rhs.pos.x;

	mov	eax, DWORD PTR [esi+12]
	cmp	DWORD PTR [esi+28], eax
	jge	SHORT $LN161@set_elemen
	mov	DWORD PTR [esi+28], eax
$LN161@set_elemen:

; 354  :         if (pos.y < rhs.pos.y) pos.y = rhs.pos.y;

	mov	eax, DWORD PTR [esi+8]
	cmp	DWORD PTR [esi+24], eax
	jge	SHORT $LN162@set_elemen
	mov	DWORD PTR [esi+24], eax
$LN162@set_elemen:

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ebx, DWORD PTR [esi+28]
	mov	eax, DWORD PTR $T12[ebp]
	sub	eax, DWORD PTR [esi+24]

; 355  :         size = lim-pos;

	mov	DWORD PTR [esi+32], eax
	mov	DWORD PTR [esi+36], ebx

; 356  :         if (size.x < 0) size.x = 0;

	test	ebx, ebx
	jge	SHORT $LN163@set_elemen
	mov	DWORD PTR [esi+36], 0
$LN163@set_elemen:

; 357  :         if (size.y < 0) size.y = 0;

	test	eax, eax
	jge	SHORT $LN164@set_elemen
	mov	DWORD PTR [esi+32], 0
$LN164@set_elemen:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1905 :               band->region_indices =

	movups	xmm0, XMMWORD PTR [esi+24]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	sub	esp, 16					; 00000010H
	movups	XMMWORD PTR [eax], xmm0
	mov	eax, esp
	movups	xmm0, XMMWORD PTR [esi+68]
	movups	XMMWORD PTR [eax], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?get_partition_indices@@YA?AUkdu_dims@@U1@0@Z ; get_partition_indices
	add	esp, 36					; 00000024H
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [esi+100], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 385  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	cmp	DWORD PTR [esi+36], 0
	jle	SHORT $LN14@set_elemen
	cmp	DWORD PTR [esi+32], 0
	jle	SHORT $LN14@set_elemen
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1908 :                 band->parent->adjust_cover(band->region,

	movzx	eax, BYTE PTR [esi+41]
	movups	xmm0, XMMWORD PTR [esi+24]
	mov	ecx, DWORD PTR [esi]
	push	eax
	movzx	eax, BYTE PTR [esi+40]
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, esp
	movups	XMMWORD PTR [eax], xmm0
	call	?adjust_cover@kd_node@@QAEXUkdu_dims@@HH@Z ; kd_node::adjust_cover
$LN14@set_elemen:

; 1894 :                 node->region_cover.size = kdu_coords(0,0);
; 1895 :             }
; 1896 :           for (b=0; b < (int) res->num_subbands; b++)

	mov	ecx, DWORD PTR _b$2$[ebp]
	mov	edx, DWORD PTR tv2249[ebp]
	inc	ecx
	movzx	eax, BYTE PTR [edi+174]
	add	edx, 132				; 00000084H
	mov	ebx, DWORD PTR _tc$1$[ebp]
	mov	DWORD PTR _b$2$[ebp], ecx
	mov	DWORD PTR tv2249[ebp], edx
	cmp	ecx, eax
	jl	$LL16@set_elemen
$LN15@set_elemen:

; 1909 :                                            band->branch_x,band->branch_y);
; 1910 :             }
; 1911 :           for (b=((int) res->num_intermediate_nodes)-1; b >= 0; b--)

	movzx	esi, BYTE PTR [edi+175]
	sub	esi, 1
	js	SHORT $LN18@set_elemen
	imul	ebx, esi, 104
	npad	10
$LL19@set_elemen:

; 1912 :             {
; 1913 :               kd_node *node = res->intermediate_nodes + b;

	mov	ecx, DWORD PTR [edi+176]
	add	ecx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 385  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	cmp	DWORD PTR [ecx+36], 0
	jle	SHORT $LN17@set_elemen
	cmp	DWORD PTR [ecx+32], 0
	jle	SHORT $LN17@set_elemen
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1915 :                 node->parent->adjust_cover(node->region_cover,

	movzx	eax, BYTE PTR [ecx+41]
	movups	xmm0, XMMWORD PTR [ecx+44]
	push	eax
	movzx	eax, BYTE PTR [ecx+40]
	mov	ecx, DWORD PTR [ecx]
	push	eax
	sub	esp, 16					; 00000010H
	mov	eax, esp
	movups	XMMWORD PTR [eax], xmm0
	call	?adjust_cover@kd_node@@QAEXUkdu_dims@@HH@Z ; kd_node::adjust_cover
$LN17@set_elemen:

; 1909 :                                            band->branch_x,band->branch_y);
; 1910 :             }
; 1911 :           for (b=((int) res->num_intermediate_nodes)-1; b >= 0; b--)

	sub	ebx, 104				; 00000068H
	sub	esi, 1
	jns	SHORT $LL19@set_elemen
$LN18@set_elemen:

; 1916 :                                            node->branch_x,node->branch_y);
; 1917 :             }
; 1918 :           res->region_indices =

	movups	xmm0, XMMWORD PTR [edi+60]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	sub	esp, 16					; 00000010H
	movups	XMMWORD PTR [eax], xmm0
	mov	eax, esp
	movups	xmm0, XMMWORD PTR [edi+120]
	movups	XMMWORD PTR [eax], xmm0
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	?get_partition_indices@@YA?AUkdu_dims@@U1@0@Z ; get_partition_indices
	add	esp, 36					; 00000024H
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [edi+152], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	edx, DWORD PTR [edi+156]
	mov	esi, DWORD PTR [edi+164]
	mov	eax, DWORD PTR [edi+148]
	add	esi, edx
	add	eax, DWORD PTR [edi+140]
	mov	ebx, DWORD PTR [edi+152]
	add	ebx, DWORD PTR [edi+160]
	mov	ecx, DWORD PTR [edi+136]
	add	ecx, DWORD PTR [edi+144]

; 334  :       /* [SYNOPSIS]
; 335  :            Returns the intersection of the region represented by `rhs' with
; 336  :            that represented by the current object.
; 337  :       */
; 338  :     kdu_dims intersection(kdu_dims &rhs)
; 339  :       { /* [SYNOPSIS] Same as `operator&', but more appropriate for
; 340  :                       some language bindings. */
; 341  :         return (*this) & rhs;
; 342  :       }
; 343  :     kdu_dims operator&=(kdu_dims &rhs) // Returns intersection of operands
; 344  :       {
; 345  :       /* [SYNOPSIS]
; 346  :            Intersects the region represented by `rhs' with that  represented
; 347  :            by the current object.
; 348  :       */
; 349  :         kdu_coords lim = pos+size;
; 350  :         kdu_coords rhs_lim = rhs.pos + rhs.size;
; 351  :         if (lim.x > rhs_lim.x) lim.x = rhs_lim.x;

	cmp	esi, eax
	cmovg	esi, eax

; 353  :         if (pos.x < rhs.pos.x) pos.x = rhs.pos.x;

	mov	eax, DWORD PTR [edi+140]
	cmp	ebx, ecx
	cmovg	ebx, ecx
	cmp	edx, eax
	jge	SHORT $LN189@set_elemen
	mov	DWORD PTR [edi+156], eax
$LN189@set_elemen:

; 354  :         if (pos.y < rhs.pos.y) pos.y = rhs.pos.y;

	mov	eax, DWORD PTR [edi+136]
	cmp	DWORD PTR [edi+152], eax
	jge	SHORT $LN190@set_elemen
	mov	DWORD PTR [edi+152], eax
$LN190@set_elemen:

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	esi, DWORD PTR [edi+156]
	sub	ebx, DWORD PTR [edi+152]

; 355  :         size = lim-pos;

	mov	DWORD PTR [edi+160], ebx
	mov	DWORD PTR [edi+164], esi

; 356  :         if (size.x < 0) size.x = 0;

	test	esi, esi
	jge	SHORT $LN191@set_elemen
	mov	DWORD PTR [edi+164], 0
$LN191@set_elemen:

; 357  :         if (size.y < 0) size.y = 0;

	test	ebx, ebx
	jge	SHORT $LN192@set_elemen
	mov	DWORD PTR [edi+160], 0
$LN192@set_elemen:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1923 :           if (parse_only_relevant_packets)

	cmp	BYTE PTR _parse_only_relevant_packets$1$[ebp], 0

; 1924 :             max_relevant_packets +=

	mov	esi, DWORD PTR _this$1$[ebp]

; 1925 :               max_relevant_layers * (int) res->region_indices.area();
; 1926 :         }

	mov	ebx, DWORD PTR _tc$1$[ebp]
	je	SHORT $LN239@set_elemen

; 1924 :             max_relevant_packets +=

	mov	eax, DWORD PTR [edi+164]
	imul	eax, DWORD PTR [edi+160]
	imul	eax, DWORD PTR [esi+140]
	cdq
	add	DWORD PTR [esi+152], eax
	adc	DWORD PTR [esi+156], edx
$LN239@set_elemen:
	mov	edx, DWORD PTR _r$1$[ebp]
$LN8@set_elemen:

; 1855 :         continue; // Any attempt to access resolution levels will generate an
; 1856 :                   // error, but it is not helpful to generate an error here.
; 1857 : 
; 1858 :       // Now work through the resolution levels.
; 1859 :       int r, b;
; 1860 :       for (r=tc->dwt_levels; r >= 0; r--)

	mov	eax, DWORD PTR tv2247[ebp]
	dec	edx
	sub	eax, 604				; 0000025cH
	mov	DWORD PTR _r$1$[ebp], edx
	mov	DWORD PTR tv2247[ebp], eax
	test	edx, edx
	jns	$LL10@set_elemen
$LN2@set_elemen:

; 1811 :       return;
; 1812 :     }
; 1813 :   for (c=0; c < num_components; c++)

	mov	edx, DWORD PTR _c$1$[ebp]
	inc	edx
	mov	DWORD PTR _c$1$[ebp], edx
	cmp	edx, DWORD PTR [esi+128]
	jl	$LL4@set_elemen
$LN3@set_elemen:

; 1927 :     }
; 1928 : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN39@set_elemen:

; 1879 :             { // This resolution is not of interest
; 1880 :               res->region_indices = res->node.region_cover; // Empty

	movups	xmm0, XMMWORD PTR [edi+60]
	mov	esi, DWORD PTR _this$1$[ebp]
	movups	XMMWORD PTR [edi+152], xmm0
	jmp	SHORT $LN8@set_elemen
?set_elements_of_interest@kd_tile@@AAEXXZ ENDP		; kd_tile::set_elements_of_interest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?adjust_unloadability@kd_tile@@QAEXXZ
_TEXT	SEGMENT
?adjust_unloadability@kd_tile@@QAEXXZ PROC		; kd_tile::adjust_unloadability, COMDAT
; _this$ = ecx

; 2742 :         // associated with tile unloadability might have changed.
; 2743 :         if ((!codestream->persistent) ||

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+337], 0
	je	SHORT $LN7@adjust_unl
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN2@adjust_unl
	cmp	BYTE PTR [eax+338], 0
	je	SHORT $LN7@adjust_unl
$LN2@adjust_unl:

; 2744 :             ((codestream->tpart_ptr_server==NULL) && !codestream->cached))
; 2745 :           { assert(!is_unloadable); return; }
; 2746 :         if (is_open || (this==codestream->active_tile))

	cmp	BYTE PTR [ecx+229], 0
	jne	SHORT $LN6@adjust_unl
	cmp	ecx, DWORD PTR [eax+364]
	je	SHORT $LN6@adjust_unl

; 2749 :               withdraw_from_unloadable_list();
; 2750 :           }
; 2751 :         else
; 2752 :           { // Should be on the unloadable list
; 2753 :             if (!is_unloadable)

	cmp	BYTE PTR [ecx+230], 0
	jne	SHORT $LN7@adjust_unl

; 2754 :               add_to_unloadable_list();

	jmp	?add_to_unloadable_list@kd_tile@@AAEXXZ	; kd_tile::add_to_unloadable_list
$LN6@adjust_unl:

; 2747 :           { // Should not be on the unloadable list
; 2748 :             if (is_unloadable)

	cmp	BYTE PTR [ecx+230], 0
	jne	?withdraw_from_unloadable_list@kd_tile@@AAEXXZ ; kd_tile::withdraw_from_unloadable_list
$LN7@adjust_unl:

; 2755 :           }
; 2756 :       }

	ret	0
?adjust_unloadability@kd_tile@@QAEXXZ ENDP		; kd_tile::adjust_unloadability
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?remove_from_in_progress_list@kd_tile@@QAEXXZ
_TEXT	SEGMENT
?remove_from_in_progress_list@kd_tile@@QAEXXZ PROC	; kd_tile::remove_from_in_progress_list, COMDAT
; _this$ = ecx

; 2647 : {

	mov	edx, ecx

; 2648 :   if (!is_in_progress)

	cmp	BYTE PTR [edx+228], 0
	je	SHORT $LN1@remove_fro

; 2649 :     return;
; 2650 :   assert(codestream->num_incomplete_tiles > 0);
; 2651 :   codestream->num_incomplete_tiles--;

	mov	eax, DWORD PTR [edx]
	dec	DWORD PTR [eax+280]

; 2652 :   if (in_progress_prev == NULL)

	mov	ecx, DWORD PTR [edx+28]

; 2653 :     {
; 2654 :       assert(this == codestream->tiles_in_progress_head);
; 2655 :       codestream->tiles_in_progress_head = in_progress_next;

	mov	eax, DWORD PTR [edx+24]
	test	ecx, ecx
	jne	SHORT $LN3@remove_fro
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+268], eax

; 2656 :     }
; 2657 :   else

	jmp	SHORT $LN4@remove_fro
$LN3@remove_fro:

; 2658 :     in_progress_prev->in_progress_next = in_progress_next;

	mov	DWORD PTR [ecx+24], eax
$LN4@remove_fro:

; 2659 :   if (in_progress_next == NULL)

	mov	ecx, DWORD PTR [edx+24]

; 2660 :     {
; 2661 :       assert(this == codestream->tiles_in_progress_tail);
; 2662 :       codestream->tiles_in_progress_tail = in_progress_prev;

	mov	eax, DWORD PTR [edx+28]
	test	ecx, ecx
	jne	SHORT $LN5@remove_fro
	mov	ecx, DWORD PTR [edx]
	mov	DWORD PTR [ecx+272], eax

; 2663 :     }
; 2664 :   else

	jmp	SHORT $LN6@remove_fro
$LN5@remove_fro:

; 2665 :     in_progress_next->in_progress_prev = in_progress_prev;

	mov	DWORD PTR [ecx+28], eax
$LN6@remove_fro:

; 2666 :   in_progress_next = in_progress_prev = NULL;

	mov	DWORD PTR [edx+28], 0
	mov	DWORD PTR [edx+24], 0

; 2667 :   is_in_progress = false;

	mov	BYTE PTR [edx+228], 0
$LN1@remove_fro:

; 2668 : }

	ret	0
?remove_from_in_progress_list@kd_tile@@QAEXXZ ENDP	; kd_tile::remove_from_in_progress_list
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?generate_tile_part@kd_tile@@QAE_JHQAG@Z
_TEXT	SEGMENT
_e$2 = -1224						; size = 20
_this$GSCopy$1$ = -1204					; size = 4
_pack_bytes$2$ = -1200					; size = 4
$T3 = -1196						; size = 4
tv1531 = -1196						; size = 4
$T4 = -1192						; size = 4
tv1533 = -1192						; size = 4
_e$5 = -1188						; size = 20
_e$6 = -1188						; size = 20
_w$7 = -1188						; size = 20
_e$8 = -1188						; size = 20
_e$9 = -1188						; size = 20
_p_idx$ = -1168						; size = 8
_word$1$ = -1160					; size = 4
_out$1$ = -1160						; size = 4
_first_layer$1$ = -1156					; size = 4
_current_plt_seg$2$ = -1156				; size = 4
_p_res$ = -1152						; size = 4
_num_tpart_packets$1$ = -1148				; size = 4
_tpart_bytes$2$ = -1144					; size = 4
_tpart_bytes$1$ = -1140					; size = 4
_precinct$3$ = -1136					; size = 4
_precinct$2$ = -1136					; size = 4
_first_resolution$1$ = -1136				; size = 4
_pack_bytes$1$ = -1132					; size = 4
_word$1$ = -1132					; size = 4
_word$1$ = -1132					; size = 4
_first_component$1$ = -1132				; size = 4
tv1430 = -1128						; size = 4
_current_plt_seg$1$ = -1128				; size = 4
_byte$1$ = -1121					; size = 1
_byte$1$ = -1121					; size = 1
_byte$1$ = -1121					; size = 1
_plt_seg_lengths$ = -1120				; size = 1024
_text$10 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_max_layers$ = 8					; size = 4
_slope_thresholds$ = 12					; size = 4
?generate_tile_part@kd_tile@@QAE_JHQAG@Z PROC		; kd_tile::generate_tile_part, COMDAT
; _this$ = ecx

; 2401 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?generate_tile_part@kd_tile@@QAE_JHQAG@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 1212				; 000004bcH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	ebx, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], ebx

; 2402 :   if (sequenced_relevant_packets == max_relevant_packets)

	mov	eax, DWORD PTR [ebx+248]
	cdq
	cmp	eax, DWORD PTR [ebx+152]
	jne	SHORT $LN21@generate_t
	cmp	edx, DWORD PTR [ebx+156]
	je	$LN297@generate_t
$LN21@generate_t:

; 2403 :     return 0;
; 2404 :   assert(is_in_progress);
; 2405 :   if (next_tpart >= 255)

	mov	eax, DWORD PTR [ebx+244]
	cmp	eax, 255				; 000000ffH
	jl	SHORT $LN22@generate_t

; 2406 :     { KDU_ERROR(e,14); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$9[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0BO@KPHEGGEJ@Too?5many?5tile?9parts?5for?5tile?5?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2406 :     { KDU_ERROR(e,14); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR _e$9[ebp+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR [ebx+4]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$10[ebp]
	push	eax
	call	_sprintf
	add	esp, 12					; 0000000cH

; 263  :         put_text(text); return *this; }

	lea	eax, DWORD PTR _text$10[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	eax
	mov	eax, DWORD PTR _e$9[ebp]
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0CJ@PEIPJIAP@?4?5?5No?5tile?5may?5have?5more?5than?525@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2410 :   else if ((codestream->tlm_generator.exists()) &&

	jmp	SHORT $LN298@generate_t
$LN22@generate_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1010 :     bool exists() { return (num_tiles > 0); }

	mov	ecx, DWORD PTR [ebx]
	cmp	DWORD PTR [ecx+56], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2410 :   else if ((codestream->tlm_generator.exists()) &&

	jle	SHORT $LN24@generate_t
	cmp	DWORD PTR [ecx+60], eax
	jg	SHORT $LN24@generate_t

; 2412 :     { KDU_ERROR(e,15); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$8[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1019 :     int get_max_tparts() { return max_tparts; }

	mov	eax, DWORD PTR [ebx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_0BO@KPHEGGEJ@Too?5many?5tile?9parts?5for?5tile?5?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2412 :     { KDU_ERROR(e,15); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1019 :     int get_max_tparts() { return max_tparts; }

	mov	edi, DWORD PTR [eax+60]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$8[ebp]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2416 :       codestream->tlm_generator.get_max_tparts() << ".";

	push	DWORD PTR [ebx+4]
	lea	ecx, DWORD PTR _e$8[ebp]
	call	??6kdu_message@@QAEAAV0@H@Z		; kdu_message::operator<<
	mov	esi, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0GI@GJEHPDEO@?4?5?5The?5maximum?5number?5of?5tile?9pa@
	mov	ecx, esi
	mov	edx, DWORD PTR [esi]
	call	DWORD PTR [edx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2416 :       codestream->tlm_generator.get_max_tparts() << ".";

	push	edi
	mov	ecx, esi
	call	??6kdu_message@@QAEAAV0@H@Z		; kdu_message::operator<<
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	mov	ecx, eax
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]
$LN298@generate_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2417 :     }

	lea	ecx, DWORD PTR _e$8[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN24@generate_t:

; 2418 :   assert(max_layers <= codestream->num_sized_layers);
; 2419 :   next_tpart++; // Makes sure packet sequencer does the right thing.
; 2420 :   kdu_long tpart_bytes = 12 + 2 +

	inc	DWORD PTR [ebx+244]
	mov	eax, DWORD PTR [ebx+244]
	mov	ecx, DWORD PTR [ebx]
	dec	eax
	push	eax
	push	DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ecx+12]
	push	0
	call	?generate_marker_segments@kdu_params@@QAEHPAVkdu_output@@HH@Z ; kdu_params::generate_marker_segments
	add	eax, 14					; 0000000eH

; 2421 :     codestream->siz->generate_marker_segments(NULL,t_num,next_tpart-1);
; 2422 :   int plt_seg_lengths[256]; // Lengths of each PLT segment, including marker
; 2423 :   int current_plt_seg = -1; // No PLT segments generated by default.

	or	edi, -1
	cdq

; 2424 :   int first_resolution = -1; // Resolution level of first packet in tile-part
; 2425 :   int first_component = -1; // Component index of first packet in tile-part
; 2426 :   int first_layer = -1; // Layer number of first packet in tile-part
; 2427 :   int n, num_tpart_packets = 0;

	xor	ecx, ecx
	mov	DWORD PTR _tpart_bytes$1$[ebp], eax

; 2428 : 
; 2429 :   if ((codestream->profile == 0) && (codestream->next_tnum >= 0))

	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR _tpart_bytes$2$[ebp], edx
	mov	DWORD PTR _current_plt_seg$1$[ebp], edi
	mov	DWORD PTR _first_resolution$1$[ebp], edi
	mov	DWORD PTR _first_component$1$[ebp], edi
	mov	DWORD PTR _first_layer$1$[ebp], edi
	mov	DWORD PTR _num_tpart_packets$1$[ebp], ecx
	cmp	DWORD PTR [eax+104], ecx
	jne	SHORT $LN27@generate_t
	mov	eax, DWORD PTR [eax+376]
	test	eax, eax
	js	SHORT $LN27@generate_t

; 2430 :     { // Check for a valid tile-part sequence.
; 2431 :       if (codestream->next_tnum != t_num)

	cmp	eax, DWORD PTR [ebx+4]
	je	SHORT $LN26@generate_t

; 2432 :         { KDU_WARNING(w,10); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$7[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$7[ebp]
	lea	ecx, DWORD PTR _w$7[ebp]
	push	OFFSET ??_C@_0MP@KJDJEMOL@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2432 :         { KDU_WARNING(w,10); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2437 :           codestream->profile = 2;

	mov	eax, DWORD PTR [ebx]

; 2438 :         }

	lea	ecx, DWORD PTR _w$7[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], edi
	mov	DWORD PTR [eax+104], 2
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN26@generate_t:

; 2439 :       codestream->next_tnum++;

	mov	eax, DWORD PTR [ebx]
	inc	DWORD PTR [eax+376]

; 2440 :       if (codestream->next_tnum ==

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx+168]
	imul	eax, DWORD PTR [ecx+164]
	cmp	DWORD PTR [ecx+376], eax
	jne	SHORT $LN27@generate_t

; 2441 :           (codestream->tile_span.x * codestream->tile_span.y))
; 2442 :         codestream->next_tnum = -1;

	mov	DWORD PTR [ecx+376], -1
$LN27@generate_t:

; 2450 :   sequencer->save_state();

	mov	ecx, DWORD PTR [ebx+52]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _p_idx$[ebp], 0
	mov	DWORD PTR _p_idx$[ebp+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2450 :   sequencer->save_state();

	call	?save_state@kd_packet_sequencer@@QAEXXZ	; kd_packet_sequencer::save_state

; 2451 :   while ((p_ref = sequencer->next_in_sequence(p_res,p_idx)) != NULL)

	mov	ecx, DWORD PTR [ebx+52]
	lea	eax, DWORD PTR _p_idx$[ebp]
	push	eax
	lea	eax, DWORD PTR _p_res$[ebp]
	push	eax
	call	?next_in_sequence@kd_packet_sequencer@@QAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_sequence
	mov	edx, eax
	test	edx, edx
	je	$LN262@generate_t
$LL2@generate_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4722 :   if (state == 3)

	mov	ecx, DWORD PTR [edx]
	mov	esi, DWORD PTR [edx+4]
	cmp	ecx, 3
	jne	SHORT $LN88@generate_t
	test	esi, esi
	je	SHORT $LN87@generate_t
$LN88@generate_t:

; 4724 :   if ((state == 0) || (state & 1))

	mov	eax, ecx
	or	eax, esi
	je	SHORT $LN90@generate_t
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN90@generate_t

; 4726 :   kd_precinct *result = (kd_precinct *) _kdu_long_to_addr(state);

	mov	esi, DWORD PTR [edx]

; 4727 :   if (result->flags & KD_PFLAG_INACTIVE)

	mov	eax, DWORD PTR [esi+8]
	test	al, 32					; 00000020H
	je	SHORT $LN91@generate_t

; 4728 :     { // Must be on the inactive list
; 4729 :       result->size_class->withdraw_from_inactive_list(result);

	mov	ecx, DWORD PTR [esi+52]
	push	esi
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list

; 4730 :       result->activate();

	mov	ecx, esi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate
	jmp	SHORT $LN87@generate_t
$LN91@generate_t:

; 4731 :     }
; 4732 :   else if (need_activate && (result->flags & KD_PFLAG_RELEASED))

	test	al, 16					; 00000010H
	je	SHORT $LN87@generate_t

; 4733 :     result->activate();

	mov	ecx, esi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate

; 4734 :   return result;

	jmp	SHORT $LN87@generate_t
$LN90@generate_t:

; 4725 :     return instantiate_precinct(res,pos_idx);

	push	DWORD PTR _p_idx$[ebp+4]
	mov	ecx, edx
	push	DWORD PTR _p_idx$[ebp]
	push	DWORD PTR _p_res$[ebp]
	call	?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z ; kd_precinct_ref::instantiate_precinct
	mov	esi, eax
$LN87@generate_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2455 :       if (precinct->num_outstanding_blocks > 0)

	cmp	DWORD PTR [esi+24], 0
	jg	$LN240@generate_t

; 2456 :         break; // This precinct has not yet been generated
; 2457 :       int layer_idx = precinct->next_layer_idx;
; 2458 :       assert (layer_idx < num_layers);
; 2459 :       if (first_resolution < 0)

	mov	ecx, DWORD PTR _first_resolution$1$[ebp]
	mov	edi, DWORD PTR [esi+16]
	test	ecx, ecx
	jns	SHORT $LN292@generate_t

; 2460 :         {
; 2461 :           first_resolution = precinct->resolution->res_level;

	mov	eax, DWORD PTR [esi]

; 2462 :           first_component = precinct->resolution->tile_comp->cnum;
; 2463 :           first_layer = layer_idx;

	mov	edx, edi
	mov	DWORD PTR _first_layer$1$[ebp], edx
	movzx	ecx, BYTE PTR [eax+12]
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _first_resolution$1$[ebp], ecx
	mov	eax, DWORD PTR [eax+12]
	mov	DWORD PTR _first_component$1$[ebp], eax
	jmp	SHORT $LN29@generate_t
$LN292@generate_t:
	mov	edx, DWORD PTR _first_layer$1$[ebp]
$LN29@generate_t:

; 2464 :         }
; 2465 :       if ((resolution_tparts &&
; 2466 :            (first_resolution != precinct->resolution->res_level)) ||
; 2467 :           (component_tparts &&
; 2468 :            (first_component != precinct->resolution->tile_comp->cnum)) ||

	cmp	BYTE PTR [ebx+236], 0
	je	SHORT $LN32@generate_t
	mov	eax, DWORD PTR [esi]
	movzx	eax, BYTE PTR [eax+12]
	cmp	ecx, eax
	jne	$LN240@generate_t
$LN32@generate_t:
	cmp	BYTE PTR [ebx+237], 0
	je	SHORT $LN33@generate_t
	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR _first_component$1$[ebp]
	mov	eax, DWORD PTR [eax+4]
	cmp	ecx, DWORD PTR [eax+12]
	jne	$LN240@generate_t
$LN33@generate_t:
	cmp	BYTE PTR [ebx+238], 0
	je	SHORT $LN30@generate_t
	cmp	edx, edi
	jne	$LN240@generate_t
$LN30@generate_t:

; 2469 :           (layer_tparts && (first_layer != layer_idx)))
; 2470 :         break; // This packet should be sequenced into the next tile-part
; 2471 : 
; 2472 :       // Include this packet in the current tile-part.
; 2473 :       if ((precinct->packet_bytes == NULL) ||

	mov	ecx, DWORD PTR [esi+32]
	test	ecx, ecx
	je	SHORT $LN35@generate_t
	mov	eax, DWORD PTR [ecx+edi*8]
	or	eax, DWORD PTR [ecx+edi*8+4]
	jne	SHORT $LN34@generate_t
$LN35@generate_t:

; 2475 :         { KDU_ERROR(e,16); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$6[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$6[ebp]
	lea	ecx, DWORD PTR _e$6[ebp]
	push	OFFSET ??_C@_0KI@NPIDLLIG@Attempting?5to?5generate?5tile?9part@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2475 :         { KDU_ERROR(e,16); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2479 :         }

	lea	ecx, DWORD PTR _e$6[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN34@generate_t:

; 2480 :       tpart_bytes += precinct->packet_bytes[layer_idx];

	mov	eax, DWORD PTR [esi+32]
	mov	ecx, DWORD PTR [eax+edi*8]
	add	DWORD PTR _tpart_bytes$1$[ebp], ecx
	mov	eax, DWORD PTR [eax+edi*8+4]
	adc	DWORD PTR _tpart_bytes$2$[ebp], eax

; 2481 :       if (insert_plt_segments)

	cmp	BYTE PTR [ebx+235], 0
	je	$LN38@generate_t

; 2482 :         { // Include the cost of PLT marker segments in the tile-part length.
; 2483 :           kdu_long pack_bytes = precinct->packet_bytes[layer_idx];
; 2484 :           int iplt_bytes;
; 2485 : 
; 2486 :           if (current_plt_seg < 0)

	cmp	DWORD PTR _current_plt_seg$1$[ebp], 0
	jge	SHORT $LN37@generate_t

; 2487 :             { current_plt_seg = 0; plt_seg_lengths[0] = 5; }

	mov	DWORD PTR _current_plt_seg$1$[ebp], 0
	mov	DWORD PTR _plt_seg_lengths$[ebp], 5
$LN37@generate_t:

; 2488 :           for (iplt_bytes=1; pack_bytes >= 128; pack_bytes>>=7, iplt_bytes++);

	mov	edi, 1
	test	eax, eax
	jl	SHORT $LN268@generate_t
	jg	SHORT $LL278@generate_t
	cmp	ecx, 128				; 00000080H
	jb	SHORT $LN268@generate_t
$LL278@generate_t:
	shrd	ecx, eax, 7
	inc	edi
	sar	eax, 7
	test	eax, eax
	jg	SHORT $LL278@generate_t
	jl	SHORT $LN268@generate_t
	cmp	ecx, 128				; 00000080H
	jae	SHORT $LL278@generate_t
$LN268@generate_t:

; 2489 :           plt_seg_lengths[current_plt_seg] += iplt_bytes;

	mov	ecx, DWORD PTR _current_plt_seg$1$[ebp]
	add	DWORD PTR _plt_seg_lengths$[ebp+ecx*4], edi
	mov	eax, DWORD PTR _plt_seg_lengths$[ebp+ecx*4]

; 2490 :           if (plt_seg_lengths[current_plt_seg] > 65537)

	cmp	eax, 65537				; 00010001H
	jle	SHORT $LN38@generate_t

; 2491 :             { // Need to start a new PLT segment.
; 2492 :               plt_seg_lengths[current_plt_seg] -= iplt_bytes;

	sub	eax, edi
	mov	DWORD PTR _plt_seg_lengths$[ebp+ecx*4], eax

; 2493 :               tpart_bytes += plt_seg_lengths[current_plt_seg];

	cdq
	add	DWORD PTR _tpart_bytes$1$[ebp], eax
	adc	DWORD PTR _tpart_bytes$2$[ebp], edx

; 2494 :               current_plt_seg++;

	inc	ecx
	mov	DWORD PTR _current_plt_seg$1$[ebp], ecx

; 2495 :               if (current_plt_seg > 255)

	cmp	ecx, 255				; 000000ffH
	jle	SHORT $LN39@generate_t

; 2496 :                 { KDU_ERROR(e,17); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0NP@BHJNFIFJ@Cannot?5satisfy?5the?5request?5to?5ge@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2496 :                 { KDU_ERROR(e,17); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2502 :                 }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	mov	ecx, DWORD PTR _current_plt_seg$1$[ebp]
$LN39@generate_t:

; 2503 :               plt_seg_lengths[current_plt_seg] = iplt_bytes + 5;

	lea	eax, DWORD PTR [edi+5]
	mov	DWORD PTR _plt_seg_lengths$[ebp+ecx*4], eax
$LN38@generate_t:

; 2504 :             }
; 2505 :         }
; 2506 :       num_tpart_packets++;
; 2507 :       precinct->next_layer_idx++; // This will be restored later.

	inc	DWORD PTR [esi+16]
	lea	eax, DWORD PTR _p_idx$[ebp]

; 2508 :       sequenced_relevant_packets++; // This will also be restored later.

	inc	DWORD PTR [ebx+248]
	mov	ecx, DWORD PTR [ebx+52]
	inc	DWORD PTR _num_tpart_packets$1$[ebp]
	push	eax
	lea	eax, DWORD PTR _p_res$[ebp]
	push	eax
	call	?next_in_sequence@kd_packet_sequencer@@QAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_sequence
	mov	edx, eax
	test	edx, edx
	jne	$LL2@generate_t
$LN240@generate_t:

; 2509 :     }
; 2510 :   if (num_tpart_packets == 0)

	mov	ecx, DWORD PTR _num_tpart_packets$1$[ebp]
	test	ecx, ecx
	je	$LN262@generate_t

; 2515 :     }
; 2516 : 
; 2517 :   if (current_plt_seg >= 0)

	mov	edi, DWORD PTR _current_plt_seg$1$[ebp]
	test	edi, edi
	js	SHORT $LN295@generate_t

; 2518 :     tpart_bytes += plt_seg_lengths[current_plt_seg];

	mov	eax, DWORD PTR _plt_seg_lengths$[ebp+edi*4]
	mov	edi, DWORD PTR _tpart_bytes$1$[ebp]
	cdq
	add	edi, eax
	mov	DWORD PTR _tpart_bytes$1$[ebp], edi
	adc	DWORD PTR _tpart_bytes$2$[ebp], edx
	jmp	SHORT $LN41@generate_t
$LN295@generate_t:
	mov	edi, DWORD PTR _tpart_bytes$1$[ebp]
$LN41@generate_t:

; 2519 : 
; 2520 :   // Now generate the tile-part header
; 2521 :   if ((tpart_bytes>>30) >= 4)

	mov	eax, edi
	and	eax, -1073741824			; c0000000H
	cmp	DWORD PTR _tpart_bytes$2$[ebp], 1
	jl	SHORT $LN42@generate_t
	jg	SHORT $LN269@generate_t
	test	eax, eax
	jb	SHORT $LN42@generate_t
$LN269@generate_t:

; 2522 :     { KDU_ERROR(e,18); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0OJ@JNMDPNHM@Length?5of?5current?5tile?9part?5exce@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2522 :     { KDU_ERROR(e,18); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2527 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN42@generate_t:

; 2528 :   kd_compressed_output *out = codestream->out;

	mov	esi, DWORD PTR [ebx]
	mov	esi, DWORD PTR [esi+8]
	mov	DWORD PTR _out$1$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN104@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN104@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN107@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN107@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 144			; 00000090H
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN112@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN112@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 0
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN115@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN115@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 10			; 0000000aH
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2535 :   out->put((kdu_uint16) t_num);

	movzx	ecx, WORD PTR [ebx+4]
	mov	DWORD PTR _word$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN120@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _word$1$[ebp]
$LN120@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN123@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN123@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	ecx, DWORD PTR _word$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2536 :   out->put((kdu_uint32) tpart_bytes);

	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2536 :   out->put((kdu_uint32) tpart_bytes);

	mov	ecx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2536 :   out->put((kdu_uint32) tpart_bytes);

	call	?put@kdu_output@@QAEHI@Z		; kdu_output::put

; 2537 :   out->put((kdu_byte)(next_tpart-1));

	mov	al, BYTE PTR [ebx+244]
	dec	al
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN126@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN126@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	cl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], cl
	mov	ecx, DWORD PTR [esi+516]
	inc	ecx
	mov	DWORD PTR [esi+516], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1010 :     bool exists() { return (num_tiles > 0); }

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+56], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2538 :   if (codestream->tlm_generator.exists())

	jle	SHORT $LN43@generate_t
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1019 :     int get_max_tparts() { return max_tparts; }

	mov	eax, DWORD PTR [eax+60]
	mov	DWORD PTR $T4[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, DWORD PTR [esi+520]
	jne	SHORT $LN133@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN133@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	ecx, DWORD PTR $T4[ebp]
	mov	BYTE PTR [eax], cl

; 144  :         return 1;
; 145  :       }

	jmp	SHORT $LN299@generate_t
$LN43@generate_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2540 :   else if (sequenced_relevant_packets == max_relevant_packets)

	mov	eax, DWORD PTR [ebx+248]
	cdq
	cmp	eax, DWORD PTR [ebx+152]
	jne	SHORT $LN45@generate_t
	cmp	edx, DWORD PTR [ebx+156]
	jne	SHORT $LN45@generate_t

; 2541 :     out->put((kdu_byte) next_tpart); // This is the last tile-part

	mov	al, BYTE PTR [ebx+244]
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, DWORD PTR [esi+520]
	jne	SHORT $LN136@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN136@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	cl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2542 :   else

	jmp	SHORT $LN299@generate_t
$LN45@generate_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, DWORD PTR [esi+520]
	jne	SHORT $LN139@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN139@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 0
$LN299@generate_t:
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2544 :   codestream->layer_sizes[0] += 12 + // 12 is for the SOT marker segment

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx]
	mov	edi, DWORD PTR [eax+288]
	mov	eax, DWORD PTR [ebx+244]
	mov	ecx, DWORD PTR [ecx+12]
	dec	eax
	push	eax
	push	DWORD PTR [ebx+4]
	push	esi
	call	?generate_marker_segments@kdu_params@@QAEHPAVkdu_output@@HH@Z ; kdu_params::generate_marker_segments
	add	eax, 12					; 0000000cH
	cdq
	add	DWORD PTR [edi], eax
	adc	DWORD PTR [edi+4], edx

; 2545 :     codestream->siz->generate_marker_segments(out,t_num,next_tpart-1);
; 2546 :   if (current_plt_seg >= 0)

	cmp	DWORD PTR _current_plt_seg$1$[ebp], 0
	jl	$LN293@generate_t

; 2547 :     { // Generate the PLT marker segments.  To do this, we need to go through
; 2548 :       // the packet sequence all over again.
; 2549 :       assert(insert_plt_segments);
; 2550 : 
; 2551 :       sequencer->restore_state();

	mov	ecx, DWORD PTR [ebx+52]
	call	?restore_state@kd_packet_sequencer@@QAEXXZ ; kd_packet_sequencer::restore_state

; 2552 :       current_plt_seg = -1;
; 2553 :       for (n=0; n < num_tpart_packets; n++)

	mov	edi, DWORD PTR _num_tpart_packets$1$[ebp]
	or	ecx, -1
	mov	DWORD PTR _current_plt_seg$2$[ebp], ecx
	test	edi, edi
	jle	$LN8@generate_t

; 2547 :     { // Generate the PLT marker segments.  To do this, we need to go through
; 2548 :       // the packet sequence all over again.
; 2549 :       assert(insert_plt_segments);
; 2550 : 
; 2551 :       sequencer->restore_state();

	lea	eax, DWORD PTR _plt_seg_lengths$[ebp]
	mov	DWORD PTR tv1533[ebp], edi
	sub	eax, 4
	mov	DWORD PTR tv1430[ebp], eax
$LL9@generate_t:

; 2554 :         {
; 2555 :           p_ref = sequencer->next_in_sequence(p_res,p_idx);

	mov	ecx, DWORD PTR [ebx+52]
	lea	eax, DWORD PTR _p_idx$[ebp]
	push	eax
	lea	eax, DWORD PTR _p_res$[ebp]
	push	eax
	call	?next_in_sequence@kd_packet_sequencer@@QAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_sequence
	mov	edx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4722 :   if (state == 3)

	mov	ecx, DWORD PTR [edx]
	mov	edi, DWORD PTR [edx+4]
	cmp	ecx, 3
	jne	SHORT $LN142@generate_t
	test	edi, edi
	jne	SHORT $LN142@generate_t

; 4723 :     return NULL; // Precinct is not currently loaded

	mov	DWORD PTR _precinct$2$[ebp], edi
	jmp	SHORT $LN141@generate_t
$LN142@generate_t:

; 4724 :   if ((state == 0) || (state & 1))

	mov	eax, ecx
	or	eax, edi
	je	SHORT $LN144@generate_t
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN144@generate_t

; 4726 :   kd_precinct *result = (kd_precinct *) _kdu_long_to_addr(state);

	mov	edi, DWORD PTR [edx]
	mov	DWORD PTR _precinct$2$[ebp], edi

; 4727 :   if (result->flags & KD_PFLAG_INACTIVE)

	mov	eax, DWORD PTR [edi+8]
	test	al, 32					; 00000020H
	je	SHORT $LN145@generate_t

; 4728 :     { // Must be on the inactive list
; 4729 :       result->size_class->withdraw_from_inactive_list(result);

	mov	ecx, DWORD PTR [edi+52]
	push	edi
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list

; 4730 :       result->activate();

	mov	ecx, edi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate
	jmp	SHORT $LN141@generate_t
$LN145@generate_t:

; 4731 :     }
; 4732 :   else if (need_activate && (result->flags & KD_PFLAG_RELEASED))

	test	al, 16					; 00000010H
	je	SHORT $LN141@generate_t

; 4733 :     result->activate();

	mov	ecx, edi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate

; 4734 :   return result;

	jmp	SHORT $LN141@generate_t
$LN144@generate_t:

; 4725 :     return instantiate_precinct(res,pos_idx);

	push	DWORD PTR _p_idx$[ebp+4]
	mov	ecx, edx
	push	DWORD PTR _p_idx$[ebp]
	push	DWORD PTR _p_res$[ebp]
	call	?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z ; kd_precinct_ref::instantiate_precinct
	mov	edi, eax
	mov	DWORD PTR _precinct$2$[ebp], eax
$LN141@generate_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2558 :           if ((current_plt_seg < 0) ||

	mov	ecx, DWORD PTR _current_plt_seg$2$[ebp]
	mov	eax, DWORD PTR tv1430[ebp]
	test	ecx, ecx
	js	SHORT $LN49@generate_t
	cmp	DWORD PTR [eax], 0
	jne	$LN48@generate_t
$LN49@generate_t:

; 2561 :               current_plt_seg++;

	add	eax, 4
	inc	ecx
	mov	DWORD PTR tv1430[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2561 :               current_plt_seg++;

	mov	DWORD PTR _current_plt_seg$2$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN152@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN152@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 255			; 000000ffH
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN155@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN155@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2563 :               out->put((kdu_uint16)(plt_seg_lengths[current_plt_seg]-2));

	mov	edx, DWORD PTR tv1430[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], 88			; 00000058H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2563 :               out->put((kdu_uint16)(plt_seg_lengths[current_plt_seg]-2));

	mov	ax, WORD PTR [edx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2563 :               out->put((kdu_uint16)(plt_seg_lengths[current_plt_seg]-2));

	sub	ax, 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2563 :               out->put((kdu_uint16)(plt_seg_lengths[current_plt_seg]-2));

	movzx	eax, ax
	mov	DWORD PTR _word$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, DWORD PTR [esi+520]
	jne	SHORT $LN160@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	eax, DWORD PTR _word$1$[ebp]
$LN160@generate_t:

; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ecx, eax

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN163@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN163@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	ecx, DWORD PTR _word$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN166@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN166@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	ecx, DWORD PTR _current_plt_seg$2$[ebp]
	mov	BYTE PTR [eax], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2565 :               plt_seg_lengths[current_plt_seg] -= 5;

	mov	eax, DWORD PTR tv1430[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2565 :               plt_seg_lengths[current_plt_seg] -= 5;

	add	DWORD PTR [eax], -5			; fffffffbH
$LN48@generate_t:

; 2566 :             }
; 2567 : 
; 2568 :           int shift;
; 2569 :           kdu_long pack_bytes =
; 2570 :             precinct->packet_bytes[precinct->next_layer_idx];

	mov	ecx, DWORD PTR [edi+32]
	mov	eax, DWORD PTR [edi+16]

; 2571 : 
; 2572 :           for (shift=0; (pack_bytes>>shift) >= 128; shift += 7);

	xor	edi, edi
	mov	edx, DWORD PTR [ecx+eax*8]
	mov	eax, DWORD PTR [ecx+eax*8+4]
	mov	DWORD PTR _pack_bytes$1$[ebp], edx
	mov	DWORD PTR _pack_bytes$2$[ebp], eax
	test	eax, eax
	jl	SHORT $LN264@generate_t
	jg	SHORT $LN286@generate_t
	cmp	edx, 128				; 00000080H
	jb	SHORT $LN264@generate_t
$LN286@generate_t:
	mov	ebx, DWORD PTR _pack_bytes$1$[ebp]
	mov	esi, DWORD PTR _pack_bytes$2$[ebp]
$LL280@generate_t:
	add	edi, 7
	mov	eax, ebx
	mov	edx, esi
	mov	ecx, edi
	call	__allshr
	test	edx, edx
	jg	SHORT $LL280@generate_t
	jl	SHORT $LN271@generate_t
	cmp	eax, 128				; 00000080H
	jae	SHORT $LL280@generate_t
$LN271@generate_t:

; 2573 :           for (; shift >= 0; shift -= 7)

	mov	esi, DWORD PTR _out$1$[ebp]
	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	test	edi, edi
	js	$LN14@generate_t
$LN264@generate_t:
	mov	eax, DWORD PTR tv1430[ebp]
	lea	ecx, DWORD PTR [edi+7]
	mov	ebx, DWORD PTR [eax]
	mov	eax, 613566757				; 24924925H
	mul	ecx
	sub	ecx, edx
	shr	ecx, 1
	add	ecx, edx
	shr	ecx, 2
	sub	ebx, ecx
	mov	DWORD PTR tv1531[ebp], ebx
	mov	ebx, DWORD PTR _pack_bytes$1$[ebp]
	npad	5
$LL263@generate_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN169@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN169@generate_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2575 :               out->put((kdu_byte)

	mov	edx, DWORD PTR _pack_bytes$2$[ebp]
	mov	eax, ebx
	mov	ecx, edi
	call	__allshr
	and	al, 127					; 0000007fH
	test	edi, edi
	setle	cl
	dec	cl
	and	cl, 128					; 00000080H
	add	al, cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR [esi+516]
	mov	BYTE PTR [ecx], al
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2573 :           for (; shift >= 0; shift -= 7)

	sub	edi, 7
	jns	SHORT $LL263@generate_t
	mov	edx, DWORD PTR tv1430[ebp]
	mov	eax, DWORD PTR tv1531[ebp]
	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR [edx], eax
$LN14@generate_t:

; 2576 :                        (((pack_bytes>>shift) & 0x7F)+((shift > 0)?0x80:0)));
; 2577 :               plt_seg_lengths[current_plt_seg]--;
; 2578 :             }
; 2579 : 
; 2580 :           precinct->next_layer_idx++; // This will be restored later.

	mov	eax, DWORD PTR _precinct$2$[ebp]
	inc	DWORD PTR [eax+16]

; 2581 :           sequenced_relevant_packets++; // This will also be restored later.

	inc	DWORD PTR [ebx+248]
	sub	DWORD PTR tv1533[ebp], 1
	jne	$LL9@generate_t
$LN293@generate_t:
	mov	edi, DWORD PTR _num_tpart_packets$1$[ebp]
$LN8@generate_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN174@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN174@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 255			; 000000ffH
	mov	eax, DWORD PTR [esi+516]
	inc	eax
	mov	DWORD PTR [esi+516], eax

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN177@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN177@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 147			; 00000093H
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2585 :   codestream->layer_sizes[0] += out->put(KDU_SOD);

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+288]
	add	DWORD PTR [eax], 2
	adc	DWORD PTR [eax+4], 0

; 2586 : 
; 2587 :   // Finally, output the packet data
; 2588 :   sequencer->restore_state();

	mov	ecx, DWORD PTR [ebx+52]
	call	?restore_state@kd_packet_sequencer@@QAEXXZ ; kd_packet_sequencer::restore_state

; 2589 :   for (n=0; n < num_tpart_packets; n++)

	test	edi, edi
	jle	$LN17@generate_t
	mov	esi, DWORD PTR _slope_thresholds$[ebp]
$LL18@generate_t:

; 2590 :     {
; 2591 :       p_ref = sequencer->next_in_sequence(p_res,p_idx);

	mov	ecx, DWORD PTR [ebx+52]
	lea	eax, DWORD PTR _p_idx$[ebp]
	push	eax
	lea	eax, DWORD PTR _p_res$[ebp]
	push	eax
	call	?next_in_sequence@kd_packet_sequencer@@QAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_sequence
	mov	edx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4722 :   if (state == 3)

	mov	ecx, DWORD PTR [edx]
	mov	edi, DWORD PTR [edx+4]
	cmp	ecx, 3
	jne	SHORT $LN180@generate_t
	test	edi, edi
	jne	SHORT $LN180@generate_t

; 4723 :     return NULL; // Precinct is not currently loaded

	xor	edx, edx
	jmp	SHORT $LN179@generate_t
$LN180@generate_t:

; 4724 :   if ((state == 0) || (state & 1))

	mov	eax, ecx
	or	eax, edi
	je	SHORT $LN182@generate_t
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN182@generate_t

; 4726 :   kd_precinct *result = (kd_precinct *) _kdu_long_to_addr(state);

	mov	edx, DWORD PTR [edx]
	mov	DWORD PTR _precinct$3$[ebp], edx

; 4727 :   if (result->flags & KD_PFLAG_INACTIVE)

	mov	eax, DWORD PTR [edx+8]
	test	al, 32					; 00000020H
	je	SHORT $LN183@generate_t

; 4728 :     { // Must be on the inactive list
; 4729 :       result->size_class->withdraw_from_inactive_list(result);

	mov	ecx, DWORD PTR [edx+52]
	push	edx
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list

; 4730 :       result->activate();

	mov	ecx, DWORD PTR _precinct$3$[ebp]
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate
	mov	edx, DWORD PTR _precinct$3$[ebp]
	jmp	SHORT $LN179@generate_t
$LN183@generate_t:

; 4731 :     }
; 4732 :   else if (need_activate && (result->flags & KD_PFLAG_RELEASED))

	test	al, 16					; 00000010H
	je	SHORT $LN179@generate_t

; 4733 :     result->activate();

	mov	ecx, edx
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate
	mov	edx, DWORD PTR _precinct$3$[ebp]

; 4734 :   return result;

	jmp	SHORT $LN179@generate_t
$LN182@generate_t:

; 4725 :     return instantiate_precinct(res,pos_idx);

	push	DWORD PTR _p_idx$[ebp+4]
	mov	ecx, edx
	push	DWORD PTR _p_idx$[ebp]
	push	DWORD PTR _p_res$[ebp]
	call	?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z ; kd_precinct_ref::instantiate_precinct
	mov	edx, eax
$LN179@generate_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2594 :       int layer_idx = precinct->next_layer_idx;

	mov	edi, DWORD PTR [edx+16]

; 2595 :       if (layer_idx < max_layers)

	cmp	edi, DWORD PTR _max_layers$[ebp]
	jge	SHORT $LN50@generate_t

; 2596 :         codestream->layer_sizes[layer_idx] +=

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edx+16]
	push	0
	mov	ecx, DWORD PTR [ecx+288]
	movzx	eax, WORD PTR [esi+eax*2]
	push	eax
	lea	edi, DWORD PTR [ecx+edi*8]
	mov	ecx, edx
	call	?write_packet@kd_precinct@@QAE_JG_N@Z	; kd_precinct::write_packet
	add	DWORD PTR [edi], eax
	adc	DWORD PTR [edi+4], edx
	jmp	SHORT $LN16@generate_t
$LN50@generate_t:

; 2597 :           precinct->write_packet(slope_thresholds[layer_idx]);
; 2598 :       else if (layer_idx < codestream->num_sized_layers)

	mov	eax, DWORD PTR [ebx]

; 2599 :         codestream->layer_sizes[layer_idx] +=

	push	1
	push	0
	cmp	edi, DWORD PTR [eax+284]
	jge	SHORT $LN52@generate_t
	mov	eax, DWORD PTR [eax+288]
	mov	ecx, edx
	lea	edi, DWORD PTR [eax+edi*8]
	call	?write_packet@kd_precinct@@QAE_JG_N@Z	; kd_precinct::write_packet
	add	DWORD PTR [edi], eax
	adc	DWORD PTR [edi+4], edx

; 2600 :           precinct->write_packet(0,true); // Write an empty packet.
; 2601 :       else

	jmp	SHORT $LN16@generate_t
$LN52@generate_t:

; 2602 :         codestream->layer_sizes[codestream->num_sized_layers-1] +=

	mov	ecx, DWORD PTR [eax+284]
	mov	eax, DWORD PTR [eax+288]
	lea	edi, DWORD PTR [eax+ecx*8]
	mov	ecx, edx
	call	?write_packet@kd_precinct@@QAE_JG_N@Z	; kd_precinct::write_packet
	add	DWORD PTR [edi-8], eax
	adc	DWORD PTR [edi-4], edx
$LN16@generate_t:

; 2589 :   for (n=0; n < num_tpart_packets; n++)

	sub	DWORD PTR _num_tpart_packets$1$[ebp], 1
	jne	$LL18@generate_t
	mov	esi, DWORD PTR _out$1$[ebp]
$LN17@generate_t:

; 2603 :           precinct->write_packet(0,true); // Write an empty packet.
; 2604 :     }
; 2605 : 
; 2606 :   // Finish up
; 2607 :   assert(tpart_bytes == (out->get_bytes_written() - start_bytes));
; 2608 :   codestream->num_completed_tparts++;

	mov	eax, DWORD PTR [ebx]

; 2610 :     codestream->tlm_generator.add_tpart_length(t_num,tpart_bytes);

	mov	edi, DWORD PTR _tpart_bytes$1$[ebp]
	inc	DWORD PTR [eax+380]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1010 :     bool exists() { return (num_tiles > 0); }

	mov	ecx, DWORD PTR [ebx]
	add	ecx, 56					; 00000038H
	cmp	DWORD PTR [ecx], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2609 :   if (codestream->tlm_generator.exists())

	jle	SHORT $LN54@generate_t

; 2610 :     codestream->tlm_generator.add_tpart_length(t_num,tpart_bytes);

	push	DWORD PTR _tpart_bytes$2$[ebp]
	push	edi
	push	DWORD PTR [ebx+4]
	call	?add_tpart_length@kd_tlm_generator@@QAEXH_J@Z ; kd_tlm_generator::add_tpart_length
$LN54@generate_t:

; 2611 :   if (sequenced_relevant_packets == max_relevant_packets)

	mov	eax, DWORD PTR [ebx+248]
	cdq
	cmp	eax, DWORD PTR [ebx+152]
	jne	$LN57@generate_t
	cmp	edx, DWORD PTR [ebx+156]
	jne	$LN57@generate_t
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1010 :     bool exists() { return (num_tiles > 0); }

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+56], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2615 :       if (codestream->tlm_generator.exists())

	jle	$LN20@generate_t

; 2616 :         {
; 2617 :           while (codestream->tlm_generator.get_max_tparts() > next_tpart)

	mov	eax, DWORD PTR [eax+60]
	cmp	eax, DWORD PTR [ebx+244]
	jle	$LN20@generate_t
	npad	9
$LL19@generate_t:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN196@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN196@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 255			; 000000ffH
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN199@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN199@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 144			; 00000090H
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN204@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN204@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 0
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN207@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN207@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 10			; 0000000aH
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2621 :               out->put((kdu_uint16) t_num);

	movzx	ecx, WORD PTR [ebx+4]
	mov	DWORD PTR _word$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN212@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _word$1$[ebp]
$LN212@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 146  :     int put(kdu_uint16 word)
; 147  :       {
; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN215@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN215@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	ecx, DWORD PTR _word$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2622 :               out->put((kdu_uint32) 14); // Was 12 in v6.0 and prior releases

	push	14					; 0000000eH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2622 :               out->put((kdu_uint32) 14); // Was 12 in v6.0 and prior releases

	mov	ecx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2622 :               out->put((kdu_uint32) 14); // Was 12 in v6.0 and prior releases

	call	?put@kdu_output@@QAEHI@Z		; kdu_output::put

; 2623 :               out->put((kdu_byte) next_tpart);

	mov	al, BYTE PTR [ebx+244]
	mov	BYTE PTR _byte$1$[ebp], al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN218@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN218@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	cl, BYTE PTR _byte$1$[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1019 :     int get_max_tparts() { return max_tparts; }

	mov	eax, DWORD PTR [ebx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1019 :     int get_max_tparts() { return max_tparts; }

	mov	eax, DWORD PTR [eax+60]
	mov	DWORD PTR $T3[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	cmp	ecx, DWORD PTR [esi+520]
	jne	SHORT $LN223@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN223@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	ecx, DWORD PTR $T3[ebp]
	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN228@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN228@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 255			; 000000ffH
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN231@generate_t

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN231@generate_t:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2627 :               codestream->tlm_generator.add_tpart_length(t_num,14);

	push	0
	push	14					; 0000000eH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], 147			; 00000093H
	inc	DWORD PTR [esi+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2626 :               codestream->layer_sizes[0] += 14;

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+288]
	add	DWORD PTR [eax], 14			; 0000000eH
	adc	DWORD PTR [eax+4], 0

; 2627 :               codestream->tlm_generator.add_tpart_length(t_num,14);

	mov	ecx, DWORD PTR [ebx]
	push	DWORD PTR [ebx+4]
	add	ecx, 56					; 00000038H
	call	?add_tpart_length@kd_tlm_generator@@QAEXH_J@Z ; kd_tlm_generator::add_tpart_length

; 2628 :               next_tpart++;

	inc	DWORD PTR [ebx+244]
	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [ebx+244]
	cmp	DWORD PTR [eax+60], ecx
	jg	$LL19@generate_t
$LN20@generate_t:

; 2629 :             }
; 2630 :         }
; 2631 : 
; 2632 :       remove_from_in_progress_list();

	mov	ecx, ebx
	call	?remove_from_in_progress_list@kd_tile@@QAEXXZ ; kd_tile::remove_from_in_progress_list

; 2633 : 
; 2634 :       // See if we can free the tile's resources at this point
; 2635 :       if (closed && !codestream->allow_restart)

	cmp	BYTE PTR [ebx+232], 0
	je	SHORT $LN57@generate_t
	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax+328], 0
	jne	SHORT $LN57@generate_t

; 2636 :         release(); // Typically self-efacing

	mov	ecx, ebx
	call	?release@kd_tile@@QAEXXZ		; kd_tile::release
$LN57@generate_t:

; 2637 :     }
; 2638 :   return tpart_bytes;

	mov	edx, DWORD PTR _tpart_bytes$2$[ebp]
	mov	eax, edi
	jmp	SHORT $LN1@generate_t
$LN262@generate_t:

; 2511 :     {
; 2512 :       next_tpart--;
; 2513 :       sequencer->restore_state();

	mov	ecx, DWORD PTR [ebx+52]
	dec	DWORD PTR [ebx+244]
	call	?restore_state@kd_packet_sequencer@@QAEXXZ ; kd_packet_sequencer::restore_state
$LN297@generate_t:

; 2514 :       return 0;

	xor	eax, eax
	xor	edx, edx
$LN1@generate_t:

; 2639 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?generate_tile_part@kd_tile@@QAE_JHQAG@Z$0:
	lea	ecx, DWORD PTR _e$9[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?generate_tile_part@kd_tile@@QAE_JHQAG@Z$1:
	lea	ecx, DWORD PTR _e$8[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?generate_tile_part@kd_tile@@QAE_JHQAG@Z$2:
	lea	ecx, DWORD PTR _w$7[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?generate_tile_part@kd_tile@@QAE_JHQAG@Z$3:
	lea	ecx, DWORD PTR _e$6[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?generate_tile_part@kd_tile@@QAE_JHQAG@Z$4:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?generate_tile_part@kd_tile@@QAE_JHQAG@Z$5:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?generate_tile_part@kd_tile@@QAE_JHQAG@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-1228]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?generate_tile_part@kd_tile@@QAE_JHQAG@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?generate_tile_part@kd_tile@@QAE_JHQAG@Z ENDP		; kd_tile::generate_tile_part
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?finished_reading@kd_tile@@QAE_NXZ
_TEXT	SEGMENT
_this$1$ = -24						; size = 4
_tc$1$ = -20						; size = 4
tv444 = -16						; size = 4
_c$1$ = -12						; size = 4
tv446 = -8						; size = 4
_r$1$ = -4						; size = 4
?finished_reading@kd_tile@@QAE_NXZ PROC			; kd_tile::finished_reading, COMDAT
; _this$ = ecx

; 2352 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 24					; 00000018H
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx

; 2353 :   if (!initialized)

	cmp	BYTE PTR [ebx+233], 0
	je	$LN3@finished_r

; 2354 :     return false; // Prevent calls here while trying to initialize a tile.
; 2355 :   if (codestream->active_tile == this)

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+364], ebx
	jne	SHORT $LN12@finished_r

; 2356 :     {
; 2357 :       assert(!exhausted);
; 2358 :       codestream->active_tile = NULL;

	mov	DWORD PTR [eax+364], 0

; 2359 :       adjust_unloadability();

	call	?adjust_unloadability@kd_tile@@QAEXXZ	; kd_tile::adjust_unloadability

; 2360 :     }
; 2361 :   else

	jmp	SHORT $LN14@finished_r
$LN12@finished_r:

; 2362 :     {
; 2363 :       adjust_unloadability(); // Just in case

	call	?adjust_unloadability@kd_tile@@QAEXXZ	; kd_tile::adjust_unloadability

; 2364 :       if (exhausted)

	cmp	BYTE PTR [ebx+268], 0
	jne	$LN3@finished_r
$LN14@finished_r:

; 2365 :         return false; // True only if this function has been called before
; 2366 :     }
; 2367 :   exhausted = true;
; 2368 :   if (closed)

	cmp	BYTE PTR [ebx+232], 0
	mov	BYTE PTR [ebx+268], 1
	je	SHORT $LN15@finished_r

; 2369 :     { // Should never happen if the codestream object is persistent.
; 2370 :       if (!codestream->allow_restart)

	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax+328], 0
	jne	$LN3@finished_r

; 2371 :         {
; 2372 :           release(); // Could be self-efacing!

	mov	ecx, ebx
	call	?release@kd_tile@@QAEXXZ		; kd_tile::release

; 2373 :           return true;

	mov	al, 1
	pop	ebx

; 2393 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN15@finished_r:

; 2374 :         }
; 2375 :       return false;
; 2376 :     }
; 2377 :   for (int c=0; c < num_components; c++)

	xor	ecx, ecx
	mov	DWORD PTR _c$1$[ebp], ecx
	cmp	DWORD PTR [ebx+128], ecx
	jle	$LN3@finished_r
	xor	eax, eax
	push	esi
	mov	DWORD PTR tv444[ebp], eax
	push	edi
	npad	5
$LL4@finished_r:

; 2378 :     {
; 2379 :       kd_tile_comp *tc = comps + c;

	mov	edx, DWORD PTR [ebx+208]
	add	edx, eax

; 2380 :       for (int r=0; r <= tc->dwt_levels; r++)

	xor	eax, eax
	mov	DWORD PTR _tc$1$[ebp], edx
	mov	DWORD PTR _r$1$[ebp], eax
	cmp	DWORD PTR [edx+56], eax
	jl	$LN2@finished_r

; 2378 :     {
; 2379 :       kd_tile_comp *tc = comps + c;

	xor	ecx, ecx
	mov	DWORD PTR tv446[ebp], ecx
	npad	2
$LL7@finished_r:

; 2381 :         {
; 2382 :           kd_resolution *res = tc->resolutions + r;

	mov	ebx, DWORD PTR [edx+144]

; 2384 :           for (int p=0; p < num_precincts; p++)

	xor	esi, esi
	add	ebx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	edi, DWORD PTR [ebx+148]
	imul	edi, DWORD PTR [ebx+144]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2384 :           for (int p=0; p < num_precincts; p++)

	test	edi, edi
	jle	$LN5@finished_r
	npad	1
$LL10@finished_r:
	mov	eax, DWORD PTR [ebx+180]
	lea	ecx, DWORD PTR [eax+esi*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }

	mov	eax, DWORD PTR [ecx]
	and	eax, 1
	or	eax, 0
	jne	$LN8@finished_r
	mov	eax, DWORD PTR [ecx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2387 :               if (precinct != NULL)

	test	eax, eax
	je	$LN8@finished_r
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4176 :         if (flags & KD_PFLAG_DESEQUENCED)

	mov	ecx, DWORD PTR [eax+8]
	test	cl, 4
	jne	$LN8@finished_r

; 4177 :           return;
; 4178 :         flags |= KD_PFLAG_DESEQUENCED;

	or	ecx, 4

; 4179 :           // desequenced = true;
; 4180 :         if (next_layer_idx == 0)

	cmp	DWORD PTR [eax+16], 0
	mov	DWORD PTR [eax+8], ecx
	jne	SHORT $LN27@finished_r

; 4181 :           {
; 4182 :             flags |= KD_PFLAG_ADDRESSABLE;

	or	ecx, 8

; 4183 :               // addressable = true;
; 4184 :             unique_address = 0;

	mov	DWORD PTR [eax+32], 0
	mov	DWORD PTR [eax+8], ecx
	mov	DWORD PTR [eax+36], 0
$LN27@finished_r:

; 4185 :           }
; 4186 :         if (num_outstanding_blocks == 0)

	cmp	DWORD PTR [eax+24], 0
	jne	SHORT $LN8@finished_r

; 3077 :       /* Returns NULL unless the reference identifies a valid `kd_precinct'
; 3078 :          object, which is already loaded in memory. */
; 3079 :     kd_precinct *active_deref();
; 3080 :       /* Returns NULL unless the reference identifies a valid `kd_precinct'
; 3081 :          object, which is already loaded in memory and is in the active
; 3082 :          state. */
; 3083 :     kd_precinct *open(kd_resolution *res, kdu_coords pos_idx,
; 3084 :                       bool need_activate);
; 3085 :       /* Attempts to open the precinct at the indicated position within the
; 3086 :          array of precincts maintained by the indicated resolution object.
; 3087 :          `pos_idx' holds the horizontal and vertical position of the
; 3088 :          precinct (starting from 0) within the array of precincts for
; 3089 :          the given resolution.  That is, `pos_idx' holds a relative, not
; 3090 :          an absolute precinct index.
; 3091 :             If the precinct is known to be unloadable (this happens if the
; 3092 :          precinct has previously been opened and has then been permanently
; 3093 :          closed), the function returns NULL.
; 3094 :             If the precinct currently exists in memory (the `state' variable
; 3095 :          contains a valid pointer to the precinct), the function returns a
; 3096 :          pointer to that precinct; however, if `need_activate' is true
; 3097 :          and the precincts's `released' flag is true, `kd_precinct::activate'
; 3098 :          is called before returning the `kd_precinct' pointer.  When the
; 3099 :          codestream object was created for input or for interchange, the
; 3100 :          `need_activate' argument should be set to true only when the
; 3101 :          precinct is being opened in order to access code-block data.  In
; 3102 :          that case, the precinct must belong to an open tile and lie within
; 3103 :          the application's current region of interest, meaning that it will
; 3104 :          be released again when the tile is closed.  For codestream objects
; 3105 :          created for output, the argument should have no effect, since
; 3106 :          output precincts are not actually released.
; 3107 :             Otherwise, the function obtains a new `kd_precinct' object from
; 3108 :          the code-stream's precinct server and calls its `initialize'
; 3109 :          function.  If the `state' variable held the precinct's unique
; 3110 :          address value on entry, that address is written into the newly
; 3111 :          instantiated `kd_precinct' object's `unique_address' field, and
; 3112 :          the P bit (see notes on `state' below) is copied to the precinct's
; 3113 :          KD_PFLAG_PARSED flag.  If compressed data comes from a cached source,
; 3114 :          or the codestream object was created for interchange (no compressed
; 3115 :          data sources or targets), the newly created precinct is automatically
; 3116 :          marked as addressable, with its `unique_address' set to the
; 3117 :          precinct's unique identifier, as described in the comments appearing
; 3118 :          with the declaration of `kd_precinct::unique_address'.  For
; 3119 :          precincts which can be addressed using a seek address (for seekable
; 3120 :          compressed data sources), the seek address is installed using
; 3121 :          `set_address' from within the `kd_packet_sequencer::next_in_sequence'
; 3122 :          function.
; 3123 :             It is worth noting that this function may cause other precincts
; 3124 :          to be unloaded from memory, in order to conserve memory resources.
; 3125 :          If this happens, only precincts which have been released and
; 3126 :          which do not intersect with the current region of interest will be
; 3127 :          unloaded. */
; 3128 :     void close();
; 3129 :       /* Closes the active `kd_precinct' object whose pointer is in
; 3130 :          `state', calling its `closing' member function and recycling its
; 3131 :          storage.  If the precinct is marked as addressable, its
; 3132 :          `unique_address' member and KD_PFLAG_PARSED flag are recorded in
; 3133 :          `state' using the convention outlined in the notes below, allowing
; 3134 :          the precinct to be re-opened at a later point.
; 3135 :             In many cases, you are better off calling the `release' member
; 3136 :          function instead of `close' (see below).
; 3137 :             Note that this function may be safely invoked even when the
; 3138 :          precinct is not currently active -- it does nothing unless `state'
; 3139 :          holds a valid precinct address. */
; 3140 :     void close_and_reset();
; 3141 :       /* This function is used only by `kdu_tile::parse_all_relevant_packets'
; 3142 :          and then only if it is asked to parse everything from scratch.  The
; 3143 :          behaviour is similar to calling `close', except that the internal
; 3144 :          `state' record is left with its P flag reset, so that when the
; 3145 :          precinct is reloaded, its packet statistics will be entered into
; 3146 :          the `kd_tile_comp::layer_stats' array -- the caller invariably
; 3147 :          resets this array. */
; 3148 :     void release();
; 3149 :       /* This function should be called once a precinct is no longer
; 3150 :          required, in preference to the `close' function.  If the system is
; 3151 :          running low on resources, the function may unload the precinct from
; 3152 :          memory to recycle its resources.  Alternatively, the function is at
; 3153 :          liberty to leave the precinct in memory, moving it to a list of
; 3154 :          inactive precincts which are subject to unloading at some point in
; 3155 :          the future, when resources may be running low.  Non-addressable or
; 3156 :          cached precincts are unloaded immediately, since they are
; 3157 :          guaranteed never to be re-opened once `release' has been called. */
; 3158 :     void clear();
; 3159 :       /* This function recycles the storage associated with any existing
; 3160 :          precinct and sets the internal `state' variable to 0.  It is called
; 3161 :          when the code-stream management machinery is restarted. */
; 3162 :     bool is_desequenced();
; 3163 :       /* This function is intended for use within
; 3164 :          `kd_packet_sequencer::next_in_sequence', for checking whether
; 3165 :          or not the precinct which is returned by that function needs
; 3166 :          to have its contents read from a compressed data source in
; 3167 :          order to desequence a new packet.  Opening precincts can be a time
; 3168 :          consuming task, especially when there are an enormous number of
; 3169 :          precincts (this can happen when working with huge untiled images,
; 3170 :          especially in geospatial applications).  This function takes
; 3171 :          advantage of the fact that there is no need to actually open a
; 3172 :          precinct which is not already loaded into memory.  The fact that this
; 3173 :          function is called first by the packet desequencer, allows a precinct
; 3174 :          which has already been fully generated to be closed immediately
; 3175 :          during packet generation mode.
; 3176 :             The function works as follows.  If the precinct is already loaded
; 3177 :          in memory, its `sequenced' flag is accessed directly.   Otherwise,
; 3178 :          if the reference `state' variable identifies a valid unique
; 3179 :          address for the precinct, it is known to be addressable and
; 3180 :          therefore must have already been fully desequenced.  Also, if the
; 3181 :          `state' variable indicates that the precinct is unloadable, or that
; 3182 :          it has been closed in packet generation mode, it is interpreted as
; 3183 :          sequenced, in the sense that the application cannot sequence further
; 3184 :          packets for the precinct.  Otherwise, the `state' variable must hold
; 3185 :          0 (see below), from which we deduce that the precinct has not yet
; 3186 :          been sequenced. */
; 3187 :     bool set_address(kd_resolution *res, kdu_coords pos_idx,
; 3188 :                      kdu_long seek_address);
; 3189 :       /* Called from within `kd_packet_sequencer::next_in_sequence', this
; 3190 :          function installs a seek address for a precinct whose packets are
; 3191 :          contiguous within the code-stream and have valid pointer information
; 3192 :          stored in PLT marker segments.  Subsequent calls to `is_sequenced'
; 3193 :          will return true.  The precinct itself may either be open or closed
; 3194 :          when this function is called.  The `pos_idx' argument is provided
; 3195 :          for computing the relevance of this precinct to the application.  It
; 3196 :          holds a relative precinct index, having the same interpretation as
; 3197 :          that passed to `kd_precinct::initialize' and `kdu_precinct_ref::open'.
; 3198 :             It can happen that this function causes the tile, and hence the
; 3199 :          precinct reference, to be destroyed.  This happens if the call to
; 3200 :          this function renders the resolution or tile completely parsed,
; 3201 :          and it is known that the application has no need for any further
; 3202 :          access to the tile.  In this case, and only in this case, the
; 3203 :          function returns false, meaning that the caller must not make
; 3204 :          any further attempt to access the tile or any of its resources. */
; 3205 :   private: // Utility functions
; 3206 :     kd_precinct *instantiate_precinct(kd_resolution *res, kdu_coords pos_idx);
; 3207 :       /* Called from `open' if the `kd_precinct' object is not in memory at
; 3208 :          the time and can legitimately be created at this point. */
; 3209 :   private: // Data
; 3210 :     kdu_long state;
; 3211 :   };
; 3212 :   /* Notes:
; 3213 :         `state' holds 0 if no information is yet available concerning the
; 3214 :      precinct associated with this reference.
; 3215 :         If the precinct is currently active in memory, `state' holds the
; 3216 :      address in memory (pointer) of the `kd_precinct' structure.
; 3217 :         If the precinct is known to be addressable, `state' holds an odd
; 3218 :      integer, equal to 4*A + 2*P + 1, where A is the precinct's
; 3219 :      `unique_address' value and P is a flag, equal to 1 if the precinct
; 3220 :      has been loaded and parsed previously.
; 3221 :         The `unique_address' value has the same definition as the
; 3222 :      corresponding data member in `kd_precinct'.
; 3223 :         This P flag plays the same role as the KD_PFLAG_PARSED bit in
; 3224 :      `kd_precinct::flags'.  It is used to avoid collecting layer size
; 3225 :      statistics twice for the same precinct which could otherwise happen
; 3226 :      when precincts get swapped in and out of memory on demand.
; 3227 :         A value of `state'=1 means that the precinct can be re-instantiated,
; 3228 :      but that it is known to contain no packets whatsoever.
; 3229 :         If a previously active precinct's resources have been recycled and
; 3230 :      re-loading is not possible, `state' is assigned the special value of 3. */
; 3231 : 
; 3232 : /*****************************************************************************/
; 3233 : /*                               kd_leaf_node                                */
; 3234 : /*****************************************************************************/
; 3235 : 
; 3236 : struct kd_leaf_node {
; 3237 :     public: // Data
; 3238 :       kd_node *parent; // Every leaf node has a non-leaf parent node
; 3239 :       kd_resolution *resolution; // Always points to the owning resolution
; 3240 :       kdu_dims dims; // Dimensions & location of the image at this node
; 3241 :       kdu_dims region; // See below
; 3242 :       kdu_byte branch_x, branch_y; // See below
; 3243 :       bool is_leaf; // False if this object is the base of `kd_node'
; 3244 :   };
; 3245 :   /* Notes:
; 3246 :         This structure is the base of the richer `kd_node' structure.  The
; 3247 :      key difference is that leaf nodes have no children, so we do not waste
; 3248 :      storage recording pointers to them.
; 3249 :         The `branch_x' and `branch_y' members describe how this node is
; 3250 :      derived from its parent node, if any.  `branch_x' holds 0 if horizontal
; 3251 :      low-pass filtering and decimation were used to obtain the node from its
; 3252 :      parent; it holds 1 if horizontal high-pass filtering and decimation were
; 3253 :      used; it holds 2 if no filtering or decimation were involved in the
; 3254 :      horizontal direction.  `branch_y' plays a similar role in describing the
; 3255 :      vertical filtering and decimation processes.  If `parent' is NULL,
; 3256 :      the `branch_x' and `branch_y' members have no meaning.
; 3257 :         This structure manages two different, yet related regions
; 3258 :      (location, plus dimensions) which deserve some explanation here.
; 3259 :      * The `dims' member serves the usual role of identifying the location and
; 3260 :        dimensions of the image, as it appears on entry into this node,
; 3261 :        during forward transformation (analysis).  For primary nodes,
; 3262 :        these are the dimensions and location of the tile-component-resolution
; 3263 :        within its canvas.
; 3264 :      * `region' identifies a subset of the `dims' region, containing
; 3265 :        all of the node's samples which are involved in the synthesis of the
; 3266 :        current region of interest, as specified in the most recent call to
; 3267 :        `kdu_codestream::apply_input_restrictions'. */
; 3268 : 
; 3269 : /*****************************************************************************/
; 3270 : /*                                 kd_node                                   */
; 3271 : /*****************************************************************************/
; 3272 : 
; 3273 : struct kd_node : public kd_leaf_node {
; 3274 :     public: // Member functions
; 3275 :       void adjust_cover(kdu_dims child_cover,
; 3276 :                         int child_branch_x, int child_branch_y);
; 3277 :         /* This function is used to find the `region_cover' members.  In
; 3278 :            a downward sweep through the decomposition branches associated
; 3279 :            with a given resolution level, the `region_cover' members are all
; 3280 :            set to empty regions.  We then assign each leaf node (subband)
; 3281 :            a region cover (not actually recorded in the leaf node) equal to
; 3282 :            its region of interest and work back up the tree from the
; 3283 :            leaves to the primary node of the resolution in question, calling
; 3284 :            this function to grow the region cover so as to encompass the
; 3285 :            smallest region which covers each of its children. */
; 3286 :     public: // Data
; 3287 :       kdu_dims region_cover; // See below
; 3288 :       kdu_dims prec_dims; // Temp storage for calculating precinct dimensions
; 3289 :       kd_leaf_node *children[4]; // Indexed by `LL_BAND' through `HH_BAND'
; 3290 :       kdu_byte num_hor_steps, num_vert_steps; // See below
; 3291 :       kdu_uint16 num_descendant_nodes;
; 3292 :       kdu_uint16 num_descendant_leaves;
; 3293 :       float *bibo_gains; // See below
; 3294 :   };
; 3295 :   /* Notes:
; 3296 :         This object is used to construct descriptions of all non-leaf
; 3297 :      nodes in the DWT decomposition structure.  Each node in the structure
; 3298 :      may be decomposed horizontally, vertically or both.  If it is decomposed
; 3299 :      in the horizontal direction, `children[HL_BAND]' will be non-NULL.  If it
; 3300 :      is decomposed in the vertical direction, `children[LH_BAND]' will be
; 3301 :      non-NULL.  If it is decomposed in both directions, `children[HH_BAND]'
; 3302 :      will also be non-NULL.  If it is decomposed at all, `children[LL_BAND]'
; 3303 :      will always be non-NULL.
; 3304 :         The decomposition structure consists of a collection of primary
; 3305 :      nodes, each of which is embedded within a `kd_resolution' object.
; 3306 :      In the case of the simple Mallat structure, each primary node has
; 3307 :      4 children, with the LL child embedded within the next lower
; 3308 :      resolution object and the remaining children embedded within
; 3309 :      `kd_subband' objects.  In wavelet packet decomposition structures,
; 3310 :      detail subbands produced by a primary node may, themselves, be
; 3311 :      decomposed further into subbands.
; 3312 :         The actual object pointed to by each non-NULL member of the `children'
; 3313 :      array may need to be cast to type `kd_node', rather than `kd_leaf_node'
; 3314 :      if the `kd_leaf_node::is_leaf' member is false.
; 3315 :         The `children[LL_BAND]' entry of a primary node always points to
; 3316 :      the node which is embedded within the next lower resolution
; 3317 :      `kd_resolution' object, except at the lowest resolution of all.
; 3318 :      The lowest `kd_resolution' object's embedded node has only one
; 3319 :      child, with `children[LL_BAND]' pointing to the single (LL) subband
; 3320 :      belonging to that resolution.
; 3321 :         The `num_hor_steps' and `num_vert_steps' members identify the number
; 3322 :      of horizontal and vertical lifting steps associated with the horizontal
; 3323 :      and vertical transform operations applied at this node to produce its
; 3324 :      children.  One or both of these may be 0, either because the transform
; 3325 :      is trivial (lazy wavelet) or because the node is split only in the
; 3326 :      horizontal direction, only in the vertical direction, or is not split
; 3327 :      at all.
; 3328 :         The `num_descendant_nodes' member holds a count of the total number
; 3329 :      of nodes (leaf nodes and non-leaf nodes) which may be reached via the
; 3330 :      `children' array.  The `num_descendant_leaves' member holds a count of
; 3331 :      the number of these descendant nodes which are leaves.  Neither of these
; 3332 :      counts includes the current node.  Clearly there is no need to
; 3333 :      maintain this information with leaf nodes, since the counts would both
; 3334 :      be 0 in this case.
; 3335 :         The `bibo_gains' member point to an array with
; 3336 :      2+`num_hor_steps'+`num_vert_steps' entries.  The first 1+`num_hor_steps'
; 3337 :      entries describe BIBO gains for the horizontal transform performed
; 3338 :      at this node.  The remaining `+`num_vert_steps' entries describe BIBO
; 3339 :      gains for the vertical transform performed at this node.  Within each
; 3340 :      of these 2 sets of BIBO gains the first entry holds the BIBO gain from
; 3341 :      the original input image to the image which is presented at the input
; 3342 :      to this node.  Subsequent entries hold the BIBO gains from the original
; 3343 :      input image to the image which is presented at the output of each
; 3344 :      successive analysis lifting step.  Al BIBO gains are assessed relative to
; 3345 :      the nominal transform normalization, in which reversible lifting steps
; 3346 :      are applied as-is, while irreversible lifting steps are followed by the
; 3347 :      relevant `kd_tile_comp::low_scale' and `kd_tile_comp::high_scale' values.
; 3348 :         The interpretation of `region_cover' is similar to that of
; 3349 :      `kd_leaf_node::region', with a subtle, yet important twist.  In order to
; 3350 :      reconstruct each sample in `region', it is necessary to decode a
; 3351 :      particular set of samples from the subbands which are associated with
; 3352 :      this node.  Each of these subband samples has a mapping onto the
; 3353 :      coordinate system associated with the node, following the usual rules of
; 3354 :      the canvas coordinate system.  `res_cover' holds the smallest region
; 3355 :      which contains all of these mapped subband sample locations, except that
; 3356 :      the LL subband branch is included only if this is not a primary node.
; 3357 :      This ensures that the primary node embedded inside each `kd_resolution'
; 3358 :      object will have a `region_cover' which spans the nominal locations of
; 3359 :      all subband samples of interest, which are represented by codestream
; 3360 :      packets associated with that resolution. */
; 3361 : 
; 3362 : /*****************************************************************************/
; 3363 : /*                                kd_subband                                 */
; 3364 : /*****************************************************************************/
; 3365 : 
; 3366 : struct kd_subband : public kd_leaf_node {
; 3367 :     // State structure for the "kdu_subband" interface
; 3368 :   public: // Identification
; 3369 :     kdu_int16 descriptor; // See `cod_params::expand_decomp_bands'
; 3370 :     kdu_byte orientation; // One of LL_BAND, HL_BAND, LH_BAND or HH_BAND.
; 3371 :                      // This is the orientation of the primary subband from
; 3372 :                      // which we are derived within the same resolution level.
; 3373 :     kdu_byte sequence_idx; // Index within the `kd_resolution::subbands' array
; 3374 :                      // This is also the order in which subbands contribute
; 3375 :                      // code-blocks to codestream packets.
; 3376 :     kdu_byte transpose_sequence_idx; // Index of the real subband which appears
; 3377 :                       // to have this `sequence_idx' value when
; 3378 :                       // `kdu_codestream::change_appearance' has been used to
; 3379 :                       // transpose the codestream's appearance.
; 3380 :   public: // Dimensions and Parameters
; 3381 :     kdu_byte epsilon; // Ranging parameter.
; 3382 :     kdu_byte K_max; // Maximum magnitude bit-planes, not including ROI upshift
; 3383 :     kdu_byte K_max_prime; // Max magnitude bit-planes, including ROI upshift
; 3384 :     float delta; // Step size, normalized for image data range of -0.5 to 0.5
; 3385 :     float G_b; // Subband energy gain factor.
; 3386 :     float W_b; // Subband amplitude weight; needs squaring to get energy weight
; 3387 :     float roi_weight; // Extra amplitude weight for ROI foreground blocks.
; 3388 :     kdu_dims block_partition; // Holds the coding origin and dimensions.
; 3389 :     kdu_dims block_indices; // Holds the range of valid block indices.
; 3390 :     kdu_dims region_indices;  // Same as `block_indices', but restricted to
; 3391 :                               // blocks which overlap the region of interest.
; 3392 :     kdu_coords blocks_per_precinct; // precinct size / block size
; 3393 :     kdu_coords log2_blocks_per_precinct; // log2 of precinct size/block size
; 3394 :   };
; 3395 :   /* Notes:
; 3396 :         It may come as a surprise to notice that this object has no
; 3397 :      direct connection to code-blocks.  To access a code-block, the object
; 3398 :      first determines the precinct to which it belongs, creating that
; 3399 :      precinct if necessary; this, in turn, creates its precinct-bands and
; 3400 :      the associated code-blocks.  In this way, no memory whatsoever need be
; 3401 :      dedicated to code-blocks which lie in unaccessed precincts. */
; 3402 : 
; 3403 : /*****************************************************************************/
; 3404 : /*                              kd_resolution                                */
; 3405 : /*****************************************************************************/
; 3406 : 
; 3407 : struct kd_resolution { // State structure for the "kdu_resolution" interface
; 3408 :   public: // Member functions
; 3409 :     kd_resolution()
; 3410 :       {
; 3411 :         codestream = NULL; tile_comp = NULL; rescomp = NULL;
; 3412 :         precinct_refs = NULL; subbands = subband_handle = NULL; num_subbands=0;
; 3413 :         num_intermediate_nodes = 0; intermediate_nodes = NULL;
; 3414 :         can_flip = true;  node.bibo_gains = NULL;
; 3415 :       }
; 3416 :     ~kd_resolution()
; 3417 :       {
; 3418 :         if (node.bibo_gains != NULL) delete[] node.bibo_gains;
; 3419 :         for (int n=0; n < (int) num_intermediate_nodes; n++)
; 3420 :           if (intermediate_nodes[n].bibo_gains != NULL)
; 3421 :             delete[] intermediate_nodes[n].bibo_gains;
; 3422 :         if (precinct_refs != NULL) delete[] precinct_refs;
; 3423 :         if (subband_handle != NULL) delete[] subband_handle;
; 3424 :         if (intermediate_nodes != NULL) delete[] intermediate_nodes;
; 3425 :       }
; 3426 :     void build_decomposition_structure(kdu_params *coc, kdu_kernels &kernels);
; 3427 :       /* This function creates the `subbands' and `intermediate_nodes'
; 3428 :          arrays and fills in all the relevant pointers.  It uses `kernels'
; 3429 :          to create and fill in the `kdu_node::hor_bibo_gains' and
; 3430 :          `kdu_node::vert_bibo_gains' arrays, where required. */
; 3431 :     void complete_initialization();
; 3432 :       /* Called from within `kd_tile::initialize' to finish the initialization
; 3433 :          process, after all of the key parameters have been set.  Currently,
; 3434 :          the only task performed here is the initialization of the
; 3435 :          `max_blocks_per_precinct' member. */
; 3436 :   public: // Links and Identification
; 3437 :     kd_codestream *codestream;
; 3438 :     kd_tile_comp *tile_comp;
; 3439 :     kd_global_rescomp *rescomp;
; 3440 :     kdu_byte res_level; // Runs from 0 (LL band) to `num_dwt_levels'
; 3441 :     kdu_byte dwt_level; // Runs from `num_dwt_levels' (res level 0 and 1) to 1
; 3442 :     kdu_byte hor_depth; // From relevant entry of `kd_comp_info::hor_depth'
; 3443 :     kdu_byte vert_depth; // From relevant entry of `kd_comp_info::vert_depth'
; 3444 : 
; 3445 :   public: // Embedded node
; 3446 :     kd_node node; // Each resolution is a primary node in the decomposition
; 3447 : 
; 3448 :   public: // Dimensions and Parameters
; 3449 :     kdu_dims precinct_partition; // Holds the coding origin and dimensions.
; 3450 :     kdu_dims precinct_indices; // Holds the range of valid precinct indices.
; 3451 :     kdu_dims region_indices; // Holds range of indices for precincts whose
; 3452 :                              // code-blocks contribute to region of interest.
; 3453 :   public: // Derived quantities
; 3454 :     int max_blocks_per_precinct; // See discussion under `kd_precinct_band'
; 3455 :     bool propagate_roi; // True if ROI masks to be propagated to descendants
; 3456 : 
; 3457 :     bool can_flip; // Set to false if this level contains subband decomposition
; 3458 :                    // styles which are incompatible with view flipping.
; 3459 : 
; 3460 :   public: // Arrays
; 3461 :     kdu_byte num_subbands; // Excludes the LL band unless `res_level'=0
; 3462 :     kdu_byte num_intermediate_nodes; // Enough for all non-leaf nodes descended
; 3463 :                                  // from the primary node in this object.
; 3464 :     kd_node *intermediate_nodes; // Array with `num_intermediate_nodes' entries
; 3465 :     kd_precinct_ref *precinct_refs;
; 3466 :     kd_subband *subbands; // Points to `subband_store' or `subband_handle'.
; 3467 :     kd_subband *subband_handle; // For dynamically allocated subbands
; 3468 :     kd_subband subband_store[3]; // Avoid dynamic allocation for common case
; 3469 : 
; 3470 :   public: // Flags and Other State Variables
; 3471 :     kdu_coords current_sequencer_pos; // Used by `kd_packet_sequencer'.
; 3472 :     kdu_coords saved_current_sequencer_pos; // For saving the sequencer state
; 3473 :   };
; 3474 :   /* Notes:
; 3475 :         The `current_sequencer_pos' coordinates are used to sequence
; 3476 :      spatially oriented packet progressions.  They maintain the
; 3477 :      indices (starting from [0,0], rather than `precinct_indices.pos')
; 3478 :      of the precinct which is currently being sequenced.
; 3479 :         The `region_indices' member holds the smallest range of precinct
; 3480 :      indices, such that the code-blocks contained within these precincts
; 3481 :      are sufficient to reconstruct all samples inside `node.region'.
; 3482 :      Equivalently, the range in `precinct_indices' yields the set of
; 3483 :      precincts which intersect with `node.region_cover'.
; 3484 :         It is worth noting that the area of intersection between each
; 3485 :      precinct's region on the resolution and the `node.region_cover' region
; 3486 :      is used to compute the information returned by
; 3487 :      `kdu_resolution::get_precinct_relevance'. */
; 3488 : 
; 3489 : /*****************************************************************************/
; 3490 : /*                             kd_header_in                                  */
; 3491 : /*****************************************************************************/
; 3492 : 
; 3493 : class kd_header_in {
; 3494 :   /* Manages the reading of packet header bytes from the code-stream, along
; 3495 :      with bit stuffing and unpacking. */
; 3496 :   public: // Member functions
; 3497 :     kd_header_in(kd_input *source)
; 3498 :       { this->source = source; bits_left=0; byte=0; header_bytes=0; }
; 3499 :     int get_bit() // throws its own "this" pointer if the source is exhausted.
; 3500 :       {
; 3501 :         if (bits_left==0)
; 3502 :           {
; 3503 :             bits_left = (byte==0xFF)?7:8;
; 3504 :             if (!source->get(byte))
; 3505 :               { bits_left = 0; throw this; }
; 3506 :             header_bytes++;
; 3507 :           }
; 3508 :         bits_left--;
; 3509 :         return (byte >> bits_left) & 1;
; 3510 :       }
; 3511 :     kdu_uint32 get_bits(int num_bits) // thorws(kd_header_in *)
; 3512 :       { kdu_uint32 result = 0;
; 3513 :         while (num_bits > 0)
; 3514 :           {
; 3515 :             if (bits_left==0)
; 3516 :               {
; 3517 :                 bits_left = (byte==0xFF)?7:8;
; 3518 :                 if (!source->get(byte))
; 3519 :                   { bits_left = 0; throw this; }
; 3520 :                 header_bytes++;
; 3521 :               }
; 3522 :             int xfer_bits = (num_bits<bits_left)?num_bits:bits_left;
; 3523 :             bits_left -= xfer_bits;
; 3524 :             num_bits -= xfer_bits;
; 3525 :             result <<= xfer_bits;
; 3526 :             result |= ((byte >> bits_left) & ~(0xFF << xfer_bits));
; 3527 :           }
; 3528 :         return result;
; 3529 :       }
; 3530 :     int finish()
; 3531 :       { // Call this when the header is all read, to consume any stuffing byte
; 3532 :         // Returns total header length
; 3533 :         if ((bits_left == 0) && (byte == 0xFF))
; 3534 :           {
; 3535 :             bits_left = 7;
; 3536 :             if (!source->get(byte))
; 3537 :               throw this;
; 3538 :             header_bytes++;
; 3539 :           }
; 3540 :         return header_bytes;
; 3541 :       }
; 3542 :   private: // Data
; 3543 :     kd_input *source; // Provides the input mechanism.
; 3544 :     kdu_byte byte;
; 3545 :     int bits_left;
; 3546 :     int header_bytes;
; 3547 :   };
; 3548 : 
; 3549 : /*****************************************************************************/
; 3550 : /*                                kd_header_out                              */
; 3551 : /*****************************************************************************/
; 3552 : 
; 3553 : class kd_header_out {
; 3554 :   /* Manages the simulated and real output of packet header bytes. */
; 3555 :   public: // Member functions
; 3556 :     kd_header_out(kdu_output *out=NULL) // Null for simulating header
; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }
; 3558 :     void put_bit(int bit)
; 3559 :       { // Output a header bit
; 3560 :         assert(bit == (bit & 1));
; 3561 :         if (bits_left == 0)
; 3562 :           { if (out != NULL) out->put(byte);
; 3563 :             completed_bytes++;
; 3564 :             bits_left = (byte==0xFF)?7:8;
; 3565 :             byte = 0; }
; 3566 :         byte += byte + bit;
; 3567 :         bits_left--;
; 3568 :       }
; 3569 :     void put_bits(kdu_int32 val, int num_bits)
; 3570 :       { // Output the least significant `num_bits' of `val'
; 3571 :         while (num_bits > 0)
; 3572 :           put_bit((val >> (--num_bits)) & 1);
; 3573 :       }
; 3574 :     int finish()
; 3575 :       { // Returns the total number of bytes consumed by the packet header.
; 3576 :         if (bits_left < 8)
; 3577 :           {
; 3578 :             byte <<= bits_left;
; 3579 :             if (out != NULL)
; 3580 :               out->put(byte);
; 3581 :             completed_bytes++;
; 3582 :             if (byte == 0xFF)
; 3583 :               { // Need the stuffing byte.
; 3584 :                 if (out != NULL)
; 3585 :                   out->put((kdu_byte) 0);
; 3586 :                 completed_bytes++;
; 3587 :               }
; 3588 :           }
; 3589 :         return completed_bytes;
; 3590 :       }
; 3591 :   private: // Data
; 3592 :     kdu_byte byte;
; 3593 :     int bits_left;
; 3594 :     int completed_bytes;
; 3595 :     kdu_output *out;
; 3596 :   };
; 3597 : 
; 3598 : /*****************************************************************************/
; 3599 : /*                                 kd_block                                  */
; 3600 : /*****************************************************************************/
; 3601 : 
; 3602 : class kd_block {
; 3603 :   /* For a very small size (only 24 bytes on 32-bit machines), this class
; 3604 :      defines a lot of member functions!. */
; 3605 :   // --------------------------------------------------------------------------
; 3606 :   public: // Lifecycle member functions
; 3607 :     void cleanup(kd_buf_server *buf_server)
; 3608 :       {
; 3609 :         while ((current_buf=first_buf) != NULL)
; 3610 :           { first_buf=current_buf->next;  buf_server->release(current_buf); }
; 3611 :         set_discard(); // Discard from any packets parsed in the future
; 3612 :       }
; 3613 :     kd_code_buffer *cleanup()
; 3614 :       { // As above, but returns the linked list of buffers
; 3615 :         kd_code_buffer *result = first_buf;  first_buf = current_buf = NULL;
; 3616 :         set_discard();
; 3617 :         return result;
; 3618 :       }
; 3619 : 
; 3620 :   // --------------------------------------------------------------------------
; 3621 :   public: // Packet manipulation member functions
; 3622 :     int parse_packet_header(kd_header_in &head, kd_buf_server *buf_server,
; 3623 :                             int layer_idx); // Throws (kdu_uint16 code)
; 3624 :       /* Parses bits in the packet header corresponding to the current
; 3625 :          block for the current layer (this must be the next layer for which
; 3626 :          information has not yet been parsed).  The function returns the
; 3627 :          number of new body bytes contributed by the code-block in this layer
; 3628 :          and also stores this value internally to be used in subsequent calls
; 3629 :          to the `read_body_bytes' member function.
; 3630 :             The `kd_header_in' object may throw an exception if the packet
; 3631 :          data terminates unexpectedly.  Moreover, to assist in locating and
; 3632 :          possibly recovering from errors, the present function may throw a
; 3633 :          16-bit unsigned integer exception code, which is either the value of
; 3634 :          an illegal marker code encountered in the packet header, or one of
; 3635 :          the special exception codes, KDU_EXCEPTION_PRECISION or
; 3636 :          KDU_EXCEPTION_ILLEGAL_LAYER. */
; 3637 :     void read_body_bytes(kd_input *source, kd_buf_server *buf_server,
; 3638 :                          bool in_memory_source)
; 3639 :       { /* This function should be called after parsing the header of a
; 3640 :            packet.  It reads the code-bytes contributed by the code-block to
; 3641 :            this packet.  If `in_memory_source' is true, only the address of
; 3642 :            the code-bytes is recorded, and then only if the length of the
; 3643 :            code-byte segment is non-zero. */
; 3644 :         if (this->temp_length > 0)
; 3645 :           {
; 3646 :             if (num_passes == 255)
; 3647 :               { // Read and discard the code-bytes.
; 3648 :                 assert(first_buf == NULL);  source->ignore(this->temp_length);
; 3649 :               }
; 3650 :             else if (in_memory_source)
; 3651 :               {
; 3652 :                 kdu_byte *addr;
; 3653 :                 this->num_bytes += source->pseudo_read(addr,this->temp_length);
; 3654 :                 put_address(addr,buf_server);
; 3655 :               }
; 3656 :             else
; 3657 :               this->num_bytes +=
; 3658 :                 source->read(current_buf,buf_pos,buf_server,this->temp_length);
; 3659 :             this->temp_length = 0;
; 3660 :           }
; 3661 :       }
; 3662 :     void retrieve_data(kdu_block *block, int max_layers, int discard_passes,
; 3663 :                        bool in_memory_source);
; 3664 :       /* Retrieves compressed code-bytes, number of coding passes and codeword
; 3665 :          segment lengths from the current code-block and stores them in the
; 3666 :          `block' object.  All fields which are common for compression and
; 3667 :          decompression have already been filled out by the caller.  The
; 3668 :          byte buffer is allocated so as to be large enough to allow a
; 3669 :          2 byte marker code to be appended to the compressed data,
; 3670 :          if desired -- see declaration of "kdu_subband::open_block".
; 3671 :             The `max_layers' argument identifies the maximum number of
; 3672 :          quality layers for which code-block contributions are to be
; 3673 :          retrieved.
; 3674 :             The `discard_passes' argument indicates the number of additional
; 3675 :          coding passes to be removed, if any.
; 3676 :             If `in_memory_source' is true, the layer code bytes are not
; 3677 :          stored in the `kd_code_buffer' list embedded inside `block'.  Instead,
; 3678 :          the `kd_code_buffer' list stores only the header information for
; 3679 :          each layer, along with the address of the code bytes, which reside
; 3680 :          in the memory block managed by an in-memory compressed data source
; 3681 :          (one which offers the `KDU_SOURCE_CAP_IN_MEMORY') capability.  In
; 3682 :          this case, we retrieve the address and then perform a simple memory
; 3683 :          block copy operation to efficiently retrieve the code bytes for
; 3684 :          each layer. */
; 3685 :     void store_data(kdu_block *block, kd_buf_server *buf_server);
; 3686 :       /* Stores compressed code-bytes, pass length and pass slope information
; 3687 :          from the `block' object into the current code-block.  This function
; 3688 :          is invoked by "kdu_subband::close_block" when the containing
; 3689 :          codestream object was not constructed for input.  Also reflects
; 3690 :          the `msbs_w' value into higher nodes in the tag tree. */
; 3691 :     void store_data(kdu_block *block, kd_thread_buf_server *thread_buf_server);
; 3692 :       /* Same as the above function, but uses `kd_thread_buf_server::get'
; 3693 :          rather than `kd_buf_server::get' to get new code buffers.  This
; 3694 :          version is used to save code-block state in multi-threaded
; 3695 :          environments so as to minimize cache coherency bottlenecks and the
; 3696 :          need to lock shared resources. */
; 3697 :     void transfer_data(kd_block &src)
; 3698 :       { /* Like `store_data', but gets results from another block.  Exploits
; 3699 :            the layout of the object to copy only whole pointers or whole
; 3700 :            32-bit words, even where these represent multiple fields. */
; 3701 :         current_buf = first_buf = src.first_buf;
; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);
; 3703 :         src.current_buf = src.first_buf = NULL;
; 3704 :       }
; 3705 :     bool trim_data(kdu_uint16 slope_threshold, kd_buf_server *buf_server);
; 3706 :       /* This function serves two purposes: it helps reduce the amount of
; 3707 :          compressed data which must be buffered in memory while compressing
; 3708 :          an image; and it allows individual block contributions to be
; 3709 :          discarded during packet construction in order to tightly fit the
; 3710 :          generated bit-rate to the target compressed bit-rate.
; 3711 :             The function sets all coding pass slopes which are less than or
; 3712 :          equal to the supplied slope threshold to 0 and then discards all
; 3713 :          code bytes which could not possibly be included in the final
; 3714 :          code-stream, as a result of this modification.
; 3715 :             If anything was discarded, the function returns true.  Otherwise,
; 3716 :          it returns false. */
; 3717 :     int start_packet(int layer_idx, kdu_uint16 slope_threshold);
; 3718 :       /* Call this function only during rate allocation or packet generation.
; 3719 :          Before the first call to this function, you must reset the tag tree
; 3720 :          (see the "reset_output_tree" member function).  If you are calling
; 3721 :          the function multiple times with the same layer for rate allocation
; 3722 :          purposes, you must use "save_output_tree" and "restore_output_tree"
; 3723 :          as described below.
; 3724 :             The function leaves behind information about the number of new
; 3725 :          coding passes and the number of new code bytes which would be
; 3726 :          contributed by this code-block if the supplied threshold were actually
; 3727 :          used.  The final contributing coding pass must have a non-zero
; 3728 :          distortion-length slope which is strictly greater than the slope
; 3729 :          threshold.  It also updates the tag tree structure to reflect any
; 3730 :          new knowledge about the first layer to which this code-block would
; 3731 :          contribute.  This information is picked up by "write_packet_header".
; 3732 :             The function's return value is the total number of new code-bytes
; 3733 :          contributed by the block.  This allows the PCRD-opt algorithm to
; 3734 :          determine roughly the right slope threshold before committing to the
; 3735 :          work of simulating packet header generation. */
; 3736 :     void write_packet_header(kd_header_out &head, int layer_idx,
; 3737 :                              bool simulate);
; 3738 :       /* Call this function only after a `start_packet' call.  It writes
; 3739 :          (or simulates the writing of) packet header information corresponding
; 3740 :          to the code-block inclusion information set up by `start_packet'.
; 3741 :          If `simulate' is true, some internal state adjustments are delayed
; 3742 :          until the next call to "save_output_tree", so multiple calls to
; 3743 :          "start_packet" and "write_packet_header" may be issued with the same
; 3744 :          layer index to determine an optimal slope threshold.  Otherwise,
; 3745 :          if `simulate' is false, the internal state information is fully
; 3746 :          updated and the "save_output_tree" and "restore_output_tree" functions
; 3747 :          need not and should not be called. */
; 3748 :     void write_body_bytes(kdu_output *dest);
; 3749 :       /* This function should be called after a non-simulated
; 3750 :          "write_packet_header" call to output the newly included body bytes.
; 3751 :          The actual number of bytes to be written was left behind by
; 3752 :          the preceding "start_packet" call in the `temp_length' field. */
; 3753 :   // --------------------------------------------------------------------------
; 3754 :   public: // Static functions used to operate on tag-trees built from kd_block
; 3755 :     static kd_block *build_tree(kdu_coords size, kdu_byte * &mem_block);
; 3756 :       /* Builds a full tag tree returning a pointer to the upper left hand
; 3757 :          corner leaf node.  Apart from the `up_down' navigation pointers,
; 3758 :          all fields are initialized to 0.  This is appropriate for tag tree
; 3759 :          decoding, but encoders will need to call "reset_output_tree" and
; 3760 :          use "start_packet" to install appropriate node values.
; 3761 :             The tag tree is not allocated from the heap.  Instead, it is
; 3762 :          allocated from an existing memory block, identified by the `mem_block'
; 3763 :          argument.  This memory block is assumed to be large enough to hold
; 3764 :          the array of `kd_block' structures.  Upon return, the `mem_block'
; 3765 :          value is advanced by an amount equal to the size of the tag tree
; 3766 :          array. */
; 3767 :     static void reset_output_tree(kd_block *tree, kdu_coords size);
; 3768 :       /* Call this function immediately before simulating or actually
; 3769 :          generating any packet data for the relevant code-blocks.  Once
; 3770 :          the PCRD-opt algorithm has completed, you should call this function
; 3771 :          a second time to prepare for actual packet output.  The function
; 3772 :          initializes the threshold state variables, `layer_w_bar' and
; 3773 :          `msbs_w_bar' to 0, and the value state variables, `layer_w' and
; 3774 :          `msbs_w' to their maximum representable values.  The succession of
; 3775 :          "start_packet" calls will update the value variables `layer_w'
; 3776 :          and `msbs_w' in such a way that the tag tree coding process runs
; 3777 :          correctly in each subsequent call to "write_packet_header". */
; 3778 :     static void save_output_tree(kd_block *tree, kdu_coords size);
; 3779 :       /* Call this only during rate allocation, before moving on to a new
; 3780 :          layer.  The function saves the current state (`msbs_wbar' and
; 3781 :          `layer_wbar') of each node in the tag tree.  For leaf nodes, it also
; 3782 :          commits the number of new coding passes found in the last call to
; 3783 :          "start_packet". */
; 3784 :     static void restore_output_tree(kd_block *tree, kdu_coords size);
; 3785 :       /* Call this during rate allocation before supplying a new slope
; 3786 :          threshold for the same layer index, in a new "start_packet" call.
; 3787 :          The function restores the `msbs_w_bar' and `layer_w_bar' values
; 3788 :          previously saved by "save_output_tree". */
; 3789 :   // --------------------------------------------------------------------------
; 3790 :   public: // State identification functions
; 3791 :     void set_discard()
; 3792 :       { /* Use this function only with input-oriented operations.  It informs
; 3793 :            the object that none of the code-blocks associated with this
; 3794 :            block will ever be accessed, so that it is free to skip over them
; 3795 :            when reading a packet.  This can save a lot of memory if you have
; 3796 :            a defined region of interest for decompression. */
; 3797 :         num_passes = 255;
; 3798 :       }
; 3799 :     bool empty()
; 3800 :       { // Returns true if the block has no code-bytes yet.
; 3801 :         return first_buf == NULL;
; 3802 :       }
; 3803 :     void set_modes(int modes)
; 3804 :       {
; 3805 :         assert(modes == (modes & 0xFF));
; 3806 :         this->modes = (kdu_byte) modes;
; 3807 :       }
; 3808 :   // --------------------------------------------------------------------------
; 3809 :   private: // Convenience functions for transferring data to/from code buffers.
; 3810 :     void start_buffering(kd_buf_server *buf_server) // Call before `put_byte'
; 3811 :       { assert(first_buf == NULL);
; 3812 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3813 :     void start_buffering(kd_thread_buf_server *buf_server)
; 3814 :       { assert(first_buf == NULL);
; 3815 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3816 :     void put_byte(kdu_byte val, kd_buf_server *buf_server)
; 3817 :       {
; 3818 :         assert(current_buf != NULL);
; 3819 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3820 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3821 :         current_buf->buf[buf_pos++] = val;
; 3822 :       }
; 3823 :     void put_word(int val, kd_buf_server *buf_server)
; 3824 :       {
; 3825 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3826 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))
; 3827 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3828 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;
; 3829 :         buf_pos += 2;
; 3830 :       }
; 3831 :     void put_address(kdu_byte *addr, kd_buf_server *buf_server)
; 3832 :       {
; 3833 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3834 :         if (buf_pos > (KD_CODE_BUFFER_LEN-KDU_POINTER_BYTES))
; 3835 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3836 : 
; 3837 :         ((kdu_byte **)(current_buf->buf+buf_pos))[0] = addr;
; 3838 :         buf_pos += KDU_POINTER_BYTES;
; 3839 :       }
; 3840 :     void put_byte(kdu_byte val, kd_thread_buf_server *buf_server)
; 3841 :       {
; 3842 :         assert(current_buf != NULL);
; 3843 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3844 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3845 :         current_buf->buf[buf_pos++] = val;
; 3846 :       }
; 3847 :     void put_word(int val, kd_thread_buf_server *buf_server)
; 3848 :       {
; 3849 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3850 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))
; 3851 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3852 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;
; 3853 :         buf_pos += 2;
; 3854 :       }
; 3855 :     void put_address(kdu_byte *addr, kd_thread_buf_server *buf_server)
; 3856 :       {
; 3857 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3858 :         if (buf_pos > (KD_CODE_BUFFER_LEN-KDU_POINTER_BYTES))
; 3859 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3860 : 
; 3861 :         ((kdu_byte **)(current_buf->buf+buf_pos))[0] = addr;
; 3862 :         buf_pos += KDU_POINTER_BYTES;
; 3863 :       }
; 3864 :     kdu_byte get_byte()
; 3865 :       {
; 3866 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3867 :           { buf_pos=0; current_buf=current_buf->next;
; 3868 :             assert(current_buf != NULL); }
; 3869 :         return current_buf->buf[buf_pos++];
; 3870 :       }
; 3871 :     int get_word()
; 3872 :       {
; 3873 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3874 :         buf_pos += 2; // Advance the buffer pointer
; 3875 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3876 :           { buf_pos=2; current_buf=current_buf->next;
; 3877 :             assert(current_buf != NULL); }
; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];
; 3879 :       }
; 3880 :     kdu_byte *get_address()
; 3881 :       {
; 3882 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3883 :         buf_pos += KDU_POINTER_BYTES; // Advance the buffer pointer
; 3884 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3885 :           { buf_pos=KDU_POINTER_BYTES; current_buf=current_buf->next;
; 3886 :             assert(current_buf != NULL); }
; 3887 :         return ((kdu_byte **)(current_buf->buf+buf_pos))[-1];
; 3888 :       }
; 3889 :     void skip_word()
; 3890 :       {
; 3891 :         buf_pos += 2 + (buf_pos & 1); // Align and advance the buffer pointer
; 3892 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3893 :           { buf_pos=2; current_buf=current_buf->next;
; 3894 :             assert(current_buf != NULL); }
; 3895 :       }
; 3896 :     void skip_address()
; 3897 :       {
; 3898 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3899 :         buf_pos += KDU_POINTER_BYTES; // Advance the buffer pointer
; 3900 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3901 :           { buf_pos=KDU_POINTER_BYTES; current_buf=current_buf->next;
; 3902 :             assert(current_buf != NULL); }
; 3903 :       }
; 3904 :   // --------------------------------------------------------------------------
; 3905 :   private: // Data (lots of unions to make it as small as possible!)
; 3906 :     union {
; 3907 :       kd_code_buffer *first_buf;
; 3908 :       kdu_uint16 save_layer_w; // Used for saving non-leaf node state
; 3909 :       };
; 3910 :     union {
; 3911 :       kd_code_buffer *current_buf;
; 3912 :       kdu_uint16 save_layer_wbar; // Used for saving_non-leaf node state
; 3913 :       };
; 3914 :     union {
; 3915 :       kdu_byte buf_pos; // Location of next read/write byte in `current_buf'.
; 3916 :       kdu_byte save_msbs_wbar; // Used for saving non-leaf node state
; 3917 :       };
; 3918 :     kdu_byte msbs_w;
; 3919 :     kdu_byte num_passes;
; 3920 :     kdu_byte pass_idx;
; 3921 :     union {
; 3922 :       kdu_uint16 layer_w; // Used only when `pass_idx'=0
; 3923 :       kdu_uint16 body_bytes_offset; // Used in packet output if `pass_idx' > 0
; 3924 :       kdu_byte save_beta; // Used during output simulation if `pass_idx' > 0
; 3925 :       };
; 3926 :     union {
; 3927 :       kdu_uint16 layer_wbar;
; 3928 :       kdu_uint16 num_bytes; // Used only for input operations
; 3929 :       kdu_byte pending_new_passes; // Used only for output operations
; 3930 :       };
; 3931 :     union {
; 3932 :       kdu_byte msbs_wbar;
; 3933 :       kdu_byte beta;
; 3934 :       };
; 3935 :     kdu_byte modes;
; 3936 :     kdu_uint16 temp_length; // Temporary storage of length quantities.
; 3937 :     kd_block *up_down;
; 3938 :   };
; 3939 :   /* Notes:
; 3940 :         This structure has been designed to provide sufficient state
; 3941 :      information for each code-block to perform packet header parsing as
; 3942 :      well as block encoding and decoding.  For coding purposes, the information
; 3943 :      represented by the structure is generally transferred to or from a
; 3944 :      much less tightly packed representation for speed of execution of the
; 3945 :      block coding routines.  As it stands, the total size of this structure
; 3946 :      should be 24 bytes on a 32-bit architecture. An array of code-blocks is
; 3947 :      maintained by each precinct-band.  The array contains one entry for
; 3948 :      every block in the relevant precinct-band, but also contains additional
; 3949 :      entries to be used as tag-tree nodes.  The total number of such extra
; 3950 :      nodes is about 1/3 the number of code-blocks and should not be a
; 3951 :      significant cause of concern for overall memory consumption. There is
; 3952 :      also substantial benefit to be had by locating the tag tree nodes in
; 3953 :      the same contiguous memory block.  Notice that the structure contains
; 3954 :      no reference back to the precinct-band to which it belongs.  When
; 3955 :      necessary, this reference must be supplied separately to interested
; 3956 :      functions. One consequence of this memory saving step is that the
; 3957 :      object's destructor cannot do anything useful.  It only checks to make
; 3958 :      sure that the explicit `cleanup' function has already been called.
; 3959 :         If a block is to be discarded (since it does not intersect with a
; 3960 :      user-specified region of interest), the `num_passes' field will hold
; 3961 :      the otherwise impossible value, 255.
; 3962 :         The `first_buf', `current_buf' and `buf_pos' fields constitute the
; 3963 :      compressed data buffer management mechanism, which is used to store all
; 3964 :      quantities whose length is unpredictable a priori. In particular, a
; 3965 :      linked list of `kd_code_buffer' structures is provided, which grows on
; 3966 :      demand through access to the codestream object's embedded `buffering'
; 3967 :      object.  Data is stored in these buffers in the following formats:
; 3968 :            * Input Format -- [<layer #> (<#bytes> <#passes> ...)] data [<...
; 3969 :              That is, for each layer to which the code-block makes a non-empty
; 3970 :              contribution, we record first the layer number (2 bytes) and
; 3971 :              then one or more #bytes/#passes pairs.  #bytes is represented
; 3972 :              using 2 bytes, while #passes is represented using only 1 byte.
; 3973 :              There is one such 3 byte pair for each layer and one additional
; 3974 :              3 byte pair for each codeword segment terminating pass which
; 3975 :              is not the final pass contributed in the layer.  In this way,
; 3976 :              sufficient information is provided to recover all termination
; 3977 :              lengths, as well as to build layer associations.  The most
; 3978 :              significant bit of the #bytes field is used as a marker to
; 3979 :              indicate whether or not this is the last such field prior to
; 3980 :              the appearance of the code bytes contributed by that layer.  A
; 3981 :              1 means that there are more fields to go before the code bytes
; 3982 :              appear.
; 3983 :            * In-memory Format --[<layer #>(<#bytes> <#passes>...)] <addr> [<...
; 3984 :              This format is used as an alternative to the Input Format above,
; 3985 :              in the special case when the compressed data source supports the
; 3986 :              `KDU_SOURCE_CAP_IN_MEMORY' capability, so that
; 3987 :              `kd_codestream::in_memory_source' is true.  In this case, the
; 3988 :              "data" field is replaced by the address where the data can be
; 3989 :              found in the memory block managed by the compressed data source.
; 3990 :              Moreover, if the number of code-bytes associated with a layer
; 3991 :              is zero, the <addr> field is missing.
; 3992 :            * Output Format -- [<RD slope> <#bytes>] ... [<RD ...] data
; 3993 :              That is, all of the header information for all coding passes
; 3994 :              appears up front, followed by all of the code bytes associated
; 3995 :              with those coding passes.  The reason for putting all the
; 3996 :              header information up front is that it facilitates the
; 3997 :              identification of appropriate layer contributions by the
; 3998 :              rate control algorithm.  Each coding pass has a 4 byte header,
; 3999 :              with 2 bytes for the distortion-length slope value and 2 bytes
; 4000 :              for the number of code-bytes for the pass.
; 4001 :      The particular format which is used to store data depends upon the
; 4002 :      member functions which are used, since these implicitly determine
; 4003 :      whether the codestream object is being used for input or output.
; 4004 :         The `modes' field holds the block coder mode fields.  Some of these
; 4005 :      are required even for correct packet header parsing, regardless of whether
; 4006 :      the block is to be actually decoded.
; 4007 :         `msbs_w' and `msbs_wbar' are the state information required
; 4008 :      for tag-tree coding of the number of missing MSB's for a code-block
; 4009 :      which is about to make its first non-empty contribution to the
; 4010 :      code-stream. Similarly, `layer_w' and `layer_wbar' hold the state
; 4011 :      information required for tag-tree coding of the layer index in which a
; 4012 :      code-block first contributes to the code-stream.  The operation of
; 4013 :      tag-tree coding and the `w' and `wbar' terminology are explained in
; 4014 :      Section 8.4 of the book by Taubman and Marcellin.
; 4015 :         The `beta' field shares storage with `msbs_wbar'.  This is not
; 4016 :      required until the number of missing MSB's has been encoded or decoded,
; 4017 :      at which point we initialize `beta' to 3 (see the JPEG2000 standard or
; 4018 :      Section 12.5.4 of the book by Taubman and Marcellin).  A useful
; 4019 :      consequence of this behaviour is that `beta' may be tested at any
; 4020 :      point of the packet header encoding or decoding process to determine
; 4021 :      whether or not the code-block has yet contributed to the code-stream
; 4022 :      -- the value will be non-zero if and only if it has done so.
; 4023 :         The `num_bytes' field shares storage with `layer_wbar'.  It
; 4024 :      identifies the total number of bytes included by the code-block in
; 4025 :      all packets read or written so far.  The value is taken to be 0 if
; 4026 :      the code-block has not yet contributed to any packets (`beta'=0),
; 4027 :      during which time the `layer_wbar' state variable is in use.
; 4028 :         The `up_down' field is used to efficiently navigate the tag-tree
; 4029 :      structure.  When the tag tree is not actually being navigated, the
; 4030 :      field points up to the current node's parent in the tag tree.  The
; 4031 :      root mode is readily identified by the fact that it has a NULL `up_down'
; 4032 :      pointer. During navigation, the tag-tree coder first walks from a
; 4033 :      leaf node up to the root, modifying the `up_down' pointers as it goes
; 4034 :      so that each successive parent's `up_down' field points bacl down to the
; 4035 :      child from which the parent was reached.  The coder then walks back down
; 4036 :      from the root to the original leaf node, restoring the `up_down' fields to
; 4037 :      their original `up' state. */
; 4038 : 
; 4039 : /*****************************************************************************/
; 4040 : /*                             kd_precinct_band                              */
; 4041 : /*****************************************************************************/
; 4042 : 
; 4043 : struct kd_precinct_band {
; 4044 :   /* Used to store state information for an element of the precinct partition
; 4045 :      within a single subband.  Once we get down to precincts and ultimately
; 4046 :      code-blocks, we have to be careful not to waste too much memory, since
; 4047 :      an image may have a very large number of these.  Moreover, it may be
; 4048 :      necessary to maintain tag-trees and other state information even for
; 4049 :      precincts which do not lie within our region of interest, so that the
; 4050 :      relevant packet headers can be parsed -- otherwise, we may have no way
; 4051 :      of knowing how to skip over packets which are not interesting to us. */
; 4052 :     kd_subband *subband;
; 4053 :     kdu_dims block_indices; /* Range of code-block indices for this precinct.
; 4054 :         This is a subset of the `block_indices' specified by the `subband'. */
; 4055 :     kd_block *blocks;
; 4056 :   };
; 4057 :   /* Notes:
; 4058 :      In order to make the representation of this object as efficient as
; 4059 :      possible, the two tag trees and all additional information required to
; 4060 :      correctly parse packet headers is maintained within the code-block
; 4061 :      array itself.  The `blocks' array consists of one element for each
; 4062 :      code-block, organized in raster fashion, plus additional elements to
; 4063 :      represent higher nodes in the tag-tree structure.  See the comments
; 4064 :      associated with the definition of `kd_block' for more information on
; 4065 :      this.
; 4066 :         In practice, the `blocks' array is not allocated separately on the
; 4067 :      heap.  Instead, the block of memory allocated to hold the `kd_precinct'
; 4068 :      structure is augmented by an amount sufficient to hold all of the
; 4069 :      code-blocks for all of the subbands in the precinct.  This is
; 4070 :      accomplished by the custom `kd_precinct::new' operator, which is
; 4071 :      informed of the maximum number of code-blocks required by any precinct
; 4072 :      within the containing `kd_resolution' object.  This value is maintained
; 4073 :      by the `kd_resolution::max_blocks_per_precinct" data member.  The
; 4074 :      `blocks' fields are initialized to the NULL state by the
; 4075 :      `kd_precinct::initialize' member function and are later set to point
; 4076 :      into appropriate locations in the precinct's memory block during
; 4077 :      tag-tree construction. */
; 4078 : 
; 4079 : /*****************************************************************************/
; 4080 : /*                                kd_precinct                                */
; 4081 : /*****************************************************************************/
; 4082 : 
; 4083 :   /* Precincts and all of their subordinate entities (precinct-bands and
; 4084 :      code-blocks) are maintained by a code-stream wide precinct server
; 4085 :      object, which allows for efficient allocation and recycling of the
; 4086 :      memory resources. The constructor is invoked from within the server,
; 4087 :      while the `initialize' and `release' functions are invoked from
; 4088 :      within the `kd_precinct_ref' class which manages references to
; 4089 :      precincts from within the `kd_resolution' object. */
; 4090 : 
; 4091 : // Interpretation of the following flags is given with the `flags' member:
; 4092 : #define KD_PFLAG_GENERATING  0x0001
; 4093 : #define KD_PFLAG_CORRUPTED   0x0002
; 4094 : #define KD_PFLAG_DESEQUENCED 0x0004
; 4095 : #define KD_PFLAG_ADDRESSABLE 0x0008
; 4096 : #define KD_PFLAG_RELEASED    0x0010
; 4097 : #define KD_PFLAG_INACTIVE    0x0020
; 4098 : #define KD_PFLAG_RELEVANT    0x0040
; 4099 : #define KD_PFLAG_SIGNIFICANT 0x0080
; 4100 : #define KD_PFLAG_PARSED      0x0100
; 4101 : 
; 4102 : struct kd_precinct {
; 4103 :   public: // Member functions
; 4104 :     void initialize(kd_resolution *resolution, kdu_coords pos_idx);
; 4105 :       /* Called from within `kd_precinct_ref::open' to configure a newly
; 4106 :          allocated (or recycled) object.  `pos_idx' holds the horizontal and
; 4107 :          vertical position of the precinct (starting from 0) within the array
; 4108 :          of precincts for the relevant resolution level.  Thus, `pos_idx'
; 4109 :          holds a relative index, rather than an absolute index. */
; 4110 :     void activate();
; 4111 :       /* This function is called from within `kd_precinct_ref::open' to
; 4112 :          re-activate a previously released precinct, which has not actually
; 4113 :          been unloaded from memory.  Substantially less work is required in
; 4114 :          this case, and the function must be careful to respect the current
; 4115 :          contents of the precinct's code-blocks.  The function sets the
; 4116 :          `num_required_layers' field for this activation (may change between
; 4117 :          successive `kd_tile::open' calls) and also sets the
; 4118 :          `num_outstanding_blocks' field to the total number of code-blocks
; 4119 :          which lie within the current region of interest. */
; 4120 :     void closing();
; 4121 :       /* Called from within `kd_precinct_ref::close' immediately prior to
; 4122 :          recycling the storage associated with the precinct, its precinct-bands
; 4123 :          and their code-blocks.  This function should release any resources
; 4124 :          which are specific to this particular precinct.  These resources
; 4125 :          include any non-NULL `layer_bytes' array and any code-byte buffers.
; 4126 :          Note that the `kd_precinct_ref::close' function may be called
; 4127 :          indirectly while opening a different precinct, if the current
; 4128 :          precinct has already been released.  This enables open calls to
; 4129 :          deal with resource limitations by unloading precincts which are not
; 4130 :          currently active. */
; 4131 :     void release()
; 4132 :       /* Used only for input codestream objects, this function is called once
; 4133 :          all code-blocks within the current region of interest have been
; 4134 :          consumed.  The function sets `num_outstanding_blocks' to 0, although
; 4135 :          in most cases this function will be called because
; 4136 :          `num_outstanding_blocks' has just become 0 (only exception is when
; 4137 :          a tile is being closed).  Also sets `released' to true.  If the
; 4138 :          KD_PFLAG_DESEQUENCED flag is false, the function returns without
; 4139 :          modifying the precinct in any other way.
; 4140 :             The `kd_precinct_ref::release' function is called to formally
; 4141 :          release the precinct's resources (this might not unload them from
; 4142 :          memory) if the codestream mode is non-persistent or if the precinct
; 4143 :          is addressable.  In the latter case, the precinct's contents can
; 4144 :          be reloaded from the compressed source if necessary.
; 4145 :             This function shall not be used with codestream objects
; 4146 :          opened for output or for interchange (no compressed data source and
; 4147 :          no compressed data target). */
; 4148 :       {
; 4149 :         assert(resolution->codestream->in != NULL);
; 4150 :         num_outstanding_blocks = 0;
; 4151 :         flags |= KD_PFLAG_RELEASED;

	or	DWORD PTR [eax+8], 16			; 00000010H
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+24], 0

; 4152 :           // released = true;
; 4153 :         if ((flags & KD_PFLAG_ADDRESSABLE) ||

	test	cl, 8
	jne	SHORT $LN32@finished_r
	test	cl, 4
	je	SHORT $LN8@finished_r
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	cmp	BYTE PTR [ecx+337], 0
	jne	SHORT $LN8@finished_r
$LN32@finished_r:

; 4154 :             ((flags & KD_PFLAG_DESEQUENCED) &&
; 4155 :                 // if (addressable ||
; 4156 :                 //     (desequenced &&
; 4157 :              !resolution->codestream->persistent))
; 4158 :           ref->release(); // May unload us from memory!

	mov	edx, DWORD PTR [eax+4]

; 4187 :           release();
; 4188 :       }
; 4189 :     bool desequence_packet()
; 4190 :       /* This function should be called when a non-NULL `kd_precinct_ref'
; 4191 :          pointer is returned by `kd_packet_sequencer::next_in_sequence' and
; 4192 :          its `kd_precinct_ref::is_sequenced' function returns false.
; 4193 :          The function invokes `read_packet' and, if successful, increments
; 4194 :          the precinct's `next_layer_idx' field and the containing tile's
; 4195 :          `num_sequenced_packets' field.
; 4196 :             The function returns false if `read_packet' returns false,
; 4197 :          in which case, more tile-parts must be read (if there are any) to
; 4198 :          recover the information required to desequence the packet.
; 4199 :             Before returning true, the function checks to see whether all
; 4200 :          packets for the tile have been sequenced.  If so, the tile's
; 4201 :          `finished_reading' function is called. */
; 4202 :       {
; 4203 :         kd_tile *tile = resolution->tile_comp->tile;
; 4204 :         assert(!(flags & (KD_PFLAG_DESEQUENCED | KD_PFLAG_ADDRESSABLE)));
; 4205 :         if (!read_packet()) return false;
; 4206 :         next_layer_idx++;
; 4207 :         if (next_layer_idx == tile->num_layers)
; 4208 :           finished_desequencing();
; 4209 :         tile->next_input_packet_num++;
; 4210 :         if ((flags & KD_PFLAG_RELEVANT) &&
; 4211 :             (next_layer_idx <= tile->max_relevant_layers))
; 4212 :           {
; 4213 :             tile->sequenced_relevant_packets++;
; 4214 :             if (tile->sequenced_relevant_packets==tile->max_relevant_packets)
; 4215 :               tile->finished_reading();
; 4216 :           }
; 4217 :         return true;
; 4218 :       }
; 4219 :     void load_required_packets()
; 4220 :       /* If the precinct is addressable, this function uses its
; 4221 :          `unique_address' to position the compressed data source at the
; 4222 :          beginning of the precinct's first packet; it then loads all required
; 4223 :          packets from the compressed source.  Otherwise, the function does
; 4224 :          nothing at all -- reading is presumed to have occurred during packet
; 4225 :          desequencing. */
; 4226 :       {
; 4227 :         if ((!(flags & KD_PFLAG_ADDRESSABLE)) ||
; 4228 :             (unique_address == 0) || (num_packets_read != 0))
; 4229 :           return;
; 4230 :         assert((flags & KD_PFLAG_DESEQUENCED) &&
; 4231 :                (next_layer_idx >= required_layers));
; 4232 :         resolution->codestream->in->seek(unique_address);
; 4233 :         while (num_packets_read < required_layers)
; 4234 :           if (!read_packet())
; 4235 :             break;
; 4236 :       }
; 4237 :     kdu_long simulate_packet(kdu_long &header_bytes,
; 4238 :                              int layer_idx, kdu_uint16 slope_threshold,
; 4239 :                              bool finalize_layer, bool last_layer,
; 4240 :                              kdu_long max_bytes=KDU_LONG_HUGE,
; 4241 :                              bool trim_to_limit=false);
; 4242 :       /* Implements the functionality of `kd_codestream::simulate_output'
; 4243 :          for a single precinct.  Note that the total number of packet bytes
; 4244 :          is left behind in the internal `layer_bytes' array.  This allows the
; 4245 :          determination of tile-part length fields later on when we come to
; 4246 :          construct the code-stream.  The function returns this total number
; 4247 :          of bytes.  It also returns the number of packet header bytes via
; 4248 :          `header_bytes' (the function return value includes the cost of these
; 4249 :          header bytes).
; 4250 :             If the `max_bytes' limit is exceeded, the function may return
; 4251 :          prematurely, without having completed the simulation.  This is
; 4252 :          unacceptable when finalizing a layer, so you must be sure that
; 4253 :          `max_bytes' is sufficient in that case.
; 4254 :             If `trim_to_limit' is true, `finalize_layer' and `last_layer'
; 4255 :          must also both be true.  The function then trims away all coding
; 4256 :          passes from the precinct's code-blocks which are associated with
; 4257 :          slope values of `slope_threshold'+1 or less, until the limit
; 4258 :          associated with `max_bytes' is satisfied.  This functionality is
; 4259 :          used to implement the `sloppy_bytes' capabilities advertised by the
; 4260 :          `kd_codestream::simulate_output' function. */
; 4261 :     kdu_long write_packet(kdu_uint16 slope_threshold, bool empty_packet=false);
; 4262 :       /* Writes out the next packet for this precinct, using the supplied
; 4263 :          distortion-length slope threshold.  Increments the `next_layer_idx'
; 4264 :          field as well as the containing tile's `num_sequenced_packets'
; 4265 :          field when done.  If `empty_packet' is true, an empty packet should
; 4266 :          be issued, having a length of 1 byte, plus the length of any required
; 4267 :          EPH marker (no SOP marker will be attached to empty packets).  The
; 4268 :          function returns the total number of bytes output for the packet. */
; 4269 :   private: // Member functions
; 4270 :     bool read_packet();
; 4271 :       /* Reads a new layer of this precinct sequentially from the
; 4272 :          compressed data source, incrementing the `num_packets_read' member.
; 4273 :          Note that packet reading may be interleaved with acesses to the
; 4274 :          precinct's code-blocks for various reasons.  For example, we
; 4275 :          may initially open a tile with only a limited number of required
; 4276 :          layers, using its code-block data to decompress an approximate
; 4277 :          representation of the image.  We may then find that the additional
; 4278 :          packets need to be loaded in order to advance to other precincts
; 4279 :          in the code-stream.
; 4280 :             The function returns false if an SOT marker (or an EOC marker) is
; 4281 :          encountered.  Note that when an SOT marker is encountered, its
; 4282 :          segment is fully read into the codestream marker service and the
; 4283 :          precinct's tile must be active (otherwise an error message will be
; 4284 :          generated).  Before returning false in this way, the function sets
; 4285 :          the `active_tile' pointer in the codestream object to NULL.  The
; 4286 :          caller may determine the cause of failure by invoking the codestream
; 4287 :          marker service's `get_code' function, which will return one of SOT,
; 4288 :          EOC or 0, where 0 occurs only if the code-stream has been
; 4289 :          exhausted. */
; 4290 :     bool handle_corrupt_packet();
; 4291 :       /* This function implements alternate processing for the `read_packet'
; 4292 :          function in the event that a packet is found to be corrupt.  It is
; 4293 :          called whenever packet corruption is detected, including when the
; 4294 :          precinct is known to have had previously corrupt packets. The function
; 4295 :          manipulates the containing tile's `skipping_to_sop' and
; 4296 :          `next_sop_sequence_num' fields, advancing to the next SOP or SOT
; 4297 :          marker if necessary (the function may be called after detecting an
; 4298 :          SOP marker already, whose sequence number is not as expected).  If
; 4299 :          an SOT marker is encountered, the function renders the current tile
; 4300 :          inactive and returns false (this is the behaviour expected of
; 4301 :          `read_packet').  Otherwise, it updates the precinct and tile state to
; 4302 :          identify the packet as having been read. */
; 4303 :   public: // Public Links and Identification
; 4304 :     kd_resolution *resolution;
; 4305 :     kd_precinct_ref *ref; // Element of `resolution->precinct_refs' array
; 4306 : 
; 4307 :   public: // Mode flags used for decompression and/or interchange
; 4308 :     int flags; // The following flags are defined.
; 4309 :        // KD_PFLAG_GENERATING -- after 1'st call to `kd_precinct::get_packets'
; 4310 :        // KD_PFLAG_CORRUPTED -- if error occurred during packet reading
; 4311 :        // KD_PFLAG_DESEQUENCED -- if all packets have been desequenced
; 4312 :        // KD_PFLAG_ADDRESSABLE -- if seekable, cached or used for interchange
; 4313 :        // KD_PFLAG_RELEASED -- if `activate' must be called to revive state
; 4314 :        // KD_PFLAG_INACTIVE -- if resides on `kd_precict_server's inactive list
; 4315 :        // KD_PFLAG_RELEVANT -- always true if codestream is for non-persistent
; 4316 :        //     input; otherwise, true only if precinct belongs to the relevant
; 4317 :        //     set of precincts of a relevant tile-component-resolution
; 4318 :        // KD_PFLAG_SIGNIFICANT -- if any code-block bytes have been generated
; 4319 :        //     by `kdu_precinct::size_packets' or `kdu_precinct::get_packets'
; 4320 :        // KD_PFLAG_PARSED -- if the precinct was parsed previously and then
; 4321 :        //     unloaded; prevents multiple accumulation of packet length stats
; 4322 :   public: // State variables
; 4323 :     int required_layers; /* Actual number of layers for output codestream;
; 4324 :                 max apparent layers for input or interchange codestream. */
; 4325 :     int next_layer_idx; // Next layer to be sequenced or generated.
; 4326 :     union { // First field used for input; second interchange; third for output
; 4327 :         int num_packets_read; // Incremented when packets read or interchanged
; 4328 :         int cumulative_bytes; // Size of all packets generated so far.
; 4329 :         int saved_next_layer_idx; // Used by "kd_packet_sequencer::save_state"
; 4330 :       };
; 4331 : 
; 4332 :   public: // Activation state variables
; 4333 :     int num_outstanding_blocks; // See notes below.
; 4334 :     union { // First field used only in reading; second only in writing.
; 4335 :         kdu_long unique_address; // See below
; 4336 :         kdu_long *packet_bytes; // Lengths generated during simulated output
; 4337 :       };
; 4338 :   public: // code-block containers
; 4339 :     kd_precinct_band *subbands; // In practice, this member points into the
; 4340 :        // same block of memory which is allocated to hold the precinct so
; 4341 :        // as to encourage memory locality and allow for manipulation of all
; 4342 :        // aspects of a precinct, including all of its code-blocks, via a
; 4343 :        // single heap block.  Note that the number of entries in this array
; 4344 :        // is given by `resolution->num_subbands'.
; 4345 : 
; 4346 :   public: // See below for an explanation of these links
; 4347 :     kd_precinct *next; // Next in free, inactive or generated list
; 4348 :     kd_precinct *prev; // Previous in inactive or generated list
; 4349 :     kd_precinct_size_class *size_class; // For correctly releasing storage
; 4350 :   };
; 4351 :   /* Notes:
; 4352 :         `unique_address' is valid if and only if the precinct is marked as
; 4353 :      addressable, meaning that the precinct has a unique address from which it
; 4354 :      may be loaded (for input codestream objects) or identified (for
; 4355 :      interchange codestream objects).  If addressable, the `unique_address'
; 4356 :      will be 0 if and only if the precinct is known to be empty, meaning that
; 4357 :      reloading the precinct does not require any actual data transfers from a
; 4358 :      compressed data source.
; 4359 :         Except as described above, when used with seekable compressed data
; 4360 :      sources, the `unique_address' member holds a positive quantity which
; 4361 :      identifies an offset into the code-stream at which the precinct's
; 4362 :      packets may be found.  In the case of cached sources (those advertising
; 4363 :      the KDU_SOURCE_CAP_CACHED capability) or codestream objects created for
; 4364 :      interchange (no compressed data source or target), the `unique_address'
; 4365 :      will be negative and -(1+`unique_address') is the precinct's unique
; 4366 :      identifier, as passed to the `kdu_compressed_source::set_precinct_scope'
; 4367 :      function, or returned by the `kdu_precinct::get_unique_id' function.
; 4368 :         The `num_outstanding_blocks' member is used to monitor the number of
; 4369 :      code-blocks from the application's region of interest which have still
; 4370 :      to be consumed (input codestreams) or the number of code-blocks which
; 4371 :      have still to be written in order to complete the precinct (output
; 4372 :      and interchange codestreams).
; 4373 :         The `next' and `prev' links may be used to manage the precinct's
; 4374 :      location in one of three different lists.  The first list is the
; 4375 :      singly-linked free list maintained by `kd_precinct_size_class', from
; 4376 :      which the `kd_precinct_server' object re-issues previously released
; 4377 :      resources.
; 4378 :         The second list on which this structure may find itself is the
; 4379 :      doubly-linked list of currently inactive precincts, which is managed by
; 4380 :      the `kd_precinct_server' object.  Precincts which find themselves on this
; 4381 :      list have been released, but their resources have not yet been recycled.
; 4382 :      They may be successfully re-activated, if their resources have not been
; 4383 :      re-issued to another precinct.  Precincts on this list may be identified
; 4384 :      by the `inactive' flag.  Every inactive precinct necessarily also has
; 4385 :      its `released' member set to true, but the converse is not necessarily
; 4386 :      true.  This is because precincts which have been partially parsed
; 4387 :      in a context for which they were not directly relevant, will be marked
; 4388 :      as released, even though they are not inactive.
; 4389 :         The third list on which this structure may find itself is the
; 4390 :      doubly-linked list of generated precincts managed by the
; 4391 :      `kd_global_rescomp' structure.  This list contains all precincts
; 4392 :      from a given resolution of a given image component, across all tiles,
; 4393 :      which have been fully generated, but not yet flushed out to the
; 4394 :      code-stream.   The list is used to manage incremental rate allocation
; 4395 :      when processing large images.  Elements on this list have not yet
; 4396 :      been closed. */
; 4397 : 
; 4398 : /*****************************************************************************/
; 4399 : /*                         kd_precinct_size_class                            */
; 4400 : /*****************************************************************************/
; 4401 : 
; 4402 :   /* For an explanation of the role played by precinct size classes, see
; 4403 :      the discussion appearing below the declaration of `kd_precinct_server'. */
; 4404 : 
; 4405 : class kd_precinct_size_class {
; 4406 :   public: // Member functions
; 4407 :     kd_precinct_size_class(int max_blocks, int num_subbands,
; 4408 :                            kd_precinct_server *server,
; 4409 :                            kd_buf_server *buf_server)
; 4410 :       {
; 4411 :         this->max_blocks = max_blocks;
; 4412 :         this->num_subbands = num_subbands;
; 4413 :         this->server = server;  this->buf_server = buf_server;
; 4414 :         total_precincts = 0; free_list = NULL; next = NULL;
; 4415 :         alloc_bytes = (int) sizeof(kd_precinct);
; 4416 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4417 :         alloc_bytes += num_subbands * (int) sizeof(kd_precinct_band);
; 4418 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4419 :         alloc_bytes += 4 + max_blocks * (int) sizeof(kd_block);
; 4420 :       }
; 4421 :     ~kd_precinct_size_class()
; 4422 :       { kd_precinct *tmp;
; 4423 :         while ((tmp=free_list) != NULL)
; 4424 :           { free_list = tmp->next; free(tmp); total_precincts--; }
; 4425 :         assert(total_precincts == 0);
; 4426 :       }
; 4427 :     kd_precinct *get()
; 4428 :       {
; 4429 :         if (free_list == NULL)
; 4430 :           augment_free_list();
; 4431 :         kd_precinct *result = free_list; free_list = free_list->next;
; 4432 :         result->next = result->prev = NULL;
; 4433 :         buf_server->augment_structure_bytes(alloc_bytes);
; 4434 :         return result;
; 4435 :       }
; 4436 :     void release(kd_precinct *precinct)
; 4437 :       {
; 4438 :         if (precinct->flags & KD_PFLAG_INACTIVE)
; 4439 :           withdraw_from_inactive_list(precinct);
; 4440 :         precinct->next = free_list;
; 4441 :         free_list = precinct;
; 4442 :         buf_server->augment_structure_bytes(-alloc_bytes);
; 4443 :       }
; 4444 :     void move_to_inactive_list(kd_precinct *precinct);
; 4445 :     void withdraw_from_inactive_list(kd_precinct *precinct);
; 4446 :       /* Used to move precincts onto or off the inactive list maintained
; 4447 :          by the `kd_precinct_server' object to which the present object
; 4448 :          belongs. */
; 4449 :   private: // Helper function
; 4450 :     void augment_free_list();
; 4451 :   private: // Data
; 4452 :     friend class kd_precinct_server;
; 4453 :     kd_precinct_server *server;
; 4454 :     kd_buf_server *buf_server;
; 4455 :     int max_blocks;
; 4456 :     int num_subbands;
; 4457 :     int alloc_bytes; // Num bytes to allocate per precinct.
; 4458 :     kdu_long total_precincts; // Number of precincts allocated with this size
; 4459 :     kd_precinct *free_list; // List of precincts which have been released
; 4460 :     kd_precinct_size_class *next; // Next size class
; 4461 :   };
; 4462 : 
; 4463 : /*****************************************************************************/
; 4464 : /*                           kd_precinct_server                              */
; 4465 : /*****************************************************************************/
; 4466 : 
; 4467 : class kd_precinct_server {
; 4468 :   public: // Member functions
; 4469 :     kd_precinct_server(kd_buf_server *buf_server)
; 4470 :       { size_classes = NULL; total_allocated_bytes = 0;
; 4471 :         inactive_head = inactive_tail = NULL; this->buf_server = buf_server; }
; 4472 :     ~kd_precinct_server()
; 4473 :       {
; 4474 :         kd_precinct_size_class *tmp;
; 4475 :         while ((tmp=size_classes) != NULL)
; 4476 :           { size_classes = tmp->next; delete tmp; }
; 4477 :       }
; 4478 :     kd_precinct *get(int max_blocks, int num_subbands);
; 4479 :     kdu_long get_total_allocated_bytes()
; 4480 :       { return total_allocated_bytes; }
; 4481 :   private: // Data
; 4482 :     friend class kd_precinct_size_class;
; 4483 :     kd_precinct_size_class *size_classes; // List of different size classes.
; 4484 :     kdu_long total_allocated_bytes;
; 4485 :     kd_precinct *inactive_head, *inactive_tail;
; 4486 :     kd_buf_server *buf_server; // Used to manage cacheing, as described below
; 4487 :   };
; 4488 :   /* Notes:
; 4489 :         This object is used to serve up empty precincts and to recycle their
; 4490 :      storage when they are no longer required.  Precinct memory blocks are
; 4491 :      organized into size classes, based on the maximum number of code-blocks
; 4492 :      and precinct-bands in the precinct, where these quantities are consistent
; 4493 :      for all precincts associated with any given `kd_resolution' object.  In
; 4494 :      many cases, it can happen that all precincts from the entire image have
; 4495 :      exactly the same size class.  This maximizes the potential for recycling
; 4496 :      precinct storage, since precincts may only be allocated from and
; 4497 :      recycled back to their own size class.  The reason for this dependence on
; 4498 :      size classes is that the block of memory associated with each precinct
; 4499 :      is large enough to accommodate all `max_blocks' code-blocks which might
; 4500 :      be required to populate the `kd_precinct_band::blocks' arrays and all
; 4501 :      precinct-bands which are required to populate the `kd_precinct::subbands'
; 4502 :      array.  This gets us out of having to maintain separate mechanisms
; 4503 :      to serve up code-block storage as a recyclable resource.  It also helps
; 4504 :      with memory localization.
; 4505 :         The object also manages a cacheing service for precincts and their
; 4506 :      data.  When precincts are released using `kd_precinct_ref::release',
; 4507 :      they are appended to a list of inactive precincts headed by
; 4508 :      `inactive_head' and concluded by `inactive_tail'.  The list is doubly
; 4509 :      linked via the `kd_precinct::next' and `kd_precinct::prev' members.  When
; 4510 :      a previously released precinct is opened using `kd_precinct_ref::open',
; 4511 :      it is removed from this list and its `kd_precinct::activate' function is
; 4512 :      called.  Note that the KD_PFLAG_RELEASED flag is not a reliable
; 4513 :      indicator of whether or not a precinct is on the inactive list, since
; 4514 :      precincts which have been released using `kd_precinct::release', but
; 4515 :      have not yet been completely desequenced (all packets have not yet been
; 4516 :      parsed from or located in the code-stream), will also have this flag
; 4517 :      set, but will not be on an inactive list.  The KD_PFLAG_INACTIVE
; 4518 :      flag should be used to determine whether or not a precinct is on the
; 4519 :      inactive list.
; 4520 :         When `kd_precinct_server::get' function is called, it queries the
; 4521 :      codestream object's `kd_buf_server' service to determine whether or not
; 4522 :      a cache threshold has been exceeded.  If so, it closes down precincts
; 4523 :      on the inactive list until the `kd_buf_server' object reports that
; 4524 :      sufficient resources are in hand. */
; 4525 : 
; 4526 : /*****************************************************************************/
; 4527 : /*                          kd_thread_block_state                            */
; 4528 : /*****************************************************************************/
; 4529 : 
; 4530 : struct kd_thread_block_state {
; 4531 :     kd_block block;
; 4532 :     kd_precinct *target_precinct;
; 4533 :     kd_block *target_block; // see below
; 4534 :   };
; 4535 :   /* An array of these structures is used to maintain information about
; 4536 :      processed code-blocks in thread-local storage, reflecting this information
; 4537 :      only every so often to the `kdu_codestream' machinery, so as to minimize
; 4538 :      thread blocking and cache coherency management overhead.  Each object of
; 4539 :      this class represents a single code-block, identified via the
; 4540 :      `target_precinct' and `target_block' members.
; 4541 :         If `target_precinct' is NULL, the record is empty.  Non-empty records
; 4542 :      may appear anywhere within the `outstanding_blocks' array in
; 4543 :      `kd_thread_env'. */
; 4544 : 
; 4545 : /*****************************************************************************/
; 4546 : /*                              kd_thread_env                                */
; 4547 : /*****************************************************************************/
; 4548 : 
; 4549 : #define KD_THREAD_MAX_OUTSTANDING_BLOCKS 8
; 4550 : 
; 4551 : class kd_thread_env {
; 4552 :   public: // Member functions
; 4553 :     kd_thread_env(kdu_thread_env *owner)
; 4554 :       {
; 4555 :         this->owner=owner;  buf_server.init(this);
; 4556 :         num_outstanding_blocks=0;  stats_codestream = NULL;
; 4557 :         memset(outstanding_blocks,0,
; 4558 :                sizeof(kd_thread_block_state)*KD_THREAD_MAX_OUTSTANDING_BLOCKS);
; 4559 :       }
; 4560 :     kd_thread_block_state *get_block_state(kd_codestream *cs,
; 4561 :                                            kd_precinct *precinct,
; 4562 :                                            kd_block *block)
; 4563 :       {
; 4564 :         if (num_outstanding_blocks == KD_THREAD_MAX_OUTSTANDING_BLOCKS)
; 4565 :           flush(true);
; 4566 :         kd_thread_block_state *scan=outstanding_blocks;
; 4567 :         for (int n=0; n < KD_THREAD_MAX_OUTSTANDING_BLOCKS; n++, scan++)
; 4568 :           if (scan->target_precinct == NULL)
; 4569 :             {
; 4570 :               num_outstanding_blocks++;
; 4571 :               scan->target_precinct=precinct;  scan->target_block=block;
; 4572 :               owner->have_outstanding_blocks = true;
; 4573 :               return scan;
; 4574 :             }
; 4575 :         return NULL; // Should not be possible!!
; 4576 :       }
; 4577 :     void update_stats(kdu_block *blk, kd_codestream *cs)
; 4578 :       { /* Called during encoding after each code-block of data has been
; 4579 :            generated, whenever coding statistics are being kept by the
; 4580 :            relevant codestream.  This function updates the internal coding
; 4581 :            statistics record managed by the `stats' member, which is
; 4582 :            reconciled against the underlying codestream only at appropriate
; 4583 :            intervals, so as to minimize thread blocking conditions. */
; 4584 :         if ((stats_codestream != cs) && (stats_codestream != NULL))
; 4585 :           {
; 4586 :             reconcile_stats();
; 4587 :             stats_codestream = cs;
; 4588 :           }
; 4589 :         stats.update_stats(blk);
; 4590 :       }
; 4591 :     void reconcile_stats();
; 4592 :       /* This function is used to reconcile the temporary information in
; 4593 :          the `stats' member with the coding statistics manager in the
; 4594 :          `kd_codestream' object referenced by the `stats_codestream' member.
; 4595 :          After reconciliation, the `stats' member will be empty and the
; 4596 :          `stats_codestream' member is reset to NULL so that we are free to
; 4597 :          accumulate statistics for a different codestream in the future.
; 4598 :          This function is invoked from `flush' and also if a call to
; 4599 :          `update_stats' specifies a different codestream to that for which
; 4600 :          coding statistics are currently being recorded in the `stats'
; 4601 :          member. */
; 4602 :     void flush(bool force_flush);
; 4603 :       /* Clears the `outstanding_blocks' queue and reconciles any outstanding
; 4604 :          `stats' information.  This function should not be called while
; 4605 :          holding any lock, since it typically needs to acquire its own lock or
; 4606 :          locks.
; 4607 :             If `force_flush' is false, the function may return without
; 4608 :          flushing anything, if it finds that the necessary mutex is already
; 4609 :          held by another thread.  This helps to keep threads alive for as long
; 4610 :          as possible.  A thread will typically try to flush its block queue
; 4611 :          each time it is augmented, once it starts getting close to full.
; 4612 :          A forced flush is required only once the queue becomes completely
; 4613 :          full -- this is performed automatically from within
; 4614 :          `get_block_state'. */
; 4615 :     void discard_all();
; 4616 :       /* This function is called from `kdu_thread_env::do_sync' or
; 4617 :          `kdu_thread_env::on_finished' if an exception has been handled
; 4618 :          by any thread in the working group.  It discards all processed
; 4619 :          code-blocks, returning any associated storage to the internal
; 4620 :          queue, being careful to do so in such a way as to avoid throwing
; 4621 :          further exceptions while acquiring locks. */
; 4622 :   private: // Padding
; 4623 :     kdu_byte _leadin[KDU_MAX_L2_CACHE_LINE];
; 4624 :   public: // Links
; 4625 :     kdu_thread_env *owner;
; 4626 :   public: // Public resources
; 4627 :     kdu_block block; // Thread-local code-block storage
; 4628 :     kd_compressed_stats stats; // Used to temporarily record statistics
; 4629 :     kd_codestream *stats_codestream; // Codestream to which statistics belong
; 4630 :     kd_thread_buf_server buf_server;
; 4631 :     int num_outstanding_blocks;
; 4632 :   private: // Private resources
; 4633 :     kd_thread_block_state outstanding_blocks[KD_THREAD_MAX_OUTSTANDING_BLOCKS];
; 4634 :   private: // Padding
; 4635 :     kdu_byte _trailer[KDU_MAX_L2_CACHE_LINE];
; 4636 :   };
; 4637 : 
; 4638 : 
; 4639 : /* ========================================================================= */
; 4640 : /*         Inlined Member Functions Delayed to Satisfy Dependencies          */
; 4641 : /* ========================================================================= */
; 4642 : 
; 4643 : inline void
; 4644 :   kd_thread_buf_server::set_codestream_buf_server(kd_buf_server *buf_server)
; 4645 : {
; 4646 :   if (buf_server != this->ultimate_buf_server)
; 4647 :     {
; 4648 :       env->owner->acquire_lock(KD_THREADLOCK_GENERAL);
; 4649 :       if (ultimate_buf_server != NULL)
; 4650 :         ultimate_buf_server->detach_thread_buf_server(this);
; 4651 :       if (buf_server != NULL)
; 4652 :         buf_server->attach_thread_buf_server(this);
; 4653 :       assert(buf_server == ultimate_buf_server);
; 4654 :       env->owner->release_lock(KD_THREADLOCK_GENERAL);
; 4655 :     }
; 4656 : }
; 4657 : 
; 4658 : inline bool
; 4659 :   kd_precinct_ref::is_desequenced()
; 4660 : {
; 4661 :   register kdu_long state_val = state;
; 4662 :   return ((state_val != 0) &&
; 4663 :           ((state_val & 1) ||
; 4664 :            (((kd_precinct *) _kdu_long_to_addr(state_val))->flags &
; 4665 :             KD_PFLAG_DESEQUENCED)));
; 4666 : }
; 4667 : 
; 4668 : inline void
; 4669 :   kd_precinct_ref::clear()
; 4670 : {
; 4671 :   if (state && !(state & 1))
; 4672 :     {
; 4673 :       kd_precinct *precinct = (kd_precinct *) _kdu_long_to_addr(state);
; 4674 :       precinct->ref = NULL; // Satisfy the test in `kd_precinct::closing'
; 4675 :       precinct->closing();
; 4676 :       precinct->size_class->release(precinct);
; 4677 :     }
; 4678 :   state = 0;
; 4679 : }
; 4680 : 
; 4681 : inline void
; 4682 :   kd_precinct_ref::close_and_reset()
; 4683 : {
; 4684 :   if (state & 1)
; 4685 :     {
; 4686 :       if (state != 3)
; 4687 :         state &= ~((kdu_long) 2);
; 4688 :     }
; 4689 :   else if (state != 0)
; 4690 :     {
; 4691 :       kd_precinct *prec = (kd_precinct *) _kdu_long_to_addr(state);
; 4692 :       if ((prec->flags & KD_PFLAG_PARSED)||(prec->num_packets_read > 0))
; 4693 :         {
; 4694 :           close();
; 4695 :           state &= ~((kdu_long) 2);
; 4696 :         }
; 4697 :     }
; 4698 : }
; 4699 : 
; 4700 : inline void
; 4701 :   kd_precinct_ref::release()
; 4702 : {
; 4703 :   kd_precinct *precinct = (kd_precinct *) _kdu_long_to_addr(state);

	mov	ecx, DWORD PTR [edx]

; 4704 :   assert((state != 0) && !(state & 1));
; 4705 :   if (precinct->flags & KD_PFLAG_INACTIVE)

	mov	eax, DWORD PTR [ecx+8]
	test	al, 32					; 00000020H
	jne	SHORT $LN8@finished_r

; 4706 :     return; // Already on the inactive list.
; 4707 :   precinct->flags |= KD_PFLAG_RELEASED;

	or	eax, 16					; 00000010H
	mov	DWORD PTR [ecx+8], eax

; 4708 :     // precinct->released = true; // In case not already set.
; 4709 :   if ((precinct->flags & KD_PFLAG_ADDRESSABLE) &&
; 4710 :       (!precinct->resolution->codestream->cached) &&

	test	al, 8
	je	SHORT $LN36@finished_r
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	cmp	BYTE PTR [eax+338], 0
	jne	SHORT $LN36@finished_r
	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN38@finished_r
	cmp	eax, DWORD PTR [ecx+16]
	jne	SHORT $LN36@finished_r
$LN38@finished_r:

; 4711 :       ((precinct->num_packets_read == 0) ||
; 4712 :        (precinct->num_packets_read == precinct->next_layer_idx)))
; 4713 :     precinct->size_class->move_to_inactive_list(precinct);

	push	ecx
	mov	ecx, DWORD PTR [ecx+52]
	call	?move_to_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::move_to_inactive_list

; 4714 :   else

	jmp	SHORT $LN8@finished_r
$LN36@finished_r:

; 4715 :     close();

	mov	ecx, edx
	call	?close@kd_precinct_ref@@QAEXXZ		; kd_precinct_ref::close
$LN8@finished_r:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2384 :           for (int p=0; p < num_precincts; p++)

	inc	esi
	cmp	esi, edi
	jl	$LL10@finished_r
	mov	eax, DWORD PTR _r$1$[ebp]
	mov	ecx, DWORD PTR tv446[ebp]
	mov	edx, DWORD PTR _tc$1$[ebp]
$LN5@finished_r:

; 2380 :       for (int r=0; r <= tc->dwt_levels; r++)

	inc	eax
	add	ecx, 604				; 0000025cH
	mov	DWORD PTR _r$1$[ebp], eax
	mov	DWORD PTR tv446[ebp], ecx
	cmp	eax, DWORD PTR [edx+56]
	jle	$LL7@finished_r
	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR _c$1$[ebp]
$LN2@finished_r:

; 2374 :         }
; 2375 :       return false;
; 2376 :     }
; 2377 :   for (int c=0; c < num_components; c++)

	mov	eax, DWORD PTR tv444[ebp]
	inc	ecx
	add	eax, 188				; 000000bcH
	mov	DWORD PTR _c$1$[ebp], ecx
	mov	DWORD PTR tv444[ebp], eax
	cmp	ecx, DWORD PTR [ebx+128]
	jl	$LL4@finished_r
	pop	edi
	pop	esi
$LN3@finished_r:

; 2388 :                 precinct->finished_desequencing();
; 2389 :             }
; 2390 :         }
; 2391 :     }
; 2392 :   return false;

	xor	al, al
	pop	ebx

; 2393 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?finished_reading@kd_tile@@QAE_NXZ ENDP			; kd_tile::finished_reading
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?read_tile_part_header@kd_tile@@QAE_NXZ
_TEXT	SEGMENT
_e$2 = -96						; size = 20
_e$3 = -76						; size = 20
_w$4 = -76						; size = 20
_e$5 = -76						; size = 20
_e$6 = -76						; size = 20
_e$7 = -76						; size = 20
_e$8 = -76						; size = 20
_e$9 = -76						; size = 20
_e$10 = -76						; size = 20
_sot_tpart_length$1$ = -56				; size = 4
$T11 = -56						; size = 4
$T12 = -52						; size = 4
_sot_num_tparts$1$ = -52				; size = 4
$T13 = -52						; size = 4
$T14 = -52						; size = 4
$T15 = -52						; size = 4
_sot_idx$2$ = -48					; size = 4
_this$1$ = -44						; size = 4
_cur_offset$2$ = -40					; size = 4
_val$1$ = -40						; size = 4
_sot_idx$1$ = -36					; size = 4
tv1635 = -32						; size = 4
_root$1$ = -32						; size = 4
_sot_address$1$ = -28					; size = 4
_val$2$ = -24						; size = 4
_sot_address$2$ = -20					; size = 4
_poc$2$ = -20						; size = 4
_cod$2$ = -16						; size = 4
_tref$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
?read_tile_part_header@kd_tile@@QAE_NXZ PROC		; kd_tile::read_tile_part_header, COMDAT
; _this$ = ecx

; 1992 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?read_tile_part_header@kd_tile@@QAE_NXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi

; 1993 :   assert(codestream->in != NULL);
; 1994 : 
; 1995 :   if (codestream->cached)

	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax+338], 0
	je	$LN12@read_tile_

; 1996 :     { // Reading of cached tile headers is quite different.
; 1997 :       assert(next_tpart == 0);
; 1998 :       if (is_unloadable)

	cmp	BYTE PTR [edi+230], 0
	je	SHORT $LN13@read_tile_

; 1999 :         withdraw_from_unloadable_list();

	call	?withdraw_from_unloadable_list@kd_tile@@AAEXXZ ; kd_tile::withdraw_from_unloadable_list
$LN13@read_tile_:

; 2000 :       codestream->unload_tiles_to_cache_threshold();

	mov	ecx, DWORD PTR [edi]
	call	?unload_tiles_to_cache_threshold@kd_codestream@@QAEXXZ ; kd_codestream::unload_tiles_to_cache_threshold

; 2001 :       if (codestream->in->set_tileheader_scope(t_num,codestream->tile_span.x *

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+168]
	imul	eax, DWORD PTR [ecx+164]
	mov	ecx, DWORD PTR [ecx+4]
	push	eax
	push	DWORD PTR [edi+4]
	call	?set_tileheader_scope@kd_compressed_input@@QAE_NHH@Z ; kd_compressed_input::set_tileheader_scope
	test	al, al
	je	$LN14@read_tile_

; 2002 :                                                codestream->tile_span.y))
; 2003 :         {
; 2004 :           kdu_params *root = codestream->siz;

	mov	ecx, DWORD PTR [edi]

; 2005 :           while (codestream->marker->read())

	push	0
	push	0
	mov	esi, DWORD PTR [ecx+12]
	mov	ecx, DWORD PTR [ecx+16]
	call	?read@kd_marker@@QAE_N_N0@Z		; kd_marker::read
	test	al, al
	je	SHORT $LN3@read_tile_
	mov	ebx, 65377				; 0000ff61H
	npad	2
$LL2@read_tile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+16]
	movzx	edx, WORD PTR [ecx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2006 :             if (codestream->marker->get_code() == KDU_PPT)

	cmp	dx, bx
	jne	SHORT $LN16@read_tile_

; 2007 :               { KDU_ERROR(e,6); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$10[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$10[ebp]
	lea	ecx, DWORD PTR _e$10[ebp]
	push	OFFSET ??_C@_0GH@CBFAGHCH@You?5cannot?5use?5PPM?5or?5PPT?5marker@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2007 :               { KDU_ERROR(e,6); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2010 :               }

	lea	ecx, DWORD PTR _e$10[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error

; 2011 :             else

	jmp	SHORT $LN17@read_tile_
$LN16@read_tile_:

; 2012 :               root->translate_marker_segment(codestream->marker->get_code(),

	push	0
	push	DWORD PTR [edi+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	mov	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2012 :               root->translate_marker_segment(codestream->marker->get_code(),

	push	DWORD PTR [ecx+20]
	push	DWORD PTR [ecx+12]
	mov	ecx, esi
	push	eax
	call	?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z ; kdu_params::translate_marker_segment
$LN17@read_tile_:

; 2005 :           while (codestream->marker->read())

	mov	ecx, DWORD PTR [edi]
	push	0
	push	0
	mov	ecx, DWORD PTR [ecx+16]
	call	?read@kd_marker@@QAE_N_N0@Z		; kd_marker::read
	test	al, al
	jne	SHORT $LL2@read_tile_
$LN3@read_tile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 528  :         return exhausted;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	al, BYTE PTR [eax+533]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2016 :           if (!codestream->in->failed())

	test	al, al
	jne	SHORT $LN18@read_tile_

; 2017 :             { KDU_ERROR(e,7); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$9[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$9[ebp]
	lea	ecx, DWORD PTR _e$9[ebp]
	push	OFFSET ??_C@_0HP@MELIFPKI@Found?5non?9marker?5code?5while?5pars@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2017 :             { KDU_ERROR(e,7); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2021 :             }

	lea	ecx, DWORD PTR _e$9[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN18@read_tile_:

; 2022 : 
; 2023 :           root->finalize_all(t_num,true); // Finalize tile-header params

	push	1
	push	DWORD PTR [edi+4]
	mov	ecx, esi
	call	?finalize_all@kdu_params@@QAEXH_N@Z	; kdu_params::finalize_all

; 2024 :         }
; 2025 :       else

	jmp	SHORT $LN15@read_tile_
$LN14@read_tile_:

; 2026 :         empty_shell = true; // Try loading header again if tile is re-opened

	mov	BYTE PTR [edi+227], 1
$LN15@read_tile_:

; 2027 :       next_tpart = num_tparts = 1;
; 2028 :       codestream->num_completed_tparts++;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [edi+240], 1
	mov	DWORD PTR [edi+244], 1
	inc	DWORD PTR [eax+380]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2743 :         if ((!codestream->persistent) ||

	mov	eax, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2029 :       exhausted = true;

	mov	BYTE PTR [edi+268], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2743 :         if ((!codestream->persistent) ||

	cmp	BYTE PTR [eax+337], 0
	je	SHORT $LN118@read_tile_
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN113@read_tile_
	cmp	BYTE PTR [eax+338], 0
	je	SHORT $LN118@read_tile_
$LN113@read_tile_:

; 2744 :             ((codestream->tpart_ptr_server==NULL) && !codestream->cached))
; 2745 :           { assert(!is_unloadable); return; }
; 2746 :         if (is_open || (this==codestream->active_tile))

	cmp	BYTE PTR [edi+229], 0
	jne	SHORT $LN117@read_tile_
	cmp	edi, DWORD PTR [eax+364]
	je	SHORT $LN117@read_tile_

; 2750 :           }
; 2751 :         else
; 2752 :           { // Should be on the unloadable list
; 2753 :             if (!is_unloadable)

	cmp	BYTE PTR [edi+230], 0
	jne	SHORT $LN118@read_tile_

; 2754 :               add_to_unloadable_list();

	mov	ecx, edi
	call	?add_to_unloadable_list@kd_tile@@AAEXXZ	; kd_tile::add_to_unloadable_list
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2032 :       return true;

	mov	al, 1

; 2342 : 
; 2343 :   return true;
; 2344 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN117@read_tile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2748 :             if (is_unloadable)

	cmp	BYTE PTR [edi+230], 0
	je	SHORT $LN118@read_tile_

; 2749 :               withdraw_from_unloadable_list();

	mov	ecx, edi
	call	?withdraw_from_unloadable_list@kd_tile@@AAEXXZ ; kd_tile::withdraw_from_unloadable_list
$LN118@read_tile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2032 :       return true;

	mov	al, 1

; 2342 : 
; 2343 :   return true;
; 2344 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN12@read_tile_:

; 2033 :     }
; 2034 : 
; 2035 :   if (exhausted) // || ((num_tparts > 0) && (next_tpart >= num_tparts)))

	cmp	BYTE PTR [edi+268], 0
	jne	$LN35@read_tile_
$LN284@read_tile_:

; 2036 :     {
; 2037 :       // if (!exhausted)
; 2038 :       //  finished_reading();
; 2039 :            /* All checking of tile part counts has been disabled since
; 2040 :               Adobe's JPEG2000 encoder writes invalid tile-part counts,
; 2041 :               causing diligent decoders to fail on some codestreams
; 2042 :               generated with Adobe software. */
; 2043 :       assert(this != codestream->active_tile);
; 2044 :       return false;
; 2045 :     }
; 2046 : 
; 2047 :   do {
; 2048 :       kd_tile *active = codestream->active_tile;

	mov	ecx, DWORD PTR [eax+364]
	mov	ebx, 65424				; 0000ff90H

; 2049 :       if (active != NULL)

	test	ecx, ecx
	je	SHORT $LN20@read_tile_

; 2050 :         {
; 2051 :           desequence_packets_until_tile_inactive(active,codestream);

	push	eax
	push	ecx
	call	?desequence_packets_until_tile_inactive@@YAXPAUkd_tile@@PAUkd_codestream@@@Z ; desequence_packets_until_tile_inactive
	add	esp, 8
$LN20@read_tile_:

; 2052 :           active = NULL;
; 2053 :         }
; 2054 :       assert(tile_ref->tile == this);
; 2055 :       if (codestream->tpart_ptr_server != NULL)

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+36]
	test	edx, edx
	je	$LN21@read_tile_

; 2056 :         { // Seeking is permitted
; 2057 :           if (tpart_ptrs != NULL)

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN23@read_tile_

; 2058 :             { // Can seek immediately to the relevant tile-part.
; 2059 :               codestream->in->seek(tpart_ptrs->address);

	push	DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [ecx+4]
	push	DWORD PTR [eax]
	call	?seek@kd_compressed_input@@QAEX_J@Z	; kd_compressed_input::seek

; 2060 :               tpart_ptrs = tpart_ptrs->next;

	mov	eax, DWORD PTR [edi+20]

; 2061 :               codestream->marker->read(); // Read the SOT marker segment

	mov	ecx, DWORD PTR [edi]
	push	0
	push	0
	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [edi+20], eax
	mov	ecx, DWORD PTR [ecx+16]
	call	?read@kd_marker@@QAE_N_N0@Z		; kd_marker::read
	jmp	$LN22@read_tile_
$LN23@read_tile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1080 :     bool using_tlm_info() { return translated_tlm_markers; }

	mov	al, BYTE PTR [edx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2063 :           else if (codestream->tpart_ptr_server->using_tlm_info() ||

	test	al, al
	jne	$LN27@read_tile_
	mov	eax, DWORD PTR [edi+16]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN25@read_tile_
	cmp	DWORD PTR [eax+4], 0
	je	$LN27@read_tile_
$LN25@read_tile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	mov	eax, DWORD PTR [ecx+16]
	movzx	eax, WORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2072 :                    (codestream->tile_span.x == 1) &&

	cmp	ax, bx
	jne	SHORT $LN28@read_tile_
	cmp	DWORD PTR [ecx+168], 1
	jne	SHORT $LN28@read_tile_
	cmp	DWORD PTR [ecx+164], 1
	jne	SHORT $LN28@read_tile_

; 2073 :                    (codestream->tile_span.y == 1))
; 2074 :             { // Save seeking to the next sot_address and reading the SOT
; 2075 :               // marker again.  We don't need this special condition, since
; 2076 :               // the next statement should handle it; however, some
; 2077 :               // codestreams with only one tile might have been written with
; 2078 :               // incorrect tile-part lengths.
; 2079 :               codestream->next_sot_address = 0;

	mov	DWORD PTR [ecx+368], 0
	mov	DWORD PTR [ecx+372], 0
	jmp	$LN22@read_tile_
$LN28@read_tile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 528  :         return exhausted;

	mov	edx, DWORD PTR [ecx+4]
	mov	al, BYTE PTR [edx+533]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2081 :           else if ((!codestream->in->failed()) &&

	test	al, al
	jne	SHORT $LN30@read_tile_
	mov	esi, DWORD PTR [ecx+372]
	mov	eax, DWORD PTR [ecx+368]
	test	esi, esi
	jl	SHORT $LN30@read_tile_
	jg	SHORT $LN268@read_tile_
	test	eax, eax
	je	SHORT $LN30@read_tile_
$LN268@read_tile_:

; 2082 :                    (codestream->next_sot_address > 0))
; 2083 :             { // Seek to next unread SOT address in code-stream
; 2084 :               codestream->in->seek(codestream->next_sot_address);

	push	esi
	push	eax
	mov	ecx, edx
	call	?seek@kd_compressed_input@@QAEX_J@Z	; kd_compressed_input::seek

; 2085 :               codestream->marker->read();

	mov	ecx, DWORD PTR [edi]
	push	0
	push	0
	mov	ecx, DWORD PTR [ecx+16]
	call	?read@kd_marker@@QAE_N_N0@Z		; kd_marker::read

; 2086 :               codestream->next_sot_address = 0; // So we know to change it

	jmp	$LN33@read_tile_
$LN30@read_tile_:

; 2087 :             }
; 2088 :           else if (codestream->next_sot_address < 0)

	cmp	DWORD PTR [ecx+372], 0
	jl	$LN35@read_tile_
	jg	$LN22@read_tile_
	cmp	DWORD PTR [ecx+368], 0
	jb	$LN35@read_tile_

; 2089 :            return false;
; 2090 :         }
; 2091 :       else

	jmp	SHORT $LN22@read_tile_
$LN21@read_tile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	mov	eax, DWORD PTR [ecx+16]
	movzx	eax, WORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2093 :           if ((codestream->marker->get_code() != KDU_SOT) &&

	cmp	ax, bx
	je	SHORT $LN33@read_tile_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 528  :         return exhausted;

	mov	ebx, DWORD PTR [ecx+4]
	mov	al, BYTE PTR [ebx+533]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2093 :           if ((codestream->marker->get_code() != KDU_SOT) &&

	test	al, al
	jne	SHORT $LN280@read_tile_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 675  :         return cur_offset + last_loaded_bytes - (first_unwritten-first_unread);

	mov	eax, DWORD PTR [ebx+528]
	sub	eax, DWORD PTR [ebx+524]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2097 :               codestream->in->ignore(codestream->next_sot_address -

	mov	esi, DWORD PTR [ebx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 675  :         return cur_offset + last_loaded_bytes - (first_unwritten-first_unread);

	cdq
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2097 :               codestream->in->ignore(codestream->next_sot_address -

	sub	eax, DWORD PTR [ebx+576]
	sbb	edx, DWORD PTR [ebx+580]
	sub	eax, DWORD PTR [ebx+544]
	sbb	edx, DWORD PTR [ebx+548]
	add	eax, DWORD PTR [ecx+368]
	adc	edx, DWORD PTR [ecx+372]
	mov	ecx, ebx
	push	edx
	push	eax
	call	DWORD PTR [esi+4]

; 2098 :                                      codestream->in->get_offset());
; 2099 :               codestream->marker->read();

	mov	ecx, DWORD PTR [edi]
	push	0
	push	0
	mov	ecx, DWORD PTR [ecx+16]
	call	?read@kd_marker@@QAE_N_N0@Z		; kd_marker::read
$LN280@read_tile_:
	mov	ebx, 65424				; 0000ff90H
$LN33@read_tile_:

; 2100 :             }
; 2101 :           codestream->next_sot_address = 0; // So we know to change it

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+368], 0
	mov	DWORD PTR [eax+372], 0
$LN22@read_tile_:

; 2104 :       if (codestream->in->failed())

	mov	ecx, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 528  :         return exhausted;

	mov	eax, DWORD PTR [ecx+4]
	mov	al, BYTE PTR [eax+533]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2104 :       if (codestream->in->failed())

	test	al, al
	jne	$LN231@read_tile_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	mov	eax, DWORD PTR [ecx+16]
	movzx	eax, WORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2110 :       if (codestream->marker->get_code() != KDU_SOT)

	cmp	ax, bx
	je	SHORT $LN36@read_tile_

; 2111 :         { KDU_ERROR(e,8); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$8[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_0CL@KHMENMGB@Invalid?5marker?5code?5found?5in?5cod@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2111 :         { KDU_ERROR(e,8); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
	push	OFFSET ??_C@_0BO@BKLJKNEJ@?7Expected?5SOT?5marker?5and?5got?5?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2114 :           codestream->marker->print_current_code(e); e << ".";

	mov	eax, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 851  :         print_marker_code(this->code,out);

	lea	ecx, DWORD PTR _e$8[ebp]
	push	ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2114 :           codestream->marker->print_current_code(e); e << ".";

	mov	eax, DWORD PTR [eax+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 851  :         print_marker_code(this->code,out);

	movzx	eax, WORD PTR [eax+8]
	push	eax
	call	?print_marker_code@@YAXGAAVkdu_message@@@Z ; print_marker_code
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$8[ebp]
	lea	ecx, DWORD PTR _e$8[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 851  :         print_marker_code(this->code,out);

	add	esp, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_01LFCBOECM@?4?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2115 :         }

	lea	ecx, DWORD PTR _e$8[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN36@read_tile_:

; 2116 : 
; 2117 :       // Now process the SOT marker.
; 2118 :       int seg_length = codestream->marker->get_length();

	mov	eax, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 884  :     int get_length() { return length; }

	mov	eax, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [eax+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2120 :       kdu_byte *bp = codestream->marker->get_bytes();

	mov	edx, DWORD PTR [eax+20]

; 2121 :       kdu_byte *end = bp+seg_length;

	add	ecx, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ecx
	sub	eax, edx
	cmp	eax, 2
	jl	$LN235@read_tile_

; 92   :   val = *(bp++);

	movzx	esi, BYTE PTR [edx]

; 93   :   if (nbytes > 1)
; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [edx+1]
	add	edx, 2
	shl	esi, 8
	add	esi, eax

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ecx
	sub	eax, edx

; 93   :   if (nbytes > 1)
; 94   :     val = (val<<8) + *(bp++);

	mov	DWORD PTR _val$2$[ebp], esi

; 90   :   if ((end-bp) < nbytes)

	cmp	eax, 4
	jl	$LN235@read_tile_

; 92   :   val = *(bp++);

	movzx	ebx, BYTE PTR [edx]

; 93   :   if (nbytes > 1)
; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [edx+1]
	shl	ebx, 8
	add	ebx, eax

; 95   :   if (nbytes > 2)
; 96   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [edx+2]
	shl	ebx, 8
	add	ebx, eax

; 97   :   if (nbytes > 3)
; 98   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [edx+3]
	shl	ebx, 8
	add	edx, 4
	add	ebx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2124 :       if (sot_tpart_length32 == 12)

	mov	eax, 14					; 0000000eH
	cmp	ebx, 12					; 0000000cH
	cmove	ebx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	mov	eax, ecx
	sub	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2124 :       if (sot_tpart_length32 == 12)

	mov	DWORD PTR _sot_tpart_length$1$[ebp], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 90   :   if ((end-bp) < nbytes)

	cmp	eax, 1
	jl	$LN235@read_tile_

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [edx]
	inc	edx

; 90   :   if ((end-bp) < nbytes)

	sub	ecx, edx

; 92   :   val = *(bp++);

	mov	DWORD PTR _val$1$[ebp], eax

; 90   :   if ((end-bp) < nbytes)

	cmp	ecx, 1
	jl	$LN235@read_tile_

; 92   :   val = *(bp++);

	movzx	eax, BYTE PTR [edx]
	mov	DWORD PTR _sot_num_tparts$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2132 :       if ((sot_tnum < 0) ||

	test	esi, esi
	js	SHORT $LN39@read_tile_
	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+168]
	imul	eax, DWORD PTR [ecx+164]
	cmp	esi, eax
	jl	SHORT $LN38@read_tile_
$LN39@read_tile_:

; 2134 :         { KDU_ERROR(e,9); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$7[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$7[ebp]
	lea	ecx, DWORD PTR _e$7[ebp]
	push	OFFSET ??_C@_0IL@OEKPKFDK@Corrupt?5SOT?5marker?5segment?5found@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2134 :         { KDU_ERROR(e,9); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2138 :         }

	lea	ecx, DWORD PTR _e$7[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN38@read_tile_:

; 2139 :      
; 2140 :       kdu_coords sot_idx, rel_sot_idx;
; 2141 :       sot_idx.y = sot_tnum / codestream->tile_span.x;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR tv1635[ebp], eax
	mov	ecx, DWORD PTR [eax+168]
	mov	eax, esi
	cdq
	idiv	ecx

; 2142 :       sot_idx.x = sot_tnum - sot_idx.y*codestream->tile_span.x;

	imul	ecx, eax
	mov	DWORD PTR _sot_idx$1$[ebp], eax
	mov	eax, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	esi, DWORD PTR tv1635[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2142 :       sot_idx.x = sot_tnum - sot_idx.y*codestream->tile_span.x;

	sub	eax, ecx

; 2148 :         rel_sot_idx.x + rel_sot_idx.y*codestream->tile_indices.size.x;

	mov	ecx, DWORD PTR [esi+184]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	edx, eax
	sub	edx, DWORD PTR [esi+176]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2142 :       sot_idx.x = sot_tnum - sot_idx.y*codestream->tile_span.x;

	mov	DWORD PTR _sot_idx$2$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	eax, DWORD PTR _sot_idx$1$[ebp]
	sub	eax, DWORD PTR [esi+172]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2148 :         rel_sot_idx.x + rel_sot_idx.y*codestream->tile_indices.size.x;

	imul	ecx, eax
	mov	eax, DWORD PTR [esi+264]

; 2150 :         codestream->in->get_offset() - (codestream->marker->get_length()+4);

	mov	esi, DWORD PTR [esi+4]
	add	ecx, edx
	mov	edi, DWORD PTR [esi+576]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	eax, DWORD PTR [eax+ecx*4]
	mov	DWORD PTR _tref$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 884  :     int get_length() { return length; }

	mov	eax, DWORD PTR tv1635[ebp]
	mov	eax, DWORD PTR [eax+16]
	mov	ecx, DWORD PTR [eax+12]

; 675  :         return cur_offset + last_loaded_bytes - (first_unwritten-first_unread);

	mov	eax, DWORD PTR [esi+528]
	sub	eax, DWORD PTR [esi+524]
	cdq
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2150 :         codestream->in->get_offset() - (codestream->marker->get_length()+4);

	sub	edi, eax
	mov	eax, DWORD PTR [esi+580]
	mov	DWORD PTR _sot_address$1$[ebp], edi
	sbb	eax, edx
	mov	DWORD PTR _sot_address$2$[ebp], eax
	lea	eax, DWORD PTR [ecx+4]
	cdq
	mov	ecx, edi

; 2151 : 
; 2152 :       if (codestream->next_sot_address == 0)

	mov	edi, DWORD PTR _this$1$[ebp]
	sub	ecx, eax
	mov	eax, DWORD PTR _sot_address$2$[ebp]
	sbb	eax, edx
	add	ecx, DWORD PTR [esi+544]
	mov	edx, DWORD PTR tv1635[ebp]
	adc	eax, DWORD PTR [esi+548]

; 2156 :               (!codestream->tpart_ptr_server->using_tlm_info()) &&

	mov	esi, DWORD PTR _tref$1$[ebp]
	mov	DWORD PTR _sot_address$2$[ebp], eax
	mov	eax, DWORD PTR [edx+368]
	or	eax, DWORD PTR [edx+372]
	mov	DWORD PTR _sot_address$1$[ebp], ecx
	jne	SHORT $LN43@read_tile_

; 2153 :         { // Advance location of first unparsed SOT marker segment.
; 2154 :           codestream->next_sot_address = sot_address + sot_tpart_length;

	mov	eax, DWORD PTR _sot_address$2$[ebp]
	add	ecx, ebx
	mov	DWORD PTR [edx+368], ecx
	adc	eax, 0
	mov	DWORD PTR [edx+372], eax

; 2156 :               (!codestream->tpart_ptr_server->using_tlm_info()) &&

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+36]
	test	ecx, ecx
	je	SHORT $LN43@read_tile_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1080 :     bool using_tlm_info() { return translated_tlm_markers; }

	mov	al, BYTE PTR [ecx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2156 :               (!codestream->tpart_ptr_server->using_tlm_info()) &&

	test	al, al
	jne	SHORT $LN43@read_tile_
	cmp	DWORD PTR [esi], 0
	je	SHORT $LN42@read_tile_
	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN43@read_tile_
$LN42@read_tile_:

; 2157 :               ((tref->tpart_head == NULL) || (tref->tpart_tail != NULL)))
; 2158 :             {
; 2159 :               codestream->tpart_ptr_server->add_tpart(tref,sot_address);

	push	DWORD PTR _sot_address$2$[ebp]
	push	DWORD PTR _sot_address$1$[ebp]
	push	esi
	call	?add_tpart@kd_tpart_pointer_server@@QAEXPAUkd_tile_ref@@_J@Z ; kd_tpart_pointer_server::add_tpart

; 2160 :               if (sot_tpart_length == 0)

	mov	eax, ebx
	or	eax, 0
	jne	SHORT $LN43@read_tile_

; 2161 :                 {
; 2162 :                   tref->tpart_tail = NULL; // There can be no more t-parts

	mov	DWORD PTR [esi+4], eax

; 2163 :                   codestream->next_sot_address = -1;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+368], -1
	mov	DWORD PTR [eax+372], -1
$LN43@read_tile_:

; 2164 :                 }
; 2165 :             }
; 2166 :         }
; 2167 : 
; 2168 :       active = tref->tile;

	mov	esi, DWORD PTR [esi+8]

; 2169 :       if ((active == KD_EXPIRED_TILE) ||

	cmp	esi, -1
	je	$LN45@read_tile_
	test	esi, esi
	je	SHORT $LN47@read_tile_
	cmp	BYTE PTR [esi+268], 0
	jne	$LN45@read_tile_

; 2177 :           continue;
; 2178 :         }
; 2179 : 
; 2180 :       if ((active != NULL) && active->needs_reinit)

	cmp	BYTE PTR [esi+234], 0
	je	SHORT $LN47@read_tile_

; 2181 :         { // Reading this tile for first time since a codestream restart
; 2182 :           assert(codestream->allow_restart);
; 2183 :           active->reinitialize(); // May recursively call here

	mov	ecx, esi
	call	?reinitialize@kd_tile@@QAEXXZ		; kd_tile::reinitialize

; 2184 :           continue;

	jmp	$LN4@read_tile_
$LN47@read_tile_:

; 2185 :         }
; 2186 : 
; 2187 :       if (active != this)

	cmp	esi, edi
	je	SHORT $LN53@read_tile_

; 2188 :         {
; 2189 :           if (codestream->tpart_ptr_server != NULL)

	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax+36], 0
	je	SHORT $LN49@read_tile_

; 2190 :             { // No need to actually parse the tile-part right now, since we
; 2191 :               // can always come back later.  But we should make sure that
; 2192 :               // `active->tpart_ptrs' correctly indexes the next unread
; 2193 :               // tile-part first.
; 2194 :               if ((active != NULL) && (active->tpart_ptrs == NULL))

	test	esi, esi
	je	$LN4@read_tile_
	cmp	DWORD PTR [esi+20], 0
	jne	$LN4@read_tile_

; 2195 :                 {
; 2196 :                   if ((active->tpart_ptrs = tref->tpart_tail) == NULL)

	mov	ebx, DWORD PTR _tref$1$[ebp]
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [esi+20], eax
	test	eax, eax
	jne	$LN4@read_tile_

; 2200 :                       for (int tpctr=1; tpctr < active->next_tpart; tpctr++)

	mov	ecx, DWORD PTR [esi+244]
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR [esi+20], eax
	cmp	ecx, 1
	jle	$LN4@read_tile_

; 2197 :                     { // May happen, since the tail can be set to NULL to
; 2198 :                       // indicate the end of a tile-part
; 2199 :                       active->tpart_ptrs = tref->tpart_head;

	dec	ecx
	npad	1
$LL9@read_tile_:

; 2201 :                         {
; 2202 :                           active->tpart_ptrs = active->tpart_ptrs->next;

	mov	eax, DWORD PTR [eax+8]
	mov	DWORD PTR [esi+20], eax
	sub	ecx, 1
	jne	SHORT $LL9@read_tile_

; 2203 :                           assert(active->tpart_ptrs != NULL);
; 2204 :                         }
; 2205 :                     }
; 2206 :                 }
; 2207 :               continue;

	jmp	$LN4@read_tile_
$LN49@read_tile_:

; 2208 :             }
; 2209 :           else if (sot_tpart_length == 0)

	mov	eax, ebx
	or	eax, 0
	je	$LN236@read_tile_
$LN53@read_tile_:

; 2210 :             { // At the last tile-part and it belongs to a different tile
; 2211 :               finished_reading();
; 2212 :               return false;
; 2213 :             }
; 2214 :         }
; 2215 : 
; 2216 :       // If we get here, we are committed to parsing this tile-part header
; 2217 :       if (active == NULL)

	test	esi, esi
	jne	SHORT $LN54@read_tile_

; 2218 :         {
; 2219 :           active = codestream->create_tile(sot_idx);

	push	DWORD PTR _sot_idx$2$[ebp]
	mov	ecx, DWORD PTR [edi]
	push	DWORD PTR _sot_idx$1$[ebp]
	call	?create_tile@kd_codestream@@QAEPAUkd_tile@@Ukdu_coords@@@Z ; kd_codestream::create_tile

; 2220 :           continue; // Above call should invoke present function recursively,

	jmp	$LN4@read_tile_
$LN54@read_tile_:

; 2221 :                     // so tile-part header will have already been parsed.
; 2222 :         }
; 2223 : 
; 2224 :       // Read a new tile-part header for the `active' tile.
; 2225 :       assert(active->t_num == sot_tnum);
; 2226 :       if (active->next_tpart != sot_tpart)

	mov	eax, DWORD PTR _val$1$[ebp]
	cmp	DWORD PTR [esi+244], eax
	je	SHORT $LN276@read_tile_

; 2227 :         { KDU_ERROR(e,10); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$6[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$6[ebp]
	lea	ecx, DWORD PTR _e$6[ebp]
	push	OFFSET ??_C@_0DH@BFBKABHP@Missing?5or?5out?9of?9sequence?5tile?9@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2227 :         { KDU_ERROR(e,10); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2229 :             "tile number ") << sot_tnum << KDU_TXT(" in code-stream!");

	mov	ebx, DWORD PTR _val$2$[ebp]
	lea	ecx, DWORD PTR _e$6[ebp]
	push	ebx
	call	??6kdu_message@@QAEAAV0@H@Z		; kdu_message::operator<<
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0BB@LBOIHLHG@?5in?5code?9stream?$CB?$AA@
	mov	ecx, eax
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2230 :         }

	lea	ecx, DWORD PTR _e$6[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	jmp	SHORT $LN55@read_tile_
$LN276@read_tile_:
	mov	ebx, DWORD PTR _val$2$[ebp]
$LN55@read_tile_:

; 2231 :       if (sot_num_tparts != 0)

	mov	ecx, DWORD PTR _sot_num_tparts$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN59@read_tile_

; 2232 :         {
; 2233 :           if (active->num_tparts == 0)

	mov	eax, DWORD PTR [esi+240]
	test	eax, eax
	jne	SHORT $LN57@read_tile_

; 2234 :             active->num_tparts = sot_num_tparts;

	mov	DWORD PTR [esi+240], ecx
	jmp	SHORT $LN59@read_tile_
$LN57@read_tile_:

; 2235 :           else if (active->num_tparts != sot_num_tparts)

	cmp	eax, ecx
	je	SHORT $LN59@read_tile_

; 2236 :             { KDU_ERROR(e,11); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0CK@JIECJLAN@The?5number?5of?5tile?9parts?5for?5til@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2236 :             { KDU_ERROR(e,11); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2238 :                 << sot_tnum <<

	push	ebx
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??6kdu_message@@QAEAAV0@H@Z		; kdu_message::operator<<
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0FD@MEKGJNMP@?5is?5identified?5by?5different?5non?9@
	mov	ecx, eax
	mov	edx, DWORD PTR [eax]
	call	DWORD PTR [edx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2241 :             }

	lea	ecx, DWORD PTR _e$5[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN59@read_tile_:

; 2242 :         }
; 2243 : 
; 2244 :       // Release unloadable tiles in accordance with caching thresholds
; 2245 :       if (active->is_unloadable)

	cmp	BYTE PTR [esi+230], 0
	je	SHORT $LN60@read_tile_

; 2246 :         active->withdraw_from_unloadable_list();

	mov	ecx, esi
	call	?withdraw_from_unloadable_list@kd_tile@@AAEXXZ ; kd_tile::withdraw_from_unloadable_list
$LN60@read_tile_:

; 2247 :       codestream->unload_tiles_to_cache_threshold();

	mov	ecx, DWORD PTR [edi]
	call	?unload_tiles_to_cache_threshold@kd_codestream@@QAEXXZ ; kd_codestream::unload_tiles_to_cache_threshold

; 2248 : 
; 2249 :       kdu_params *root = codestream->siz;

	mov	eax, DWORD PTR [edi]

; 2250 :       kdu_params *cod = root->access_cluster(COD_params);

	push	OFFSET ??_C@_03LIMJJHMM@COD?$AA@
	mov	eax, DWORD PTR [eax+12]
	mov	ecx, eax
	mov	DWORD PTR _root$1$[ebp], eax
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 2251 :       cod = cod->access_relation(sot_tnum,-1,0,true); assert(cod != NULL);

	push	1
	push	0
	push	-1
	push	ebx
	mov	ecx, eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 2252 :       kdu_params *poc = root->access_cluster(POC_params);

	mov	ecx, DWORD PTR _root$1$[ebp]
	push	OFFSET ??_C@_03LFCEPJHK@POC?$AA@
	mov	DWORD PTR _cod$2$[ebp], eax
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 2253 :       poc = poc->access_relation(sot_tnum,-1,0,true); assert(poc != NULL);

	push	1
	push	0
	push	-1
	push	ebx
	mov	ecx, eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 2256 :       while (codestream->marker->read() &&

	mov	ecx, DWORD PTR [edi]
	push	0
	push	0
	mov	DWORD PTR _poc$2$[ebp], eax
	mov	ecx, DWORD PTR [ecx+16]
	call	?read@kd_marker@@QAE_N_N0@Z		; kd_marker::read
	test	al, al
	je	$LN237@read_tile_
	npad	3
$LL10@read_tile_:
	mov	ecx, DWORD PTR [edi]
	mov	edx, 65427				; 0000ff93H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 882  :     kdu_uint16 get_code() { return code; }

	mov	eax, DWORD PTR [ecx+16]
	movzx	ebx, WORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2256 :       while (codestream->marker->read() &&

	cmp	bx, dx
	je	$LN11@read_tile_

; 2257 :              ((code = codestream->marker->get_code()) != KDU_SOD))
; 2258 :         {
; 2259 :           if (code == KDU_PPT)

	mov	edx, 65377				; 0000ff61H
	cmp	bx, dx
	jne	SHORT $LN61@read_tile_

; 2260 :             {
; 2261 :               if (codestream->profile == 0)

	cmp	DWORD PTR [ecx+104], 0
	jne	SHORT $LN63@read_tile_

; 2262 :                 { KDU_WARNING(w,9); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$4[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$4[ebp]
	lea	ecx, DWORD PTR _w$4[ebp]
	push	OFFSET ??_C@_0KL@FMHHAPCD@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2262 :                 { KDU_WARNING(w,9); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2267 :                   codestream->profile = 2; // Prevent further warnings

	mov	eax, DWORD PTR [edi]

; 2268 :                 }

	lea	ecx, DWORD PTR _w$4[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [eax+104], 2
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN63@read_tile_:

; 2269 :               if (active->ppt_markers == NULL)

	cmp	DWORD PTR [esi+44], 0
	jne	SHORT $LN64@read_tile_

; 2270 :                 active->ppt_markers = new kd_pp_markers;

	push	8
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T15[ebp], eax
	test	eax, eax
	je	SHORT $LN78@read_tile_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 912  :       { list = NULL; }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2270 :                 active->ppt_markers = new kd_pp_markers;

	jmp	SHORT $LN79@read_tile_
$LN78@read_tile_:
	xor	eax, eax
$LN79@read_tile_:
	mov	DWORD PTR [esi+44], eax
$LN64@read_tile_:

; 2271 :               active->ppt_markers->add_marker(*(codestream->marker));

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [esi+44]
	push	DWORD PTR [eax+16]
	call	?add_marker@kd_pp_markers@@QAEXAAVkd_marker@@@Z ; kd_pp_markers::add_marker
	jmp	SHORT $LN66@read_tile_
$LN61@read_tile_:

; 2272 :             }
; 2273 :           else if (code == KDU_PLT)

	mov	ecx, 65368				; 0000ff58H
	cmp	bx, cx
	jne	SHORT $LN65@read_tile_

; 2274 :             active->precinct_pointer_server.add_plt_marker(

	push	DWORD PTR _poc$2$[ebp]
	lea	ecx, DWORD PTR [esi+56]
	push	DWORD PTR _cod$2$[ebp]
	push	eax
	call	?add_plt_marker@kd_precinct_pointer_server@@QAEXAAVkd_marker@@PAVkdu_params@@1@Z ; kd_precinct_pointer_server::add_plt_marker

; 2275 :                                               *(codestream->marker),cod,poc);
; 2276 :           else

	jmp	SHORT $LN66@read_tile_
$LN65@read_tile_:

; 2277 :             root->translate_marker_segment(code,

	push	DWORD PTR _val$1$[ebp]
	mov	ecx, DWORD PTR _root$1$[ebp]
	push	DWORD PTR _val$2$[ebp]
	push	DWORD PTR [eax+20]
	push	DWORD PTR [eax+12]
	push	ebx
	call	?translate_marker_segment@kdu_params@@QAE_NGHQAEHH@Z ; kdu_params::translate_marker_segment
$LN66@read_tile_:

; 2256 :       while (codestream->marker->read() &&

	mov	ecx, DWORD PTR [edi]
	push	0
	push	0
	mov	ecx, DWORD PTR [ecx+16]
	call	?read@kd_marker@@QAE_N_N0@Z		; kd_marker::read
	test	al, al
	jne	$LL10@read_tile_
$LN11@read_tile_:

; 2278 :                                            codestream->marker->get_length(),
; 2279 :                                            codestream->marker->get_bytes(),
; 2280 :                                            sot_tnum,sot_tpart);
; 2281 :         }
; 2282 :       if (code == 0)

	test	bx, bx
	je	$LN237@read_tile_

; 2291 :           return false;
; 2292 :         }
; 2293 : 
; 2294 :       root->finalize_all(sot_tnum,true); // Finalize tile-header params

	mov	ecx, DWORD PTR _root$1$[ebp]
	push	1
	push	DWORD PTR _val$2$[ebp]
	call	?finalize_all@kdu_params@@QAEXH_N@Z	; kdu_params::finalize_all

; 2295 :       kdu_long cur_offset = codestream->in->get_offset();

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 675  :         return cur_offset + last_loaded_bytes - (first_unwritten-first_unread);

	mov	eax, DWORD PTR [ecx+528]
	sub	eax, DWORD PTR [ecx+524]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2295 :       kdu_long cur_offset = codestream->in->get_offset();

	mov	ebx, DWORD PTR [ecx+576]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 675  :         return cur_offset + last_loaded_bytes - (first_unwritten-first_unread);

	cdq
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2295 :       kdu_long cur_offset = codestream->in->get_offset();

	sub	ebx, eax
	mov	eax, DWORD PTR [ecx+580]
	sbb	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 675  :         return cur_offset + last_loaded_bytes - (first_unwritten-first_unread);

	add	ebx, DWORD PTR [ecx+544]
	adc	eax, DWORD PTR [ecx+548]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2298 :       if (active->ppt_markers != NULL)

	cmp	DWORD PTR [esi+44], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 675  :         return cur_offset + last_loaded_bytes - (first_unwritten-first_unread);

	mov	DWORD PTR _cur_offset$2$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2300 :           if (codestream->ppm_markers != NULL)

	mov	eax, DWORD PTR [edi]
	je	$LN69@read_tile_
	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN71@read_tile_

; 2301 :             { KDU_ERROR(e,13); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0DE@HNLKCMOC@Use?5of?5both?5PPM?5and?5PPT?5marker?5s@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2301 :             { KDU_ERROR(e,13); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2304 :             }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN71@read_tile_:

; 2305 :           if (active->packed_headers == NULL)

	cmp	DWORD PTR [esi+48], 0
	jne	SHORT $LN72@read_tile_

; 2306 :             active->packed_headers = new kd_pph_input(codestream->buf_server);

	push	564					; 00000234H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T14[ebp], eax
	test	eax, eax
	je	SHORT $LN80@read_tile_
	mov	ecx, DWORD PTR [edi]
	push	DWORD PTR [ecx+24]
	mov	ecx, eax
	call	??0kd_pph_input@@QAE@PAVkd_buf_server@@@Z ; kd_pph_input::kd_pph_input
	jmp	SHORT $LN81@read_tile_
$LN80@read_tile_:
	xor	eax, eax
$LN81@read_tile_:
	mov	DWORD PTR [esi+48], eax
$LN72@read_tile_:

; 2307 :           active->ppt_markers->transfer_tpart(active->packed_headers);

	push	DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [esi+44]
	call	?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z ; kd_pp_markers::transfer_tpart

; 2308 :           delete active->ppt_markers;

	mov	eax, DWORD PTR [esi+44]
	mov	DWORD PTR $T12[ebp], eax
	test	eax, eax
	je	SHORT $LN219@read_tile_
	mov	ecx, eax
	call	??1kd_pp_markers@@QAE@XZ		; kd_pp_markers::~kd_pp_markers
	push	8
	push	DWORD PTR $T12[ebp]
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN219@read_tile_:

; 2309 :           active->ppt_markers = NULL;

	mov	DWORD PTR [esi+44], 0
	jmp	SHORT $LN73@read_tile_
$LN69@read_tile_:

; 2310 :         }
; 2311 :       else if (codestream->ppm_markers != NULL)

	cmp	DWORD PTR [eax+20], 0
	je	SHORT $LN73@read_tile_

; 2312 :         {
; 2313 :           if (active->packed_headers == NULL)

	cmp	DWORD PTR [esi+48], 0
	jne	SHORT $LN74@read_tile_

; 2314 :                 active->packed_headers =

	push	564					; 00000234H
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T13[ebp], eax
	test	eax, eax
	je	SHORT $LN84@read_tile_
	mov	ecx, DWORD PTR [edi]
	push	DWORD PTR [ecx+24]
	mov	ecx, eax
	call	??0kd_pph_input@@QAE@PAVkd_buf_server@@@Z ; kd_pph_input::kd_pph_input
	jmp	SHORT $LN85@read_tile_
$LN84@read_tile_:
	xor	eax, eax
$LN85@read_tile_:
	mov	DWORD PTR [esi+48], eax
$LN74@read_tile_:

; 2315 :                   new kd_pph_input(codestream->buf_server);
; 2316 :               codestream->ppm_markers->transfer_tpart(active->packed_headers);

	mov	ecx, DWORD PTR [edi]
	push	DWORD PTR [esi+48]
	mov	ecx, DWORD PTR [ecx+20]
	call	?transfer_tpart@kd_pp_markers@@QAEXPAVkd_pph_input@@@Z ; kd_pp_markers::transfer_tpart
$LN73@read_tile_:

; 2317 :         }
; 2318 : 
; 2319 :       // Compute precinct pointers from any available packet length info.
; 2320 :       if (sot_tpart_length == 0)

	mov	ecx, DWORD PTR _sot_tpart_length$1$[ebp]
	mov	eax, ecx
	or	eax, 0
	jne	SHORT $LN75@read_tile_

; 2321 :         active->precinct_pointer_server.start_tpart_body(cur_offset,0,cod,poc,

	cmp	DWORD PTR [esi+48], eax
	push	1
	setne	al
	movzx	eax, al
	push	eax
	push	DWORD PTR _poc$2$[ebp]
	push	DWORD PTR _cod$2$[ebp]
	push	0

; 2322 :                                         (active->packed_headers!=NULL),true);
; 2323 :       else

	jmp	SHORT $LN283@read_tile_
$LN75@read_tile_:

; 2324 :         {
; 2325 :           kdu_long tpart_body_length =
; 2326 :             sot_address + sot_tpart_length - cur_offset;
; 2327 :           assert(tpart_body_length >= 0);
; 2328 :           active->precinct_pointer_server.start_tpart_body(cur_offset,

	cmp	DWORD PTR [esi+48], 0
	push	0
	setne	al
	sub	ecx, ebx
	add	ecx, DWORD PTR _sot_address$1$[ebp]
	movzx	eax, al
	push	eax
	push	DWORD PTR _poc$2$[ebp]
	push	DWORD PTR _cod$2$[ebp]
	push	ecx
$LN283@read_tile_:
	push	DWORD PTR _cur_offset$2$[ebp]
	lea	ecx, DWORD PTR [esi+56]
	push	ebx
	call	?start_tpart_body@kd_precinct_pointer_server@@QAEX_JIPAVkdu_params@@1_N2@Z ; kd_precinct_pointer_server::start_tpart_body

; 2329 :                                       ((kdu_uint32) tpart_body_length),
; 2330 :                                       cod,poc,(active->packed_headers!=NULL),
; 2331 :                                       false);
; 2332 :         }
; 2333 : 
; 2334 :       // Make `active' the active tile.
; 2335 :       active->next_tpart++;

	inc	DWORD PTR [esi+244]

; 2338 :       active->adjust_unloadability();

	mov	ecx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1154 :       { return (buf_server != NULL); }

	cmp	DWORD PTR [esi+56], 0
	setne	al
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2336 :       active->is_addressable = active->precinct_pointer_server.is_active();

	mov	BYTE PTR [esi+231], al

; 2337 :       codestream->active_tile = active;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+364], esi

; 2338 :       active->adjust_unloadability();

	call	?adjust_unloadability@kd_tile@@QAEXXZ	; kd_tile::adjust_unloadability

; 2339 :       codestream->num_completed_tparts++;

	mov	eax, DWORD PTR [edi]
	inc	DWORD PTR [eax+380]
	jmp	SHORT $LN4@read_tile_
$LN45@read_tile_:

; 2170 :           ((active != NULL) && active->exhausted))
; 2171 :         { /* There is no more relevant information to be parsed from this tile.
; 2172 :              Skip to next SOT marker and discard any PPM/PLT info which may
; 2173 :              be available for this tile-part. */
; 2174 :           if (codestream->ppm_markers != NULL)

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [eax+20]
	test	ecx, ecx
	je	SHORT $LN46@read_tile_

; 2175 :             codestream->ppm_markers->ignore_tpart();

	call	?ignore_tpart@kd_pp_markers@@QAEXXZ	; kd_pp_markers::ignore_tpart
$LN46@read_tile_:

; 2176 :           codestream->marker->clear(); // Forces seeking to next tile-part

	mov	eax, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 891  :     void clear() { code = 0; length = 0; encountered_skip_code = false; }

	xor	ecx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2176 :           codestream->marker->clear(); // Forces seeking to next tile-part

	mov	eax, DWORD PTR [eax+16]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 891  :     void clear() { code = 0; length = 0; encountered_skip_code = false; }

	mov	WORD PTR [eax+8], cx
	mov	DWORD PTR [eax+12], ecx
	mov	BYTE PTR [eax+24], cl
$LN4@read_tile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2341 :     } while (this != codestream->active_tile);

	mov	eax, DWORD PTR [edi]
	cmp	edi, DWORD PTR [eax+364]
	je	$LN118@read_tile_
	jmp	$LN284@read_tile_
$LN27@read_tile_:

; 2064 :                    ((tile_ref->tpart_head != NULL) &&
; 2065 :                     (tile_ref->tpart_tail == NULL)))
; 2066 :             { // No more tile-parts for this tile.
; 2067 :               num_tparts = next_tpart;

	mov	eax, DWORD PTR [edi+244]
	mov	DWORD PTR [edi+240], eax
$LN236@read_tile_:

; 2068 :               finished_reading();

	mov	ecx, edi
	call	?finished_reading@kd_tile@@QAE_NXZ	; kd_tile::finished_reading

; 2108 :           return false;

	xor	al, al

; 2342 : 
; 2343 :   return true;
; 2344 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN237@read_tile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 528  :         return exhausted;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+4]
	mov	al, BYTE PTR [eax+533]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2284 :           if (!codestream->in->failed())

	test	al, al
	jne	SHORT $LN35@read_tile_

; 2285 :             { KDU_ERROR(e,12); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0JC@HCNJDFHD@Found?5non?9marker?5code?5while?5look@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2285 :             { KDU_ERROR(e,12); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2290 :             }

	lea	ecx, DWORD PTR _e$3[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
	xor	al, al

; 2342 : 
; 2343 :   return true;
; 2344 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN235@read_tile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T11[ebp]
	mov	DWORD PTR $T11[ebp], edx
	push	eax
	call	__CxxThrowException@8
$LN285@read_tile_:
$LN231@read_tile_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2106 :           if (codestream->next_sot_address == 0)

	mov	eax, DWORD PTR [ecx+368]
	or	eax, DWORD PTR [ecx+372]
	jne	SHORT $LN35@read_tile_

; 2107 :             codestream->next_sot_address = -1;

	mov	DWORD PTR [ecx+368], -1
	mov	DWORD PTR [ecx+372], -1
$LN35@read_tile_:

; 2108 :           return false;

	xor	al, al

; 2342 : 
; 2343 :   return true;
; 2344 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN282@read_tile_:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$0:
	lea	ecx, DWORD PTR _e$10[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$1:
	lea	ecx, DWORD PTR _e$9[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$2:
	lea	ecx, DWORD PTR _e$8[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$3:
	lea	ecx, DWORD PTR _e$7[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$4:
	lea	ecx, DWORD PTR _e$6[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$5:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$6:
	lea	ecx, DWORD PTR _w$4[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$9:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?read_tile_part_header@kd_tile@@QAE_NXZ$8:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?read_tile_part_header@kd_tile@@QAE_NXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?read_tile_part_header@kd_tile@@QAE_NXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?read_tile_part_header@kd_tile@@QAE_NXZ ENDP		; kd_tile::read_tile_part_header
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?open@kd_tile@@QAEXXZ
_TEXT	SEGMENT
_e$2 = -136						; size = 20
$T3 = -132						; size = 16
_this$1$ = -116						; size = 4
_ps$4 = -112						; size = 8
_p_dims$2$ = -108					; size = 4
_p_dims$1$ = -104					; size = 4
_check_dims$5 = -100					; size = 16
_p_dims$6 = -84						; size = 16
tv665 = -68						; size = 4
tv664 = -64						; size = 4
_r$1$ = -60						; size = 4
_p_idx$2$ = -56						; size = 4
_h_span$1$ = -52					; size = 4
_comp$1$ = -48						; size = 4
tv667 = -44						; size = 4
_rc$1$ = -40						; size = 4
_corner$1$ = -36					; size = 4
_v$1$ = -32						; size = 4
_c$1$ = -28						; size = 4
_ps$1$ = -24						; size = 4
_res$1$ = -20						; size = 4
_hor_split$1$ = -15					; size = 1
_reopening$1$ = -14					; size = 1
_vert_split$1$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
?open@kd_tile@@QAEXXZ PROC				; kd_tile::open, COMDAT
; _this$ = ecx

; 1663 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?open@kd_tile@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 124				; 0000007cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi

; 1664 :   if (is_open)

	cmp	BYTE PTR [edi+229], 0
	je	SHORT $LN20@open

; 1665 :     { KDU_ERROR_DEV(e,5); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0DB@CKMBKEOA@You?5must?5close?5a?5tile?5before?5you@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1665 :     { KDU_ERROR_DEV(e,5); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1667 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN20@open:

; 1668 :   if (codestream->persistent)

	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax+337], 0
	je	SHORT $LN21@open

; 1669 :     set_elements_of_interest();

	mov	ecx, edi
	call	?set_elements_of_interest@kd_tile@@AAEXXZ ; kd_tile::set_elements_of_interest
$LN21@open:

; 1670 :   if (codestream->out != NULL)

	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax+8], 0
	je	$LN3@open

; 1671 :     {
; 1672 :       assert((!is_in_progress) && (in_progress_next == NULL));
; 1673 :       if ((in_progress_prev = codestream->tiles_in_progress_tail) == NULL)

	mov	ecx, DWORD PTR [eax+272]
	mov	DWORD PTR [edi+28], ecx
	test	ecx, ecx
	jne	SHORT $LN23@open

; 1674 :         codestream->tiles_in_progress_head = this;

	mov	DWORD PTR [eax+268], edi

; 1675 :       else

	jmp	SHORT $LN24@open
$LN23@open:

; 1676 :         in_progress_prev->in_progress_next = this;

	mov	DWORD PTR [ecx+24], edi
$LN24@open:

; 1677 :       codestream->tiles_in_progress_tail = this;

	mov	eax, DWORD PTR [edi]

; 1678 :       is_in_progress = true;
; 1679 : 
; 1680 :       for (int c=0; c < num_components; c++)

	xor	ecx, ecx
	mov	DWORD PTR _c$1$[ebp], ecx
	mov	DWORD PTR [eax+272], edi
	mov	BYTE PTR [edi+228], 1
	cmp	DWORD PTR [edi+128], ecx
	jle	$LN3@open

; 1677 :       codestream->tiles_in_progress_tail = this;

	xor	edx, edx
	xor	ebx, ebx
	mov	DWORD PTR tv665[ebp], edx
	mov	DWORD PTR tv664[ebp], ebx
$LL4@open:

; 1681 :         {
; 1682 :           kd_tile_comp *comp = comps+c;

	mov	eax, DWORD PTR [edi+208]
	add	eax, ebx
	mov	DWORD PTR _comp$1$[ebp], eax

; 1683 :           kd_global_rescomp *rc = codestream->global_rescomps + c;

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax+276]

; 1684 :           bool reopening = false;
; 1685 :           int r;
; 1686 :           for (r=comp->dwt_levels; r >= 0; r--, rc+=num_components)

	mov	eax, DWORD PTR _comp$1$[ebp]
	add	ebx, edx
	xor	dl, dl
	mov	DWORD PTR _rc$1$[ebp], ebx
	mov	BYTE PTR _reopening$1$[ebp], dl
	mov	esi, DWORD PTR [eax+56]
	mov	DWORD PTR _r$1$[ebp], esi
	test	esi, esi
	js	$LN99@open

; 1681 :         {
; 1682 :           kd_tile_comp *comp = comps+c;

	imul	ecx, esi, 604
	mov	DWORD PTR tv667[ebp], ecx
	npad	6
$LL7@open:

; 1687 :             {
; 1688 :               kd_resolution *res = comp->resolutions + r;

	mov	eax, DWORD PTR [eax+144]
	add	eax, ecx
	mov	DWORD PTR _res$1$[ebp], eax

; 1689 :               if (reopening || (res->rescomp != NULL))

	test	dl, dl
	jne	$LN27@open
	cmp	DWORD PTR [eax+8], 0
	jne	$LN27@open

; 1693 :                 }
; 1694 :               else
; 1695 :                 {
; 1696 :                   res->rescomp = rc;
; 1697 :                   rc->notify_tile_status(dims,true);

	push	1
	mov	DWORD PTR [eax+8], ebx
	sub	esp, 16					; 00000010H
	movups	xmm0, XMMWORD PTR [edi+160]
	mov	eax, esp
	mov	ecx, ebx
	movups	XMMWORD PTR [eax], xmm0
	call	?notify_tile_status@kd_global_rescomp@@QAEXUkdu_dims@@_N@Z ; kd_global_rescomp::notify_tile_status

; 1698 : 
; 1699 :                   // Check for precincts, which contain no code-blocks.  These
; 1700 :                   // should be placed on the ready list immediately, since
; 1701 :                   // they will not be placed there by code-block generation.
; 1702 :                   if ((res->res_level > 0) && !(!res->precinct_indices))

	mov	edx, DWORD PTR _res$1$[ebp]
	cmp	BYTE PTR [edx+12], 0
	jbe	$LN109@open
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	cmp	DWORD PTR [edx+148], 0
	jle	$LN109@open
	cmp	DWORD PTR [edx+144], 0
	jle	$LN109@open
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1704 :                       bool hor_split = (res->node.children[HL_BAND] != NULL);

	movups	xmm1, XMMWORD PTR [edx+120]
	cmp	DWORD PTR [edx+96], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _ps$4[ebp+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1704 :                       bool hor_split = (res->node.children[HL_BAND] != NULL);

	setne	ch
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _ps$4[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1705 :                       bool vert_split = (res->node.children[LH_BAND] != NULL);

	cmp	DWORD PTR [edx+100], 0

; 1706 :                       kdu_coords ps, p_idx = res->precinct_indices.pos;
; 1707 :                       kdu_dims check_dims, p_dims = res->precinct_partition;
; 1708 :                       p_dims.pos.x += p_idx.x*p_dims.size.x;

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	movd	eax, xmm0
	setne	cl
	movups	XMMWORD PTR _p_dims$6[ebp], xmm1
	mov	BYTE PTR _hor_split$1$[ebp], ch
	mov	DWORD PTR _p_dims$1$[ebp], eax
	imul	eax, DWORD PTR [edx+140]
	psrldq	xmm1, 4
	movd	edi, xmm1
	mov	BYTE PTR _vert_split$1$[ebp], cl
	add	edi, eax

; 1709 :                       p_dims.pos.y += p_idx.y*p_dims.size.y;

	mov	eax, DWORD PTR _p_dims$6[ebp+8]
	imul	eax, DWORD PTR [edx+136]
	mov	DWORD PTR _p_dims$6[ebp+4], edi
	mov	DWORD PTR _p_dims$2$[ebp], edi
	add	DWORD PTR _p_dims$6[ebp], eax

; 1710 :                       for (int corner=0; corner < 4; corner++)

	xor	eax, eax
	movups	xmm0, XMMWORD PTR _p_dims$6[ebp]
	mov	DWORD PTR _corner$1$[ebp], eax
$LL10@open:

; 1711 :                         { // Check the four corner precincts
; 1712 :                           p_idx.x = p_idx.y = 0;

	xor	esi, esi
	xor	ebx, ebx
	mov	DWORD PTR _ps$1$[ebp], esi
	mov	DWORD PTR _p_idx$2$[ebp], ebx

; 1713 :                           if (corner & 1)

	test	al, 1
	je	SHORT $LN30@open

; 1714 :                             {
; 1715 :                               p_idx.x = res->precinct_indices.size.x - 1;

	mov	ebx, DWORD PTR [edx+148]
	dec	ebx
	mov	DWORD PTR _p_idx$2$[ebp], ebx

; 1716 :                               if ((p_idx.x < 1) || !hor_split)

	cmp	ebx, 1
	jl	$LN8@open
	test	ch, ch
	je	$LN8@open
$LN30@open:

; 1717 :                                 continue;
; 1718 :                             }
; 1719 :                           if (corner & 2)

	test	al, 2
	je	SHORT $LN33@open

; 1720 :                             {
; 1721 :                               p_idx.y = res->precinct_indices.size.y - 1;

	mov	esi, DWORD PTR [edx+144]
	dec	esi
	mov	DWORD PTR _ps$1$[ebp], esi

; 1722 :                               if ((p_idx.y < 1) || !vert_split)

	cmp	esi, 1
	jl	$LN8@open
	test	cl, cl
	je	$LN8@open
$LN33@open:

; 1723 :                                 continue;
; 1724 :                             }
; 1725 :                           check_dims = p_dims;
; 1726 :                           check_dims.pos.x += p_idx.x*check_dims.size.x;

	mov	eax, DWORD PTR _p_dims$1$[ebp]

; 1727 :                           check_dims.pos.y += p_idx.y*check_dims.size.y;
; 1728 :                           check_dims &= res->node.dims;

	lea	ecx, DWORD PTR _check_dims$5[ebp]
	imul	eax, ebx
	movups	XMMWORD PTR _check_dims$5[ebp], xmm0
	add	eax, edi
	mov	DWORD PTR _check_dims$5[ebp+4], eax
	mov	eax, DWORD PTR _check_dims$5[ebp+8]
	imul	eax, esi
	add	DWORD PTR _check_dims$5[ebp], eax
	lea	eax, DWORD PTR [edx+24]
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=

; 1729 :                           if (hor_split && ((check_dims.size.x != 1) ||

	mov	ch, BYTE PTR _hor_split$1$[ebp]
	test	ch, ch
	je	SHORT $LN35@open
	cmp	DWORD PTR _check_dims$5[ebp+12], 1
	jne	$LN102@open
	test	BYTE PTR _check_dims$5[ebp+4], 1
	jne	$LN102@open
$LN35@open:

; 1730 :                                             (check_dims.pos.x & 1)))
; 1731 :                             continue; // Precinct has horiz high-pass blocks
; 1732 :                           if (vert_split && ((check_dims.size.y != 1) ||

	mov	cl, BYTE PTR _vert_split$1$[ebp]
	test	cl, cl
	je	SHORT $LN37@open
	cmp	DWORD PTR _check_dims$5[ebp+8], 1
	jne	$LN101@open
	test	BYTE PTR _check_dims$5[ebp], 1
	jne	$LN101@open
$LN37@open:

; 1733 :                                              (check_dims.pos.y & 1)))
; 1734 :                             continue; // Precinct has vertical high-pass blocks
; 1735 : 
; 1736 :                           // If we get here, we have found a corner precinct
; 1737 :                           // which contains no code-blocks.  However, if this
; 1738 :                           // decomposition stage is not split in one of the
; 1739 :                           // horizontal or vertical directions, we will need
; 1740 :                           // to deal with a whole row or column (or even an
; 1741 :                           // entire region) of precincts which do not contain
; 1742 :                           // any code-blocks.
; 1743 :                           int h, v, h_span=1, v_span=1;
; 1744 :                           if (!hor_split)

	cmp	BYTE PTR _hor_split$1$[ebp], 0
	mov	ecx, 1

; 1745 :                             {
; 1746 :                               assert(p_idx.x == 0);
; 1747 :                               h_span = res->precinct_indices.size.x;

	mov	edx, DWORD PTR _res$1$[ebp]
	mov	eax, ecx
	mov	DWORD PTR _h_span$1$[ebp], ecx
	mov	DWORD PTR _v$1$[ebp], eax
	jne	SHORT $LN39@open
	mov	ecx, DWORD PTR [edx+148]
	mov	DWORD PTR _h_span$1$[ebp], ecx
$LN39@open:

; 1748 :                             }
; 1749 :                           if (!vert_split)

	cmp	BYTE PTR _vert_split$1$[ebp], 0
	jne	SHORT $LN40@open

; 1750 :                             {
; 1751 :                               assert(p_idx.y == 0);
; 1752 :                               v_span = res->precinct_indices.size.y;

	mov	eax, DWORD PTR [edx+144]
	mov	DWORD PTR _v$1$[ebp], eax
$LN40@open:

; 1753 :                             }
; 1754 : 
; 1755 :                           for (ps.y=p_idx.y, v=v_span; v > 0; v--, ps.y++)

	test	eax, eax
	jle	$LN105@open
$LL13@open:

; 1756 :                             for (ps.x=p_idx.x, h=h_span; h > 0; h--, ps.x++)

	mov	edi, ebx
	mov	ebx, ecx
	test	ecx, ecx
	jle	$LN11@open
$LL16@open:

; 1761 :                                   res->precinct_refs[pnum].open(res,ps,true);

	mov	ecx, DWORD PTR [edx+148]
	mov	eax, DWORD PTR [edx+180]
	imul	ecx, esi
	add	ecx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4722 :   if (state == 3)

	mov	edx, DWORD PTR [eax+ecx*8+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1761 :                                   res->precinct_refs[pnum].open(res,ps,true);

	lea	esi, DWORD PTR [eax+ecx*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4722 :   if (state == 3)

	mov	ecx, DWORD PTR [esi]
	cmp	ecx, 3
	jne	SHORT $LN59@open
	test	edx, edx
	jne	SHORT $LN59@open

; 4723 :     return NULL; // Precinct is not currently loaded

	xor	esi, esi
	jmp	SHORT $LN58@open
$LN59@open:

; 4724 :   if ((state == 0) || (state & 1))

	mov	eax, ecx
	or	eax, edx
	je	SHORT $LN61@open
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN61@open

; 4726 :   kd_precinct *result = (kd_precinct *) _kdu_long_to_addr(state);

	mov	esi, DWORD PTR [esi]

; 4727 :   if (result->flags & KD_PFLAG_INACTIVE)

	mov	eax, DWORD PTR [esi+8]
	test	al, 32					; 00000020H
	je	SHORT $LN62@open

; 4728 :     { // Must be on the inactive list
; 4729 :       result->size_class->withdraw_from_inactive_list(result);

	mov	ecx, DWORD PTR [esi+52]
	push	esi
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list

; 4730 :       result->activate();

	mov	ecx, esi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate
	jmp	SHORT $LN58@open
$LN62@open:

; 4731 :     }
; 4732 :   else if (need_activate && (result->flags & KD_PFLAG_RELEASED))

	test	al, 16					; 00000010H
	je	SHORT $LN58@open

; 4733 :     result->activate();

	mov	ecx, esi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate

; 4734 :   return result;

	jmp	SHORT $LN58@open
$LN61@open:

; 4725 :     return instantiate_precinct(res,pos_idx);

	mov	eax, DWORD PTR _res$1$[ebp]
	mov	ecx, esi
	push	edi
	push	DWORD PTR _ps$1$[ebp]
	push	eax
	call	?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z ; kd_precinct_ref::instantiate_precinct
	mov	esi, eax
$LN58@open:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1762 :                                 rc->add_ready_precinct(precinct);

	mov	ecx, DWORD PTR _rc$1$[ebp]
	push	esi
	call	?add_ready_precinct@kd_global_rescomp@@QAEXPAUkd_precinct@@@Z ; kd_global_rescomp::add_ready_precinct
	mov	esi, DWORD PTR _ps$1$[ebp]
	dec	ebx
	mov	edx, DWORD PTR _res$1$[ebp]
	inc	edi
	test	ebx, ebx
	jg	$LL16@open
	mov	eax, DWORD PTR _v$1$[ebp]
	mov	ecx, DWORD PTR _h_span$1$[ebp]
$LN11@open:

; 1753 :                             }
; 1754 : 
; 1755 :                           for (ps.y=p_idx.y, v=v_span; v > 0; v--, ps.y++)

	mov	edx, DWORD PTR _res$1$[ebp]
	dec	eax
	mov	ebx, DWORD PTR _p_idx$2$[ebp]
	inc	esi
	mov	DWORD PTR _v$1$[ebp], eax
	mov	DWORD PTR _ps$1$[ebp], esi
	test	eax, eax
	jg	$LL13@open
	mov	edi, DWORD PTR _p_dims$2$[ebp]
$LN105@open:
	mov	ch, BYTE PTR _hor_split$1$[ebp]
$LN113@open:
	mov	cl, BYTE PTR _vert_split$1$[ebp]
$LN112@open:
	movups	xmm0, XMMWORD PTR _p_dims$6[ebp]
$LN8@open:

; 1710 :                       for (int corner=0; corner < 4; corner++)

	mov	ebx, DWORD PTR _corner$1$[ebp]
	inc	ebx
	mov	DWORD PTR _corner$1$[ebp], ebx
	mov	eax, ebx
	cmp	ebx, 4
	jl	$LL10@open

; 1689 :               if (reopening || (res->rescomp != NULL))

	mov	ebx, DWORD PTR _rc$1$[ebp]
	mov	edi, DWORD PTR _this$1$[ebp]
	mov	esi, DWORD PTR _r$1$[ebp]
$LN109@open:
	mov	dl, BYTE PTR _reopening$1$[ebp]
$LN5@open:

; 1684 :           bool reopening = false;
; 1685 :           int r;
; 1686 :           for (r=comp->dwt_levels; r >= 0; r--, rc+=num_components)

	mov	eax, DWORD PTR [edi+128]
	dec	esi
	sub	DWORD PTR tv667[ebp], 604		; 0000025cH
	mov	ecx, DWORD PTR tv667[ebp]
	mov	DWORD PTR _r$1$[ebp], esi
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 4
	add	ebx, eax
	mov	eax, DWORD PTR _comp$1$[ebp]
	mov	DWORD PTR _rc$1$[ebp], ebx
	test	esi, esi
	jns	$LL7@open

; 1763 :                               }
; 1764 :                         }
; 1765 :                     }
; 1766 :                 }
; 1767 :             }
; 1768 :           if (!reopening)

	mov	ecx, DWORD PTR _c$1$[ebp]
	test	dl, dl
	jne	SHORT $LN2@open
$LN99@open:

; 1769 :             for (r=32-comp->dwt_levels; r > 0; r--, rc+=num_components)

	mov	esi, 32					; 00000020H
	sub	esi, DWORD PTR [eax+56]
	test	esi, esi
	jle	SHORT $LN2@open
	npad	4
$LL19@open:

; 1770 :               rc->notify_tile_status(dims,false);

	movups	xmm0, XMMWORD PTR [edi+160]
	push	0
	sub	esp, 16					; 00000010H
	mov	ecx, ebx
	mov	eax, esp
	movups	XMMWORD PTR [eax], xmm0
	call	?notify_tile_status@kd_global_rescomp@@QAEXUkdu_dims@@_N@Z ; kd_global_rescomp::notify_tile_status
	mov	eax, DWORD PTR [edi+128]
	dec	esi
	lea	eax, DWORD PTR [eax+eax*4]
	shl	eax, 4
	add	ebx, eax
	test	esi, esi
	jg	SHORT $LL19@open
	mov	ecx, DWORD PTR _c$1$[ebp]
$LN2@open:

; 1678 :       is_in_progress = true;
; 1679 : 
; 1680 :       for (int c=0; c < num_components; c++)

	mov	ebx, DWORD PTR tv664[ebp]
	inc	ecx
	mov	edx, DWORD PTR tv665[ebp]
	add	ebx, 188				; 000000bcH
	add	edx, 80					; 00000050H
	mov	DWORD PTR _c$1$[ebp], ecx
	mov	DWORD PTR tv664[ebp], ebx
	mov	DWORD PTR tv665[ebp], edx
	cmp	ecx, DWORD PTR [edi+128]
	jl	$LL4@open
$LN3@open:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2743 :         if ((!codestream->persistent) ||

	mov	eax, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1773 :   is_open = true;

	mov	BYTE PTR [edi+229], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2743 :         if ((!codestream->persistent) ||

	cmp	BYTE PTR [eax+337], 0
	je	SHORT $LN72@open
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN67@open
	cmp	BYTE PTR [eax+338], 0
	je	SHORT $LN72@open
$LN67@open:

; 2744 :             ((codestream->tpart_ptr_server==NULL) && !codestream->cached))
; 2745 :           { assert(!is_unloadable); return; }
; 2746 :         if (is_open || (this==codestream->active_tile))
; 2747 :           { // Should not be on the unloadable list
; 2748 :             if (is_unloadable)

	cmp	BYTE PTR [edi+230], 0
	je	SHORT $LN72@open

; 2749 :               withdraw_from_unloadable_list();

	mov	ecx, edi
	call	?withdraw_from_unloadable_list@kd_tile@@AAEXXZ ; kd_tile::withdraw_from_unloadable_list
$LN72@open:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1775 :   codestream->num_open_tiles++;

	mov	eax, DWORD PTR [edi]
	inc	DWORD PTR [eax+204]

; 1776 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN101@open:
	mov	edx, DWORD PTR _res$1$[ebp]
	jmp	$LN112@open
$LN102@open:
	mov	edx, DWORD PTR _res$1$[ebp]
	jmp	$LN113@open
$LN27@open:

; 1690 :                 {
; 1691 :                   assert(res->rescomp == rc);
; 1692 :                   reopening = true;

	mov	dl, 1
	mov	BYTE PTR _reopening$1$[ebp], dl
	jmp	$LN5@open
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open@kd_tile@@QAEXXZ$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?open@kd_tile@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-140]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?open@kd_tile@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?open@kd_tile@@QAEXXZ ENDP				; kd_tile::open
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?reinitialize@kd_tile@@QAEXXZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
?reinitialize@kd_tile@@QAEXXZ PROC			; kd_tile::reinitialize, COMDAT
; _this$ = ecx

; 1607 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?reinitialize@kd_tile@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1608 :   assert(needs_reinit && !is_open);
; 1609 :   needs_reinit = false;
; 1610 : 
; 1611 :   assert(tile_ref->tile == this);
; 1612 : 
; 1613 :   // Read code-stream headers as required (input only) and check for changes
; 1614 :   bool read_failure = false;
; 1615 :   if (codestream->in != NULL)

	mov	eax, DWORD PTR [esi]
	xor	bl, bl
	mov	BYTE PTR [esi+234], 0
	mov	ecx, DWORD PTR [eax+4]
	test	ecx, ecx
	je	SHORT $LN51@reinitiali
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 656  :       { return source->get_capabilities(); }

	mov	ecx, DWORD PTR [ecx+540]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1617 :       if (codestream->in->get_capabilities() & KDU_SOURCE_CAP_SEEKABLE)

	test	al, 2
	je	SHORT $LN5@reinitiali

; 1618 :         precinct_pointer_server.initialize(codestream->buf_server);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+56]
	push	DWORD PTR [eax+24]
	call	?initialize@kd_precinct_pointer_server@@QAEXPAVkd_buf_server@@@Z ; kd_precinct_pointer_server::initialize
$LN5@reinitiali:

; 1619 :       tpart_ptrs = tile_ref->tpart_head;

	mov	eax, DWORD PTR [esi+16]

; 1620 :       if (!read_tile_part_header())

	mov	ecx, esi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+20], eax
	call	?read_tile_part_header@kd_tile@@QAE_NXZ	; kd_tile::read_tile_part_header
	test	al, al
	jne	SHORT $LN51@reinitiali

; 1621 :         read_failure = true;

	mov	bl, 1
$LN9@reinitiali:

; 1624 :     { // We can fully re-use the existing structure
; 1625 :       initialized = true;
; 1626 :       sequencer->init();

	mov	ecx, DWORD PTR [esi+52]
	mov	BYTE PTR [esi+233], 1
	call	?init@kd_packet_sequencer@@QAEXXZ	; kd_packet_sequencer::init

; 1627 :       if (!codestream->persistent)

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+337], 0
	jne	SHORT $LN10@reinitiali

; 1628 :         set_elements_of_interest(); // May change `max_relevant_packets/layers'

	mov	ecx, esi
	call	?set_elements_of_interest@kd_tile@@AAEXXZ ; kd_tile::set_elements_of_interest
$LN10@reinitiali:

; 1629 :       if (read_failure)

	test	bl, bl
	je	SHORT $LN11@reinitiali

; 1630 :         finished_reading();

	mov	ecx, esi
	call	?finished_reading@kd_tile@@QAE_NXZ	; kd_tile::finished_reading
$LN11@reinitiali:

; 1654 :     }
; 1655 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
$LN51@reinitiali:

; 1622 :     }
; 1623 :   if (read_failure || !codestream->siz->any_changes())

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+12]
	call	?any_changes@kdu_params@@QAE_NXZ	; kdu_params::any_changes
	test	al, al
	je	SHORT $LN9@reinitiali

; 1631 :     }
; 1632 :   else
; 1633 :     { /* We need to delete the tile's contents and start again
; 1634 :          with a call to `initialize'. */
; 1635 :       if (sequencer != NULL)

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN12@reinitiali

; 1636 :         delete sequencer;

	push	176					; 000000b0H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN12@reinitiali:

; 1637 :       sequencer = NULL;
; 1638 :       if (comps != NULL)

	mov	eax, DWORD PTR [esi+208]
	mov	DWORD PTR [esi+52], 0
	test	eax, eax
	je	SHORT $LN15@reinitiali
	push	OFFSET ??1kd_tile_comp@@QAE@XZ		; kd_tile_comp::~kd_tile_comp
	push	DWORD PTR [eax-4]
	lea	edi, DWORD PTR [eax-4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	188					; 000000bcH
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	imul	eax, DWORD PTR [edi], 188
	add	eax, 4
	push	eax
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN15@reinitiali:

; 1641 :       while ((mct_tail=mct_head) != NULL)

	mov	eax, DWORD PTR [esi+200]
	mov	DWORD PTR [esi+208], 0
	mov	DWORD PTR [esi+204], eax
	test	eax, eax
	je	$LN3@reinitiali
$LL2@reinitiali:

; 1642 :         {
; 1643 :           mct_head = mct_tail->next_stage;

	mov	eax, DWORD PTR [esi+204]

; 1644 :           delete mct_tail;

	mov	ebx, DWORD PTR [esi+204]
	mov	eax, DWORD PTR [eax+36]
	mov	DWORD PTR [esi+200], eax
	test	ebx, ebx
	je	SHORT $LN17@reinitiali
	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2136 :         if (input_required_indices != NULL)

	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax
	je	SHORT $LN32@reinitiali

; 2137 :           delete[] input_required_indices;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN32@reinitiali:

; 2138 :         if (output_comp_info != NULL) delete[] output_comp_info;

	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	SHORT $LN33@reinitiali
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN33@reinitiali:

; 2139 :         if (blocks != NULL) delete[] blocks;

	mov	eax, DWORD PTR [ebx+28]
	test	eax, eax
	je	SHORT $LN42@reinitiali
	push	OFFSET ??1kd_mct_block@@QAE@XZ		; kd_mct_block::~kd_mct_block
	push	DWORD PTR [eax-4]
	lea	edi, DWORD PTR [eax-4]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	108					; 0000006cH
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	imul	eax, DWORD PTR [edi], 108
	add	eax, 4
	push	eax
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN42@reinitiali:
	push	40					; 00000028H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN17@reinitiali:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1641 :       while ((mct_tail=mct_head) != NULL)

	mov	eax, DWORD PTR [esi+200]
	mov	DWORD PTR [esi+204], eax
	test	eax, eax
	jne	$LL2@reinitiali
$LN3@reinitiali:

; 1645 :         }
; 1646 :       is_typical = fully_typical = false;
; 1647 :       insert_plt_segments = false;
; 1648 :       resolution_tparts = component_tparts = layer_tparts = false;
; 1649 :       initialized = true; // Make sure `initialize' does not call
; 1650 :                           // `read_tile_part_header' again
; 1651 :       codestream->buf_server->augment_structure_bytes(-structure_bytes);

	mov	eax, DWORD PTR [esi]
	mov	WORD PTR [esi+124], 0
	mov	DWORD PTR [esi+235], 0
	mov	BYTE PTR [esi+233], 1
	mov	ecx, DWORD PTR [eax+24]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	mov	eax, DWORD PTR [esi+216]
	sub	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR [esi+220]
	sbb	DWORD PTR [ecx+36], eax

; 281  :         if (structure_bytes > peak_structure_bytes)

	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [ecx+32]
	cmp	edx, DWORD PTR [ecx+44]
	jl	SHORT $LN46@reinitiali
	jg	SHORT $LN52@reinitiali
	cmp	eax, DWORD PTR [ecx+40]
	jbe	SHORT $LN46@reinitiali
$LN52@reinitiali:

; 282  :           peak_structure_bytes = structure_bytes;

	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+44], edx
$LN46@reinitiali:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1653 :       initialize();

	mov	ecx, esi
	mov	DWORD PTR [esi+216], 0
	mov	DWORD PTR [esi+220], 0
	call	?initialize@kd_tile@@QAEXXZ		; kd_tile::initialize

; 1654 :     }
; 1655 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?reinitialize@kd_tile@@QAEXXZ$0:
	call	___std_terminate
	ret	0
__unwindfunclet$?reinitialize@kd_tile@@QAEXXZ$1:
	call	___std_terminate
	ret	0
__unwindfunclet$?reinitialize@kd_tile@@QAEXXZ$2:
	call	___std_terminate
	ret	0
__unwindfunclet$?reinitialize@kd_tile@@QAEXXZ$3:
	call	___std_terminate
	ret	0
__ehhandler$?reinitialize@kd_tile@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?reinitialize@kd_tile@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?reinitialize@kd_tile@@QAEXXZ ENDP			; kd_tile::reinitialize
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?restart@kd_tile@@QAEXXZ
_TEXT	SEGMENT
_this$GSCopy$1$ = -124					; size = 4
_comp$1$ = -120						; size = 4
_res$1$ = -116						; size = 4
_this$1$ = -112						; size = 4
tv688 = -108						; size = 4
tv689 = -104						; size = 4
_r$1$ = -100						; size = 4
_idx$2$ = -96						; size = 4
_c$1$ = -92						; size = 4
_idx$1$ = -88						; size = 4
_text$1 = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
?restart@kd_tile@@QAEXXZ PROC				; kd_tile::restart, COMDAT
; _this$ = ecx

; 1533 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 124				; 0000007cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, ecx
	push	esi
	mov	DWORD PTR _this$GSCopy$1$[ebp], ebx

; 1534 :   if (codestream->textualize_out != NULL)

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax], 0
	je	SHORT $LN20@restart

; 1535 :     {
; 1536 :       if (is_in_progress)

	cmp	BYTE PTR [ebx+228], 0
	je	SHORT $LN21@restart

; 1537 :         remove_from_in_progress_list(); // Should not happen; just for safety

	call	?remove_from_in_progress_list@kd_tile@@QAEXXZ ; kd_tile::remove_from_in_progress_list
$LN21@restart:

; 1538 :       kdu_message &out = *codestream->textualize_out;

	mov	eax, DWORD PTR [ebx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0BN@MCFNCJCD@?6?$DO?$DO?5New?5attributes?5for?5tile?5?$AA@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1538 :       kdu_message &out = *codestream->textualize_out;

	mov	esi, DWORD PTR [eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	ecx, esi
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR [esi+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR [ebx+4]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$1[ebp]
	push	eax
	call	_sprintf

; 263  :         put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$1[ebp]
	add	esp, 12					; 0000000cH
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_02NDKNKOCB@?3?6?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1540 :       codestream->siz->textualize_attributes(out,t_num,t_num);

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx]
	push	1
	push	eax
	push	eax
	mov	ecx, DWORD PTR [ecx+12]
	push	esi
	call	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@HH_N@Z ; kdu_params::textualize_attributes

; 1541 :       out.flush();

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	0
	call	DWORD PTR [eax+12]
$LN20@restart:

; 1542 :     }
; 1543 : 
; 1544 :   tpart_ptrs = NULL;
; 1545 :   if (packed_headers != NULL)

	mov	ecx, DWORD PTR [ebx+48]
	mov	DWORD PTR [ebx+20], 0
	test	ecx, ecx
	je	SHORT $LN24@restart

; 1546 :     delete packed_headers;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN24@restart:

; 1547 :   packed_headers = NULL;

	mov	DWORD PTR [ebx+48], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1231 :         if (buf_server == NULL) return;

	cmp	DWORD PTR [ebx+56], 0
	je	SHORT $LN34@restart

; 1232 :         while ((tail=head) != NULL)

	mov	eax, DWORD PTR [ebx+60]
	mov	DWORD PTR [ebx+64], eax
	test	eax, eax
	je	SHORT $LN36@restart
	npad	6
$LL35@restart:

; 1233 :           { head = tail->next; buf_server->release(tail); }

	mov	ecx, DWORD PTR [ebx+64]
	push	ecx
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ebx+56]
	mov	DWORD PTR [ebx+60], eax
	call	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ; kd_buf_server::release
	mov	eax, DWORD PTR [ebx+60]
	mov	DWORD PTR [ebx+64], eax
	test	eax, eax
	jne	SHORT $LL35@restart
$LN36@restart:

; 1234 :         buf_server = NULL;

	mov	DWORD PTR [ebx+56], 0
$LN34@restart:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1555 :   max_relevant_layers = num_layers; // May be reduced later

	mov	eax, DWORD PTR [ebx+132]
	mov	DWORD PTR [ebx+140], eax

; 1556 :   max_relevant_packets = total_precincts * num_layers; // May be reduced later

	cdq
	push	edx
	push	eax
	push	DWORD PTR [ebx+148]
	mov	DWORD PTR [ebx+184], 0
	push	DWORD PTR [ebx+144]
	mov	DWORD PTR [ebx+188], 0
	mov	DWORD PTR [ebx+240], 0
	mov	DWORD PTR [ebx+244], 0
	mov	WORD PTR [ebx+232], 0
	mov	BYTE PTR [ebx+268], 0
	mov	BYTE PTR [ebx+234], 1
	mov	DWORD PTR [ebx+248], 0
	call	__allmul
	mov	DWORD PTR [ebx+152], eax

; 1557 :   skipping_to_sop = false;
; 1558 :   next_input_packet_num = next_sop_sequence_num = 0;
; 1559 : 
; 1560 :   for (int c=0; c < num_components; c++)

	xor	eax, eax
	mov	DWORD PTR [ebx+156], edx
	mov	BYTE PTR [ebx+256], 0
	mov	DWORD PTR [ebx+260], 0
	mov	DWORD PTR [ebx+252], 0
	mov	DWORD PTR _c$1$[ebp], eax
	cmp	DWORD PTR [ebx+128], eax
	jle	$LN3@restart
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 210  :     kdu_coords(int x, int y) {this->x=x; this->y=y; }

	xor	ecx, ecx
	mov	DWORD PTR tv688[ebp], ecx
	push	edi
	npad	7
$LL4@restart:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1562 :       kd_tile_comp *comp = comps+c;

	mov	ebx, DWORD PTR [ebx+208]
	add	ebx, ecx
	mov	DWORD PTR _comp$1$[ebp], ebx

; 1563 :       comp->enabled = true;

	mov	WORD PTR [ebx+152], 257			; 00000101H

; 1567 :       comp->region = comp->dims;

	movups	xmm0, XMMWORD PTR [ebx+24]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2957 :         if (layer_stats != NULL)

	mov	edx, DWORD PTR [ebx+148]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1566 :       comp->apparent_dwt_levels = comp->dwt_levels;

	mov	ecx, DWORD PTR [ebx+56]
	mov	DWORD PTR [ebx+124], -1082130432	; bf800000H
	mov	DWORD PTR [ebx+60], ecx

; 1567 :       comp->region = comp->dims;

	movups	XMMWORD PTR [ebx+40], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2957 :         if (layer_stats != NULL)

	test	edx, edx
	je	SHORT $LN42@restart

; 2958 :           {
; 2959 :             int num_entries = ((1+dwt_levels)*tile->num_layers)<<1;
; 2960 :             memset(layer_stats,0,(size_t)(sizeof(kdu_long)*num_entries));

	mov	eax, DWORD PTR [ebx+4]
	inc	ecx
	imul	ecx, DWORD PTR [eax+132]
	shl	ecx, 4
	push	ecx
	push	0
	push	edx
	call	_memset
	mov	eax, DWORD PTR _c$1$[ebp]
	add	esp, 12					; 0000000cH
$LN42@restart:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1569 :       for (int r=0; r <= comp->dwt_levels; r++)

	cmp	DWORD PTR [ebx+56], 0
	mov	DWORD PTR _r$1$[ebp], 0
	jl	$LN2@restart
	xor	edx, edx
	mov	DWORD PTR tv689[ebp], edx
$LL7@restart:

; 1570 :         {
; 1571 :           kd_resolution *res = comp->resolutions + r;

	mov	ecx, DWORD PTR [ebx+144]

; 1572 :           res->rescomp = NULL;
; 1573 :           res->node.region = res->node.region_cover = res->node.dims;
; 1574 :           res->region_indices = res->precinct_indices;
; 1575 : 
; 1576 :           int b;
; 1577 :           for (b=0; b < res->num_intermediate_nodes; b++)

	xor	esi, esi
	add	ecx, edx
	mov	DWORD PTR _res$1$[ebp], ecx
	mov	DWORD PTR [ecx+8], 0
	cmp	BYTE PTR [ecx+175], 0
	movups	xmm0, XMMWORD PTR [ecx+24]
	movups	XMMWORD PTR [ecx+60], xmm0
	movups	xmm0, XMMWORD PTR [ecx+24]
	movups	XMMWORD PTR [ecx+40], xmm0
	movups	xmm0, XMMWORD PTR [ecx+136]
	movups	XMMWORD PTR [ecx+152], xmm0
	jbe	SHORT $LN9@restart

; 1570 :         {
; 1571 :           kd_resolution *res = comp->resolutions + r;

	xor	edx, edx
$LL10@restart:

; 1578 :             {
; 1579 :               kd_node *node = res->intermediate_nodes + b;

	mov	eax, DWORD PTR [ecx+176]
	inc	esi
	add	eax, edx
	add	edx, 104				; 00000068H

; 1580 :               node->region = node->region_cover = node->dims;

	movups	xmm0, XMMWORD PTR [eax+8]
	movups	XMMWORD PTR [eax+44], xmm0
	movups	xmm0, XMMWORD PTR [eax+8]
	movups	XMMWORD PTR [eax+24], xmm0
	movzx	eax, BYTE PTR [ecx+175]
	cmp	esi, eax
	jl	SHORT $LL10@restart
$LN9@restart:

; 1581 :             }
; 1582 :           for (b=0; b < res->num_subbands; b++)

	xor	edx, edx
	cmp	BYTE PTR [ecx+174], dl
	jbe	SHORT $LN12@restart
	xor	esi, esi
$LL13@restart:

; 1583 :             {
; 1584 :               kd_subband *band = res->subbands + b;

	mov	eax, DWORD PTR [ecx+184]
	inc	edx
	add	eax, esi
	add	esi, 132				; 00000084H

; 1585 :               band->region = band->dims;

	movups	xmm0, XMMWORD PTR [eax+8]
	movups	XMMWORD PTR [eax+24], xmm0

; 1586 :               band->region_indices = band->block_indices;

	movups	xmm0, XMMWORD PTR [eax+84]
	movups	XMMWORD PTR [eax+100], xmm0
	movzx	eax, BYTE PTR [ecx+174]
	cmp	edx, eax
	jl	SHORT $LL13@restart
$LN12@restart:

; 1587 :             }
; 1588 : 
; 1589 :           kdu_coords idx;
; 1590 :           for (idx.y=0; idx.y < res->precinct_indices.size.y; idx.y++)

	xor	edx, edx
	mov	DWORD PTR _idx$1$[ebp], edx
	cmp	DWORD PTR [ecx+144], edx
	jle	$LN5@restart
$LL16@restart:

; 1591 :             for (idx.x=0; idx.x < res->precinct_indices.size.x; idx.x++)

	xor	eax, eax
	mov	DWORD PTR _idx$2$[ebp], eax
	cmp	DWORD PTR [ecx+148], eax
	jle	$LN14@restart
	npad	14
$LL19@restart:

; 1592 :               {
; 1593 :                 kd_precinct_ref *ref = res->precinct_refs + idx.x +

	mov	esi, DWORD PTR [ecx+148]
	mov	ebx, DWORD PTR [ecx+180]
	imul	esi, edx
	add	esi, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4671 :   if (state && !(state & 1))

	mov	ecx, DWORD PTR [ebx+esi*8]
	mov	eax, ecx
	or	eax, DWORD PTR [ebx+esi*8+4]
	je	SHORT $LN53@restart
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN53@restart

; 4672 :     {
; 4673 :       kd_precinct *precinct = (kd_precinct *) _kdu_long_to_addr(state);

	mov	edi, DWORD PTR [ebx+esi*8]

; 4674 :       precinct->ref = NULL; // Satisfy the test in `kd_precinct::closing'

	mov	DWORD PTR [edi+4], ecx

; 4675 :       precinct->closing();

	mov	ecx, edi
	call	?closing@kd_precinct@@QAEXXZ		; kd_precinct::closing

; 2961 :           }
; 2962 :       }
; 2963 :   public: // Links and Identification
; 2964 :     kd_codestream *codestream;
; 2965 :     kd_tile *tile;
; 2966 :     kd_comp_info *comp_info; // Ptr to relevant `codestream->comp_info' entry
; 2967 :     int cnum;
; 2968 : 
; 2969 :   public: // Dimensions and Parameters
; 2970 :     kdu_coords sub_sampling;
; 2971 :     kdu_dims dims;
; 2972 :     kdu_dims region;
; 2973 :     int dwt_levels, apparent_dwt_levels;
; 2974 :     bool reversible;
; 2975 :     int kernel_id; // Ckernels_W5X3, Ckernels_W9X7 or Ckernels_ATK
; 2976 :     bool kernel_symmetric, kernel_symmetric_extension;
; 2977 :     int kernel_num_steps;
; 2978 :     kdu_kernel_step_info *kernel_step_info, *kernel_step_info_flipped;
; 2979 :     float *kernel_coefficients, *kernel_coefficients_flipped;
; 2980 :     float kernel_low_scale; // Amount to scale low-pass lifting analysis output
; 2981 :     float kernel_high_scale; // Amount to scale hi-pass lifting analysis output
; 2982 :     int low_support_min, low_support_max; // low-pass synthesis impulse support
; 2983 :     int high_support_min, high_support_max; // high-pass synth impulse support
; 2984 :     float G_tc; // Global multi-component energy gain term; -ve if not known
; 2985 :     float G_tc_restricted; // Multi-component energy gain term based only on
; 2986 :             // those output components currently of interest; -ve if not known
; 2987 :     int recommended_extra_bits;
; 2988 :     kdu_coords blk; // Nominal code-block dimensions.
; 2989 :     int modes; // Block coder modes.  Flags defined in scope `cod_params'
; 2990 : 
; 2991 :   public: // Arrays
; 2992 :     kd_resolution *resolutions; // Contains 1+`dwt_levels' entries.
; 2993 :     kdu_long *layer_stats; // Contains `num_layers' pairs per resolution,
; 2994 :       // starting from the lowest resolution (`res_level'=0); each pair holds
; 2995 :       // number of parsed packets for the layer-resolution, followed by
; 2996 :       // number of parsed packet bytes for the layer-resolution.  Available
; 2997 :       // only for input codestreams; populated by `kd_precinct::read_packet'.
; 2998 : 
; 2999 :   public: // Flags and Other State Variables
; 3000 :     bool enabled; // See below
; 3001 :     bool is_of_interest; // See below
; 3002 :     kdu_coords grid_min; // These fields are used by "kd_packet_sequencer"
; 3003 :     kdu_coords grid_inc; // for spatially oriented progressions.
; 3004 :     kdu_coords saved_grid_min; // For "kd_packet_sequencer::save_state"
; 3005 :     kdu_coords saved_grid_inc; // For "kd_packet_sequencer::save_state"
; 3006 :   };
; 3007 :   /* Notes:
; 3008 :         `recommended_extra_bits' may be added to the sample bit-depth
; 3009 :      (precision) for this component to determine an appropriate number
; 3010 :      of bits for internal representations associated with the data
; 3011 :      processing path.
; 3012 :         In the reversible path, the value is set to the maximum bit-depth
; 3013 :      expansion factor, as reported in Table 17.4 of the book by Taubman and
; 3014 :      Marcellin, adding an extra 1 bit if the RCT has been used -- note that it
; 3015 :      is not desirable for luminance and chrominance components to have
; 3016 :      different numeric representations, since that would significantly
; 3017 :      complicate the colour transform procedure.
; 3018 :         In the irreversible path, the value is set to 7, which means
; 3019 :      that 16-bit representations are judged sufficient for 9 bit
; 3020 :      imagery or less.  Of course, the impact of selecting a reduced
; 3021 :      representation precision is only reduced accuracy in the
; 3022 :      irreversible processing path.
; 3023 :         The `enabled' flag is used to efficiently identify the tile-components
; 3024 :      which are enabled.  Remember that a tile-component may be disabled,
; 3025 :      either because the corresponding codestream image component is not
; 3026 :      apparent (only when the `kd_codestream::component_access_mode' is
; 3027 :      `KDU_WANT_CODESTREAM_COMPONENTS'), or because the tile-component
; 3028 :      is not involved in the construction of an apparent output image
; 3029 :      component (when the `kd_codestream::component_access_mode' is
; 3030 :      `KDU_WANT_OUTPUT_COMPONENTS').  In the latter case, all codestream
; 3031 :      image components are apparent, but disabled ones cannot be
; 3032 :      accessed -- this is important, since in the latter case the set
; 3033 :      of enabled components may vary from tile to tile.
; 3034 :         The `is_of_interest' flag is used to store the identify of components
; 3035 :      which are marked as being of interest, by calls to
; 3036 :      `kdu_tile::set_components_of_interest'.  This is done only when the
; 3037 :      component access mode is `KDU_WANT_CODESTREAM_COMPONENTS' or the
; 3038 :      `mct_head' member is NULL.  Otherwise, the components of interest are
; 3039 :      passed directly to the `kd_mct_stage::apply_output_restrictions'
; 3040 :      function.  Note that the `is_of_interest' flags do not generally
; 3041 :      belong to the component in which they are stored.  They are just
; 3042 :      copies of the information supplied to
; 3043 :      `kdu_tile::set_components_of_interest', without any attempt to apply
; 3044 :      any component index permutations which might be relevant. */
; 3045 : 
; 3046 : /*****************************************************************************/
; 3047 : /*                            kd_precinct_ref                                */
; 3048 : /*****************************************************************************/
; 3049 : 
; 3050 :   /* Objects of this class provide the vehicle through which precincts
; 3051 :      references are instantiated and removed from the array of precinct
; 3052 :      references maintained by the `kd_resolution' object.  It is important
; 3053 :      that the state information be small.  In particular, it has the same
; 3054 :      size as `kdu_long', which should never be smaller than the size of
; 3055 :      a memory pointer, but may be larger -- see the declaration of
; 3056 :      `kdu_long' in "elementary.h".  For precincts whose seek addresses are
; 3057 :      deduced from PLT marker segments in the code-stream, or precincts which
; 3058 :      are maintained by a caching data source, or precincts which are used by
; 3059 :      codestream objects created for interchange, this object provides
; 3060 :      facilities for recycling a disused precinct's resources while keeping its
; 3061 :      unique address around for rapid reloading in the event that it
; 3062 :      is required at a later point. */
; 3063 : 
; 3064 : class kd_precinct_ref {
; 3065 :   public: // Member functions
; 3066 :     kd_precinct_ref()
; 3067 :       { state = 0; }
; 3068 :     ~kd_precinct_ref()
; 3069 :       { if (!((state == 0) || (state & 1))) close(); }
; 3070 :     bool parsed_and_unloaded()
; 3071 :       { return ((state & 3) == 3) && (state != 3); }
; 3072 :       /* Returns true if the precinct is addressable (i.e., dynamically
; 3073 :          loadable) and it has been parsed and subsequently unloaded from
; 3074 :          memory. */
; 3075 :     kd_precinct *deref()
; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }
; 3077 :       /* Returns NULL unless the reference identifies a valid `kd_precinct'
; 3078 :          object, which is already loaded in memory. */
; 3079 :     kd_precinct *active_deref();
; 3080 :       /* Returns NULL unless the reference identifies a valid `kd_precinct'
; 3081 :          object, which is already loaded in memory and is in the active
; 3082 :          state. */
; 3083 :     kd_precinct *open(kd_resolution *res, kdu_coords pos_idx,
; 3084 :                       bool need_activate);
; 3085 :       /* Attempts to open the precinct at the indicated position within the
; 3086 :          array of precincts maintained by the indicated resolution object.
; 3087 :          `pos_idx' holds the horizontal and vertical position of the
; 3088 :          precinct (starting from 0) within the array of precincts for
; 3089 :          the given resolution.  That is, `pos_idx' holds a relative, not
; 3090 :          an absolute precinct index.
; 3091 :             If the precinct is known to be unloadable (this happens if the
; 3092 :          precinct has previously been opened and has then been permanently
; 3093 :          closed), the function returns NULL.
; 3094 :             If the precinct currently exists in memory (the `state' variable
; 3095 :          contains a valid pointer to the precinct), the function returns a
; 3096 :          pointer to that precinct; however, if `need_activate' is true
; 3097 :          and the precincts's `released' flag is true, `kd_precinct::activate'
; 3098 :          is called before returning the `kd_precinct' pointer.  When the
; 3099 :          codestream object was created for input or for interchange, the
; 3100 :          `need_activate' argument should be set to true only when the
; 3101 :          precinct is being opened in order to access code-block data.  In
; 3102 :          that case, the precinct must belong to an open tile and lie within
; 3103 :          the application's current region of interest, meaning that it will
; 3104 :          be released again when the tile is closed.  For codestream objects
; 3105 :          created for output, the argument should have no effect, since
; 3106 :          output precincts are not actually released.
; 3107 :             Otherwise, the function obtains a new `kd_precinct' object from
; 3108 :          the code-stream's precinct server and calls its `initialize'
; 3109 :          function.  If the `state' variable held the precinct's unique
; 3110 :          address value on entry, that address is written into the newly
; 3111 :          instantiated `kd_precinct' object's `unique_address' field, and
; 3112 :          the P bit (see notes on `state' below) is copied to the precinct's
; 3113 :          KD_PFLAG_PARSED flag.  If compressed data comes from a cached source,
; 3114 :          or the codestream object was created for interchange (no compressed
; 3115 :          data sources or targets), the newly created precinct is automatically
; 3116 :          marked as addressable, with its `unique_address' set to the
; 3117 :          precinct's unique identifier, as described in the comments appearing
; 3118 :          with the declaration of `kd_precinct::unique_address'.  For
; 3119 :          precincts which can be addressed using a seek address (for seekable
; 3120 :          compressed data sources), the seek address is installed using
; 3121 :          `set_address' from within the `kd_packet_sequencer::next_in_sequence'
; 3122 :          function.
; 3123 :             It is worth noting that this function may cause other precincts
; 3124 :          to be unloaded from memory, in order to conserve memory resources.
; 3125 :          If this happens, only precincts which have been released and
; 3126 :          which do not intersect with the current region of interest will be
; 3127 :          unloaded. */
; 3128 :     void close();
; 3129 :       /* Closes the active `kd_precinct' object whose pointer is in
; 3130 :          `state', calling its `closing' member function and recycling its
; 3131 :          storage.  If the precinct is marked as addressable, its
; 3132 :          `unique_address' member and KD_PFLAG_PARSED flag are recorded in
; 3133 :          `state' using the convention outlined in the notes below, allowing
; 3134 :          the precinct to be re-opened at a later point.
; 3135 :             In many cases, you are better off calling the `release' member
; 3136 :          function instead of `close' (see below).
; 3137 :             Note that this function may be safely invoked even when the
; 3138 :          precinct is not currently active -- it does nothing unless `state'
; 3139 :          holds a valid precinct address. */
; 3140 :     void close_and_reset();
; 3141 :       /* This function is used only by `kdu_tile::parse_all_relevant_packets'
; 3142 :          and then only if it is asked to parse everything from scratch.  The
; 3143 :          behaviour is similar to calling `close', except that the internal
; 3144 :          `state' record is left with its P flag reset, so that when the
; 3145 :          precinct is reloaded, its packet statistics will be entered into
; 3146 :          the `kd_tile_comp::layer_stats' array -- the caller invariably
; 3147 :          resets this array. */
; 3148 :     void release();
; 3149 :       /* This function should be called once a precinct is no longer
; 3150 :          required, in preference to the `close' function.  If the system is
; 3151 :          running low on resources, the function may unload the precinct from
; 3152 :          memory to recycle its resources.  Alternatively, the function is at
; 3153 :          liberty to leave the precinct in memory, moving it to a list of
; 3154 :          inactive precincts which are subject to unloading at some point in
; 3155 :          the future, when resources may be running low.  Non-addressable or
; 3156 :          cached precincts are unloaded immediately, since they are
; 3157 :          guaranteed never to be re-opened once `release' has been called. */
; 3158 :     void clear();
; 3159 :       /* This function recycles the storage associated with any existing
; 3160 :          precinct and sets the internal `state' variable to 0.  It is called
; 3161 :          when the code-stream management machinery is restarted. */
; 3162 :     bool is_desequenced();
; 3163 :       /* This function is intended for use within
; 3164 :          `kd_packet_sequencer::next_in_sequence', for checking whether
; 3165 :          or not the precinct which is returned by that function needs
; 3166 :          to have its contents read from a compressed data source in
; 3167 :          order to desequence a new packet.  Opening precincts can be a time
; 3168 :          consuming task, especially when there are an enormous number of
; 3169 :          precincts (this can happen when working with huge untiled images,
; 3170 :          especially in geospatial applications).  This function takes
; 3171 :          advantage of the fact that there is no need to actually open a
; 3172 :          precinct which is not already loaded into memory.  The fact that this
; 3173 :          function is called first by the packet desequencer, allows a precinct
; 3174 :          which has already been fully generated to be closed immediately
; 3175 :          during packet generation mode.
; 3176 :             The function works as follows.  If the precinct is already loaded
; 3177 :          in memory, its `sequenced' flag is accessed directly.   Otherwise,
; 3178 :          if the reference `state' variable identifies a valid unique
; 3179 :          address for the precinct, it is known to be addressable and
; 3180 :          therefore must have already been fully desequenced.  Also, if the
; 3181 :          `state' variable indicates that the precinct is unloadable, or that
; 3182 :          it has been closed in packet generation mode, it is interpreted as
; 3183 :          sequenced, in the sense that the application cannot sequence further
; 3184 :          packets for the precinct.  Otherwise, the `state' variable must hold
; 3185 :          0 (see below), from which we deduce that the precinct has not yet
; 3186 :          been sequenced. */
; 3187 :     bool set_address(kd_resolution *res, kdu_coords pos_idx,
; 3188 :                      kdu_long seek_address);
; 3189 :       /* Called from within `kd_packet_sequencer::next_in_sequence', this
; 3190 :          function installs a seek address for a precinct whose packets are
; 3191 :          contiguous within the code-stream and have valid pointer information
; 3192 :          stored in PLT marker segments.  Subsequent calls to `is_sequenced'
; 3193 :          will return true.  The precinct itself may either be open or closed
; 3194 :          when this function is called.  The `pos_idx' argument is provided
; 3195 :          for computing the relevance of this precinct to the application.  It
; 3196 :          holds a relative precinct index, having the same interpretation as
; 3197 :          that passed to `kd_precinct::initialize' and `kdu_precinct_ref::open'.
; 3198 :             It can happen that this function causes the tile, and hence the
; 3199 :          precinct reference, to be destroyed.  This happens if the call to
; 3200 :          this function renders the resolution or tile completely parsed,
; 3201 :          and it is known that the application has no need for any further
; 3202 :          access to the tile.  In this case, and only in this case, the
; 3203 :          function returns false, meaning that the caller must not make
; 3204 :          any further attempt to access the tile or any of its resources. */
; 3205 :   private: // Utility functions
; 3206 :     kd_precinct *instantiate_precinct(kd_resolution *res, kdu_coords pos_idx);
; 3207 :       /* Called from `open' if the `kd_precinct' object is not in memory at
; 3208 :          the time and can legitimately be created at this point. */
; 3209 :   private: // Data
; 3210 :     kdu_long state;
; 3211 :   };
; 3212 :   /* Notes:
; 3213 :         `state' holds 0 if no information is yet available concerning the
; 3214 :      precinct associated with this reference.
; 3215 :         If the precinct is currently active in memory, `state' holds the
; 3216 :      address in memory (pointer) of the `kd_precinct' structure.
; 3217 :         If the precinct is known to be addressable, `state' holds an odd
; 3218 :      integer, equal to 4*A + 2*P + 1, where A is the precinct's
; 3219 :      `unique_address' value and P is a flag, equal to 1 if the precinct
; 3220 :      has been loaded and parsed previously.
; 3221 :         The `unique_address' value has the same definition as the
; 3222 :      corresponding data member in `kd_precinct'.
; 3223 :         This P flag plays the same role as the KD_PFLAG_PARSED bit in
; 3224 :      `kd_precinct::flags'.  It is used to avoid collecting layer size
; 3225 :      statistics twice for the same precinct which could otherwise happen
; 3226 :      when precincts get swapped in and out of memory on demand.
; 3227 :         A value of `state'=1 means that the precinct can be re-instantiated,
; 3228 :      but that it is known to contain no packets whatsoever.
; 3229 :         If a previously active precinct's resources have been recycled and
; 3230 :      re-loading is not possible, `state' is assigned the special value of 3. */
; 3231 : 
; 3232 : /*****************************************************************************/
; 3233 : /*                               kd_leaf_node                                */
; 3234 : /*****************************************************************************/
; 3235 : 
; 3236 : struct kd_leaf_node {
; 3237 :     public: // Data
; 3238 :       kd_node *parent; // Every leaf node has a non-leaf parent node
; 3239 :       kd_resolution *resolution; // Always points to the owning resolution
; 3240 :       kdu_dims dims; // Dimensions & location of the image at this node
; 3241 :       kdu_dims region; // See below
; 3242 :       kdu_byte branch_x, branch_y; // See below
; 3243 :       bool is_leaf; // False if this object is the base of `kd_node'
; 3244 :   };
; 3245 :   /* Notes:
; 3246 :         This structure is the base of the richer `kd_node' structure.  The
; 3247 :      key difference is that leaf nodes have no children, so we do not waste
; 3248 :      storage recording pointers to them.
; 3249 :         The `branch_x' and `branch_y' members describe how this node is
; 3250 :      derived from its parent node, if any.  `branch_x' holds 0 if horizontal
; 3251 :      low-pass filtering and decimation were used to obtain the node from its
; 3252 :      parent; it holds 1 if horizontal high-pass filtering and decimation were
; 3253 :      used; it holds 2 if no filtering or decimation were involved in the
; 3254 :      horizontal direction.  `branch_y' plays a similar role in describing the
; 3255 :      vertical filtering and decimation processes.  If `parent' is NULL,
; 3256 :      the `branch_x' and `branch_y' members have no meaning.
; 3257 :         This structure manages two different, yet related regions
; 3258 :      (location, plus dimensions) which deserve some explanation here.
; 3259 :      * The `dims' member serves the usual role of identifying the location and
; 3260 :        dimensions of the image, as it appears on entry into this node,
; 3261 :        during forward transformation (analysis).  For primary nodes,
; 3262 :        these are the dimensions and location of the tile-component-resolution
; 3263 :        within its canvas.
; 3264 :      * `region' identifies a subset of the `dims' region, containing
; 3265 :        all of the node's samples which are involved in the synthesis of the
; 3266 :        current region of interest, as specified in the most recent call to
; 3267 :        `kdu_codestream::apply_input_restrictions'. */
; 3268 : 
; 3269 : /*****************************************************************************/
; 3270 : /*                                 kd_node                                   */
; 3271 : /*****************************************************************************/
; 3272 : 
; 3273 : struct kd_node : public kd_leaf_node {
; 3274 :     public: // Member functions
; 3275 :       void adjust_cover(kdu_dims child_cover,
; 3276 :                         int child_branch_x, int child_branch_y);
; 3277 :         /* This function is used to find the `region_cover' members.  In
; 3278 :            a downward sweep through the decomposition branches associated
; 3279 :            with a given resolution level, the `region_cover' members are all
; 3280 :            set to empty regions.  We then assign each leaf node (subband)
; 3281 :            a region cover (not actually recorded in the leaf node) equal to
; 3282 :            its region of interest and work back up the tree from the
; 3283 :            leaves to the primary node of the resolution in question, calling
; 3284 :            this function to grow the region cover so as to encompass the
; 3285 :            smallest region which covers each of its children. */
; 3286 :     public: // Data
; 3287 :       kdu_dims region_cover; // See below
; 3288 :       kdu_dims prec_dims; // Temp storage for calculating precinct dimensions
; 3289 :       kd_leaf_node *children[4]; // Indexed by `LL_BAND' through `HH_BAND'
; 3290 :       kdu_byte num_hor_steps, num_vert_steps; // See below
; 3291 :       kdu_uint16 num_descendant_nodes;
; 3292 :       kdu_uint16 num_descendant_leaves;
; 3293 :       float *bibo_gains; // See below
; 3294 :   };
; 3295 :   /* Notes:
; 3296 :         This object is used to construct descriptions of all non-leaf
; 3297 :      nodes in the DWT decomposition structure.  Each node in the structure
; 3298 :      may be decomposed horizontally, vertically or both.  If it is decomposed
; 3299 :      in the horizontal direction, `children[HL_BAND]' will be non-NULL.  If it
; 3300 :      is decomposed in the vertical direction, `children[LH_BAND]' will be
; 3301 :      non-NULL.  If it is decomposed in both directions, `children[HH_BAND]'
; 3302 :      will also be non-NULL.  If it is decomposed at all, `children[LL_BAND]'
; 3303 :      will always be non-NULL.
; 3304 :         The decomposition structure consists of a collection of primary
; 3305 :      nodes, each of which is embedded within a `kd_resolution' object.
; 3306 :      In the case of the simple Mallat structure, each primary node has
; 3307 :      4 children, with the LL child embedded within the next lower
; 3308 :      resolution object and the remaining children embedded within
; 3309 :      `kd_subband' objects.  In wavelet packet decomposition structures,
; 3310 :      detail subbands produced by a primary node may, themselves, be
; 3311 :      decomposed further into subbands.
; 3312 :         The actual object pointed to by each non-NULL member of the `children'
; 3313 :      array may need to be cast to type `kd_node', rather than `kd_leaf_node'
; 3314 :      if the `kd_leaf_node::is_leaf' member is false.
; 3315 :         The `children[LL_BAND]' entry of a primary node always points to
; 3316 :      the node which is embedded within the next lower resolution
; 3317 :      `kd_resolution' object, except at the lowest resolution of all.
; 3318 :      The lowest `kd_resolution' object's embedded node has only one
; 3319 :      child, with `children[LL_BAND]' pointing to the single (LL) subband
; 3320 :      belonging to that resolution.
; 3321 :         The `num_hor_steps' and `num_vert_steps' members identify the number
; 3322 :      of horizontal and vertical lifting steps associated with the horizontal
; 3323 :      and vertical transform operations applied at this node to produce its
; 3324 :      children.  One or both of these may be 0, either because the transform
; 3325 :      is trivial (lazy wavelet) or because the node is split only in the
; 3326 :      horizontal direction, only in the vertical direction, or is not split
; 3327 :      at all.
; 3328 :         The `num_descendant_nodes' member holds a count of the total number
; 3329 :      of nodes (leaf nodes and non-leaf nodes) which may be reached via the
; 3330 :      `children' array.  The `num_descendant_leaves' member holds a count of
; 3331 :      the number of these descendant nodes which are leaves.  Neither of these
; 3332 :      counts includes the current node.  Clearly there is no need to
; 3333 :      maintain this information with leaf nodes, since the counts would both
; 3334 :      be 0 in this case.
; 3335 :         The `bibo_gains' member point to an array with
; 3336 :      2+`num_hor_steps'+`num_vert_steps' entries.  The first 1+`num_hor_steps'
; 3337 :      entries describe BIBO gains for the horizontal transform performed
; 3338 :      at this node.  The remaining `+`num_vert_steps' entries describe BIBO
; 3339 :      gains for the vertical transform performed at this node.  Within each
; 3340 :      of these 2 sets of BIBO gains the first entry holds the BIBO gain from
; 3341 :      the original input image to the image which is presented at the input
; 3342 :      to this node.  Subsequent entries hold the BIBO gains from the original
; 3343 :      input image to the image which is presented at the output of each
; 3344 :      successive analysis lifting step.  Al BIBO gains are assessed relative to
; 3345 :      the nominal transform normalization, in which reversible lifting steps
; 3346 :      are applied as-is, while irreversible lifting steps are followed by the
; 3347 :      relevant `kd_tile_comp::low_scale' and `kd_tile_comp::high_scale' values.
; 3348 :         The interpretation of `region_cover' is similar to that of
; 3349 :      `kd_leaf_node::region', with a subtle, yet important twist.  In order to
; 3350 :      reconstruct each sample in `region', it is necessary to decode a
; 3351 :      particular set of samples from the subbands which are associated with
; 3352 :      this node.  Each of these subband samples has a mapping onto the
; 3353 :      coordinate system associated with the node, following the usual rules of
; 3354 :      the canvas coordinate system.  `res_cover' holds the smallest region
; 3355 :      which contains all of these mapped subband sample locations, except that
; 3356 :      the LL subband branch is included only if this is not a primary node.
; 3357 :      This ensures that the primary node embedded inside each `kd_resolution'
; 3358 :      object will have a `region_cover' which spans the nominal locations of
; 3359 :      all subband samples of interest, which are represented by codestream
; 3360 :      packets associated with that resolution. */
; 3361 : 
; 3362 : /*****************************************************************************/
; 3363 : /*                                kd_subband                                 */
; 3364 : /*****************************************************************************/
; 3365 : 
; 3366 : struct kd_subband : public kd_leaf_node {
; 3367 :     // State structure for the "kdu_subband" interface
; 3368 :   public: // Identification
; 3369 :     kdu_int16 descriptor; // See `cod_params::expand_decomp_bands'
; 3370 :     kdu_byte orientation; // One of LL_BAND, HL_BAND, LH_BAND or HH_BAND.
; 3371 :                      // This is the orientation of the primary subband from
; 3372 :                      // which we are derived within the same resolution level.
; 3373 :     kdu_byte sequence_idx; // Index within the `kd_resolution::subbands' array
; 3374 :                      // This is also the order in which subbands contribute
; 3375 :                      // code-blocks to codestream packets.
; 3376 :     kdu_byte transpose_sequence_idx; // Index of the real subband which appears
; 3377 :                       // to have this `sequence_idx' value when
; 3378 :                       // `kdu_codestream::change_appearance' has been used to
; 3379 :                       // transpose the codestream's appearance.
; 3380 :   public: // Dimensions and Parameters
; 3381 :     kdu_byte epsilon; // Ranging parameter.
; 3382 :     kdu_byte K_max; // Maximum magnitude bit-planes, not including ROI upshift
; 3383 :     kdu_byte K_max_prime; // Max magnitude bit-planes, including ROI upshift
; 3384 :     float delta; // Step size, normalized for image data range of -0.5 to 0.5
; 3385 :     float G_b; // Subband energy gain factor.
; 3386 :     float W_b; // Subband amplitude weight; needs squaring to get energy weight
; 3387 :     float roi_weight; // Extra amplitude weight for ROI foreground blocks.
; 3388 :     kdu_dims block_partition; // Holds the coding origin and dimensions.
; 3389 :     kdu_dims block_indices; // Holds the range of valid block indices.
; 3390 :     kdu_dims region_indices;  // Same as `block_indices', but restricted to
; 3391 :                               // blocks which overlap the region of interest.
; 3392 :     kdu_coords blocks_per_precinct; // precinct size / block size
; 3393 :     kdu_coords log2_blocks_per_precinct; // log2 of precinct size/block size
; 3394 :   };
; 3395 :   /* Notes:
; 3396 :         It may come as a surprise to notice that this object has no
; 3397 :      direct connection to code-blocks.  To access a code-block, the object
; 3398 :      first determines the precinct to which it belongs, creating that
; 3399 :      precinct if necessary; this, in turn, creates its precinct-bands and
; 3400 :      the associated code-blocks.  In this way, no memory whatsoever need be
; 3401 :      dedicated to code-blocks which lie in unaccessed precincts. */
; 3402 : 
; 3403 : /*****************************************************************************/
; 3404 : /*                              kd_resolution                                */
; 3405 : /*****************************************************************************/
; 3406 : 
; 3407 : struct kd_resolution { // State structure for the "kdu_resolution" interface
; 3408 :   public: // Member functions
; 3409 :     kd_resolution()
; 3410 :       {
; 3411 :         codestream = NULL; tile_comp = NULL; rescomp = NULL;
; 3412 :         precinct_refs = NULL; subbands = subband_handle = NULL; num_subbands=0;
; 3413 :         num_intermediate_nodes = 0; intermediate_nodes = NULL;
; 3414 :         can_flip = true;  node.bibo_gains = NULL;
; 3415 :       }
; 3416 :     ~kd_resolution()
; 3417 :       {
; 3418 :         if (node.bibo_gains != NULL) delete[] node.bibo_gains;
; 3419 :         for (int n=0; n < (int) num_intermediate_nodes; n++)
; 3420 :           if (intermediate_nodes[n].bibo_gains != NULL)
; 3421 :             delete[] intermediate_nodes[n].bibo_gains;
; 3422 :         if (precinct_refs != NULL) delete[] precinct_refs;
; 3423 :         if (subband_handle != NULL) delete[] subband_handle;
; 3424 :         if (intermediate_nodes != NULL) delete[] intermediate_nodes;
; 3425 :       }
; 3426 :     void build_decomposition_structure(kdu_params *coc, kdu_kernels &kernels);
; 3427 :       /* This function creates the `subbands' and `intermediate_nodes'
; 3428 :          arrays and fills in all the relevant pointers.  It uses `kernels'
; 3429 :          to create and fill in the `kdu_node::hor_bibo_gains' and
; 3430 :          `kdu_node::vert_bibo_gains' arrays, where required. */
; 3431 :     void complete_initialization();
; 3432 :       /* Called from within `kd_tile::initialize' to finish the initialization
; 3433 :          process, after all of the key parameters have been set.  Currently,
; 3434 :          the only task performed here is the initialization of the
; 3435 :          `max_blocks_per_precinct' member. */
; 3436 :   public: // Links and Identification
; 3437 :     kd_codestream *codestream;
; 3438 :     kd_tile_comp *tile_comp;
; 3439 :     kd_global_rescomp *rescomp;
; 3440 :     kdu_byte res_level; // Runs from 0 (LL band) to `num_dwt_levels'
; 3441 :     kdu_byte dwt_level; // Runs from `num_dwt_levels' (res level 0 and 1) to 1
; 3442 :     kdu_byte hor_depth; // From relevant entry of `kd_comp_info::hor_depth'
; 3443 :     kdu_byte vert_depth; // From relevant entry of `kd_comp_info::vert_depth'
; 3444 : 
; 3445 :   public: // Embedded node
; 3446 :     kd_node node; // Each resolution is a primary node in the decomposition
; 3447 : 
; 3448 :   public: // Dimensions and Parameters
; 3449 :     kdu_dims precinct_partition; // Holds the coding origin and dimensions.
; 3450 :     kdu_dims precinct_indices; // Holds the range of valid precinct indices.
; 3451 :     kdu_dims region_indices; // Holds range of indices for precincts whose
; 3452 :                              // code-blocks contribute to region of interest.
; 3453 :   public: // Derived quantities
; 3454 :     int max_blocks_per_precinct; // See discussion under `kd_precinct_band'
; 3455 :     bool propagate_roi; // True if ROI masks to be propagated to descendants
; 3456 : 
; 3457 :     bool can_flip; // Set to false if this level contains subband decomposition
; 3458 :                    // styles which are incompatible with view flipping.
; 3459 : 
; 3460 :   public: // Arrays
; 3461 :     kdu_byte num_subbands; // Excludes the LL band unless `res_level'=0
; 3462 :     kdu_byte num_intermediate_nodes; // Enough for all non-leaf nodes descended
; 3463 :                                  // from the primary node in this object.
; 3464 :     kd_node *intermediate_nodes; // Array with `num_intermediate_nodes' entries
; 3465 :     kd_precinct_ref *precinct_refs;
; 3466 :     kd_subband *subbands; // Points to `subband_store' or `subband_handle'.
; 3467 :     kd_subband *subband_handle; // For dynamically allocated subbands
; 3468 :     kd_subband subband_store[3]; // Avoid dynamic allocation for common case
; 3469 : 
; 3470 :   public: // Flags and Other State Variables
; 3471 :     kdu_coords current_sequencer_pos; // Used by `kd_packet_sequencer'.
; 3472 :     kdu_coords saved_current_sequencer_pos; // For saving the sequencer state
; 3473 :   };
; 3474 :   /* Notes:
; 3475 :         The `current_sequencer_pos' coordinates are used to sequence
; 3476 :      spatially oriented packet progressions.  They maintain the
; 3477 :      indices (starting from [0,0], rather than `precinct_indices.pos')
; 3478 :      of the precinct which is currently being sequenced.
; 3479 :         The `region_indices' member holds the smallest range of precinct
; 3480 :      indices, such that the code-blocks contained within these precincts
; 3481 :      are sufficient to reconstruct all samples inside `node.region'.
; 3482 :      Equivalently, the range in `precinct_indices' yields the set of
; 3483 :      precincts which intersect with `node.region_cover'.
; 3484 :         It is worth noting that the area of intersection between each
; 3485 :      precinct's region on the resolution and the `node.region_cover' region
; 3486 :      is used to compute the information returned by
; 3487 :      `kdu_resolution::get_precinct_relevance'. */
; 3488 : 
; 3489 : /*****************************************************************************/
; 3490 : /*                             kd_header_in                                  */
; 3491 : /*****************************************************************************/
; 3492 : 
; 3493 : class kd_header_in {
; 3494 :   /* Manages the reading of packet header bytes from the code-stream, along
; 3495 :      with bit stuffing and unpacking. */
; 3496 :   public: // Member functions
; 3497 :     kd_header_in(kd_input *source)
; 3498 :       { this->source = source; bits_left=0; byte=0; header_bytes=0; }
; 3499 :     int get_bit() // throws its own "this" pointer if the source is exhausted.
; 3500 :       {
; 3501 :         if (bits_left==0)
; 3502 :           {
; 3503 :             bits_left = (byte==0xFF)?7:8;
; 3504 :             if (!source->get(byte))
; 3505 :               { bits_left = 0; throw this; }
; 3506 :             header_bytes++;
; 3507 :           }
; 3508 :         bits_left--;
; 3509 :         return (byte >> bits_left) & 1;
; 3510 :       }
; 3511 :     kdu_uint32 get_bits(int num_bits) // thorws(kd_header_in *)
; 3512 :       { kdu_uint32 result = 0;
; 3513 :         while (num_bits > 0)
; 3514 :           {
; 3515 :             if (bits_left==0)
; 3516 :               {
; 3517 :                 bits_left = (byte==0xFF)?7:8;
; 3518 :                 if (!source->get(byte))
; 3519 :                   { bits_left = 0; throw this; }
; 3520 :                 header_bytes++;
; 3521 :               }
; 3522 :             int xfer_bits = (num_bits<bits_left)?num_bits:bits_left;
; 3523 :             bits_left -= xfer_bits;
; 3524 :             num_bits -= xfer_bits;
; 3525 :             result <<= xfer_bits;
; 3526 :             result |= ((byte >> bits_left) & ~(0xFF << xfer_bits));
; 3527 :           }
; 3528 :         return result;
; 3529 :       }
; 3530 :     int finish()
; 3531 :       { // Call this when the header is all read, to consume any stuffing byte
; 3532 :         // Returns total header length
; 3533 :         if ((bits_left == 0) && (byte == 0xFF))
; 3534 :           {
; 3535 :             bits_left = 7;
; 3536 :             if (!source->get(byte))
; 3537 :               throw this;
; 3538 :             header_bytes++;
; 3539 :           }
; 3540 :         return header_bytes;
; 3541 :       }
; 3542 :   private: // Data
; 3543 :     kd_input *source; // Provides the input mechanism.
; 3544 :     kdu_byte byte;
; 3545 :     int bits_left;
; 3546 :     int header_bytes;
; 3547 :   };
; 3548 : 
; 3549 : /*****************************************************************************/
; 3550 : /*                                kd_header_out                              */
; 3551 : /*****************************************************************************/
; 3552 : 
; 3553 : class kd_header_out {
; 3554 :   /* Manages the simulated and real output of packet header bytes. */
; 3555 :   public: // Member functions
; 3556 :     kd_header_out(kdu_output *out=NULL) // Null for simulating header
; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }
; 3558 :     void put_bit(int bit)
; 3559 :       { // Output a header bit
; 3560 :         assert(bit == (bit & 1));
; 3561 :         if (bits_left == 0)
; 3562 :           { if (out != NULL) out->put(byte);
; 3563 :             completed_bytes++;
; 3564 :             bits_left = (byte==0xFF)?7:8;
; 3565 :             byte = 0; }
; 3566 :         byte += byte + bit;
; 3567 :         bits_left--;
; 3568 :       }
; 3569 :     void put_bits(kdu_int32 val, int num_bits)
; 3570 :       { // Output the least significant `num_bits' of `val'
; 3571 :         while (num_bits > 0)
; 3572 :           put_bit((val >> (--num_bits)) & 1);
; 3573 :       }
; 3574 :     int finish()
; 3575 :       { // Returns the total number of bytes consumed by the packet header.
; 3576 :         if (bits_left < 8)
; 3577 :           {
; 3578 :             byte <<= bits_left;
; 3579 :             if (out != NULL)
; 3580 :               out->put(byte);
; 3581 :             completed_bytes++;
; 3582 :             if (byte == 0xFF)
; 3583 :               { // Need the stuffing byte.
; 3584 :                 if (out != NULL)
; 3585 :                   out->put((kdu_byte) 0);
; 3586 :                 completed_bytes++;
; 3587 :               }
; 3588 :           }
; 3589 :         return completed_bytes;
; 3590 :       }
; 3591 :   private: // Data
; 3592 :     kdu_byte byte;
; 3593 :     int bits_left;
; 3594 :     int completed_bytes;
; 3595 :     kdu_output *out;
; 3596 :   };
; 3597 : 
; 3598 : /*****************************************************************************/
; 3599 : /*                                 kd_block                                  */
; 3600 : /*****************************************************************************/
; 3601 : 
; 3602 : class kd_block {
; 3603 :   /* For a very small size (only 24 bytes on 32-bit machines), this class
; 3604 :      defines a lot of member functions!. */
; 3605 :   // --------------------------------------------------------------------------
; 3606 :   public: // Lifecycle member functions
; 3607 :     void cleanup(kd_buf_server *buf_server)
; 3608 :       {
; 3609 :         while ((current_buf=first_buf) != NULL)
; 3610 :           { first_buf=current_buf->next;  buf_server->release(current_buf); }
; 3611 :         set_discard(); // Discard from any packets parsed in the future
; 3612 :       }
; 3613 :     kd_code_buffer *cleanup()
; 3614 :       { // As above, but returns the linked list of buffers
; 3615 :         kd_code_buffer *result = first_buf;  first_buf = current_buf = NULL;
; 3616 :         set_discard();
; 3617 :         return result;
; 3618 :       }
; 3619 : 
; 3620 :   // --------------------------------------------------------------------------
; 3621 :   public: // Packet manipulation member functions
; 3622 :     int parse_packet_header(kd_header_in &head, kd_buf_server *buf_server,
; 3623 :                             int layer_idx); // Throws (kdu_uint16 code)
; 3624 :       /* Parses bits in the packet header corresponding to the current
; 3625 :          block for the current layer (this must be the next layer for which
; 3626 :          information has not yet been parsed).  The function returns the
; 3627 :          number of new body bytes contributed by the code-block in this layer
; 3628 :          and also stores this value internally to be used in subsequent calls
; 3629 :          to the `read_body_bytes' member function.
; 3630 :             The `kd_header_in' object may throw an exception if the packet
; 3631 :          data terminates unexpectedly.  Moreover, to assist in locating and
; 3632 :          possibly recovering from errors, the present function may throw a
; 3633 :          16-bit unsigned integer exception code, which is either the value of
; 3634 :          an illegal marker code encountered in the packet header, or one of
; 3635 :          the special exception codes, KDU_EXCEPTION_PRECISION or
; 3636 :          KDU_EXCEPTION_ILLEGAL_LAYER. */
; 3637 :     void read_body_bytes(kd_input *source, kd_buf_server *buf_server,
; 3638 :                          bool in_memory_source)
; 3639 :       { /* This function should be called after parsing the header of a
; 3640 :            packet.  It reads the code-bytes contributed by the code-block to
; 3641 :            this packet.  If `in_memory_source' is true, only the address of
; 3642 :            the code-bytes is recorded, and then only if the length of the
; 3643 :            code-byte segment is non-zero. */
; 3644 :         if (this->temp_length > 0)
; 3645 :           {
; 3646 :             if (num_passes == 255)
; 3647 :               { // Read and discard the code-bytes.
; 3648 :                 assert(first_buf == NULL);  source->ignore(this->temp_length);
; 3649 :               }
; 3650 :             else if (in_memory_source)
; 3651 :               {
; 3652 :                 kdu_byte *addr;
; 3653 :                 this->num_bytes += source->pseudo_read(addr,this->temp_length);
; 3654 :                 put_address(addr,buf_server);
; 3655 :               }
; 3656 :             else
; 3657 :               this->num_bytes +=
; 3658 :                 source->read(current_buf,buf_pos,buf_server,this->temp_length);
; 3659 :             this->temp_length = 0;
; 3660 :           }
; 3661 :       }
; 3662 :     void retrieve_data(kdu_block *block, int max_layers, int discard_passes,
; 3663 :                        bool in_memory_source);
; 3664 :       /* Retrieves compressed code-bytes, number of coding passes and codeword
; 3665 :          segment lengths from the current code-block and stores them in the
; 3666 :          `block' object.  All fields which are common for compression and
; 3667 :          decompression have already been filled out by the caller.  The
; 3668 :          byte buffer is allocated so as to be large enough to allow a
; 3669 :          2 byte marker code to be appended to the compressed data,
; 3670 :          if desired -- see declaration of "kdu_subband::open_block".
; 3671 :             The `max_layers' argument identifies the maximum number of
; 3672 :          quality layers for which code-block contributions are to be
; 3673 :          retrieved.
; 3674 :             The `discard_passes' argument indicates the number of additional
; 3675 :          coding passes to be removed, if any.
; 3676 :             If `in_memory_source' is true, the layer code bytes are not
; 3677 :          stored in the `kd_code_buffer' list embedded inside `block'.  Instead,
; 3678 :          the `kd_code_buffer' list stores only the header information for
; 3679 :          each layer, along with the address of the code bytes, which reside
; 3680 :          in the memory block managed by an in-memory compressed data source
; 3681 :          (one which offers the `KDU_SOURCE_CAP_IN_MEMORY') capability.  In
; 3682 :          this case, we retrieve the address and then perform a simple memory
; 3683 :          block copy operation to efficiently retrieve the code bytes for
; 3684 :          each layer. */
; 3685 :     void store_data(kdu_block *block, kd_buf_server *buf_server);
; 3686 :       /* Stores compressed code-bytes, pass length and pass slope information
; 3687 :          from the `block' object into the current code-block.  This function
; 3688 :          is invoked by "kdu_subband::close_block" when the containing
; 3689 :          codestream object was not constructed for input.  Also reflects
; 3690 :          the `msbs_w' value into higher nodes in the tag tree. */
; 3691 :     void store_data(kdu_block *block, kd_thread_buf_server *thread_buf_server);
; 3692 :       /* Same as the above function, but uses `kd_thread_buf_server::get'
; 3693 :          rather than `kd_buf_server::get' to get new code buffers.  This
; 3694 :          version is used to save code-block state in multi-threaded
; 3695 :          environments so as to minimize cache coherency bottlenecks and the
; 3696 :          need to lock shared resources. */
; 3697 :     void transfer_data(kd_block &src)
; 3698 :       { /* Like `store_data', but gets results from another block.  Exploits
; 3699 :            the layout of the object to copy only whole pointers or whole
; 3700 :            32-bit words, even where these represent multiple fields. */
; 3701 :         current_buf = first_buf = src.first_buf;
; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);
; 3703 :         src.current_buf = src.first_buf = NULL;
; 3704 :       }
; 3705 :     bool trim_data(kdu_uint16 slope_threshold, kd_buf_server *buf_server);
; 3706 :       /* This function serves two purposes: it helps reduce the amount of
; 3707 :          compressed data which must be buffered in memory while compressing
; 3708 :          an image; and it allows individual block contributions to be
; 3709 :          discarded during packet construction in order to tightly fit the
; 3710 :          generated bit-rate to the target compressed bit-rate.
; 3711 :             The function sets all coding pass slopes which are less than or
; 3712 :          equal to the supplied slope threshold to 0 and then discards all
; 3713 :          code bytes which could not possibly be included in the final
; 3714 :          code-stream, as a result of this modification.
; 3715 :             If anything was discarded, the function returns true.  Otherwise,
; 3716 :          it returns false. */
; 3717 :     int start_packet(int layer_idx, kdu_uint16 slope_threshold);
; 3718 :       /* Call this function only during rate allocation or packet generation.
; 3719 :          Before the first call to this function, you must reset the tag tree
; 3720 :          (see the "reset_output_tree" member function).  If you are calling
; 3721 :          the function multiple times with the same layer for rate allocation
; 3722 :          purposes, you must use "save_output_tree" and "restore_output_tree"
; 3723 :          as described below.
; 3724 :             The function leaves behind information about the number of new
; 3725 :          coding passes and the number of new code bytes which would be
; 3726 :          contributed by this code-block if the supplied threshold were actually
; 3727 :          used.  The final contributing coding pass must have a non-zero
; 3728 :          distortion-length slope which is strictly greater than the slope
; 3729 :          threshold.  It also updates the tag tree structure to reflect any
; 3730 :          new knowledge about the first layer to which this code-block would
; 3731 :          contribute.  This information is picked up by "write_packet_header".
; 3732 :             The function's return value is the total number of new code-bytes
; 3733 :          contributed by the block.  This allows the PCRD-opt algorithm to
; 3734 :          determine roughly the right slope threshold before committing to the
; 3735 :          work of simulating packet header generation. */
; 3736 :     void write_packet_header(kd_header_out &head, int layer_idx,
; 3737 :                              bool simulate);
; 3738 :       /* Call this function only after a `start_packet' call.  It writes
; 3739 :          (or simulates the writing of) packet header information corresponding
; 3740 :          to the code-block inclusion information set up by `start_packet'.
; 3741 :          If `simulate' is true, some internal state adjustments are delayed
; 3742 :          until the next call to "save_output_tree", so multiple calls to
; 3743 :          "start_packet" and "write_packet_header" may be issued with the same
; 3744 :          layer index to determine an optimal slope threshold.  Otherwise,
; 3745 :          if `simulate' is false, the internal state information is fully
; 3746 :          updated and the "save_output_tree" and "restore_output_tree" functions
; 3747 :          need not and should not be called. */
; 3748 :     void write_body_bytes(kdu_output *dest);
; 3749 :       /* This function should be called after a non-simulated
; 3750 :          "write_packet_header" call to output the newly included body bytes.
; 3751 :          The actual number of bytes to be written was left behind by
; 3752 :          the preceding "start_packet" call in the `temp_length' field. */
; 3753 :   // --------------------------------------------------------------------------
; 3754 :   public: // Static functions used to operate on tag-trees built from kd_block
; 3755 :     static kd_block *build_tree(kdu_coords size, kdu_byte * &mem_block);
; 3756 :       /* Builds a full tag tree returning a pointer to the upper left hand
; 3757 :          corner leaf node.  Apart from the `up_down' navigation pointers,
; 3758 :          all fields are initialized to 0.  This is appropriate for tag tree
; 3759 :          decoding, but encoders will need to call "reset_output_tree" and
; 3760 :          use "start_packet" to install appropriate node values.
; 3761 :             The tag tree is not allocated from the heap.  Instead, it is
; 3762 :          allocated from an existing memory block, identified by the `mem_block'
; 3763 :          argument.  This memory block is assumed to be large enough to hold
; 3764 :          the array of `kd_block' structures.  Upon return, the `mem_block'
; 3765 :          value is advanced by an amount equal to the size of the tag tree
; 3766 :          array. */
; 3767 :     static void reset_output_tree(kd_block *tree, kdu_coords size);
; 3768 :       /* Call this function immediately before simulating or actually
; 3769 :          generating any packet data for the relevant code-blocks.  Once
; 3770 :          the PCRD-opt algorithm has completed, you should call this function
; 3771 :          a second time to prepare for actual packet output.  The function
; 3772 :          initializes the threshold state variables, `layer_w_bar' and
; 3773 :          `msbs_w_bar' to 0, and the value state variables, `layer_w' and
; 3774 :          `msbs_w' to their maximum representable values.  The succession of
; 3775 :          "start_packet" calls will update the value variables `layer_w'
; 3776 :          and `msbs_w' in such a way that the tag tree coding process runs
; 3777 :          correctly in each subsequent call to "write_packet_header". */
; 3778 :     static void save_output_tree(kd_block *tree, kdu_coords size);
; 3779 :       /* Call this only during rate allocation, before moving on to a new
; 3780 :          layer.  The function saves the current state (`msbs_wbar' and
; 3781 :          `layer_wbar') of each node in the tag tree.  For leaf nodes, it also
; 3782 :          commits the number of new coding passes found in the last call to
; 3783 :          "start_packet". */
; 3784 :     static void restore_output_tree(kd_block *tree, kdu_coords size);
; 3785 :       /* Call this during rate allocation before supplying a new slope
; 3786 :          threshold for the same layer index, in a new "start_packet" call.
; 3787 :          The function restores the `msbs_w_bar' and `layer_w_bar' values
; 3788 :          previously saved by "save_output_tree". */
; 3789 :   // --------------------------------------------------------------------------
; 3790 :   public: // State identification functions
; 3791 :     void set_discard()
; 3792 :       { /* Use this function only with input-oriented operations.  It informs
; 3793 :            the object that none of the code-blocks associated with this
; 3794 :            block will ever be accessed, so that it is free to skip over them
; 3795 :            when reading a packet.  This can save a lot of memory if you have
; 3796 :            a defined region of interest for decompression. */
; 3797 :         num_passes = 255;
; 3798 :       }
; 3799 :     bool empty()
; 3800 :       { // Returns true if the block has no code-bytes yet.
; 3801 :         return first_buf == NULL;
; 3802 :       }
; 3803 :     void set_modes(int modes)
; 3804 :       {
; 3805 :         assert(modes == (modes & 0xFF));
; 3806 :         this->modes = (kdu_byte) modes;
; 3807 :       }
; 3808 :   // --------------------------------------------------------------------------
; 3809 :   private: // Convenience functions for transferring data to/from code buffers.
; 3810 :     void start_buffering(kd_buf_server *buf_server) // Call before `put_byte'
; 3811 :       { assert(first_buf == NULL);
; 3812 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3813 :     void start_buffering(kd_thread_buf_server *buf_server)
; 3814 :       { assert(first_buf == NULL);
; 3815 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3816 :     void put_byte(kdu_byte val, kd_buf_server *buf_server)
; 3817 :       {
; 3818 :         assert(current_buf != NULL);
; 3819 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3820 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3821 :         current_buf->buf[buf_pos++] = val;
; 3822 :       }
; 3823 :     void put_word(int val, kd_buf_server *buf_server)
; 3824 :       {
; 3825 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3826 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))
; 3827 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3828 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;
; 3829 :         buf_pos += 2;
; 3830 :       }
; 3831 :     void put_address(kdu_byte *addr, kd_buf_server *buf_server)
; 3832 :       {
; 3833 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3834 :         if (buf_pos > (KD_CODE_BUFFER_LEN-KDU_POINTER_BYTES))
; 3835 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3836 : 
; 3837 :         ((kdu_byte **)(current_buf->buf+buf_pos))[0] = addr;
; 3838 :         buf_pos += KDU_POINTER_BYTES;
; 3839 :       }
; 3840 :     void put_byte(kdu_byte val, kd_thread_buf_server *buf_server)
; 3841 :       {
; 3842 :         assert(current_buf != NULL);
; 3843 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3844 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3845 :         current_buf->buf[buf_pos++] = val;
; 3846 :       }
; 3847 :     void put_word(int val, kd_thread_buf_server *buf_server)
; 3848 :       {
; 3849 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3850 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))
; 3851 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3852 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;
; 3853 :         buf_pos += 2;
; 3854 :       }
; 3855 :     void put_address(kdu_byte *addr, kd_thread_buf_server *buf_server)
; 3856 :       {
; 3857 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3858 :         if (buf_pos > (KD_CODE_BUFFER_LEN-KDU_POINTER_BYTES))
; 3859 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3860 : 
; 3861 :         ((kdu_byte **)(current_buf->buf+buf_pos))[0] = addr;
; 3862 :         buf_pos += KDU_POINTER_BYTES;
; 3863 :       }
; 3864 :     kdu_byte get_byte()
; 3865 :       {
; 3866 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3867 :           { buf_pos=0; current_buf=current_buf->next;
; 3868 :             assert(current_buf != NULL); }
; 3869 :         return current_buf->buf[buf_pos++];
; 3870 :       }
; 3871 :     int get_word()
; 3872 :       {
; 3873 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3874 :         buf_pos += 2; // Advance the buffer pointer
; 3875 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3876 :           { buf_pos=2; current_buf=current_buf->next;
; 3877 :             assert(current_buf != NULL); }
; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];
; 3879 :       }
; 3880 :     kdu_byte *get_address()
; 3881 :       {
; 3882 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3883 :         buf_pos += KDU_POINTER_BYTES; // Advance the buffer pointer
; 3884 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3885 :           { buf_pos=KDU_POINTER_BYTES; current_buf=current_buf->next;
; 3886 :             assert(current_buf != NULL); }
; 3887 :         return ((kdu_byte **)(current_buf->buf+buf_pos))[-1];
; 3888 :       }
; 3889 :     void skip_word()
; 3890 :       {
; 3891 :         buf_pos += 2 + (buf_pos & 1); // Align and advance the buffer pointer
; 3892 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3893 :           { buf_pos=2; current_buf=current_buf->next;
; 3894 :             assert(current_buf != NULL); }
; 3895 :       }
; 3896 :     void skip_address()
; 3897 :       {
; 3898 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3899 :         buf_pos += KDU_POINTER_BYTES; // Advance the buffer pointer
; 3900 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3901 :           { buf_pos=KDU_POINTER_BYTES; current_buf=current_buf->next;
; 3902 :             assert(current_buf != NULL); }
; 3903 :       }
; 3904 :   // --------------------------------------------------------------------------
; 3905 :   private: // Data (lots of unions to make it as small as possible!)
; 3906 :     union {
; 3907 :       kd_code_buffer *first_buf;
; 3908 :       kdu_uint16 save_layer_w; // Used for saving non-leaf node state
; 3909 :       };
; 3910 :     union {
; 3911 :       kd_code_buffer *current_buf;
; 3912 :       kdu_uint16 save_layer_wbar; // Used for saving_non-leaf node state
; 3913 :       };
; 3914 :     union {
; 3915 :       kdu_byte buf_pos; // Location of next read/write byte in `current_buf'.
; 3916 :       kdu_byte save_msbs_wbar; // Used for saving non-leaf node state
; 3917 :       };
; 3918 :     kdu_byte msbs_w;
; 3919 :     kdu_byte num_passes;
; 3920 :     kdu_byte pass_idx;
; 3921 :     union {
; 3922 :       kdu_uint16 layer_w; // Used only when `pass_idx'=0
; 3923 :       kdu_uint16 body_bytes_offset; // Used in packet output if `pass_idx' > 0
; 3924 :       kdu_byte save_beta; // Used during output simulation if `pass_idx' > 0
; 3925 :       };
; 3926 :     union {
; 3927 :       kdu_uint16 layer_wbar;
; 3928 :       kdu_uint16 num_bytes; // Used only for input operations
; 3929 :       kdu_byte pending_new_passes; // Used only for output operations
; 3930 :       };
; 3931 :     union {
; 3932 :       kdu_byte msbs_wbar;
; 3933 :       kdu_byte beta;
; 3934 :       };
; 3935 :     kdu_byte modes;
; 3936 :     kdu_uint16 temp_length; // Temporary storage of length quantities.
; 3937 :     kd_block *up_down;
; 3938 :   };
; 3939 :   /* Notes:
; 3940 :         This structure has been designed to provide sufficient state
; 3941 :      information for each code-block to perform packet header parsing as
; 3942 :      well as block encoding and decoding.  For coding purposes, the information
; 3943 :      represented by the structure is generally transferred to or from a
; 3944 :      much less tightly packed representation for speed of execution of the
; 3945 :      block coding routines.  As it stands, the total size of this structure
; 3946 :      should be 24 bytes on a 32-bit architecture. An array of code-blocks is
; 3947 :      maintained by each precinct-band.  The array contains one entry for
; 3948 :      every block in the relevant precinct-band, but also contains additional
; 3949 :      entries to be used as tag-tree nodes.  The total number of such extra
; 3950 :      nodes is about 1/3 the number of code-blocks and should not be a
; 3951 :      significant cause of concern for overall memory consumption. There is
; 3952 :      also substantial benefit to be had by locating the tag tree nodes in
; 3953 :      the same contiguous memory block.  Notice that the structure contains
; 3954 :      no reference back to the precinct-band to which it belongs.  When
; 3955 :      necessary, this reference must be supplied separately to interested
; 3956 :      functions. One consequence of this memory saving step is that the
; 3957 :      object's destructor cannot do anything useful.  It only checks to make
; 3958 :      sure that the explicit `cleanup' function has already been called.
; 3959 :         If a block is to be discarded (since it does not intersect with a
; 3960 :      user-specified region of interest), the `num_passes' field will hold
; 3961 :      the otherwise impossible value, 255.
; 3962 :         The `first_buf', `current_buf' and `buf_pos' fields constitute the
; 3963 :      compressed data buffer management mechanism, which is used to store all
; 3964 :      quantities whose length is unpredictable a priori. In particular, a
; 3965 :      linked list of `kd_code_buffer' structures is provided, which grows on
; 3966 :      demand through access to the codestream object's embedded `buffering'
; 3967 :      object.  Data is stored in these buffers in the following formats:
; 3968 :            * Input Format -- [<layer #> (<#bytes> <#passes> ...)] data [<...
; 3969 :              That is, for each layer to which the code-block makes a non-empty
; 3970 :              contribution, we record first the layer number (2 bytes) and
; 3971 :              then one or more #bytes/#passes pairs.  #bytes is represented
; 3972 :              using 2 bytes, while #passes is represented using only 1 byte.
; 3973 :              There is one such 3 byte pair for each layer and one additional
; 3974 :              3 byte pair for each codeword segment terminating pass which
; 3975 :              is not the final pass contributed in the layer.  In this way,
; 3976 :              sufficient information is provided to recover all termination
; 3977 :              lengths, as well as to build layer associations.  The most
; 3978 :              significant bit of the #bytes field is used as a marker to
; 3979 :              indicate whether or not this is the last such field prior to
; 3980 :              the appearance of the code bytes contributed by that layer.  A
; 3981 :              1 means that there are more fields to go before the code bytes
; 3982 :              appear.
; 3983 :            * In-memory Format --[<layer #>(<#bytes> <#passes>...)] <addr> [<...
; 3984 :              This format is used as an alternative to the Input Format above,
; 3985 :              in the special case when the compressed data source supports the
; 3986 :              `KDU_SOURCE_CAP_IN_MEMORY' capability, so that
; 3987 :              `kd_codestream::in_memory_source' is true.  In this case, the
; 3988 :              "data" field is replaced by the address where the data can be
; 3989 :              found in the memory block managed by the compressed data source.
; 3990 :              Moreover, if the number of code-bytes associated with a layer
; 3991 :              is zero, the <addr> field is missing.
; 3992 :            * Output Format -- [<RD slope> <#bytes>] ... [<RD ...] data
; 3993 :              That is, all of the header information for all coding passes
; 3994 :              appears up front, followed by all of the code bytes associated
; 3995 :              with those coding passes.  The reason for putting all the
; 3996 :              header information up front is that it facilitates the
; 3997 :              identification of appropriate layer contributions by the
; 3998 :              rate control algorithm.  Each coding pass has a 4 byte header,
; 3999 :              with 2 bytes for the distortion-length slope value and 2 bytes
; 4000 :              for the number of code-bytes for the pass.
; 4001 :      The particular format which is used to store data depends upon the
; 4002 :      member functions which are used, since these implicitly determine
; 4003 :      whether the codestream object is being used for input or output.
; 4004 :         The `modes' field holds the block coder mode fields.  Some of these
; 4005 :      are required even for correct packet header parsing, regardless of whether
; 4006 :      the block is to be actually decoded.
; 4007 :         `msbs_w' and `msbs_wbar' are the state information required
; 4008 :      for tag-tree coding of the number of missing MSB's for a code-block
; 4009 :      which is about to make its first non-empty contribution to the
; 4010 :      code-stream. Similarly, `layer_w' and `layer_wbar' hold the state
; 4011 :      information required for tag-tree coding of the layer index in which a
; 4012 :      code-block first contributes to the code-stream.  The operation of
; 4013 :      tag-tree coding and the `w' and `wbar' terminology are explained in
; 4014 :      Section 8.4 of the book by Taubman and Marcellin.
; 4015 :         The `beta' field shares storage with `msbs_wbar'.  This is not
; 4016 :      required until the number of missing MSB's has been encoded or decoded,
; 4017 :      at which point we initialize `beta' to 3 (see the JPEG2000 standard or
; 4018 :      Section 12.5.4 of the book by Taubman and Marcellin).  A useful
; 4019 :      consequence of this behaviour is that `beta' may be tested at any
; 4020 :      point of the packet header encoding or decoding process to determine
; 4021 :      whether or not the code-block has yet contributed to the code-stream
; 4022 :      -- the value will be non-zero if and only if it has done so.
; 4023 :         The `num_bytes' field shares storage with `layer_wbar'.  It
; 4024 :      identifies the total number of bytes included by the code-block in
; 4025 :      all packets read or written so far.  The value is taken to be 0 if
; 4026 :      the code-block has not yet contributed to any packets (`beta'=0),
; 4027 :      during which time the `layer_wbar' state variable is in use.
; 4028 :         The `up_down' field is used to efficiently navigate the tag-tree
; 4029 :      structure.  When the tag tree is not actually being navigated, the
; 4030 :      field points up to the current node's parent in the tag tree.  The
; 4031 :      root mode is readily identified by the fact that it has a NULL `up_down'
; 4032 :      pointer. During navigation, the tag-tree coder first walks from a
; 4033 :      leaf node up to the root, modifying the `up_down' pointers as it goes
; 4034 :      so that each successive parent's `up_down' field points bacl down to the
; 4035 :      child from which the parent was reached.  The coder then walks back down
; 4036 :      from the root to the original leaf node, restoring the `up_down' fields to
; 4037 :      their original `up' state. */
; 4038 : 
; 4039 : /*****************************************************************************/
; 4040 : /*                             kd_precinct_band                              */
; 4041 : /*****************************************************************************/
; 4042 : 
; 4043 : struct kd_precinct_band {
; 4044 :   /* Used to store state information for an element of the precinct partition
; 4045 :      within a single subband.  Once we get down to precincts and ultimately
; 4046 :      code-blocks, we have to be careful not to waste too much memory, since
; 4047 :      an image may have a very large number of these.  Moreover, it may be
; 4048 :      necessary to maintain tag-trees and other state information even for
; 4049 :      precincts which do not lie within our region of interest, so that the
; 4050 :      relevant packet headers can be parsed -- otherwise, we may have no way
; 4051 :      of knowing how to skip over packets which are not interesting to us. */
; 4052 :     kd_subband *subband;
; 4053 :     kdu_dims block_indices; /* Range of code-block indices for this precinct.
; 4054 :         This is a subset of the `block_indices' specified by the `subband'. */
; 4055 :     kd_block *blocks;
; 4056 :   };
; 4057 :   /* Notes:
; 4058 :      In order to make the representation of this object as efficient as
; 4059 :      possible, the two tag trees and all additional information required to
; 4060 :      correctly parse packet headers is maintained within the code-block
; 4061 :      array itself.  The `blocks' array consists of one element for each
; 4062 :      code-block, organized in raster fashion, plus additional elements to
; 4063 :      represent higher nodes in the tag-tree structure.  See the comments
; 4064 :      associated with the definition of `kd_block' for more information on
; 4065 :      this.
; 4066 :         In practice, the `blocks' array is not allocated separately on the
; 4067 :      heap.  Instead, the block of memory allocated to hold the `kd_precinct'
; 4068 :      structure is augmented by an amount sufficient to hold all of the
; 4069 :      code-blocks for all of the subbands in the precinct.  This is
; 4070 :      accomplished by the custom `kd_precinct::new' operator, which is
; 4071 :      informed of the maximum number of code-blocks required by any precinct
; 4072 :      within the containing `kd_resolution' object.  This value is maintained
; 4073 :      by the `kd_resolution::max_blocks_per_precinct" data member.  The
; 4074 :      `blocks' fields are initialized to the NULL state by the
; 4075 :      `kd_precinct::initialize' member function and are later set to point
; 4076 :      into appropriate locations in the precinct's memory block during
; 4077 :      tag-tree construction. */
; 4078 : 
; 4079 : /*****************************************************************************/
; 4080 : /*                                kd_precinct                                */
; 4081 : /*****************************************************************************/
; 4082 : 
; 4083 :   /* Precincts and all of their subordinate entities (precinct-bands and
; 4084 :      code-blocks) are maintained by a code-stream wide precinct server
; 4085 :      object, which allows for efficient allocation and recycling of the
; 4086 :      memory resources. The constructor is invoked from within the server,
; 4087 :      while the `initialize' and `release' functions are invoked from
; 4088 :      within the `kd_precinct_ref' class which manages references to
; 4089 :      precincts from within the `kd_resolution' object. */
; 4090 : 
; 4091 : // Interpretation of the following flags is given with the `flags' member:
; 4092 : #define KD_PFLAG_GENERATING  0x0001
; 4093 : #define KD_PFLAG_CORRUPTED   0x0002
; 4094 : #define KD_PFLAG_DESEQUENCED 0x0004
; 4095 : #define KD_PFLAG_ADDRESSABLE 0x0008
; 4096 : #define KD_PFLAG_RELEASED    0x0010
; 4097 : #define KD_PFLAG_INACTIVE    0x0020
; 4098 : #define KD_PFLAG_RELEVANT    0x0040
; 4099 : #define KD_PFLAG_SIGNIFICANT 0x0080
; 4100 : #define KD_PFLAG_PARSED      0x0100
; 4101 : 
; 4102 : struct kd_precinct {
; 4103 :   public: // Member functions
; 4104 :     void initialize(kd_resolution *resolution, kdu_coords pos_idx);
; 4105 :       /* Called from within `kd_precinct_ref::open' to configure a newly
; 4106 :          allocated (or recycled) object.  `pos_idx' holds the horizontal and
; 4107 :          vertical position of the precinct (starting from 0) within the array
; 4108 :          of precincts for the relevant resolution level.  Thus, `pos_idx'
; 4109 :          holds a relative index, rather than an absolute index. */
; 4110 :     void activate();
; 4111 :       /* This function is called from within `kd_precinct_ref::open' to
; 4112 :          re-activate a previously released precinct, which has not actually
; 4113 :          been unloaded from memory.  Substantially less work is required in
; 4114 :          this case, and the function must be careful to respect the current
; 4115 :          contents of the precinct's code-blocks.  The function sets the
; 4116 :          `num_required_layers' field for this activation (may change between
; 4117 :          successive `kd_tile::open' calls) and also sets the
; 4118 :          `num_outstanding_blocks' field to the total number of code-blocks
; 4119 :          which lie within the current region of interest. */
; 4120 :     void closing();
; 4121 :       /* Called from within `kd_precinct_ref::close' immediately prior to
; 4122 :          recycling the storage associated with the precinct, its precinct-bands
; 4123 :          and their code-blocks.  This function should release any resources
; 4124 :          which are specific to this particular precinct.  These resources
; 4125 :          include any non-NULL `layer_bytes' array and any code-byte buffers.
; 4126 :          Note that the `kd_precinct_ref::close' function may be called
; 4127 :          indirectly while opening a different precinct, if the current
; 4128 :          precinct has already been released.  This enables open calls to
; 4129 :          deal with resource limitations by unloading precincts which are not
; 4130 :          currently active. */
; 4131 :     void release()
; 4132 :       /* Used only for input codestream objects, this function is called once
; 4133 :          all code-blocks within the current region of interest have been
; 4134 :          consumed.  The function sets `num_outstanding_blocks' to 0, although
; 4135 :          in most cases this function will be called because
; 4136 :          `num_outstanding_blocks' has just become 0 (only exception is when
; 4137 :          a tile is being closed).  Also sets `released' to true.  If the
; 4138 :          KD_PFLAG_DESEQUENCED flag is false, the function returns without
; 4139 :          modifying the precinct in any other way.
; 4140 :             The `kd_precinct_ref::release' function is called to formally
; 4141 :          release the precinct's resources (this might not unload them from
; 4142 :          memory) if the codestream mode is non-persistent or if the precinct
; 4143 :          is addressable.  In the latter case, the precinct's contents can
; 4144 :          be reloaded from the compressed source if necessary.
; 4145 :             This function shall not be used with codestream objects
; 4146 :          opened for output or for interchange (no compressed data source and
; 4147 :          no compressed data target). */
; 4148 :       {
; 4149 :         assert(resolution->codestream->in != NULL);
; 4150 :         num_outstanding_blocks = 0;
; 4151 :         flags |= KD_PFLAG_RELEASED;
; 4152 :           // released = true;
; 4153 :         if ((flags & KD_PFLAG_ADDRESSABLE) ||
; 4154 :             ((flags & KD_PFLAG_DESEQUENCED) &&
; 4155 :                 // if (addressable ||
; 4156 :                 //     (desequenced &&
; 4157 :              !resolution->codestream->persistent))
; 4158 :           ref->release(); // May unload us from memory!
; 4159 :       }
; 4160 :     void finished_desequencing()
; 4161 :       /* Called once we can be sure that no more packets will be available
; 4162 :          for this precinct.  In practice, the function is called when the
; 4163 :          last packet has been desequenced or when the containing tile has
; 4164 :          been completely read.  If no packets at all have been desequenced for
; 4165 :          the precinct when this function is called (must have been invoked
; 4166 :          from within `kd_tile::finished_reading'), the precinct is marked
; 4167 :          as addressable, with an address of 0.  This is because it is safe
; 4168 :          to unload such a precinct and then reload it again regardless of
; 4169 :          the services offered by the compressed data source -- there is no
; 4170 :          data actually available from the compressed source for the
; 4171 :          precinct anyway, so reloading is a no-op.
; 4172 :             It should be noted that this function may unload the precinct
; 4173 :          from memory if it is determined that all code-blocks in the
; 4174 :          region of interest (there may be none) have already been consumed. */
; 4175 :       {
; 4176 :         if (flags & KD_PFLAG_DESEQUENCED)
; 4177 :           return;
; 4178 :         flags |= KD_PFLAG_DESEQUENCED;
; 4179 :           // desequenced = true;
; 4180 :         if (next_layer_idx == 0)
; 4181 :           {
; 4182 :             flags |= KD_PFLAG_ADDRESSABLE;
; 4183 :               // addressable = true;
; 4184 :             unique_address = 0;
; 4185 :           }
; 4186 :         if (num_outstanding_blocks == 0)
; 4187 :           release();
; 4188 :       }
; 4189 :     bool desequence_packet()
; 4190 :       /* This function should be called when a non-NULL `kd_precinct_ref'
; 4191 :          pointer is returned by `kd_packet_sequencer::next_in_sequence' and
; 4192 :          its `kd_precinct_ref::is_sequenced' function returns false.
; 4193 :          The function invokes `read_packet' and, if successful, increments
; 4194 :          the precinct's `next_layer_idx' field and the containing tile's
; 4195 :          `num_sequenced_packets' field.
; 4196 :             The function returns false if `read_packet' returns false,
; 4197 :          in which case, more tile-parts must be read (if there are any) to
; 4198 :          recover the information required to desequence the packet.
; 4199 :             Before returning true, the function checks to see whether all
; 4200 :          packets for the tile have been sequenced.  If so, the tile's
; 4201 :          `finished_reading' function is called. */
; 4202 :       {
; 4203 :         kd_tile *tile = resolution->tile_comp->tile;
; 4204 :         assert(!(flags & (KD_PFLAG_DESEQUENCED | KD_PFLAG_ADDRESSABLE)));
; 4205 :         if (!read_packet()) return false;
; 4206 :         next_layer_idx++;
; 4207 :         if (next_layer_idx == tile->num_layers)
; 4208 :           finished_desequencing();
; 4209 :         tile->next_input_packet_num++;
; 4210 :         if ((flags & KD_PFLAG_RELEVANT) &&
; 4211 :             (next_layer_idx <= tile->max_relevant_layers))
; 4212 :           {
; 4213 :             tile->sequenced_relevant_packets++;
; 4214 :             if (tile->sequenced_relevant_packets==tile->max_relevant_packets)
; 4215 :               tile->finished_reading();
; 4216 :           }
; 4217 :         return true;
; 4218 :       }
; 4219 :     void load_required_packets()
; 4220 :       /* If the precinct is addressable, this function uses its
; 4221 :          `unique_address' to position the compressed data source at the
; 4222 :          beginning of the precinct's first packet; it then loads all required
; 4223 :          packets from the compressed source.  Otherwise, the function does
; 4224 :          nothing at all -- reading is presumed to have occurred during packet
; 4225 :          desequencing. */
; 4226 :       {
; 4227 :         if ((!(flags & KD_PFLAG_ADDRESSABLE)) ||
; 4228 :             (unique_address == 0) || (num_packets_read != 0))
; 4229 :           return;
; 4230 :         assert((flags & KD_PFLAG_DESEQUENCED) &&
; 4231 :                (next_layer_idx >= required_layers));
; 4232 :         resolution->codestream->in->seek(unique_address);
; 4233 :         while (num_packets_read < required_layers)
; 4234 :           if (!read_packet())
; 4235 :             break;
; 4236 :       }
; 4237 :     kdu_long simulate_packet(kdu_long &header_bytes,
; 4238 :                              int layer_idx, kdu_uint16 slope_threshold,
; 4239 :                              bool finalize_layer, bool last_layer,
; 4240 :                              kdu_long max_bytes=KDU_LONG_HUGE,
; 4241 :                              bool trim_to_limit=false);
; 4242 :       /* Implements the functionality of `kd_codestream::simulate_output'
; 4243 :          for a single precinct.  Note that the total number of packet bytes
; 4244 :          is left behind in the internal `layer_bytes' array.  This allows the
; 4245 :          determination of tile-part length fields later on when we come to
; 4246 :          construct the code-stream.  The function returns this total number
; 4247 :          of bytes.  It also returns the number of packet header bytes via
; 4248 :          `header_bytes' (the function return value includes the cost of these
; 4249 :          header bytes).
; 4250 :             If the `max_bytes' limit is exceeded, the function may return
; 4251 :          prematurely, without having completed the simulation.  This is
; 4252 :          unacceptable when finalizing a layer, so you must be sure that
; 4253 :          `max_bytes' is sufficient in that case.
; 4254 :             If `trim_to_limit' is true, `finalize_layer' and `last_layer'
; 4255 :          must also both be true.  The function then trims away all coding
; 4256 :          passes from the precinct's code-blocks which are associated with
; 4257 :          slope values of `slope_threshold'+1 or less, until the limit
; 4258 :          associated with `max_bytes' is satisfied.  This functionality is
; 4259 :          used to implement the `sloppy_bytes' capabilities advertised by the
; 4260 :          `kd_codestream::simulate_output' function. */
; 4261 :     kdu_long write_packet(kdu_uint16 slope_threshold, bool empty_packet=false);
; 4262 :       /* Writes out the next packet for this precinct, using the supplied
; 4263 :          distortion-length slope threshold.  Increments the `next_layer_idx'
; 4264 :          field as well as the containing tile's `num_sequenced_packets'
; 4265 :          field when done.  If `empty_packet' is true, an empty packet should
; 4266 :          be issued, having a length of 1 byte, plus the length of any required
; 4267 :          EPH marker (no SOP marker will be attached to empty packets).  The
; 4268 :          function returns the total number of bytes output for the packet. */
; 4269 :   private: // Member functions
; 4270 :     bool read_packet();
; 4271 :       /* Reads a new layer of this precinct sequentially from the
; 4272 :          compressed data source, incrementing the `num_packets_read' member.
; 4273 :          Note that packet reading may be interleaved with acesses to the
; 4274 :          precinct's code-blocks for various reasons.  For example, we
; 4275 :          may initially open a tile with only a limited number of required
; 4276 :          layers, using its code-block data to decompress an approximate
; 4277 :          representation of the image.  We may then find that the additional
; 4278 :          packets need to be loaded in order to advance to other precincts
; 4279 :          in the code-stream.
; 4280 :             The function returns false if an SOT marker (or an EOC marker) is
; 4281 :          encountered.  Note that when an SOT marker is encountered, its
; 4282 :          segment is fully read into the codestream marker service and the
; 4283 :          precinct's tile must be active (otherwise an error message will be
; 4284 :          generated).  Before returning false in this way, the function sets
; 4285 :          the `active_tile' pointer in the codestream object to NULL.  The
; 4286 :          caller may determine the cause of failure by invoking the codestream
; 4287 :          marker service's `get_code' function, which will return one of SOT,
; 4288 :          EOC or 0, where 0 occurs only if the code-stream has been
; 4289 :          exhausted. */
; 4290 :     bool handle_corrupt_packet();
; 4291 :       /* This function implements alternate processing for the `read_packet'
; 4292 :          function in the event that a packet is found to be corrupt.  It is
; 4293 :          called whenever packet corruption is detected, including when the
; 4294 :          precinct is known to have had previously corrupt packets. The function
; 4295 :          manipulates the containing tile's `skipping_to_sop' and
; 4296 :          `next_sop_sequence_num' fields, advancing to the next SOP or SOT
; 4297 :          marker if necessary (the function may be called after detecting an
; 4298 :          SOP marker already, whose sequence number is not as expected).  If
; 4299 :          an SOT marker is encountered, the function renders the current tile
; 4300 :          inactive and returns false (this is the behaviour expected of
; 4301 :          `read_packet').  Otherwise, it updates the precinct and tile state to
; 4302 :          identify the packet as having been read. */
; 4303 :   public: // Public Links and Identification
; 4304 :     kd_resolution *resolution;
; 4305 :     kd_precinct_ref *ref; // Element of `resolution->precinct_refs' array
; 4306 : 
; 4307 :   public: // Mode flags used for decompression and/or interchange
; 4308 :     int flags; // The following flags are defined.
; 4309 :        // KD_PFLAG_GENERATING -- after 1'st call to `kd_precinct::get_packets'
; 4310 :        // KD_PFLAG_CORRUPTED -- if error occurred during packet reading
; 4311 :        // KD_PFLAG_DESEQUENCED -- if all packets have been desequenced
; 4312 :        // KD_PFLAG_ADDRESSABLE -- if seekable, cached or used for interchange
; 4313 :        // KD_PFLAG_RELEASED -- if `activate' must be called to revive state
; 4314 :        // KD_PFLAG_INACTIVE -- if resides on `kd_precict_server's inactive list
; 4315 :        // KD_PFLAG_RELEVANT -- always true if codestream is for non-persistent
; 4316 :        //     input; otherwise, true only if precinct belongs to the relevant
; 4317 :        //     set of precincts of a relevant tile-component-resolution
; 4318 :        // KD_PFLAG_SIGNIFICANT -- if any code-block bytes have been generated
; 4319 :        //     by `kdu_precinct::size_packets' or `kdu_precinct::get_packets'
; 4320 :        // KD_PFLAG_PARSED -- if the precinct was parsed previously and then
; 4321 :        //     unloaded; prevents multiple accumulation of packet length stats
; 4322 :   public: // State variables
; 4323 :     int required_layers; /* Actual number of layers for output codestream;
; 4324 :                 max apparent layers for input or interchange codestream. */
; 4325 :     int next_layer_idx; // Next layer to be sequenced or generated.
; 4326 :     union { // First field used for input; second interchange; third for output
; 4327 :         int num_packets_read; // Incremented when packets read or interchanged
; 4328 :         int cumulative_bytes; // Size of all packets generated so far.
; 4329 :         int saved_next_layer_idx; // Used by "kd_packet_sequencer::save_state"
; 4330 :       };
; 4331 : 
; 4332 :   public: // Activation state variables
; 4333 :     int num_outstanding_blocks; // See notes below.
; 4334 :     union { // First field used only in reading; second only in writing.
; 4335 :         kdu_long unique_address; // See below
; 4336 :         kdu_long *packet_bytes; // Lengths generated during simulated output
; 4337 :       };
; 4338 :   public: // code-block containers
; 4339 :     kd_precinct_band *subbands; // In practice, this member points into the
; 4340 :        // same block of memory which is allocated to hold the precinct so
; 4341 :        // as to encourage memory locality and allow for manipulation of all
; 4342 :        // aspects of a precinct, including all of its code-blocks, via a
; 4343 :        // single heap block.  Note that the number of entries in this array
; 4344 :        // is given by `resolution->num_subbands'.
; 4345 : 
; 4346 :   public: // See below for an explanation of these links
; 4347 :     kd_precinct *next; // Next in free, inactive or generated list
; 4348 :     kd_precinct *prev; // Previous in inactive or generated list
; 4349 :     kd_precinct_size_class *size_class; // For correctly releasing storage
; 4350 :   };
; 4351 :   /* Notes:
; 4352 :         `unique_address' is valid if and only if the precinct is marked as
; 4353 :      addressable, meaning that the precinct has a unique address from which it
; 4354 :      may be loaded (for input codestream objects) or identified (for
; 4355 :      interchange codestream objects).  If addressable, the `unique_address'
; 4356 :      will be 0 if and only if the precinct is known to be empty, meaning that
; 4357 :      reloading the precinct does not require any actual data transfers from a
; 4358 :      compressed data source.
; 4359 :         Except as described above, when used with seekable compressed data
; 4360 :      sources, the `unique_address' member holds a positive quantity which
; 4361 :      identifies an offset into the code-stream at which the precinct's
; 4362 :      packets may be found.  In the case of cached sources (those advertising
; 4363 :      the KDU_SOURCE_CAP_CACHED capability) or codestream objects created for
; 4364 :      interchange (no compressed data source or target), the `unique_address'
; 4365 :      will be negative and -(1+`unique_address') is the precinct's unique
; 4366 :      identifier, as passed to the `kdu_compressed_source::set_precinct_scope'
; 4367 :      function, or returned by the `kdu_precinct::get_unique_id' function.
; 4368 :         The `num_outstanding_blocks' member is used to monitor the number of
; 4369 :      code-blocks from the application's region of interest which have still
; 4370 :      to be consumed (input codestreams) or the number of code-blocks which
; 4371 :      have still to be written in order to complete the precinct (output
; 4372 :      and interchange codestreams).
; 4373 :         The `next' and `prev' links may be used to manage the precinct's
; 4374 :      location in one of three different lists.  The first list is the
; 4375 :      singly-linked free list maintained by `kd_precinct_size_class', from
; 4376 :      which the `kd_precinct_server' object re-issues previously released
; 4377 :      resources.
; 4378 :         The second list on which this structure may find itself is the
; 4379 :      doubly-linked list of currently inactive precincts, which is managed by
; 4380 :      the `kd_precinct_server' object.  Precincts which find themselves on this
; 4381 :      list have been released, but their resources have not yet been recycled.
; 4382 :      They may be successfully re-activated, if their resources have not been
; 4383 :      re-issued to another precinct.  Precincts on this list may be identified
; 4384 :      by the `inactive' flag.  Every inactive precinct necessarily also has
; 4385 :      its `released' member set to true, but the converse is not necessarily
; 4386 :      true.  This is because precincts which have been partially parsed
; 4387 :      in a context for which they were not directly relevant, will be marked
; 4388 :      as released, even though they are not inactive.
; 4389 :         The third list on which this structure may find itself is the
; 4390 :      doubly-linked list of generated precincts managed by the
; 4391 :      `kd_global_rescomp' structure.  This list contains all precincts
; 4392 :      from a given resolution of a given image component, across all tiles,
; 4393 :      which have been fully generated, but not yet flushed out to the
; 4394 :      code-stream.   The list is used to manage incremental rate allocation
; 4395 :      when processing large images.  Elements on this list have not yet
; 4396 :      been closed. */
; 4397 : 
; 4398 : /*****************************************************************************/
; 4399 : /*                         kd_precinct_size_class                            */
; 4400 : /*****************************************************************************/
; 4401 : 
; 4402 :   /* For an explanation of the role played by precinct size classes, see
; 4403 :      the discussion appearing below the declaration of `kd_precinct_server'. */
; 4404 : 
; 4405 : class kd_precinct_size_class {
; 4406 :   public: // Member functions
; 4407 :     kd_precinct_size_class(int max_blocks, int num_subbands,
; 4408 :                            kd_precinct_server *server,
; 4409 :                            kd_buf_server *buf_server)
; 4410 :       {
; 4411 :         this->max_blocks = max_blocks;
; 4412 :         this->num_subbands = num_subbands;
; 4413 :         this->server = server;  this->buf_server = buf_server;
; 4414 :         total_precincts = 0; free_list = NULL; next = NULL;
; 4415 :         alloc_bytes = (int) sizeof(kd_precinct);
; 4416 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4417 :         alloc_bytes += num_subbands * (int) sizeof(kd_precinct_band);
; 4418 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4419 :         alloc_bytes += 4 + max_blocks * (int) sizeof(kd_block);
; 4420 :       }
; 4421 :     ~kd_precinct_size_class()
; 4422 :       { kd_precinct *tmp;
; 4423 :         while ((tmp=free_list) != NULL)
; 4424 :           { free_list = tmp->next; free(tmp); total_precincts--; }
; 4425 :         assert(total_precincts == 0);
; 4426 :       }
; 4427 :     kd_precinct *get()
; 4428 :       {
; 4429 :         if (free_list == NULL)
; 4430 :           augment_free_list();
; 4431 :         kd_precinct *result = free_list; free_list = free_list->next;
; 4432 :         result->next = result->prev = NULL;
; 4433 :         buf_server->augment_structure_bytes(alloc_bytes);
; 4434 :         return result;
; 4435 :       }
; 4436 :     void release(kd_precinct *precinct)
; 4437 :       {
; 4438 :         if (precinct->flags & KD_PFLAG_INACTIVE)

	test	BYTE PTR [edi+8], 32			; 00000020H

; 4676 :       precinct->size_class->release(precinct);

	mov	edx, DWORD PTR [edi+52]
	mov	DWORD PTR _this$1$[ebp], edx

; 2961 :           }
; 2962 :       }
; 2963 :   public: // Links and Identification
; 2964 :     kd_codestream *codestream;
; 2965 :     kd_tile *tile;
; 2966 :     kd_comp_info *comp_info; // Ptr to relevant `codestream->comp_info' entry
; 2967 :     int cnum;
; 2968 : 
; 2969 :   public: // Dimensions and Parameters
; 2970 :     kdu_coords sub_sampling;
; 2971 :     kdu_dims dims;
; 2972 :     kdu_dims region;
; 2973 :     int dwt_levels, apparent_dwt_levels;
; 2974 :     bool reversible;
; 2975 :     int kernel_id; // Ckernels_W5X3, Ckernels_W9X7 or Ckernels_ATK
; 2976 :     bool kernel_symmetric, kernel_symmetric_extension;
; 2977 :     int kernel_num_steps;
; 2978 :     kdu_kernel_step_info *kernel_step_info, *kernel_step_info_flipped;
; 2979 :     float *kernel_coefficients, *kernel_coefficients_flipped;
; 2980 :     float kernel_low_scale; // Amount to scale low-pass lifting analysis output
; 2981 :     float kernel_high_scale; // Amount to scale hi-pass lifting analysis output
; 2982 :     int low_support_min, low_support_max; // low-pass synthesis impulse support
; 2983 :     int high_support_min, high_support_max; // high-pass synth impulse support
; 2984 :     float G_tc; // Global multi-component energy gain term; -ve if not known
; 2985 :     float G_tc_restricted; // Multi-component energy gain term based only on
; 2986 :             // those output components currently of interest; -ve if not known
; 2987 :     int recommended_extra_bits;
; 2988 :     kdu_coords blk; // Nominal code-block dimensions.
; 2989 :     int modes; // Block coder modes.  Flags defined in scope `cod_params'
; 2990 : 
; 2991 :   public: // Arrays
; 2992 :     kd_resolution *resolutions; // Contains 1+`dwt_levels' entries.
; 2993 :     kdu_long *layer_stats; // Contains `num_layers' pairs per resolution,
; 2994 :       // starting from the lowest resolution (`res_level'=0); each pair holds
; 2995 :       // number of parsed packets for the layer-resolution, followed by
; 2996 :       // number of parsed packet bytes for the layer-resolution.  Available
; 2997 :       // only for input codestreams; populated by `kd_precinct::read_packet'.
; 2998 : 
; 2999 :   public: // Flags and Other State Variables
; 3000 :     bool enabled; // See below
; 3001 :     bool is_of_interest; // See below
; 3002 :     kdu_coords grid_min; // These fields are used by "kd_packet_sequencer"
; 3003 :     kdu_coords grid_inc; // for spatially oriented progressions.
; 3004 :     kdu_coords saved_grid_min; // For "kd_packet_sequencer::save_state"
; 3005 :     kdu_coords saved_grid_inc; // For "kd_packet_sequencer::save_state"
; 3006 :   };
; 3007 :   /* Notes:
; 3008 :         `recommended_extra_bits' may be added to the sample bit-depth
; 3009 :      (precision) for this component to determine an appropriate number
; 3010 :      of bits for internal representations associated with the data
; 3011 :      processing path.
; 3012 :         In the reversible path, the value is set to the maximum bit-depth
; 3013 :      expansion factor, as reported in Table 17.4 of the book by Taubman and
; 3014 :      Marcellin, adding an extra 1 bit if the RCT has been used -- note that it
; 3015 :      is not desirable for luminance and chrominance components to have
; 3016 :      different numeric representations, since that would significantly
; 3017 :      complicate the colour transform procedure.
; 3018 :         In the irreversible path, the value is set to 7, which means
; 3019 :      that 16-bit representations are judged sufficient for 9 bit
; 3020 :      imagery or less.  Of course, the impact of selecting a reduced
; 3021 :      representation precision is only reduced accuracy in the
; 3022 :      irreversible processing path.
; 3023 :         The `enabled' flag is used to efficiently identify the tile-components
; 3024 :      which are enabled.  Remember that a tile-component may be disabled,
; 3025 :      either because the corresponding codestream image component is not
; 3026 :      apparent (only when the `kd_codestream::component_access_mode' is
; 3027 :      `KDU_WANT_CODESTREAM_COMPONENTS'), or because the tile-component
; 3028 :      is not involved in the construction of an apparent output image
; 3029 :      component (when the `kd_codestream::component_access_mode' is
; 3030 :      `KDU_WANT_OUTPUT_COMPONENTS').  In the latter case, all codestream
; 3031 :      image components are apparent, but disabled ones cannot be
; 3032 :      accessed -- this is important, since in the latter case the set
; 3033 :      of enabled components may vary from tile to tile.
; 3034 :         The `is_of_interest' flag is used to store the identify of components
; 3035 :      which are marked as being of interest, by calls to
; 3036 :      `kdu_tile::set_components_of_interest'.  This is done only when the
; 3037 :      component access mode is `KDU_WANT_CODESTREAM_COMPONENTS' or the
; 3038 :      `mct_head' member is NULL.  Otherwise, the components of interest are
; 3039 :      passed directly to the `kd_mct_stage::apply_output_restrictions'
; 3040 :      function.  Note that the `is_of_interest' flags do not generally
; 3041 :      belong to the component in which they are stored.  They are just
; 3042 :      copies of the information supplied to
; 3043 :      `kdu_tile::set_components_of_interest', without any attempt to apply
; 3044 :      any component index permutations which might be relevant. */
; 3045 : 
; 3046 : /*****************************************************************************/
; 3047 : /*                            kd_precinct_ref                                */
; 3048 : /*****************************************************************************/
; 3049 : 
; 3050 :   /* Objects of this class provide the vehicle through which precincts
; 3051 :      references are instantiated and removed from the array of precinct
; 3052 :      references maintained by the `kd_resolution' object.  It is important
; 3053 :      that the state information be small.  In particular, it has the same
; 3054 :      size as `kdu_long', which should never be smaller than the size of
; 3055 :      a memory pointer, but may be larger -- see the declaration of
; 3056 :      `kdu_long' in "elementary.h".  For precincts whose seek addresses are
; 3057 :      deduced from PLT marker segments in the code-stream, or precincts which
; 3058 :      are maintained by a caching data source, or precincts which are used by
; 3059 :      codestream objects created for interchange, this object provides
; 3060 :      facilities for recycling a disused precinct's resources while keeping its
; 3061 :      unique address around for rapid reloading in the event that it
; 3062 :      is required at a later point. */
; 3063 : 
; 3064 : class kd_precinct_ref {
; 3065 :   public: // Member functions
; 3066 :     kd_precinct_ref()
; 3067 :       { state = 0; }
; 3068 :     ~kd_precinct_ref()
; 3069 :       { if (!((state == 0) || (state & 1))) close(); }
; 3070 :     bool parsed_and_unloaded()
; 3071 :       { return ((state & 3) == 3) && (state != 3); }
; 3072 :       /* Returns true if the precinct is addressable (i.e., dynamically
; 3073 :          loadable) and it has been parsed and subsequently unloaded from
; 3074 :          memory. */
; 3075 :     kd_precinct *deref()
; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }
; 3077 :       /* Returns NULL unless the reference identifies a valid `kd_precinct'
; 3078 :          object, which is already loaded in memory. */
; 3079 :     kd_precinct *active_deref();
; 3080 :       /* Returns NULL unless the reference identifies a valid `kd_precinct'
; 3081 :          object, which is already loaded in memory and is in the active
; 3082 :          state. */
; 3083 :     kd_precinct *open(kd_resolution *res, kdu_coords pos_idx,
; 3084 :                       bool need_activate);
; 3085 :       /* Attempts to open the precinct at the indicated position within the
; 3086 :          array of precincts maintained by the indicated resolution object.
; 3087 :          `pos_idx' holds the horizontal and vertical position of the
; 3088 :          precinct (starting from 0) within the array of precincts for
; 3089 :          the given resolution.  That is, `pos_idx' holds a relative, not
; 3090 :          an absolute precinct index.
; 3091 :             If the precinct is known to be unloadable (this happens if the
; 3092 :          precinct has previously been opened and has then been permanently
; 3093 :          closed), the function returns NULL.
; 3094 :             If the precinct currently exists in memory (the `state' variable
; 3095 :          contains a valid pointer to the precinct), the function returns a
; 3096 :          pointer to that precinct; however, if `need_activate' is true
; 3097 :          and the precincts's `released' flag is true, `kd_precinct::activate'
; 3098 :          is called before returning the `kd_precinct' pointer.  When the
; 3099 :          codestream object was created for input or for interchange, the
; 3100 :          `need_activate' argument should be set to true only when the
; 3101 :          precinct is being opened in order to access code-block data.  In
; 3102 :          that case, the precinct must belong to an open tile and lie within
; 3103 :          the application's current region of interest, meaning that it will
; 3104 :          be released again when the tile is closed.  For codestream objects
; 3105 :          created for output, the argument should have no effect, since
; 3106 :          output precincts are not actually released.
; 3107 :             Otherwise, the function obtains a new `kd_precinct' object from
; 3108 :          the code-stream's precinct server and calls its `initialize'
; 3109 :          function.  If the `state' variable held the precinct's unique
; 3110 :          address value on entry, that address is written into the newly
; 3111 :          instantiated `kd_precinct' object's `unique_address' field, and
; 3112 :          the P bit (see notes on `state' below) is copied to the precinct's
; 3113 :          KD_PFLAG_PARSED flag.  If compressed data comes from a cached source,
; 3114 :          or the codestream object was created for interchange (no compressed
; 3115 :          data sources or targets), the newly created precinct is automatically
; 3116 :          marked as addressable, with its `unique_address' set to the
; 3117 :          precinct's unique identifier, as described in the comments appearing
; 3118 :          with the declaration of `kd_precinct::unique_address'.  For
; 3119 :          precincts which can be addressed using a seek address (for seekable
; 3120 :          compressed data sources), the seek address is installed using
; 3121 :          `set_address' from within the `kd_packet_sequencer::next_in_sequence'
; 3122 :          function.
; 3123 :             It is worth noting that this function may cause other precincts
; 3124 :          to be unloaded from memory, in order to conserve memory resources.
; 3125 :          If this happens, only precincts which have been released and
; 3126 :          which do not intersect with the current region of interest will be
; 3127 :          unloaded. */
; 3128 :     void close();
; 3129 :       /* Closes the active `kd_precinct' object whose pointer is in
; 3130 :          `state', calling its `closing' member function and recycling its
; 3131 :          storage.  If the precinct is marked as addressable, its
; 3132 :          `unique_address' member and KD_PFLAG_PARSED flag are recorded in
; 3133 :          `state' using the convention outlined in the notes below, allowing
; 3134 :          the precinct to be re-opened at a later point.
; 3135 :             In many cases, you are better off calling the `release' member
; 3136 :          function instead of `close' (see below).
; 3137 :             Note that this function may be safely invoked even when the
; 3138 :          precinct is not currently active -- it does nothing unless `state'
; 3139 :          holds a valid precinct address. */
; 3140 :     void close_and_reset();
; 3141 :       /* This function is used only by `kdu_tile::parse_all_relevant_packets'
; 3142 :          and then only if it is asked to parse everything from scratch.  The
; 3143 :          behaviour is similar to calling `close', except that the internal
; 3144 :          `state' record is left with its P flag reset, so that when the
; 3145 :          precinct is reloaded, its packet statistics will be entered into
; 3146 :          the `kd_tile_comp::layer_stats' array -- the caller invariably
; 3147 :          resets this array. */
; 3148 :     void release();
; 3149 :       /* This function should be called once a precinct is no longer
; 3150 :          required, in preference to the `close' function.  If the system is
; 3151 :          running low on resources, the function may unload the precinct from
; 3152 :          memory to recycle its resources.  Alternatively, the function is at
; 3153 :          liberty to leave the precinct in memory, moving it to a list of
; 3154 :          inactive precincts which are subject to unloading at some point in
; 3155 :          the future, when resources may be running low.  Non-addressable or
; 3156 :          cached precincts are unloaded immediately, since they are
; 3157 :          guaranteed never to be re-opened once `release' has been called. */
; 3158 :     void clear();
; 3159 :       /* This function recycles the storage associated with any existing
; 3160 :          precinct and sets the internal `state' variable to 0.  It is called
; 3161 :          when the code-stream management machinery is restarted. */
; 3162 :     bool is_desequenced();
; 3163 :       /* This function is intended for use within
; 3164 :          `kd_packet_sequencer::next_in_sequence', for checking whether
; 3165 :          or not the precinct which is returned by that function needs
; 3166 :          to have its contents read from a compressed data source in
; 3167 :          order to desequence a new packet.  Opening precincts can be a time
; 3168 :          consuming task, especially when there are an enormous number of
; 3169 :          precincts (this can happen when working with huge untiled images,
; 3170 :          especially in geospatial applications).  This function takes
; 3171 :          advantage of the fact that there is no need to actually open a
; 3172 :          precinct which is not already loaded into memory.  The fact that this
; 3173 :          function is called first by the packet desequencer, allows a precinct
; 3174 :          which has already been fully generated to be closed immediately
; 3175 :          during packet generation mode.
; 3176 :             The function works as follows.  If the precinct is already loaded
; 3177 :          in memory, its `sequenced' flag is accessed directly.   Otherwise,
; 3178 :          if the reference `state' variable identifies a valid unique
; 3179 :          address for the precinct, it is known to be addressable and
; 3180 :          therefore must have already been fully desequenced.  Also, if the
; 3181 :          `state' variable indicates that the precinct is unloadable, or that
; 3182 :          it has been closed in packet generation mode, it is interpreted as
; 3183 :          sequenced, in the sense that the application cannot sequence further
; 3184 :          packets for the precinct.  Otherwise, the `state' variable must hold
; 3185 :          0 (see below), from which we deduce that the precinct has not yet
; 3186 :          been sequenced. */
; 3187 :     bool set_address(kd_resolution *res, kdu_coords pos_idx,
; 3188 :                      kdu_long seek_address);
; 3189 :       /* Called from within `kd_packet_sequencer::next_in_sequence', this
; 3190 :          function installs a seek address for a precinct whose packets are
; 3191 :          contiguous within the code-stream and have valid pointer information
; 3192 :          stored in PLT marker segments.  Subsequent calls to `is_sequenced'
; 3193 :          will return true.  The precinct itself may either be open or closed
; 3194 :          when this function is called.  The `pos_idx' argument is provided
; 3195 :          for computing the relevance of this precinct to the application.  It
; 3196 :          holds a relative precinct index, having the same interpretation as
; 3197 :          that passed to `kd_precinct::initialize' and `kdu_precinct_ref::open'.
; 3198 :             It can happen that this function causes the tile, and hence the
; 3199 :          precinct reference, to be destroyed.  This happens if the call to
; 3200 :          this function renders the resolution or tile completely parsed,
; 3201 :          and it is known that the application has no need for any further
; 3202 :          access to the tile.  In this case, and only in this case, the
; 3203 :          function returns false, meaning that the caller must not make
; 3204 :          any further attempt to access the tile or any of its resources. */
; 3205 :   private: // Utility functions
; 3206 :     kd_precinct *instantiate_precinct(kd_resolution *res, kdu_coords pos_idx);
; 3207 :       /* Called from `open' if the `kd_precinct' object is not in memory at
; 3208 :          the time and can legitimately be created at this point. */
; 3209 :   private: // Data
; 3210 :     kdu_long state;
; 3211 :   };
; 3212 :   /* Notes:
; 3213 :         `state' holds 0 if no information is yet available concerning the
; 3214 :      precinct associated with this reference.
; 3215 :         If the precinct is currently active in memory, `state' holds the
; 3216 :      address in memory (pointer) of the `kd_precinct' structure.
; 3217 :         If the precinct is known to be addressable, `state' holds an odd
; 3218 :      integer, equal to 4*A + 2*P + 1, where A is the precinct's
; 3219 :      `unique_address' value and P is a flag, equal to 1 if the precinct
; 3220 :      has been loaded and parsed previously.
; 3221 :         The `unique_address' value has the same definition as the
; 3222 :      corresponding data member in `kd_precinct'.
; 3223 :         This P flag plays the same role as the KD_PFLAG_PARSED bit in
; 3224 :      `kd_precinct::flags'.  It is used to avoid collecting layer size
; 3225 :      statistics twice for the same precinct which could otherwise happen
; 3226 :      when precincts get swapped in and out of memory on demand.
; 3227 :         A value of `state'=1 means that the precinct can be re-instantiated,
; 3228 :      but that it is known to contain no packets whatsoever.
; 3229 :         If a previously active precinct's resources have been recycled and
; 3230 :      re-loading is not possible, `state' is assigned the special value of 3. */
; 3231 : 
; 3232 : /*****************************************************************************/
; 3233 : /*                               kd_leaf_node                                */
; 3234 : /*****************************************************************************/
; 3235 : 
; 3236 : struct kd_leaf_node {
; 3237 :     public: // Data
; 3238 :       kd_node *parent; // Every leaf node has a non-leaf parent node
; 3239 :       kd_resolution *resolution; // Always points to the owning resolution
; 3240 :       kdu_dims dims; // Dimensions & location of the image at this node
; 3241 :       kdu_dims region; // See below
; 3242 :       kdu_byte branch_x, branch_y; // See below
; 3243 :       bool is_leaf; // False if this object is the base of `kd_node'
; 3244 :   };
; 3245 :   /* Notes:
; 3246 :         This structure is the base of the richer `kd_node' structure.  The
; 3247 :      key difference is that leaf nodes have no children, so we do not waste
; 3248 :      storage recording pointers to them.
; 3249 :         The `branch_x' and `branch_y' members describe how this node is
; 3250 :      derived from its parent node, if any.  `branch_x' holds 0 if horizontal
; 3251 :      low-pass filtering and decimation were used to obtain the node from its
; 3252 :      parent; it holds 1 if horizontal high-pass filtering and decimation were
; 3253 :      used; it holds 2 if no filtering or decimation were involved in the
; 3254 :      horizontal direction.  `branch_y' plays a similar role in describing the
; 3255 :      vertical filtering and decimation processes.  If `parent' is NULL,
; 3256 :      the `branch_x' and `branch_y' members have no meaning.
; 3257 :         This structure manages two different, yet related regions
; 3258 :      (location, plus dimensions) which deserve some explanation here.
; 3259 :      * The `dims' member serves the usual role of identifying the location and
; 3260 :        dimensions of the image, as it appears on entry into this node,
; 3261 :        during forward transformation (analysis).  For primary nodes,
; 3262 :        these are the dimensions and location of the tile-component-resolution
; 3263 :        within its canvas.
; 3264 :      * `region' identifies a subset of the `dims' region, containing
; 3265 :        all of the node's samples which are involved in the synthesis of the
; 3266 :        current region of interest, as specified in the most recent call to
; 3267 :        `kdu_codestream::apply_input_restrictions'. */
; 3268 : 
; 3269 : /*****************************************************************************/
; 3270 : /*                                 kd_node                                   */
; 3271 : /*****************************************************************************/
; 3272 : 
; 3273 : struct kd_node : public kd_leaf_node {
; 3274 :     public: // Member functions
; 3275 :       void adjust_cover(kdu_dims child_cover,
; 3276 :                         int child_branch_x, int child_branch_y);
; 3277 :         /* This function is used to find the `region_cover' members.  In
; 3278 :            a downward sweep through the decomposition branches associated
; 3279 :            with a given resolution level, the `region_cover' members are all
; 3280 :            set to empty regions.  We then assign each leaf node (subband)
; 3281 :            a region cover (not actually recorded in the leaf node) equal to
; 3282 :            its region of interest and work back up the tree from the
; 3283 :            leaves to the primary node of the resolution in question, calling
; 3284 :            this function to grow the region cover so as to encompass the
; 3285 :            smallest region which covers each of its children. */
; 3286 :     public: // Data
; 3287 :       kdu_dims region_cover; // See below
; 3288 :       kdu_dims prec_dims; // Temp storage for calculating precinct dimensions
; 3289 :       kd_leaf_node *children[4]; // Indexed by `LL_BAND' through `HH_BAND'
; 3290 :       kdu_byte num_hor_steps, num_vert_steps; // See below
; 3291 :       kdu_uint16 num_descendant_nodes;
; 3292 :       kdu_uint16 num_descendant_leaves;
; 3293 :       float *bibo_gains; // See below
; 3294 :   };
; 3295 :   /* Notes:
; 3296 :         This object is used to construct descriptions of all non-leaf
; 3297 :      nodes in the DWT decomposition structure.  Each node in the structure
; 3298 :      may be decomposed horizontally, vertically or both.  If it is decomposed
; 3299 :      in the horizontal direction, `children[HL_BAND]' will be non-NULL.  If it
; 3300 :      is decomposed in the vertical direction, `children[LH_BAND]' will be
; 3301 :      non-NULL.  If it is decomposed in both directions, `children[HH_BAND]'
; 3302 :      will also be non-NULL.  If it is decomposed at all, `children[LL_BAND]'
; 3303 :      will always be non-NULL.
; 3304 :         The decomposition structure consists of a collection of primary
; 3305 :      nodes, each of which is embedded within a `kd_resolution' object.
; 3306 :      In the case of the simple Mallat structure, each primary node has
; 3307 :      4 children, with the LL child embedded within the next lower
; 3308 :      resolution object and the remaining children embedded within
; 3309 :      `kd_subband' objects.  In wavelet packet decomposition structures,
; 3310 :      detail subbands produced by a primary node may, themselves, be
; 3311 :      decomposed further into subbands.
; 3312 :         The actual object pointed to by each non-NULL member of the `children'
; 3313 :      array may need to be cast to type `kd_node', rather than `kd_leaf_node'
; 3314 :      if the `kd_leaf_node::is_leaf' member is false.
; 3315 :         The `children[LL_BAND]' entry of a primary node always points to
; 3316 :      the node which is embedded within the next lower resolution
; 3317 :      `kd_resolution' object, except at the lowest resolution of all.
; 3318 :      The lowest `kd_resolution' object's embedded node has only one
; 3319 :      child, with `children[LL_BAND]' pointing to the single (LL) subband
; 3320 :      belonging to that resolution.
; 3321 :         The `num_hor_steps' and `num_vert_steps' members identify the number
; 3322 :      of horizontal and vertical lifting steps associated with the horizontal
; 3323 :      and vertical transform operations applied at this node to produce its
; 3324 :      children.  One or both of these may be 0, either because the transform
; 3325 :      is trivial (lazy wavelet) or because the node is split only in the
; 3326 :      horizontal direction, only in the vertical direction, or is not split
; 3327 :      at all.
; 3328 :         The `num_descendant_nodes' member holds a count of the total number
; 3329 :      of nodes (leaf nodes and non-leaf nodes) which may be reached via the
; 3330 :      `children' array.  The `num_descendant_leaves' member holds a count of
; 3331 :      the number of these descendant nodes which are leaves.  Neither of these
; 3332 :      counts includes the current node.  Clearly there is no need to
; 3333 :      maintain this information with leaf nodes, since the counts would both
; 3334 :      be 0 in this case.
; 3335 :         The `bibo_gains' member point to an array with
; 3336 :      2+`num_hor_steps'+`num_vert_steps' entries.  The first 1+`num_hor_steps'
; 3337 :      entries describe BIBO gains for the horizontal transform performed
; 3338 :      at this node.  The remaining `+`num_vert_steps' entries describe BIBO
; 3339 :      gains for the vertical transform performed at this node.  Within each
; 3340 :      of these 2 sets of BIBO gains the first entry holds the BIBO gain from
; 3341 :      the original input image to the image which is presented at the input
; 3342 :      to this node.  Subsequent entries hold the BIBO gains from the original
; 3343 :      input image to the image which is presented at the output of each
; 3344 :      successive analysis lifting step.  Al BIBO gains are assessed relative to
; 3345 :      the nominal transform normalization, in which reversible lifting steps
; 3346 :      are applied as-is, while irreversible lifting steps are followed by the
; 3347 :      relevant `kd_tile_comp::low_scale' and `kd_tile_comp::high_scale' values.
; 3348 :         The interpretation of `region_cover' is similar to that of
; 3349 :      `kd_leaf_node::region', with a subtle, yet important twist.  In order to
; 3350 :      reconstruct each sample in `region', it is necessary to decode a
; 3351 :      particular set of samples from the subbands which are associated with
; 3352 :      this node.  Each of these subband samples has a mapping onto the
; 3353 :      coordinate system associated with the node, following the usual rules of
; 3354 :      the canvas coordinate system.  `res_cover' holds the smallest region
; 3355 :      which contains all of these mapped subband sample locations, except that
; 3356 :      the LL subband branch is included only if this is not a primary node.
; 3357 :      This ensures that the primary node embedded inside each `kd_resolution'
; 3358 :      object will have a `region_cover' which spans the nominal locations of
; 3359 :      all subband samples of interest, which are represented by codestream
; 3360 :      packets associated with that resolution. */
; 3361 : 
; 3362 : /*****************************************************************************/
; 3363 : /*                                kd_subband                                 */
; 3364 : /*****************************************************************************/
; 3365 : 
; 3366 : struct kd_subband : public kd_leaf_node {
; 3367 :     // State structure for the "kdu_subband" interface
; 3368 :   public: // Identification
; 3369 :     kdu_int16 descriptor; // See `cod_params::expand_decomp_bands'
; 3370 :     kdu_byte orientation; // One of LL_BAND, HL_BAND, LH_BAND or HH_BAND.
; 3371 :                      // This is the orientation of the primary subband from
; 3372 :                      // which we are derived within the same resolution level.
; 3373 :     kdu_byte sequence_idx; // Index within the `kd_resolution::subbands' array
; 3374 :                      // This is also the order in which subbands contribute
; 3375 :                      // code-blocks to codestream packets.
; 3376 :     kdu_byte transpose_sequence_idx; // Index of the real subband which appears
; 3377 :                       // to have this `sequence_idx' value when
; 3378 :                       // `kdu_codestream::change_appearance' has been used to
; 3379 :                       // transpose the codestream's appearance.
; 3380 :   public: // Dimensions and Parameters
; 3381 :     kdu_byte epsilon; // Ranging parameter.
; 3382 :     kdu_byte K_max; // Maximum magnitude bit-planes, not including ROI upshift
; 3383 :     kdu_byte K_max_prime; // Max magnitude bit-planes, including ROI upshift
; 3384 :     float delta; // Step size, normalized for image data range of -0.5 to 0.5
; 3385 :     float G_b; // Subband energy gain factor.
; 3386 :     float W_b; // Subband amplitude weight; needs squaring to get energy weight
; 3387 :     float roi_weight; // Extra amplitude weight for ROI foreground blocks.
; 3388 :     kdu_dims block_partition; // Holds the coding origin and dimensions.
; 3389 :     kdu_dims block_indices; // Holds the range of valid block indices.
; 3390 :     kdu_dims region_indices;  // Same as `block_indices', but restricted to
; 3391 :                               // blocks which overlap the region of interest.
; 3392 :     kdu_coords blocks_per_precinct; // precinct size / block size
; 3393 :     kdu_coords log2_blocks_per_precinct; // log2 of precinct size/block size
; 3394 :   };
; 3395 :   /* Notes:
; 3396 :         It may come as a surprise to notice that this object has no
; 3397 :      direct connection to code-blocks.  To access a code-block, the object
; 3398 :      first determines the precinct to which it belongs, creating that
; 3399 :      precinct if necessary; this, in turn, creates its precinct-bands and
; 3400 :      the associated code-blocks.  In this way, no memory whatsoever need be
; 3401 :      dedicated to code-blocks which lie in unaccessed precincts. */
; 3402 : 
; 3403 : /*****************************************************************************/
; 3404 : /*                              kd_resolution                                */
; 3405 : /*****************************************************************************/
; 3406 : 
; 3407 : struct kd_resolution { // State structure for the "kdu_resolution" interface
; 3408 :   public: // Member functions
; 3409 :     kd_resolution()
; 3410 :       {
; 3411 :         codestream = NULL; tile_comp = NULL; rescomp = NULL;
; 3412 :         precinct_refs = NULL; subbands = subband_handle = NULL; num_subbands=0;
; 3413 :         num_intermediate_nodes = 0; intermediate_nodes = NULL;
; 3414 :         can_flip = true;  node.bibo_gains = NULL;
; 3415 :       }
; 3416 :     ~kd_resolution()
; 3417 :       {
; 3418 :         if (node.bibo_gains != NULL) delete[] node.bibo_gains;
; 3419 :         for (int n=0; n < (int) num_intermediate_nodes; n++)
; 3420 :           if (intermediate_nodes[n].bibo_gains != NULL)
; 3421 :             delete[] intermediate_nodes[n].bibo_gains;
; 3422 :         if (precinct_refs != NULL) delete[] precinct_refs;
; 3423 :         if (subband_handle != NULL) delete[] subband_handle;
; 3424 :         if (intermediate_nodes != NULL) delete[] intermediate_nodes;
; 3425 :       }
; 3426 :     void build_decomposition_structure(kdu_params *coc, kdu_kernels &kernels);
; 3427 :       /* This function creates the `subbands' and `intermediate_nodes'
; 3428 :          arrays and fills in all the relevant pointers.  It uses `kernels'
; 3429 :          to create and fill in the `kdu_node::hor_bibo_gains' and
; 3430 :          `kdu_node::vert_bibo_gains' arrays, where required. */
; 3431 :     void complete_initialization();
; 3432 :       /* Called from within `kd_tile::initialize' to finish the initialization
; 3433 :          process, after all of the key parameters have been set.  Currently,
; 3434 :          the only task performed here is the initialization of the
; 3435 :          `max_blocks_per_precinct' member. */
; 3436 :   public: // Links and Identification
; 3437 :     kd_codestream *codestream;
; 3438 :     kd_tile_comp *tile_comp;
; 3439 :     kd_global_rescomp *rescomp;
; 3440 :     kdu_byte res_level; // Runs from 0 (LL band) to `num_dwt_levels'
; 3441 :     kdu_byte dwt_level; // Runs from `num_dwt_levels' (res level 0 and 1) to 1
; 3442 :     kdu_byte hor_depth; // From relevant entry of `kd_comp_info::hor_depth'
; 3443 :     kdu_byte vert_depth; // From relevant entry of `kd_comp_info::vert_depth'
; 3444 : 
; 3445 :   public: // Embedded node
; 3446 :     kd_node node; // Each resolution is a primary node in the decomposition
; 3447 : 
; 3448 :   public: // Dimensions and Parameters
; 3449 :     kdu_dims precinct_partition; // Holds the coding origin and dimensions.
; 3450 :     kdu_dims precinct_indices; // Holds the range of valid precinct indices.
; 3451 :     kdu_dims region_indices; // Holds range of indices for precincts whose
; 3452 :                              // code-blocks contribute to region of interest.
; 3453 :   public: // Derived quantities
; 3454 :     int max_blocks_per_precinct; // See discussion under `kd_precinct_band'
; 3455 :     bool propagate_roi; // True if ROI masks to be propagated to descendants
; 3456 : 
; 3457 :     bool can_flip; // Set to false if this level contains subband decomposition
; 3458 :                    // styles which are incompatible with view flipping.
; 3459 : 
; 3460 :   public: // Arrays
; 3461 :     kdu_byte num_subbands; // Excludes the LL band unless `res_level'=0
; 3462 :     kdu_byte num_intermediate_nodes; // Enough for all non-leaf nodes descended
; 3463 :                                  // from the primary node in this object.
; 3464 :     kd_node *intermediate_nodes; // Array with `num_intermediate_nodes' entries
; 3465 :     kd_precinct_ref *precinct_refs;
; 3466 :     kd_subband *subbands; // Points to `subband_store' or `subband_handle'.
; 3467 :     kd_subband *subband_handle; // For dynamically allocated subbands
; 3468 :     kd_subband subband_store[3]; // Avoid dynamic allocation for common case
; 3469 : 
; 3470 :   public: // Flags and Other State Variables
; 3471 :     kdu_coords current_sequencer_pos; // Used by `kd_packet_sequencer'.
; 3472 :     kdu_coords saved_current_sequencer_pos; // For saving the sequencer state
; 3473 :   };
; 3474 :   /* Notes:
; 3475 :         The `current_sequencer_pos' coordinates are used to sequence
; 3476 :      spatially oriented packet progressions.  They maintain the
; 3477 :      indices (starting from [0,0], rather than `precinct_indices.pos')
; 3478 :      of the precinct which is currently being sequenced.
; 3479 :         The `region_indices' member holds the smallest range of precinct
; 3480 :      indices, such that the code-blocks contained within these precincts
; 3481 :      are sufficient to reconstruct all samples inside `node.region'.
; 3482 :      Equivalently, the range in `precinct_indices' yields the set of
; 3483 :      precincts which intersect with `node.region_cover'.
; 3484 :         It is worth noting that the area of intersection between each
; 3485 :      precinct's region on the resolution and the `node.region_cover' region
; 3486 :      is used to compute the information returned by
; 3487 :      `kdu_resolution::get_precinct_relevance'. */
; 3488 : 
; 3489 : /*****************************************************************************/
; 3490 : /*                             kd_header_in                                  */
; 3491 : /*****************************************************************************/
; 3492 : 
; 3493 : class kd_header_in {
; 3494 :   /* Manages the reading of packet header bytes from the code-stream, along
; 3495 :      with bit stuffing and unpacking. */
; 3496 :   public: // Member functions
; 3497 :     kd_header_in(kd_input *source)
; 3498 :       { this->source = source; bits_left=0; byte=0; header_bytes=0; }
; 3499 :     int get_bit() // throws its own "this" pointer if the source is exhausted.
; 3500 :       {
; 3501 :         if (bits_left==0)
; 3502 :           {
; 3503 :             bits_left = (byte==0xFF)?7:8;
; 3504 :             if (!source->get(byte))
; 3505 :               { bits_left = 0; throw this; }
; 3506 :             header_bytes++;
; 3507 :           }
; 3508 :         bits_left--;
; 3509 :         return (byte >> bits_left) & 1;
; 3510 :       }
; 3511 :     kdu_uint32 get_bits(int num_bits) // thorws(kd_header_in *)
; 3512 :       { kdu_uint32 result = 0;
; 3513 :         while (num_bits > 0)
; 3514 :           {
; 3515 :             if (bits_left==0)
; 3516 :               {
; 3517 :                 bits_left = (byte==0xFF)?7:8;
; 3518 :                 if (!source->get(byte))
; 3519 :                   { bits_left = 0; throw this; }
; 3520 :                 header_bytes++;
; 3521 :               }
; 3522 :             int xfer_bits = (num_bits<bits_left)?num_bits:bits_left;
; 3523 :             bits_left -= xfer_bits;
; 3524 :             num_bits -= xfer_bits;
; 3525 :             result <<= xfer_bits;
; 3526 :             result |= ((byte >> bits_left) & ~(0xFF << xfer_bits));
; 3527 :           }
; 3528 :         return result;
; 3529 :       }
; 3530 :     int finish()
; 3531 :       { // Call this when the header is all read, to consume any stuffing byte
; 3532 :         // Returns total header length
; 3533 :         if ((bits_left == 0) && (byte == 0xFF))
; 3534 :           {
; 3535 :             bits_left = 7;
; 3536 :             if (!source->get(byte))
; 3537 :               throw this;
; 3538 :             header_bytes++;
; 3539 :           }
; 3540 :         return header_bytes;
; 3541 :       }
; 3542 :   private: // Data
; 3543 :     kd_input *source; // Provides the input mechanism.
; 3544 :     kdu_byte byte;
; 3545 :     int bits_left;
; 3546 :     int header_bytes;
; 3547 :   };
; 3548 : 
; 3549 : /*****************************************************************************/
; 3550 : /*                                kd_header_out                              */
; 3551 : /*****************************************************************************/
; 3552 : 
; 3553 : class kd_header_out {
; 3554 :   /* Manages the simulated and real output of packet header bytes. */
; 3555 :   public: // Member functions
; 3556 :     kd_header_out(kdu_output *out=NULL) // Null for simulating header
; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }
; 3558 :     void put_bit(int bit)
; 3559 :       { // Output a header bit
; 3560 :         assert(bit == (bit & 1));
; 3561 :         if (bits_left == 0)
; 3562 :           { if (out != NULL) out->put(byte);
; 3563 :             completed_bytes++;
; 3564 :             bits_left = (byte==0xFF)?7:8;
; 3565 :             byte = 0; }
; 3566 :         byte += byte + bit;
; 3567 :         bits_left--;
; 3568 :       }
; 3569 :     void put_bits(kdu_int32 val, int num_bits)
; 3570 :       { // Output the least significant `num_bits' of `val'
; 3571 :         while (num_bits > 0)
; 3572 :           put_bit((val >> (--num_bits)) & 1);
; 3573 :       }
; 3574 :     int finish()
; 3575 :       { // Returns the total number of bytes consumed by the packet header.
; 3576 :         if (bits_left < 8)
; 3577 :           {
; 3578 :             byte <<= bits_left;
; 3579 :             if (out != NULL)
; 3580 :               out->put(byte);
; 3581 :             completed_bytes++;
; 3582 :             if (byte == 0xFF)
; 3583 :               { // Need the stuffing byte.
; 3584 :                 if (out != NULL)
; 3585 :                   out->put((kdu_byte) 0);
; 3586 :                 completed_bytes++;
; 3587 :               }
; 3588 :           }
; 3589 :         return completed_bytes;
; 3590 :       }
; 3591 :   private: // Data
; 3592 :     kdu_byte byte;
; 3593 :     int bits_left;
; 3594 :     int completed_bytes;
; 3595 :     kdu_output *out;
; 3596 :   };
; 3597 : 
; 3598 : /*****************************************************************************/
; 3599 : /*                                 kd_block                                  */
; 3600 : /*****************************************************************************/
; 3601 : 
; 3602 : class kd_block {
; 3603 :   /* For a very small size (only 24 bytes on 32-bit machines), this class
; 3604 :      defines a lot of member functions!. */
; 3605 :   // --------------------------------------------------------------------------
; 3606 :   public: // Lifecycle member functions
; 3607 :     void cleanup(kd_buf_server *buf_server)
; 3608 :       {
; 3609 :         while ((current_buf=first_buf) != NULL)
; 3610 :           { first_buf=current_buf->next;  buf_server->release(current_buf); }
; 3611 :         set_discard(); // Discard from any packets parsed in the future
; 3612 :       }
; 3613 :     kd_code_buffer *cleanup()
; 3614 :       { // As above, but returns the linked list of buffers
; 3615 :         kd_code_buffer *result = first_buf;  first_buf = current_buf = NULL;
; 3616 :         set_discard();
; 3617 :         return result;
; 3618 :       }
; 3619 : 
; 3620 :   // --------------------------------------------------------------------------
; 3621 :   public: // Packet manipulation member functions
; 3622 :     int parse_packet_header(kd_header_in &head, kd_buf_server *buf_server,
; 3623 :                             int layer_idx); // Throws (kdu_uint16 code)
; 3624 :       /* Parses bits in the packet header corresponding to the current
; 3625 :          block for the current layer (this must be the next layer for which
; 3626 :          information has not yet been parsed).  The function returns the
; 3627 :          number of new body bytes contributed by the code-block in this layer
; 3628 :          and also stores this value internally to be used in subsequent calls
; 3629 :          to the `read_body_bytes' member function.
; 3630 :             The `kd_header_in' object may throw an exception if the packet
; 3631 :          data terminates unexpectedly.  Moreover, to assist in locating and
; 3632 :          possibly recovering from errors, the present function may throw a
; 3633 :          16-bit unsigned integer exception code, which is either the value of
; 3634 :          an illegal marker code encountered in the packet header, or one of
; 3635 :          the special exception codes, KDU_EXCEPTION_PRECISION or
; 3636 :          KDU_EXCEPTION_ILLEGAL_LAYER. */
; 3637 :     void read_body_bytes(kd_input *source, kd_buf_server *buf_server,
; 3638 :                          bool in_memory_source)
; 3639 :       { /* This function should be called after parsing the header of a
; 3640 :            packet.  It reads the code-bytes contributed by the code-block to
; 3641 :            this packet.  If `in_memory_source' is true, only the address of
; 3642 :            the code-bytes is recorded, and then only if the length of the
; 3643 :            code-byte segment is non-zero. */
; 3644 :         if (this->temp_length > 0)
; 3645 :           {
; 3646 :             if (num_passes == 255)
; 3647 :               { // Read and discard the code-bytes.
; 3648 :                 assert(first_buf == NULL);  source->ignore(this->temp_length);
; 3649 :               }
; 3650 :             else if (in_memory_source)
; 3651 :               {
; 3652 :                 kdu_byte *addr;
; 3653 :                 this->num_bytes += source->pseudo_read(addr,this->temp_length);
; 3654 :                 put_address(addr,buf_server);
; 3655 :               }
; 3656 :             else
; 3657 :               this->num_bytes +=
; 3658 :                 source->read(current_buf,buf_pos,buf_server,this->temp_length);
; 3659 :             this->temp_length = 0;
; 3660 :           }
; 3661 :       }
; 3662 :     void retrieve_data(kdu_block *block, int max_layers, int discard_passes,
; 3663 :                        bool in_memory_source);
; 3664 :       /* Retrieves compressed code-bytes, number of coding passes and codeword
; 3665 :          segment lengths from the current code-block and stores them in the
; 3666 :          `block' object.  All fields which are common for compression and
; 3667 :          decompression have already been filled out by the caller.  The
; 3668 :          byte buffer is allocated so as to be large enough to allow a
; 3669 :          2 byte marker code to be appended to the compressed data,
; 3670 :          if desired -- see declaration of "kdu_subband::open_block".
; 3671 :             The `max_layers' argument identifies the maximum number of
; 3672 :          quality layers for which code-block contributions are to be
; 3673 :          retrieved.
; 3674 :             The `discard_passes' argument indicates the number of additional
; 3675 :          coding passes to be removed, if any.
; 3676 :             If `in_memory_source' is true, the layer code bytes are not
; 3677 :          stored in the `kd_code_buffer' list embedded inside `block'.  Instead,
; 3678 :          the `kd_code_buffer' list stores only the header information for
; 3679 :          each layer, along with the address of the code bytes, which reside
; 3680 :          in the memory block managed by an in-memory compressed data source
; 3681 :          (one which offers the `KDU_SOURCE_CAP_IN_MEMORY') capability.  In
; 3682 :          this case, we retrieve the address and then perform a simple memory
; 3683 :          block copy operation to efficiently retrieve the code bytes for
; 3684 :          each layer. */
; 3685 :     void store_data(kdu_block *block, kd_buf_server *buf_server);
; 3686 :       /* Stores compressed code-bytes, pass length and pass slope information
; 3687 :          from the `block' object into the current code-block.  This function
; 3688 :          is invoked by "kdu_subband::close_block" when the containing
; 3689 :          codestream object was not constructed for input.  Also reflects
; 3690 :          the `msbs_w' value into higher nodes in the tag tree. */
; 3691 :     void store_data(kdu_block *block, kd_thread_buf_server *thread_buf_server);
; 3692 :       /* Same as the above function, but uses `kd_thread_buf_server::get'
; 3693 :          rather than `kd_buf_server::get' to get new code buffers.  This
; 3694 :          version is used to save code-block state in multi-threaded
; 3695 :          environments so as to minimize cache coherency bottlenecks and the
; 3696 :          need to lock shared resources. */
; 3697 :     void transfer_data(kd_block &src)
; 3698 :       { /* Like `store_data', but gets results from another block.  Exploits
; 3699 :            the layout of the object to copy only whole pointers or whole
; 3700 :            32-bit words, even where these represent multiple fields. */
; 3701 :         current_buf = first_buf = src.first_buf;
; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);
; 3703 :         src.current_buf = src.first_buf = NULL;
; 3704 :       }
; 3705 :     bool trim_data(kdu_uint16 slope_threshold, kd_buf_server *buf_server);
; 3706 :       /* This function serves two purposes: it helps reduce the amount of
; 3707 :          compressed data which must be buffered in memory while compressing
; 3708 :          an image; and it allows individual block contributions to be
; 3709 :          discarded during packet construction in order to tightly fit the
; 3710 :          generated bit-rate to the target compressed bit-rate.
; 3711 :             The function sets all coding pass slopes which are less than or
; 3712 :          equal to the supplied slope threshold to 0 and then discards all
; 3713 :          code bytes which could not possibly be included in the final
; 3714 :          code-stream, as a result of this modification.
; 3715 :             If anything was discarded, the function returns true.  Otherwise,
; 3716 :          it returns false. */
; 3717 :     int start_packet(int layer_idx, kdu_uint16 slope_threshold);
; 3718 :       /* Call this function only during rate allocation or packet generation.
; 3719 :          Before the first call to this function, you must reset the tag tree
; 3720 :          (see the "reset_output_tree" member function).  If you are calling
; 3721 :          the function multiple times with the same layer for rate allocation
; 3722 :          purposes, you must use "save_output_tree" and "restore_output_tree"
; 3723 :          as described below.
; 3724 :             The function leaves behind information about the number of new
; 3725 :          coding passes and the number of new code bytes which would be
; 3726 :          contributed by this code-block if the supplied threshold were actually
; 3727 :          used.  The final contributing coding pass must have a non-zero
; 3728 :          distortion-length slope which is strictly greater than the slope
; 3729 :          threshold.  It also updates the tag tree structure to reflect any
; 3730 :          new knowledge about the first layer to which this code-block would
; 3731 :          contribute.  This information is picked up by "write_packet_header".
; 3732 :             The function's return value is the total number of new code-bytes
; 3733 :          contributed by the block.  This allows the PCRD-opt algorithm to
; 3734 :          determine roughly the right slope threshold before committing to the
; 3735 :          work of simulating packet header generation. */
; 3736 :     void write_packet_header(kd_header_out &head, int layer_idx,
; 3737 :                              bool simulate);
; 3738 :       /* Call this function only after a `start_packet' call.  It writes
; 3739 :          (or simulates the writing of) packet header information corresponding
; 3740 :          to the code-block inclusion information set up by `start_packet'.
; 3741 :          If `simulate' is true, some internal state adjustments are delayed
; 3742 :          until the next call to "save_output_tree", so multiple calls to
; 3743 :          "start_packet" and "write_packet_header" may be issued with the same
; 3744 :          layer index to determine an optimal slope threshold.  Otherwise,
; 3745 :          if `simulate' is false, the internal state information is fully
; 3746 :          updated and the "save_output_tree" and "restore_output_tree" functions
; 3747 :          need not and should not be called. */
; 3748 :     void write_body_bytes(kdu_output *dest);
; 3749 :       /* This function should be called after a non-simulated
; 3750 :          "write_packet_header" call to output the newly included body bytes.
; 3751 :          The actual number of bytes to be written was left behind by
; 3752 :          the preceding "start_packet" call in the `temp_length' field. */
; 3753 :   // --------------------------------------------------------------------------
; 3754 :   public: // Static functions used to operate on tag-trees built from kd_block
; 3755 :     static kd_block *build_tree(kdu_coords size, kdu_byte * &mem_block);
; 3756 :       /* Builds a full tag tree returning a pointer to the upper left hand
; 3757 :          corner leaf node.  Apart from the `up_down' navigation pointers,
; 3758 :          all fields are initialized to 0.  This is appropriate for tag tree
; 3759 :          decoding, but encoders will need to call "reset_output_tree" and
; 3760 :          use "start_packet" to install appropriate node values.
; 3761 :             The tag tree is not allocated from the heap.  Instead, it is
; 3762 :          allocated from an existing memory block, identified by the `mem_block'
; 3763 :          argument.  This memory block is assumed to be large enough to hold
; 3764 :          the array of `kd_block' structures.  Upon return, the `mem_block'
; 3765 :          value is advanced by an amount equal to the size of the tag tree
; 3766 :          array. */
; 3767 :     static void reset_output_tree(kd_block *tree, kdu_coords size);
; 3768 :       /* Call this function immediately before simulating or actually
; 3769 :          generating any packet data for the relevant code-blocks.  Once
; 3770 :          the PCRD-opt algorithm has completed, you should call this function
; 3771 :          a second time to prepare for actual packet output.  The function
; 3772 :          initializes the threshold state variables, `layer_w_bar' and
; 3773 :          `msbs_w_bar' to 0, and the value state variables, `layer_w' and
; 3774 :          `msbs_w' to their maximum representable values.  The succession of
; 3775 :          "start_packet" calls will update the value variables `layer_w'
; 3776 :          and `msbs_w' in such a way that the tag tree coding process runs
; 3777 :          correctly in each subsequent call to "write_packet_header". */
; 3778 :     static void save_output_tree(kd_block *tree, kdu_coords size);
; 3779 :       /* Call this only during rate allocation, before moving on to a new
; 3780 :          layer.  The function saves the current state (`msbs_wbar' and
; 3781 :          `layer_wbar') of each node in the tag tree.  For leaf nodes, it also
; 3782 :          commits the number of new coding passes found in the last call to
; 3783 :          "start_packet". */
; 3784 :     static void restore_output_tree(kd_block *tree, kdu_coords size);
; 3785 :       /* Call this during rate allocation before supplying a new slope
; 3786 :          threshold for the same layer index, in a new "start_packet" call.
; 3787 :          The function restores the `msbs_w_bar' and `layer_w_bar' values
; 3788 :          previously saved by "save_output_tree". */
; 3789 :   // --------------------------------------------------------------------------
; 3790 :   public: // State identification functions
; 3791 :     void set_discard()
; 3792 :       { /* Use this function only with input-oriented operations.  It informs
; 3793 :            the object that none of the code-blocks associated with this
; 3794 :            block will ever be accessed, so that it is free to skip over them
; 3795 :            when reading a packet.  This can save a lot of memory if you have
; 3796 :            a defined region of interest for decompression. */
; 3797 :         num_passes = 255;
; 3798 :       }
; 3799 :     bool empty()
; 3800 :       { // Returns true if the block has no code-bytes yet.
; 3801 :         return first_buf == NULL;
; 3802 :       }
; 3803 :     void set_modes(int modes)
; 3804 :       {
; 3805 :         assert(modes == (modes & 0xFF));
; 3806 :         this->modes = (kdu_byte) modes;
; 3807 :       }
; 3808 :   // --------------------------------------------------------------------------
; 3809 :   private: // Convenience functions for transferring data to/from code buffers.
; 3810 :     void start_buffering(kd_buf_server *buf_server) // Call before `put_byte'
; 3811 :       { assert(first_buf == NULL);
; 3812 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3813 :     void start_buffering(kd_thread_buf_server *buf_server)
; 3814 :       { assert(first_buf == NULL);
; 3815 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3816 :     void put_byte(kdu_byte val, kd_buf_server *buf_server)
; 3817 :       {
; 3818 :         assert(current_buf != NULL);
; 3819 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3820 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3821 :         current_buf->buf[buf_pos++] = val;
; 3822 :       }
; 3823 :     void put_word(int val, kd_buf_server *buf_server)
; 3824 :       {
; 3825 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3826 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))
; 3827 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3828 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;
; 3829 :         buf_pos += 2;
; 3830 :       }
; 3831 :     void put_address(kdu_byte *addr, kd_buf_server *buf_server)
; 3832 :       {
; 3833 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3834 :         if (buf_pos > (KD_CODE_BUFFER_LEN-KDU_POINTER_BYTES))
; 3835 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3836 : 
; 3837 :         ((kdu_byte **)(current_buf->buf+buf_pos))[0] = addr;
; 3838 :         buf_pos += KDU_POINTER_BYTES;
; 3839 :       }
; 3840 :     void put_byte(kdu_byte val, kd_thread_buf_server *buf_server)
; 3841 :       {
; 3842 :         assert(current_buf != NULL);
; 3843 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3844 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3845 :         current_buf->buf[buf_pos++] = val;
; 3846 :       }
; 3847 :     void put_word(int val, kd_thread_buf_server *buf_server)
; 3848 :       {
; 3849 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3850 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))
; 3851 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3852 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;
; 3853 :         buf_pos += 2;
; 3854 :       }
; 3855 :     void put_address(kdu_byte *addr, kd_thread_buf_server *buf_server)
; 3856 :       {
; 3857 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3858 :         if (buf_pos > (KD_CODE_BUFFER_LEN-KDU_POINTER_BYTES))
; 3859 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3860 : 
; 3861 :         ((kdu_byte **)(current_buf->buf+buf_pos))[0] = addr;
; 3862 :         buf_pos += KDU_POINTER_BYTES;
; 3863 :       }
; 3864 :     kdu_byte get_byte()
; 3865 :       {
; 3866 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3867 :           { buf_pos=0; current_buf=current_buf->next;
; 3868 :             assert(current_buf != NULL); }
; 3869 :         return current_buf->buf[buf_pos++];
; 3870 :       }
; 3871 :     int get_word()
; 3872 :       {
; 3873 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3874 :         buf_pos += 2; // Advance the buffer pointer
; 3875 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3876 :           { buf_pos=2; current_buf=current_buf->next;
; 3877 :             assert(current_buf != NULL); }
; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];
; 3879 :       }
; 3880 :     kdu_byte *get_address()
; 3881 :       {
; 3882 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3883 :         buf_pos += KDU_POINTER_BYTES; // Advance the buffer pointer
; 3884 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3885 :           { buf_pos=KDU_POINTER_BYTES; current_buf=current_buf->next;
; 3886 :             assert(current_buf != NULL); }
; 3887 :         return ((kdu_byte **)(current_buf->buf+buf_pos))[-1];
; 3888 :       }
; 3889 :     void skip_word()
; 3890 :       {
; 3891 :         buf_pos += 2 + (buf_pos & 1); // Align and advance the buffer pointer
; 3892 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3893 :           { buf_pos=2; current_buf=current_buf->next;
; 3894 :             assert(current_buf != NULL); }
; 3895 :       }
; 3896 :     void skip_address()
; 3897 :       {
; 3898 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3899 :         buf_pos += KDU_POINTER_BYTES; // Advance the buffer pointer
; 3900 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3901 :           { buf_pos=KDU_POINTER_BYTES; current_buf=current_buf->next;
; 3902 :             assert(current_buf != NULL); }
; 3903 :       }
; 3904 :   // --------------------------------------------------------------------------
; 3905 :   private: // Data (lots of unions to make it as small as possible!)
; 3906 :     union {
; 3907 :       kd_code_buffer *first_buf;
; 3908 :       kdu_uint16 save_layer_w; // Used for saving non-leaf node state
; 3909 :       };
; 3910 :     union {
; 3911 :       kd_code_buffer *current_buf;
; 3912 :       kdu_uint16 save_layer_wbar; // Used for saving_non-leaf node state
; 3913 :       };
; 3914 :     union {
; 3915 :       kdu_byte buf_pos; // Location of next read/write byte in `current_buf'.
; 3916 :       kdu_byte save_msbs_wbar; // Used for saving non-leaf node state
; 3917 :       };
; 3918 :     kdu_byte msbs_w;
; 3919 :     kdu_byte num_passes;
; 3920 :     kdu_byte pass_idx;
; 3921 :     union {
; 3922 :       kdu_uint16 layer_w; // Used only when `pass_idx'=0
; 3923 :       kdu_uint16 body_bytes_offset; // Used in packet output if `pass_idx' > 0
; 3924 :       kdu_byte save_beta; // Used during output simulation if `pass_idx' > 0
; 3925 :       };
; 3926 :     union {
; 3927 :       kdu_uint16 layer_wbar;
; 3928 :       kdu_uint16 num_bytes; // Used only for input operations
; 3929 :       kdu_byte pending_new_passes; // Used only for output operations
; 3930 :       };
; 3931 :     union {
; 3932 :       kdu_byte msbs_wbar;
; 3933 :       kdu_byte beta;
; 3934 :       };
; 3935 :     kdu_byte modes;
; 3936 :     kdu_uint16 temp_length; // Temporary storage of length quantities.
; 3937 :     kd_block *up_down;
; 3938 :   };
; 3939 :   /* Notes:
; 3940 :         This structure has been designed to provide sufficient state
; 3941 :      information for each code-block to perform packet header parsing as
; 3942 :      well as block encoding and decoding.  For coding purposes, the information
; 3943 :      represented by the structure is generally transferred to or from a
; 3944 :      much less tightly packed representation for speed of execution of the
; 3945 :      block coding routines.  As it stands, the total size of this structure
; 3946 :      should be 24 bytes on a 32-bit architecture. An array of code-blocks is
; 3947 :      maintained by each precinct-band.  The array contains one entry for
; 3948 :      every block in the relevant precinct-band, but also contains additional
; 3949 :      entries to be used as tag-tree nodes.  The total number of such extra
; 3950 :      nodes is about 1/3 the number of code-blocks and should not be a
; 3951 :      significant cause of concern for overall memory consumption. There is
; 3952 :      also substantial benefit to be had by locating the tag tree nodes in
; 3953 :      the same contiguous memory block.  Notice that the structure contains
; 3954 :      no reference back to the precinct-band to which it belongs.  When
; 3955 :      necessary, this reference must be supplied separately to interested
; 3956 :      functions. One consequence of this memory saving step is that the
; 3957 :      object's destructor cannot do anything useful.  It only checks to make
; 3958 :      sure that the explicit `cleanup' function has already been called.
; 3959 :         If a block is to be discarded (since it does not intersect with a
; 3960 :      user-specified region of interest), the `num_passes' field will hold
; 3961 :      the otherwise impossible value, 255.
; 3962 :         The `first_buf', `current_buf' and `buf_pos' fields constitute the
; 3963 :      compressed data buffer management mechanism, which is used to store all
; 3964 :      quantities whose length is unpredictable a priori. In particular, a
; 3965 :      linked list of `kd_code_buffer' structures is provided, which grows on
; 3966 :      demand through access to the codestream object's embedded `buffering'
; 3967 :      object.  Data is stored in these buffers in the following formats:
; 3968 :            * Input Format -- [<layer #> (<#bytes> <#passes> ...)] data [<...
; 3969 :              That is, for each layer to which the code-block makes a non-empty
; 3970 :              contribution, we record first the layer number (2 bytes) and
; 3971 :              then one or more #bytes/#passes pairs.  #bytes is represented
; 3972 :              using 2 bytes, while #passes is represented using only 1 byte.
; 3973 :              There is one such 3 byte pair for each layer and one additional
; 3974 :              3 byte pair for each codeword segment terminating pass which
; 3975 :              is not the final pass contributed in the layer.  In this way,
; 3976 :              sufficient information is provided to recover all termination
; 3977 :              lengths, as well as to build layer associations.  The most
; 3978 :              significant bit of the #bytes field is used as a marker to
; 3979 :              indicate whether or not this is the last such field prior to
; 3980 :              the appearance of the code bytes contributed by that layer.  A
; 3981 :              1 means that there are more fields to go before the code bytes
; 3982 :              appear.
; 3983 :            * In-memory Format --[<layer #>(<#bytes> <#passes>...)] <addr> [<...
; 3984 :              This format is used as an alternative to the Input Format above,
; 3985 :              in the special case when the compressed data source supports the
; 3986 :              `KDU_SOURCE_CAP_IN_MEMORY' capability, so that
; 3987 :              `kd_codestream::in_memory_source' is true.  In this case, the
; 3988 :              "data" field is replaced by the address where the data can be
; 3989 :              found in the memory block managed by the compressed data source.
; 3990 :              Moreover, if the number of code-bytes associated with a layer
; 3991 :              is zero, the <addr> field is missing.
; 3992 :            * Output Format -- [<RD slope> <#bytes>] ... [<RD ...] data
; 3993 :              That is, all of the header information for all coding passes
; 3994 :              appears up front, followed by all of the code bytes associated
; 3995 :              with those coding passes.  The reason for putting all the
; 3996 :              header information up front is that it facilitates the
; 3997 :              identification of appropriate layer contributions by the
; 3998 :              rate control algorithm.  Each coding pass has a 4 byte header,
; 3999 :              with 2 bytes for the distortion-length slope value and 2 bytes
; 4000 :              for the number of code-bytes for the pass.
; 4001 :      The particular format which is used to store data depends upon the
; 4002 :      member functions which are used, since these implicitly determine
; 4003 :      whether the codestream object is being used for input or output.
; 4004 :         The `modes' field holds the block coder mode fields.  Some of these
; 4005 :      are required even for correct packet header parsing, regardless of whether
; 4006 :      the block is to be actually decoded.
; 4007 :         `msbs_w' and `msbs_wbar' are the state information required
; 4008 :      for tag-tree coding of the number of missing MSB's for a code-block
; 4009 :      which is about to make its first non-empty contribution to the
; 4010 :      code-stream. Similarly, `layer_w' and `layer_wbar' hold the state
; 4011 :      information required for tag-tree coding of the layer index in which a
; 4012 :      code-block first contributes to the code-stream.  The operation of
; 4013 :      tag-tree coding and the `w' and `wbar' terminology are explained in
; 4014 :      Section 8.4 of the book by Taubman and Marcellin.
; 4015 :         The `beta' field shares storage with `msbs_wbar'.  This is not
; 4016 :      required until the number of missing MSB's has been encoded or decoded,
; 4017 :      at which point we initialize `beta' to 3 (see the JPEG2000 standard or
; 4018 :      Section 12.5.4 of the book by Taubman and Marcellin).  A useful
; 4019 :      consequence of this behaviour is that `beta' may be tested at any
; 4020 :      point of the packet header encoding or decoding process to determine
; 4021 :      whether or not the code-block has yet contributed to the code-stream
; 4022 :      -- the value will be non-zero if and only if it has done so.
; 4023 :         The `num_bytes' field shares storage with `layer_wbar'.  It
; 4024 :      identifies the total number of bytes included by the code-block in
; 4025 :      all packets read or written so far.  The value is taken to be 0 if
; 4026 :      the code-block has not yet contributed to any packets (`beta'=0),
; 4027 :      during which time the `layer_wbar' state variable is in use.
; 4028 :         The `up_down' field is used to efficiently navigate the tag-tree
; 4029 :      structure.  When the tag tree is not actually being navigated, the
; 4030 :      field points up to the current node's parent in the tag tree.  The
; 4031 :      root mode is readily identified by the fact that it has a NULL `up_down'
; 4032 :      pointer. During navigation, the tag-tree coder first walks from a
; 4033 :      leaf node up to the root, modifying the `up_down' pointers as it goes
; 4034 :      so that each successive parent's `up_down' field points bacl down to the
; 4035 :      child from which the parent was reached.  The coder then walks back down
; 4036 :      from the root to the original leaf node, restoring the `up_down' fields to
; 4037 :      their original `up' state. */
; 4038 : 
; 4039 : /*****************************************************************************/
; 4040 : /*                             kd_precinct_band                              */
; 4041 : /*****************************************************************************/
; 4042 : 
; 4043 : struct kd_precinct_band {
; 4044 :   /* Used to store state information for an element of the precinct partition
; 4045 :      within a single subband.  Once we get down to precincts and ultimately
; 4046 :      code-blocks, we have to be careful not to waste too much memory, since
; 4047 :      an image may have a very large number of these.  Moreover, it may be
; 4048 :      necessary to maintain tag-trees and other state information even for
; 4049 :      precincts which do not lie within our region of interest, so that the
; 4050 :      relevant packet headers can be parsed -- otherwise, we may have no way
; 4051 :      of knowing how to skip over packets which are not interesting to us. */
; 4052 :     kd_subband *subband;
; 4053 :     kdu_dims block_indices; /* Range of code-block indices for this precinct.
; 4054 :         This is a subset of the `block_indices' specified by the `subband'. */
; 4055 :     kd_block *blocks;
; 4056 :   };
; 4057 :   /* Notes:
; 4058 :      In order to make the representation of this object as efficient as
; 4059 :      possible, the two tag trees and all additional information required to
; 4060 :      correctly parse packet headers is maintained within the code-block
; 4061 :      array itself.  The `blocks' array consists of one element for each
; 4062 :      code-block, organized in raster fashion, plus additional elements to
; 4063 :      represent higher nodes in the tag-tree structure.  See the comments
; 4064 :      associated with the definition of `kd_block' for more information on
; 4065 :      this.
; 4066 :         In practice, the `blocks' array is not allocated separately on the
; 4067 :      heap.  Instead, the block of memory allocated to hold the `kd_precinct'
; 4068 :      structure is augmented by an amount sufficient to hold all of the
; 4069 :      code-blocks for all of the subbands in the precinct.  This is
; 4070 :      accomplished by the custom `kd_precinct::new' operator, which is
; 4071 :      informed of the maximum number of code-blocks required by any precinct
; 4072 :      within the containing `kd_resolution' object.  This value is maintained
; 4073 :      by the `kd_resolution::max_blocks_per_precinct" data member.  The
; 4074 :      `blocks' fields are initialized to the NULL state by the
; 4075 :      `kd_precinct::initialize' member function and are later set to point
; 4076 :      into appropriate locations in the precinct's memory block during
; 4077 :      tag-tree construction. */
; 4078 : 
; 4079 : /*****************************************************************************/
; 4080 : /*                                kd_precinct                                */
; 4081 : /*****************************************************************************/
; 4082 : 
; 4083 :   /* Precincts and all of their subordinate entities (precinct-bands and
; 4084 :      code-blocks) are maintained by a code-stream wide precinct server
; 4085 :      object, which allows for efficient allocation and recycling of the
; 4086 :      memory resources. The constructor is invoked from within the server,
; 4087 :      while the `initialize' and `release' functions are invoked from
; 4088 :      within the `kd_precinct_ref' class which manages references to
; 4089 :      precincts from within the `kd_resolution' object. */
; 4090 : 
; 4091 : // Interpretation of the following flags is given with the `flags' member:
; 4092 : #define KD_PFLAG_GENERATING  0x0001
; 4093 : #define KD_PFLAG_CORRUPTED   0x0002
; 4094 : #define KD_PFLAG_DESEQUENCED 0x0004
; 4095 : #define KD_PFLAG_ADDRESSABLE 0x0008
; 4096 : #define KD_PFLAG_RELEASED    0x0010
; 4097 : #define KD_PFLAG_INACTIVE    0x0020
; 4098 : #define KD_PFLAG_RELEVANT    0x0040
; 4099 : #define KD_PFLAG_SIGNIFICANT 0x0080
; 4100 : #define KD_PFLAG_PARSED      0x0100
; 4101 : 
; 4102 : struct kd_precinct {
; 4103 :   public: // Member functions
; 4104 :     void initialize(kd_resolution *resolution, kdu_coords pos_idx);
; 4105 :       /* Called from within `kd_precinct_ref::open' to configure a newly
; 4106 :          allocated (or recycled) object.  `pos_idx' holds the horizontal and
; 4107 :          vertical position of the precinct (starting from 0) within the array
; 4108 :          of precincts for the relevant resolution level.  Thus, `pos_idx'
; 4109 :          holds a relative index, rather than an absolute index. */
; 4110 :     void activate();
; 4111 :       /* This function is called from within `kd_precinct_ref::open' to
; 4112 :          re-activate a previously released precinct, which has not actually
; 4113 :          been unloaded from memory.  Substantially less work is required in
; 4114 :          this case, and the function must be careful to respect the current
; 4115 :          contents of the precinct's code-blocks.  The function sets the
; 4116 :          `num_required_layers' field for this activation (may change between
; 4117 :          successive `kd_tile::open' calls) and also sets the
; 4118 :          `num_outstanding_blocks' field to the total number of code-blocks
; 4119 :          which lie within the current region of interest. */
; 4120 :     void closing();
; 4121 :       /* Called from within `kd_precinct_ref::close' immediately prior to
; 4122 :          recycling the storage associated with the precinct, its precinct-bands
; 4123 :          and their code-blocks.  This function should release any resources
; 4124 :          which are specific to this particular precinct.  These resources
; 4125 :          include any non-NULL `layer_bytes' array and any code-byte buffers.
; 4126 :          Note that the `kd_precinct_ref::close' function may be called
; 4127 :          indirectly while opening a different precinct, if the current
; 4128 :          precinct has already been released.  This enables open calls to
; 4129 :          deal with resource limitations by unloading precincts which are not
; 4130 :          currently active. */
; 4131 :     void release()
; 4132 :       /* Used only for input codestream objects, this function is called once
; 4133 :          all code-blocks within the current region of interest have been
; 4134 :          consumed.  The function sets `num_outstanding_blocks' to 0, although
; 4135 :          in most cases this function will be called because
; 4136 :          `num_outstanding_blocks' has just become 0 (only exception is when
; 4137 :          a tile is being closed).  Also sets `released' to true.  If the
; 4138 :          KD_PFLAG_DESEQUENCED flag is false, the function returns without
; 4139 :          modifying the precinct in any other way.
; 4140 :             The `kd_precinct_ref::release' function is called to formally
; 4141 :          release the precinct's resources (this might not unload them from
; 4142 :          memory) if the codestream mode is non-persistent or if the precinct
; 4143 :          is addressable.  In the latter case, the precinct's contents can
; 4144 :          be reloaded from the compressed source if necessary.
; 4145 :             This function shall not be used with codestream objects
; 4146 :          opened for output or for interchange (no compressed data source and
; 4147 :          no compressed data target). */
; 4148 :       {
; 4149 :         assert(resolution->codestream->in != NULL);
; 4150 :         num_outstanding_blocks = 0;
; 4151 :         flags |= KD_PFLAG_RELEASED;
; 4152 :           // released = true;
; 4153 :         if ((flags & KD_PFLAG_ADDRESSABLE) ||
; 4154 :             ((flags & KD_PFLAG_DESEQUENCED) &&
; 4155 :                 // if (addressable ||
; 4156 :                 //     (desequenced &&
; 4157 :              !resolution->codestream->persistent))
; 4158 :           ref->release(); // May unload us from memory!
; 4159 :       }
; 4160 :     void finished_desequencing()
; 4161 :       /* Called once we can be sure that no more packets will be available
; 4162 :          for this precinct.  In practice, the function is called when the
; 4163 :          last packet has been desequenced or when the containing tile has
; 4164 :          been completely read.  If no packets at all have been desequenced for
; 4165 :          the precinct when this function is called (must have been invoked
; 4166 :          from within `kd_tile::finished_reading'), the precinct is marked
; 4167 :          as addressable, with an address of 0.  This is because it is safe
; 4168 :          to unload such a precinct and then reload it again regardless of
; 4169 :          the services offered by the compressed data source -- there is no
; 4170 :          data actually available from the compressed source for the
; 4171 :          precinct anyway, so reloading is a no-op.
; 4172 :             It should be noted that this function may unload the precinct
; 4173 :          from memory if it is determined that all code-blocks in the
; 4174 :          region of interest (there may be none) have already been consumed. */
; 4175 :       {
; 4176 :         if (flags & KD_PFLAG_DESEQUENCED)
; 4177 :           return;
; 4178 :         flags |= KD_PFLAG_DESEQUENCED;
; 4179 :           // desequenced = true;
; 4180 :         if (next_layer_idx == 0)
; 4181 :           {
; 4182 :             flags |= KD_PFLAG_ADDRESSABLE;
; 4183 :               // addressable = true;
; 4184 :             unique_address = 0;
; 4185 :           }
; 4186 :         if (num_outstanding_blocks == 0)
; 4187 :           release();
; 4188 :       }
; 4189 :     bool desequence_packet()
; 4190 :       /* This function should be called when a non-NULL `kd_precinct_ref'
; 4191 :          pointer is returned by `kd_packet_sequencer::next_in_sequence' and
; 4192 :          its `kd_precinct_ref::is_sequenced' function returns false.
; 4193 :          The function invokes `read_packet' and, if successful, increments
; 4194 :          the precinct's `next_layer_idx' field and the containing tile's
; 4195 :          `num_sequenced_packets' field.
; 4196 :             The function returns false if `read_packet' returns false,
; 4197 :          in which case, more tile-parts must be read (if there are any) to
; 4198 :          recover the information required to desequence the packet.
; 4199 :             Before returning true, the function checks to see whether all
; 4200 :          packets for the tile have been sequenced.  If so, the tile's
; 4201 :          `finished_reading' function is called. */
; 4202 :       {
; 4203 :         kd_tile *tile = resolution->tile_comp->tile;
; 4204 :         assert(!(flags & (KD_PFLAG_DESEQUENCED | KD_PFLAG_ADDRESSABLE)));
; 4205 :         if (!read_packet()) return false;
; 4206 :         next_layer_idx++;
; 4207 :         if (next_layer_idx == tile->num_layers)
; 4208 :           finished_desequencing();
; 4209 :         tile->next_input_packet_num++;
; 4210 :         if ((flags & KD_PFLAG_RELEVANT) &&
; 4211 :             (next_layer_idx <= tile->max_relevant_layers))
; 4212 :           {
; 4213 :             tile->sequenced_relevant_packets++;
; 4214 :             if (tile->sequenced_relevant_packets==tile->max_relevant_packets)
; 4215 :               tile->finished_reading();
; 4216 :           }
; 4217 :         return true;
; 4218 :       }
; 4219 :     void load_required_packets()
; 4220 :       /* If the precinct is addressable, this function uses its
; 4221 :          `unique_address' to position the compressed data source at the
; 4222 :          beginning of the precinct's first packet; it then loads all required
; 4223 :          packets from the compressed source.  Otherwise, the function does
; 4224 :          nothing at all -- reading is presumed to have occurred during packet
; 4225 :          desequencing. */
; 4226 :       {
; 4227 :         if ((!(flags & KD_PFLAG_ADDRESSABLE)) ||
; 4228 :             (unique_address == 0) || (num_packets_read != 0))
; 4229 :           return;
; 4230 :         assert((flags & KD_PFLAG_DESEQUENCED) &&
; 4231 :                (next_layer_idx >= required_layers));
; 4232 :         resolution->codestream->in->seek(unique_address);
; 4233 :         while (num_packets_read < required_layers)
; 4234 :           if (!read_packet())
; 4235 :             break;
; 4236 :       }
; 4237 :     kdu_long simulate_packet(kdu_long &header_bytes,
; 4238 :                              int layer_idx, kdu_uint16 slope_threshold,
; 4239 :                              bool finalize_layer, bool last_layer,
; 4240 :                              kdu_long max_bytes=KDU_LONG_HUGE,
; 4241 :                              bool trim_to_limit=false);
; 4242 :       /* Implements the functionality of `kd_codestream::simulate_output'
; 4243 :          for a single precinct.  Note that the total number of packet bytes
; 4244 :          is left behind in the internal `layer_bytes' array.  This allows the
; 4245 :          determination of tile-part length fields later on when we come to
; 4246 :          construct the code-stream.  The function returns this total number
; 4247 :          of bytes.  It also returns the number of packet header bytes via
; 4248 :          `header_bytes' (the function return value includes the cost of these
; 4249 :          header bytes).
; 4250 :             If the `max_bytes' limit is exceeded, the function may return
; 4251 :          prematurely, without having completed the simulation.  This is
; 4252 :          unacceptable when finalizing a layer, so you must be sure that
; 4253 :          `max_bytes' is sufficient in that case.
; 4254 :             If `trim_to_limit' is true, `finalize_layer' and `last_layer'
; 4255 :          must also both be true.  The function then trims away all coding
; 4256 :          passes from the precinct's code-blocks which are associated with
; 4257 :          slope values of `slope_threshold'+1 or less, until the limit
; 4258 :          associated with `max_bytes' is satisfied.  This functionality is
; 4259 :          used to implement the `sloppy_bytes' capabilities advertised by the
; 4260 :          `kd_codestream::simulate_output' function. */
; 4261 :     kdu_long write_packet(kdu_uint16 slope_threshold, bool empty_packet=false);
; 4262 :       /* Writes out the next packet for this precinct, using the supplied
; 4263 :          distortion-length slope threshold.  Increments the `next_layer_idx'
; 4264 :          field as well as the containing tile's `num_sequenced_packets'
; 4265 :          field when done.  If `empty_packet' is true, an empty packet should
; 4266 :          be issued, having a length of 1 byte, plus the length of any required
; 4267 :          EPH marker (no SOP marker will be attached to empty packets).  The
; 4268 :          function returns the total number of bytes output for the packet. */
; 4269 :   private: // Member functions
; 4270 :     bool read_packet();
; 4271 :       /* Reads a new layer of this precinct sequentially from the
; 4272 :          compressed data source, incrementing the `num_packets_read' member.
; 4273 :          Note that packet reading may be interleaved with acesses to the
; 4274 :          precinct's code-blocks for various reasons.  For example, we
; 4275 :          may initially open a tile with only a limited number of required
; 4276 :          layers, using its code-block data to decompress an approximate
; 4277 :          representation of the image.  We may then find that the additional
; 4278 :          packets need to be loaded in order to advance to other precincts
; 4279 :          in the code-stream.
; 4280 :             The function returns false if an SOT marker (or an EOC marker) is
; 4281 :          encountered.  Note that when an SOT marker is encountered, its
; 4282 :          segment is fully read into the codestream marker service and the
; 4283 :          precinct's tile must be active (otherwise an error message will be
; 4284 :          generated).  Before returning false in this way, the function sets
; 4285 :          the `active_tile' pointer in the codestream object to NULL.  The
; 4286 :          caller may determine the cause of failure by invoking the codestream
; 4287 :          marker service's `get_code' function, which will return one of SOT,
; 4288 :          EOC or 0, where 0 occurs only if the code-stream has been
; 4289 :          exhausted. */
; 4290 :     bool handle_corrupt_packet();
; 4291 :       /* This function implements alternate processing for the `read_packet'
; 4292 :          function in the event that a packet is found to be corrupt.  It is
; 4293 :          called whenever packet corruption is detected, including when the
; 4294 :          precinct is known to have had previously corrupt packets. The function
; 4295 :          manipulates the containing tile's `skipping_to_sop' and
; 4296 :          `next_sop_sequence_num' fields, advancing to the next SOP or SOT
; 4297 :          marker if necessary (the function may be called after detecting an
; 4298 :          SOP marker already, whose sequence number is not as expected).  If
; 4299 :          an SOT marker is encountered, the function renders the current tile
; 4300 :          inactive and returns false (this is the behaviour expected of
; 4301 :          `read_packet').  Otherwise, it updates the precinct and tile state to
; 4302 :          identify the packet as having been read. */
; 4303 :   public: // Public Links and Identification
; 4304 :     kd_resolution *resolution;
; 4305 :     kd_precinct_ref *ref; // Element of `resolution->precinct_refs' array
; 4306 : 
; 4307 :   public: // Mode flags used for decompression and/or interchange
; 4308 :     int flags; // The following flags are defined.
; 4309 :        // KD_PFLAG_GENERATING -- after 1'st call to `kd_precinct::get_packets'
; 4310 :        // KD_PFLAG_CORRUPTED -- if error occurred during packet reading
; 4311 :        // KD_PFLAG_DESEQUENCED -- if all packets have been desequenced
; 4312 :        // KD_PFLAG_ADDRESSABLE -- if seekable, cached or used for interchange
; 4313 :        // KD_PFLAG_RELEASED -- if `activate' must be called to revive state
; 4314 :        // KD_PFLAG_INACTIVE -- if resides on `kd_precict_server's inactive list
; 4315 :        // KD_PFLAG_RELEVANT -- always true if codestream is for non-persistent
; 4316 :        //     input; otherwise, true only if precinct belongs to the relevant
; 4317 :        //     set of precincts of a relevant tile-component-resolution
; 4318 :        // KD_PFLAG_SIGNIFICANT -- if any code-block bytes have been generated
; 4319 :        //     by `kdu_precinct::size_packets' or `kdu_precinct::get_packets'
; 4320 :        // KD_PFLAG_PARSED -- if the precinct was parsed previously and then
; 4321 :        //     unloaded; prevents multiple accumulation of packet length stats
; 4322 :   public: // State variables
; 4323 :     int required_layers; /* Actual number of layers for output codestream;
; 4324 :                 max apparent layers for input or interchange codestream. */
; 4325 :     int next_layer_idx; // Next layer to be sequenced or generated.
; 4326 :     union { // First field used for input; second interchange; third for output
; 4327 :         int num_packets_read; // Incremented when packets read or interchanged
; 4328 :         int cumulative_bytes; // Size of all packets generated so far.
; 4329 :         int saved_next_layer_idx; // Used by "kd_packet_sequencer::save_state"
; 4330 :       };
; 4331 : 
; 4332 :   public: // Activation state variables
; 4333 :     int num_outstanding_blocks; // See notes below.
; 4334 :     union { // First field used only in reading; second only in writing.
; 4335 :         kdu_long unique_address; // See below
; 4336 :         kdu_long *packet_bytes; // Lengths generated during simulated output
; 4337 :       };
; 4338 :   public: // code-block containers
; 4339 :     kd_precinct_band *subbands; // In practice, this member points into the
; 4340 :        // same block of memory which is allocated to hold the precinct so
; 4341 :        // as to encourage memory locality and allow for manipulation of all
; 4342 :        // aspects of a precinct, including all of its code-blocks, via a
; 4343 :        // single heap block.  Note that the number of entries in this array
; 4344 :        // is given by `resolution->num_subbands'.
; 4345 : 
; 4346 :   public: // See below for an explanation of these links
; 4347 :     kd_precinct *next; // Next in free, inactive or generated list
; 4348 :     kd_precinct *prev; // Previous in inactive or generated list
; 4349 :     kd_precinct_size_class *size_class; // For correctly releasing storage
; 4350 :   };
; 4351 :   /* Notes:
; 4352 :         `unique_address' is valid if and only if the precinct is marked as
; 4353 :      addressable, meaning that the precinct has a unique address from which it
; 4354 :      may be loaded (for input codestream objects) or identified (for
; 4355 :      interchange codestream objects).  If addressable, the `unique_address'
; 4356 :      will be 0 if and only if the precinct is known to be empty, meaning that
; 4357 :      reloading the precinct does not require any actual data transfers from a
; 4358 :      compressed data source.
; 4359 :         Except as described above, when used with seekable compressed data
; 4360 :      sources, the `unique_address' member holds a positive quantity which
; 4361 :      identifies an offset into the code-stream at which the precinct's
; 4362 :      packets may be found.  In the case of cached sources (those advertising
; 4363 :      the KDU_SOURCE_CAP_CACHED capability) or codestream objects created for
; 4364 :      interchange (no compressed data source or target), the `unique_address'
; 4365 :      will be negative and -(1+`unique_address') is the precinct's unique
; 4366 :      identifier, as passed to the `kdu_compressed_source::set_precinct_scope'
; 4367 :      function, or returned by the `kdu_precinct::get_unique_id' function.
; 4368 :         The `num_outstanding_blocks' member is used to monitor the number of
; 4369 :      code-blocks from the application's region of interest which have still
; 4370 :      to be consumed (input codestreams) or the number of code-blocks which
; 4371 :      have still to be written in order to complete the precinct (output
; 4372 :      and interchange codestreams).
; 4373 :         The `next' and `prev' links may be used to manage the precinct's
; 4374 :      location in one of three different lists.  The first list is the
; 4375 :      singly-linked free list maintained by `kd_precinct_size_class', from
; 4376 :      which the `kd_precinct_server' object re-issues previously released
; 4377 :      resources.
; 4378 :         The second list on which this structure may find itself is the
; 4379 :      doubly-linked list of currently inactive precincts, which is managed by
; 4380 :      the `kd_precinct_server' object.  Precincts which find themselves on this
; 4381 :      list have been released, but their resources have not yet been recycled.
; 4382 :      They may be successfully re-activated, if their resources have not been
; 4383 :      re-issued to another precinct.  Precincts on this list may be identified
; 4384 :      by the `inactive' flag.  Every inactive precinct necessarily also has
; 4385 :      its `released' member set to true, but the converse is not necessarily
; 4386 :      true.  This is because precincts which have been partially parsed
; 4387 :      in a context for which they were not directly relevant, will be marked
; 4388 :      as released, even though they are not inactive.
; 4389 :         The third list on which this structure may find itself is the
; 4390 :      doubly-linked list of generated precincts managed by the
; 4391 :      `kd_global_rescomp' structure.  This list contains all precincts
; 4392 :      from a given resolution of a given image component, across all tiles,
; 4393 :      which have been fully generated, but not yet flushed out to the
; 4394 :      code-stream.   The list is used to manage incremental rate allocation
; 4395 :      when processing large images.  Elements on this list have not yet
; 4396 :      been closed. */
; 4397 : 
; 4398 : /*****************************************************************************/
; 4399 : /*                         kd_precinct_size_class                            */
; 4400 : /*****************************************************************************/
; 4401 : 
; 4402 :   /* For an explanation of the role played by precinct size classes, see
; 4403 :      the discussion appearing below the declaration of `kd_precinct_server'. */
; 4404 : 
; 4405 : class kd_precinct_size_class {
; 4406 :   public: // Member functions
; 4407 :     kd_precinct_size_class(int max_blocks, int num_subbands,
; 4408 :                            kd_precinct_server *server,
; 4409 :                            kd_buf_server *buf_server)
; 4410 :       {
; 4411 :         this->max_blocks = max_blocks;
; 4412 :         this->num_subbands = num_subbands;
; 4413 :         this->server = server;  this->buf_server = buf_server;
; 4414 :         total_precincts = 0; free_list = NULL; next = NULL;
; 4415 :         alloc_bytes = (int) sizeof(kd_precinct);
; 4416 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4417 :         alloc_bytes += num_subbands * (int) sizeof(kd_precinct_band);
; 4418 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4419 :         alloc_bytes += 4 + max_blocks * (int) sizeof(kd_block);
; 4420 :       }
; 4421 :     ~kd_precinct_size_class()
; 4422 :       { kd_precinct *tmp;
; 4423 :         while ((tmp=free_list) != NULL)
; 4424 :           { free_list = tmp->next; free(tmp); total_precincts--; }
; 4425 :         assert(total_precincts == 0);
; 4426 :       }
; 4427 :     kd_precinct *get()
; 4428 :       {
; 4429 :         if (free_list == NULL)
; 4430 :           augment_free_list();
; 4431 :         kd_precinct *result = free_list; free_list = free_list->next;
; 4432 :         result->next = result->prev = NULL;
; 4433 :         buf_server->augment_structure_bytes(alloc_bytes);
; 4434 :         return result;
; 4435 :       }
; 4436 :     void release(kd_precinct *precinct)
; 4437 :       {
; 4438 :         if (precinct->flags & KD_PFLAG_INACTIVE)

	je	SHORT $LN50@restart

; 4439 :           withdraw_from_inactive_list(precinct);

	push	edi
	mov	ecx, edx
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list
	mov	edx, DWORD PTR _this$1$[ebp]
$LN50@restart:

; 4440 :         precinct->next = free_list;

	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [edi+44], eax

; 4442 :         buf_server->augment_structure_bytes(-alloc_bytes);

	mov	ecx, DWORD PTR [edx+4]

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	mov	eax, DWORD PTR [edx+16]

; 4441 :         free_list = precinct;

	mov	DWORD PTR [edx+32], edi

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	neg	eax

; 4442 :         buf_server->augment_structure_bytes(-alloc_bytes);

	cdq

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	add	DWORD PTR [ecx+32], eax

; 281  :         if (structure_bytes > peak_structure_bytes)

	mov	eax, DWORD PTR [ecx+32]
	adc	DWORD PTR [ecx+36], edx
	mov	edx, DWORD PTR [ecx+36]
	cmp	edx, DWORD PTR [ecx+44]
	jl	SHORT $LN85@restart
	jg	SHORT $LN83@restart
	cmp	eax, DWORD PTR [ecx+40]
	jbe	SHORT $LN85@restart
$LN83@restart:

; 282  :           peak_structure_bytes = structure_bytes;

	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+44], edx
$LN85@restart:
	mov	edx, DWORD PTR _idx$1$[ebp]
$LN53@restart:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1591 :             for (idx.x=0; idx.x < res->precinct_indices.size.x; idx.x++)

	mov	eax, DWORD PTR _idx$2$[ebp]
	mov	ecx, DWORD PTR _res$1$[ebp]
	inc	eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4678 :   state = 0;

	mov	DWORD PTR [ebx+esi*8], 0
	mov	DWORD PTR [ebx+esi*8+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1591 :             for (idx.x=0; idx.x < res->precinct_indices.size.x; idx.x++)

	mov	DWORD PTR _idx$2$[ebp], eax
	cmp	eax, DWORD PTR [ecx+148]
	jl	$LL19@restart
$LN14@restart:

; 1587 :             }
; 1588 : 
; 1589 :           kdu_coords idx;
; 1590 :           for (idx.y=0; idx.y < res->precinct_indices.size.y; idx.y++)

	inc	edx
	mov	DWORD PTR _idx$1$[ebp], edx
	cmp	edx, DWORD PTR [ecx+144]
	jl	$LL16@restart
	mov	ebx, DWORD PTR _comp$1$[ebp]
$LN5@restart:

; 1569 :       for (int r=0; r <= comp->dwt_levels; r++)

	mov	eax, DWORD PTR _r$1$[ebp]
	mov	edx, DWORD PTR tv689[ebp]
	inc	eax
	add	edx, 604				; 0000025cH
	mov	DWORD PTR _r$1$[ebp], eax
	mov	DWORD PTR tv689[ebp], edx
	cmp	eax, DWORD PTR [ebx+56]
	jle	$LL7@restart
	mov	eax, DWORD PTR _c$1$[ebp]
$LN2@restart:

; 1557 :   skipping_to_sop = false;
; 1558 :   next_input_packet_num = next_sop_sequence_num = 0;
; 1559 : 
; 1560 :   for (int c=0; c < num_components; c++)

	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	inc	eax
	mov	ecx, DWORD PTR tv688[ebp]
	add	ecx, 188				; 000000bcH
	mov	DWORD PTR _c$1$[ebp], eax
	mov	DWORD PTR tv688[ebp], ecx
	cmp	eax, DWORD PTR [ebx+128]
	jl	$LL4@restart
	pop	edi
$LN3@restart:

; 1594 :                   idx.y*res->precinct_indices.size.x;
; 1595 :                 ref->clear();
; 1596 :               }
; 1597 :         }
; 1598 :     }
; 1599 : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	pop	esi
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?restart@kd_tile@@QAEXXZ ENDP				; kd_tile::restart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z
_TEXT	SEGMENT
$T2 = -208						; size = 16
_w$3 = -192						; size = 20
$T4 = -188						; size = 16
$T5 = -172						; size = 16
$T6 = -156						; size = 16
$T7 = -140						; size = 16
_rgn$2$ = -124						; size = 4
_min$8 = -120						; size = 8
_qcd$2$ = -116						; size = 4
$T9 = -116						; size = 4
$T10 = -116						; size = 4
_eps$11 = -112						; size = 4
$T12 = -112						; size = 4
_r$1$ = -108						; size = 4
_cumulative_subbands$1$ = -104				; size = 4
tv2337 = -100						; size = 4
tv2336 = -96						; size = 4
_b$1$ = -92						; size = 4
_base_delta$13 = -88					; size = 4
_roi_levels$14 = -84					; size = 4
_e$15 = -80						; size = 20
_w$16 = -80						; size = 20
_w$17 = -80						; size = 20
_e$18 = -80						; size = 20
tv2333 = -60						; size = 4
_c$2$ = -56						; size = 4
_qcc$1$ = -52						; size = 4
_res$1$ = -48						; size = 4
_c$1$ = -48						; size = 4
_new_structure_bytes$2$ = -44				; size = 4
_new_structure_bytes$1$ = -40				; size = 4
_this$1$ = -36						; size = 4
_r$1$ = -32						; size = 4
_kmax$19 = -32						; size = 4
_old_num_precincts$2$ = -28				; size = 4
_band$1$ = -28						; size = 4
_node$1$ = -28						; size = 4
_lim$1$ = -28						; size = 4
tv2334 = -28						; size = 4
_read_failure$1$ = -21					; size = 1
_rgc$1$ = -20						; size = 4
tv2345 = -20						; size = 4
_delta$2$ = -16						; size = 4
_branch_x$1$ = -16					; size = 4
_branch_x$1$ = -16					; size = 4
_delta$20 = -16						; size = 4
__$EHRec$ = -12						; size = 12
_num_precincts$2$ = 8					; size = 4
$T21 = 8						; size = 4
_branch_x$1$ = 8					; size = 4
_tref$ = 8						; size = 4
_b$2$ = 11						; size = 1
_b$1$ = 11						; size = 1
_derived_quant$22 = 11					; size = 1
_idx$ = 12						; size = 8
_dims$ = 20						; size = 16
?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z PROC ; kd_tile::recycle, COMDAT
; _this$ = ecx

; 1220 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 196				; 000000c4H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	DWORD PTR _this$1$[ebp], ecx

; 1221 :   assert(structure_bytes == 0);
; 1222 : 
; 1223 :   // Start by reproducing initialization steps from the constructor, which
; 1224 :   // would have been done for new tiles, but do not damage the existing
; 1225 :   // structures.
; 1226 :   assert((tile_ref == NULL) && (t_num < 0) && is_typical);
; 1227 :   this->tile_ref = tref;
; 1228 :   this->t_idx = idx;

	mov	esi, DWORD PTR _idx$[ebp]
	mov	eax, DWORD PTR _tref$[ebp]
	mov	edx, DWORD PTR _idx$[ebp+4]

; 1229 :   this->t_num = idx.x + idx.y*codestream->tile_span.x;
; 1230 :   this->dims = dims;

	movups	xmm0, XMMWORD PTR _dims$[ebp]
	mov	DWORD PTR [ecx+16], eax
	mov	DWORD PTR [ecx+8], esi
	mov	DWORD PTR [ecx+12], edx
	mov	ecx, DWORD PTR [ecx]

; 1231 : 
; 1232 :   region.size = kdu_coords(0,0);
; 1233 :   typical_next = NULL;
; 1234 :   assert((ppt_markers == NULL) && (packed_headers == NULL) &&
; 1235 :          (sequencer == NULL) && (unloadable_next == NULL) &&
; 1236 :          (unloadable_prev == NULL));
; 1237 :   initialized = is_open = is_unloadable = closed = exhausted = false;
; 1238 :   needs_reinit = empty_shell = false;
; 1239 :   num_tparts = next_tpart = sequenced_relevant_packets = 0;
; 1240 :   skipping_to_sop = false;
; 1241 :   next_input_packet_num = next_sop_sequence_num = 0;
; 1242 : 
; 1243 :   // Now reproduce the relevant steps from `initialize', determining as
; 1244 :   // soon as possible whether or not we need to destroy the structure and
; 1245 :   // start from scratch.
; 1246 :   assert(num_components == codestream->num_components);
; 1247 :   bool read_failure = false;

	mov	BYTE PTR _read_failure$1$[ebp], 0
	mov	eax, DWORD PTR [ecx+168]
	imul	eax, esi
	mov	esi, DWORD PTR _this$1$[ebp]
	add	eax, edx
	mov	DWORD PTR [esi+184], 0
	mov	DWORD PTR [esi+4], eax
	movups	XMMWORD PTR [esi+160], xmm0
	mov	DWORD PTR [esi+188], 0
	mov	DWORD PTR [esi+40], 0
	mov	BYTE PTR [esi+268], 0
	mov	WORD PTR [esi+232], 0
	mov	WORD PTR [esi+229], 0
	mov	BYTE PTR [esi+227], 0
	mov	BYTE PTR [esi+234], 0
	mov	DWORD PTR [esi+248], 0
	mov	DWORD PTR [esi+244], 0
	mov	DWORD PTR [esi+240], 0
	mov	BYTE PTR [esi+256], 0
	mov	DWORD PTR [esi+260], 0
	mov	DWORD PTR [esi+252], 0

; 1248 :   if (codestream->in != NULL)

	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	je	SHORT $LN258@recycle
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 656  :       { return source->get_capabilities(); }

	mov	ecx, DWORD PTR [ecx+540]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1250 :       if (codestream->in->get_capabilities() & KDU_SOURCE_CAP_SEEKABLE)

	test	al, 2
	je	SHORT $LN29@recycle

; 1251 :         precinct_pointer_server.initialize(codestream->buf_server);

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR [esi+56]
	push	DWORD PTR [eax+24]
	call	?initialize@kd_precinct_pointer_server@@QAEXPAVkd_buf_server@@@Z ; kd_precinct_pointer_server::initialize
$LN29@recycle:

; 1252 :       tpart_ptrs = tile_ref->tpart_head;

	mov	eax, DWORD PTR [esi+16]

; 1253 :       read_failure = !read_tile_part_header();

	mov	ecx, esi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+20], eax
	call	?read_tile_part_header@kd_tile@@QAE_NXZ	; kd_tile::read_tile_part_header
	test	al, al
	sete	al
	mov	BYTE PTR _read_failure$1$[ebp], al

; 1254 :     }
; 1255 : 
; 1256 :   if (!read_failure)

	test	al, al
	jne	$LN33@recycle
$LN258@recycle:

; 1257 :     {
; 1258 :       if (fully_typical && !codestream->siz->check_typical_tile(t_num))

	cmp	BYTE PTR [esi+125], 0
	je	SHORT $LN31@recycle
	mov	ecx, DWORD PTR [esi]
	push	0
	push	DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+12]
	call	?check_typical_tile@kdu_params@@QAE_NHPBD@Z ; kdu_params::check_typical_tile
	test	al, al
	jne	SHORT $LN31@recycle

; 1259 :         fully_typical = false;

	mov	BYTE PTR [esi+125], al
$LN31@recycle:

; 1260 :       if (is_typical && !fully_typical)

	cmp	BYTE PTR [esi+124], 0
	je	SHORT $LN274@recycle
	cmp	BYTE PTR [esi+125], 0
	jne	SHORT $LN32@recycle

; 1261 :         is_typical =

	mov	ecx, DWORD PTR [esi]
	push	OFFSET ??_C@_07HDMBGKJA@QCD?3RGN?$AA@
	push	DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [ecx+12]
	call	?check_typical_tile@kdu_params@@QAE_NHPBD@Z ; kdu_params::check_typical_tile
	mov	BYTE PTR [esi+124], al
$LN32@recycle:

; 1262 :           codestream->siz->check_typical_tile(t_num,
; 1263 :                                               (QCD_params ":" RGN_params));
; 1264 :       if (!is_typical)

	cmp	BYTE PTR [esi+124], 0
	jne	$LN33@recycle
$LN274@recycle:

; 1265 :         { // Need to initialize from scratch
; 1266 :           if (comps != NULL)

	mov	eax, DWORD PTR [esi+208]
	test	eax, eax
	je	SHORT $LN65@recycle
	push	OFFSET ??1kd_tile_comp@@QAE@XZ		; kd_tile_comp::~kd_tile_comp
	push	DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	188					; 000000bcH
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	imul	eax, DWORD PTR [esi], 188
	add	eax, 4
	push	eax
	push	esi
	call	??_V@YAXPAXI@Z				; operator delete[]
	mov	esi, DWORD PTR _this$1$[ebp]
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN65@recycle:

; 1269 :           while ((mct_tail = mct_head) != NULL)

	mov	eax, DWORD PTR [esi+200]
	mov	DWORD PTR [esi+208], 0
	mov	DWORD PTR [esi+204], eax
	test	eax, eax
	je	$LN3@recycle
	npad	8
$LL2@recycle:

; 1270 :             {
; 1271 :               mct_head = mct_tail->next_stage;

	mov	edi, DWORD PTR [esi+204]
	mov	eax, DWORD PTR [edi+36]
	mov	DWORD PTR [esi+200], eax

; 1272 :               delete mct_tail;

	test	edi, edi
	je	SHORT $LN67@recycle
	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2136 :         if (input_required_indices != NULL)

	mov	eax, DWORD PTR [edi+8]
	test	eax, eax
	je	SHORT $LN97@recycle

; 2137 :           delete[] input_required_indices;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN97@recycle:

; 2138 :         if (output_comp_info != NULL) delete[] output_comp_info;

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN98@recycle
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN98@recycle:

; 2139 :         if (blocks != NULL) delete[] blocks;

	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN107@recycle
	push	OFFSET ??1kd_mct_block@@QAE@XZ		; kd_mct_block::~kd_mct_block
	push	DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]
	mov	BYTE PTR __$EHRec$[ebp+8], 3
	push	108					; 0000006cH
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	imul	eax, DWORD PTR [esi], 108
	add	eax, 4
	push	eax
	push	esi
	call	??_V@YAXPAXI@Z				; operator delete[]
	mov	esi, DWORD PTR _this$1$[ebp]
	add	esp, 8
$LN107@recycle:
	push	40					; 00000028H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN67@recycle:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1269 :           while ((mct_tail = mct_head) != NULL)

	mov	eax, DWORD PTR [esi+200]
	mov	DWORD PTR [esi+204], eax
	test	eax, eax
	jne	$LL2@recycle
$LN3@recycle:

; 1273 :             }
; 1274 :           initialized = true; // Make sure `initialize' does not call
; 1275 :                               // `read_tile_part_header' again
; 1276 :           insert_plt_segments = false;
; 1277 :           resolution_tparts = component_tparts = layer_tparts = false;
; 1278 :           initialize();

	mov	ecx, esi
	mov	BYTE PTR [esi+233], 1
	mov	DWORD PTR [esi+235], 0
	call	?initialize@kd_tile@@QAEXXZ		; kd_tile::initialize

; 1525 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
$LN33@recycle:

; 1279 :           return;
; 1280 :         }
; 1281 :     }
; 1282 : 
; 1283 :   // If we get here, we are able to recycle a typical tile
; 1284 :   num_apparent_layers = num_layers;

	mov	eax, DWORD PTR [esi+132]

; 1285 : 
; 1286 :   // Visit tile-components
; 1287 :   int c;
; 1288 :   kd_tile_comp *tc = comps;
; 1289 :   this->total_precincts = 0;
; 1290 :   kdu_long new_structure_bytes = (int) sizeof(*this);

	xor	ebx, ebx
	mov	ecx, 272				; 00000110H
	mov	DWORD PTR [esi+136], eax
	mov	eax, DWORD PTR [esi+208]
	mov	DWORD PTR [esi+144], 0
	mov	DWORD PTR [esi+148], 0
	mov	DWORD PTR _new_structure_bytes$1$[ebp], ecx
	mov	DWORD PTR _new_structure_bytes$2$[ebp], ebx

; 1291 :   for (c=0; c < num_components; c++, tc++)

	mov	DWORD PTR _c$1$[ebp], ebx
	cmp	DWORD PTR [esi+128], ebx
	jle	$LN5@recycle

; 1279 :           return;
; 1280 :         }
; 1281 :     }
; 1282 : 
; 1283 :   // If we get here, we are able to recycle a typical tile
; 1284 :   num_apparent_layers = num_layers;

	lea	edx, DWORD PTR [eax+153]
	mov	DWORD PTR tv2345[ebp], edx
	npad	8
$LL6@recycle:

; 1296 : 
; 1297 :       tc->enabled = true;
; 1298 :       tc->is_of_interest = true;
; 1299 :       tc->G_tc_restricted = -1.0F; // Need to regenerate this if needed
; 1300 :       subs = tc->sub_sampling;

	mov	esi, DWORD PTR [edx-133]
	add	ecx, 188				; 000000bcH
	mov	WORD PTR [edx-1], 257			; 00000101H
	mov	DWORD PTR [edx-29], -1082130432		; bf800000H
	adc	ebx, 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	eax, DWORD PTR _dims$[ebp+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1295 :       new_structure_bytes += (int) sizeof(*tc);

	mov	DWORD PTR _new_structure_bytes$1$[ebp], ecx

; 1301 :       min = dims.pos; lim = min + dims.size;

	mov	ecx, DWORD PTR _dims$[ebp+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	eax, ecx
	mov	DWORD PTR $T21[ebp], eax
	mov	eax, DWORD PTR _dims$[ebp+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1295 :       new_structure_bytes += (int) sizeof(*tc);

	mov	DWORD PTR _new_structure_bytes$2$[ebp], ebx

; 1301 :       min = dims.pos; lim = min + dims.size;

	mov	ebx, DWORD PTR _dims$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	eax, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1301 :       min = dims.pos; lim = min + dims.size;

	mov	DWORD PTR _min$8[ebp+4], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	DWORD PTR _lim$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	ecx, ecx
	jg	SHORT $LN121@recycle

; 180  :     return -((-num)/den);

	mov	eax, ecx
	cdq
	idiv	esi
	mov	edi, eax
	jmp	SHORT $LN122@recycle
$LN121@recycle:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ecx-1]
	cdq
	idiv	esi
	lea	edi, DWORD PTR [eax+1]
$LN122@recycle:

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR $T21[ebp]
	test	eax, eax
	jg	SHORT $LN125@recycle

; 180  :     return -((-num)/den);

	cdq
	idiv	esi
	mov	ecx, eax
	jmp	SHORT $LN126@recycle
$LN125@recycle:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	esi
	lea	ecx, DWORD PTR [eax+1]
$LN126@recycle:

; 180  :     return -((-num)/den);

	mov	esi, DWORD PTR tv2345[ebp]
	test	ebx, ebx
	jg	SHORT $LN129@recycle
	mov	eax, ebx
	mov	ebx, DWORD PTR [esi-137]
	cdq
	idiv	ebx
	mov	esi, eax
	jmp	SHORT $LN130@recycle
$LN129@recycle:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ebx-1]
	mov	ebx, DWORD PTR [esi-137]
	cdq
	idiv	ebx
	lea	esi, DWORD PTR [eax+1]
$LN130@recycle:

; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _lim$1$[ebp]
	test	eax, eax
	jg	SHORT $LN133@recycle

; 180  :     return -((-num)/den);

	cdq
	idiv	ebx
	jmp	SHORT $LN134@recycle
$LN133@recycle:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	ebx
	inc	eax
$LN134@recycle:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1304 :       tc->dims.pos = min; tc->dims.size = lim - min;

	mov	edx, DWORD PTR tv2345[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	eax, esi
	sub	ecx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1304 :       tc->dims.pos = min; tc->dims.size = lim - min;

	mov	DWORD PTR [edx-121], eax

; 1305 :       tc->apparent_dwt_levels = tc->dwt_levels;

	mov	eax, DWORD PTR [edx-97]
	mov	DWORD PTR [edx-129], esi
	mov	DWORD PTR [edx-125], edi
	mov	DWORD PTR [edx-117], ecx
	mov	DWORD PTR _r$1$[ebp], eax
	mov	DWORD PTR [edx-93], eax

; 1306 : 
; 1307 :       // Now visit the resolution level structure
; 1308 :       int r;
; 1309 :       for (r=tc->dwt_levels; r >= 0; r--)

	test	eax, eax
	js	$LN4@recycle
	npad	13
$LL9@recycle:

; 1310 :         {
; 1311 :           kd_resolution *res = tc->resolutions + r;

	imul	edi, eax, 604
	add	edi, DWORD PTR [edx-9]

; 1312 :           new_structure_bytes += (int) sizeof(*res);

	add	DWORD PTR _new_structure_bytes$1$[ebp], 604 ; 0000025cH
	adc	DWORD PTR _new_structure_bytes$2$[ebp], 0

; 1313 : 
; 1314 :           if (r == tc->dwt_levels)

	cmp	eax, DWORD PTR [edx-97]
	jne	SHORT $LN35@recycle

; 1315 :             res->node.dims = tc->dims;

	movups	xmm0, XMMWORD PTR [edx-129]

; 1316 :           else

	jmp	$LN275@recycle
$LN35@recycle:

; 1317 :             res->node.dims =

	movzx	eax, BYTE PTR [edi+56]
	movzx	ebx, BYTE PTR [edi+57]
	mov	DWORD PTR _branch_x$1$[ebp], eax
	mov	eax, DWORD PTR [edi+16]
	movups	xmm1, XMMWORD PTR [eax+8]

; 122  :   kdu_coords min = parent_dims.pos;

	movaps	xmm0, xmm1
	movd	edx, xmm1
	psrldq	xmm0, 4
	movd	esi, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	psrldq	xmm1, 8
	movd	ecx, xmm0
	movd	eax, xmm1
	add	ecx, esi
	add	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 125  :   if ((branch_x & ~1) == 0)

	test	DWORD PTR _branch_x$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN141@recycle

; 126  :     { // Parent node is split horizontally
; 127  :       min.x -= (branch_x)?high_support_max:low_support_max;
; 128  :       lim.x -= (branch_x)?high_support_min:low_support_min;
; 129  :       min.x = (min.x + 1 - branch_x) >> 1;

	sub	esi, DWORD PTR _branch_x$1$[ebp]

; 130  :       lim.x = (lim.x + 1 - branch_x) >> 1;

	sub	ecx, DWORD PTR _branch_x$1$[ebp]
	inc	esi
	inc	ecx
	sar	esi, 1
	sar	ecx, 1
$LN141@recycle:

; 131  :     }
; 132  : 
; 133  :   if ((branch_y & ~1) == 0)

	test	ebx, -2					; fffffffeH
	jne	SHORT $LN142@recycle

; 134  :     { // Parent node is split vertically
; 135  :       min.y -= (branch_y)?high_support_max:low_support_max;
; 136  :       lim.y -= (branch_y)?high_support_min:low_support_min;
; 137  :       min.y = (min.y + 1 - branch_y) >> 1;

	sub	edx, ebx

; 138  :       lim.y = (lim.y + 1 - branch_y) >> 1;

	sub	eax, ebx
	inc	edx
	inc	eax
	sar	edx, 1
	sar	eax, 1
$LN142@recycle:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ecx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 142  :   result.pos = min;

	mov	DWORD PTR $T7[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 142  :   result.pos = min;

	mov	DWORD PTR $T7[ebp+4], esi

; 143  :   result.size = lim-min;

	mov	DWORD PTR $T7[ebp+8], eax
	mov	DWORD PTR $T7[ebp+12], ecx

; 1317 :             res->node.dims =

	movups	xmm0, XMMWORD PTR $T7[ebp]
$LN275@recycle:
	movups	XMMWORD PTR [edi+24], xmm0

; 1318 :               get_child_dims(res->node.parent->dims,
; 1319 :                              res->node.branch_x,res->node.branch_y);
; 1320 : 
; 1321 :           res->rescomp = NULL;

	mov	DWORD PTR [edi+8], 0

; 1325 :           res->precinct_indices = res->region_indices =

	sub	esp, 16					; 00000010H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [edi+148]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1325 :           res->precinct_indices = res->region_indices =

	mov	ecx, esp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	imul	DWORD PTR [edi+144]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1325 :           res->precinct_indices = res->region_indices =

	movups	xmm0, XMMWORD PTR [edi+24]
	movups	XMMWORD PTR [ecx], xmm0
	sub	esp, 16					; 00000010H
	movups	xmm0, XMMWORD PTR [edi+120]
	mov	ecx, esp
	mov	DWORD PTR _old_num_precincts$2$[ebp], edx
	mov	esi, eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	movups	XMMWORD PTR [ecx], xmm0
	call	?get_partition_indices@@YA?AUkdu_dims@@U1@0@Z ; get_partition_indices
	add	esp, 36					; 00000024H
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [edi+152], xmm0
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [edi+136], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [edi+148]
	imul	DWORD PTR [edi+144]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1327 :           kdu_long num_precincts = res->precinct_indices.area();

	mov	ebx, eax
	mov	eax, edx
	mov	DWORD PTR _num_precincts$2$[ebp], eax

; 1328 :           if (num_precincts != old_num_precincts)

	cmp	ebx, esi
	jne	SHORT $LN259@recycle
	cmp	eax, DWORD PTR _old_num_precincts$2$[ebp]
	je	$LN37@recycle
$LN259@recycle:

; 1329 :             { // Reallocate precinct references array
; 1330 :               if (res->precinct_refs != NULL)

	mov	ecx, DWORD PTR [edi+180]
	test	ecx, ecx
	je	SHORT $LN69@recycle
	push	OFFSET ??1kd_precinct_ref@@QAE@XZ	; kd_precinct_ref::~kd_precinct_ref
	push	DWORD PTR [ecx-4]
	lea	esi, DWORD PTR [ecx-4]
	mov	DWORD PTR __$EHRec$[ebp+8], 4
	push	8
	push	ecx
	call	??_M@YGXPAXIIP6EX0@Z@Z
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax*8+4]
	push	eax
	push	esi
	call	??_V@YAXPAXI@Z				; operator delete[]
	mov	eax, DWORD PTR _num_precincts$2$[ebp]
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN69@recycle:

; 1331 :                 delete[] res->precinct_refs;
; 1332 :               res->precinct_refs = NULL;

	mov	DWORD PTR [edi+180], 0

; 1333 :               if (num_precincts > (1<<30))

	test	eax, eax
	jl	SHORT $LN39@recycle
	jg	SHORT $LN260@recycle
	cmp	ebx, 1073741824				; 40000000H
	jbe	SHORT $LN39@recycle
$LN260@recycle:

; 1334 :                 { KDU_ERROR(e,0x07110801); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$18[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$18[ebp]
	lea	ecx, DWORD PTR _e$18[ebp]
	push	OFFSET ??_C@_0BBK@KIFKIPEK@Tile?9component?9resolution?5encoun@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1334 :                 { KDU_ERROR(e,0x07110801); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1342 :                 }

	lea	ecx, DWORD PTR _e$18[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN39@recycle:

; 1343 :               res->precinct_refs = new kd_precinct_ref[(int) num_precincts];

	xor	ecx, ecx
	mov	DWORD PTR $T10[ebp], ebx
	mov	eax, ebx
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T12[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 7
	test	eax, eax
	je	SHORT $LN71@recycle
	push	OFFSET ??1kd_precinct_ref@@QAE@XZ	; kd_precinct_ref::~kd_precinct_ref
	push	OFFSET ??0kd_precinct_ref@@QAE@XZ	; kd_precinct_ref::kd_precinct_ref
	push	ebx
	lea	esi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], ebx
	push	8
	push	esi
	call	??_L@YGXPAXIIP6EX0@Z1@Z
	jmp	SHORT $LN72@recycle
$LN71@recycle:
	xor	esi, esi
$LN72@recycle:
	mov	eax, DWORD PTR _num_precincts$2$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [edi+180], esi
$LN37@recycle:

; 1344 :             }
; 1345 :           this->total_precincts += num_precincts;

	mov	esi, DWORD PTR _this$1$[ebp]
	add	DWORD PTR [esi+144], ebx
	adc	DWORD PTR [esi+148], eax

; 1346 :           new_structure_bytes += num_precincts * sizeof(kd_precinct_ref);

	shld	eax, ebx, 3
	shl	ebx, 3
	add	DWORD PTR _new_structure_bytes$1$[ebp], ebx
	adc	DWORD PTR _new_structure_bytes$2$[ebp], eax

; 1347 : 
; 1348 :           // Run profile checks.
; 1349 :           if ((r == 0) && (c < 4) && (codestream->profile < 2) &&

	cmp	DWORD PTR _r$1$[ebp], 0
	jne	SHORT $LN40@recycle
	cmp	DWORD PTR _c$1$[ebp], 4
	jge	SHORT $LN40@recycle
	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+104], 2
	jge	SHORT $LN40@recycle
	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [ecx+20]
	imul	eax, DWORD PTR [edi+36]
	cmp	eax, 128				; 00000080H
	jg	SHORT $LN41@recycle
	mov	eax, DWORD PTR [ecx+16]
	imul	eax, DWORD PTR [edi+32]
	cmp	eax, 128				; 00000080H
	jle	SHORT $LN40@recycle
$LN41@recycle:

; 1354 :             { KDU_WARNING(w,7); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$17[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$17[ebp]
	lea	ecx, DWORD PTR _w$17[ebp]
	push	OFFSET ??_C@_0BBP@FFHCNMHP@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1354 :             { KDU_WARNING(w,7); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1361 :               codestream->profile = 2;

	mov	eax, DWORD PTR [esi]

; 1362 :             }

	lea	ecx, DWORD PTR _w$17[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [eax+104], 2
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN40@recycle:

; 1365 :               (res->node.dims.size.y <= 128) &&

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+104], 0
	jne	SHORT $LN42@recycle
	cmp	DWORD PTR [edi+36], 128			; 00000080H
	jg	SHORT $LN42@recycle
	cmp	DWORD PTR [edi+32], 128			; 00000080H
	jg	SHORT $LN42@recycle
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [edi+148]
	imul	DWORD PTR [edi+144]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1365 :               (res->node.dims.size.y <= 128) &&

	test	edx, edx
	jl	SHORT $LN42@recycle
	jg	SHORT $LN261@recycle
	cmp	eax, 1
	jbe	SHORT $LN42@recycle
$LN261@recycle:

; 1367 :             { KDU_WARNING(w,8);  w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$16[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$16[ebp]
	lea	ecx, DWORD PTR _w$16[ebp]
	push	OFFSET ??_C@_0MJ@MHJOJOLI@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1367 :             { KDU_WARNING(w,8);  w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 9
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1372 :               codestream->profile = 2;

	mov	eax, DWORD PTR [esi]

; 1373 :             }

	lea	ecx, DWORD PTR _w$16[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [eax+104], 2
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN42@recycle:

; 1374 : 
; 1375 :           // Now visit all intermediate and subband nodes, filling in their
; 1376 :           // dimensions, along with the code-block partition parameters
; 1377 :           kdu_byte b;
; 1378 :           kd_node *node;
; 1379 :           for (b=0; b < res->num_intermediate_nodes; b++)

	xor	al, al
	mov	BYTE PTR _b$1$[ebp], al
	cmp	BYTE PTR [edi+175], al
	jbe	$LN11@recycle
$LL12@recycle:

; 1380 :             {
; 1381 :               node = res->intermediate_nodes + b;

	movzx	eax, al
	imul	ecx, eax, 104
	add	ecx, DWORD PTR [edi+176]
	mov	DWORD PTR _node$1$[ebp], ecx

; 1382 :               node->dims = get_child_dims(node->parent->dims,

	movzx	eax, BYTE PTR [ecx+40]
	movzx	ebx, BYTE PTR [ecx+41]
	mov	DWORD PTR _branch_x$1$[ebp], eax
	mov	eax, DWORD PTR [ecx]
	movups	xmm1, XMMWORD PTR [eax+8]

; 122  :   kdu_coords min = parent_dims.pos;

	movaps	xmm0, xmm1
	movd	edx, xmm1
	psrldq	xmm0, 4
	movd	esi, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	psrldq	xmm1, 8
	movd	ecx, xmm0
	movd	eax, xmm1
	add	ecx, esi
	add	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 125  :   if ((branch_x & ~1) == 0)

	test	DWORD PTR _branch_x$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN181@recycle

; 126  :     { // Parent node is split horizontally
; 127  :       min.x -= (branch_x)?high_support_max:low_support_max;
; 128  :       lim.x -= (branch_x)?high_support_min:low_support_min;
; 129  :       min.x = (min.x + 1 - branch_x) >> 1;

	sub	esi, DWORD PTR _branch_x$1$[ebp]

; 130  :       lim.x = (lim.x + 1 - branch_x) >> 1;

	sub	ecx, DWORD PTR _branch_x$1$[ebp]
	inc	esi
	inc	ecx
	sar	esi, 1
	sar	ecx, 1
$LN181@recycle:

; 131  :     }
; 132  : 
; 133  :   if ((branch_y & ~1) == 0)

	test	ebx, -2					; fffffffeH
	jne	SHORT $LN182@recycle

; 134  :     { // Parent node is split vertically
; 135  :       min.y -= (branch_y)?high_support_max:low_support_max;
; 136  :       lim.y -= (branch_y)?high_support_min:low_support_min;
; 137  :       min.y = (min.y + 1 - branch_y) >> 1;

	sub	edx, ebx

; 138  :       lim.y = (lim.y + 1 - branch_y) >> 1;

	sub	eax, ebx
	inc	edx
	inc	eax
	sar	edx, 1
	sar	eax, 1
$LN182@recycle:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 142  :   result.pos = min;

	mov	DWORD PTR $T6[ebp], edx

; 143  :   result.size = lim-min;

	mov	DWORD PTR $T6[ebp+8], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ecx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1382 :               node->dims = get_child_dims(node->parent->dims,

	mov	eax, DWORD PTR _node$1$[ebp]

; 142  :   result.pos = min;

	mov	DWORD PTR $T6[ebp+4], esi

; 143  :   result.size = lim-min;

	mov	DWORD PTR $T6[ebp+12], ecx

; 1382 :               node->dims = get_child_dims(node->parent->dims,

	movups	xmm0, XMMWORD PTR $T6[ebp]
	movups	XMMWORD PTR [eax+8], xmm0
	mov	al, BYTE PTR _b$1$[ebp]
	add	al, 1
	mov	BYTE PTR _b$1$[ebp], al
	cmp	al, BYTE PTR [edi+175]
	jb	$LL12@recycle
$LN11@recycle:

; 1383 :                                           node->branch_x,node->branch_y);
; 1384 :             }
; 1385 :           for (b=0; b < res->num_subbands; b++)

	xor	al, al
	mov	BYTE PTR _b$2$[ebp], al
	cmp	BYTE PTR [edi+174], al
	jbe	$LN14@recycle
$LL15@recycle:

; 1386 :             {
; 1387 :               kd_subband *band = res->subbands + b;

	movzx	eax, al
	imul	ecx, eax, 132
	add	ecx, DWORD PTR [edi+184]
	mov	DWORD PTR _band$1$[ebp], ecx

; 1388 :               band->dims = get_child_dims(band->parent->dims,

	movzx	eax, BYTE PTR [ecx+40]
	movzx	ebx, BYTE PTR [ecx+41]
	mov	DWORD PTR _branch_x$1$[ebp], eax
	mov	eax, DWORD PTR [ecx]
	movups	xmm1, XMMWORD PTR [eax+8]

; 122  :   kdu_coords min = parent_dims.pos;

	movaps	xmm0, xmm1
	movd	ecx, xmm1
	psrldq	xmm0, 4
	movd	edx, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	psrldq	xmm1, 8
	movd	esi, xmm0
	movd	eax, xmm1
	add	esi, edx
	add	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 125  :   if ((branch_x & ~1) == 0)

	test	DWORD PTR _branch_x$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN199@recycle

; 126  :     { // Parent node is split horizontally
; 127  :       min.x -= (branch_x)?high_support_max:low_support_max;
; 128  :       lim.x -= (branch_x)?high_support_min:low_support_min;
; 129  :       min.x = (min.x + 1 - branch_x) >> 1;

	sub	edx, DWORD PTR _branch_x$1$[ebp]

; 130  :       lim.x = (lim.x + 1 - branch_x) >> 1;

	sub	esi, DWORD PTR _branch_x$1$[ebp]
	inc	edx
	inc	esi
	sar	edx, 1
	sar	esi, 1
$LN199@recycle:

; 131  :     }
; 132  : 
; 133  :   if ((branch_y & ~1) == 0)

	test	ebx, -2					; fffffffeH
	jne	SHORT $LN200@recycle

; 134  :     { // Parent node is split vertically
; 135  :       min.y -= (branch_y)?high_support_max:low_support_max;
; 136  :       lim.y -= (branch_y)?high_support_min:low_support_min;
; 137  :       min.y = (min.y + 1 - branch_y) >> 1;

	sub	ecx, ebx

; 138  :       lim.y = (lim.y + 1 - branch_y) >> 1;

	sub	eax, ebx
	inc	ecx
	inc	eax
	sar	ecx, 1
	sar	eax, 1
$LN200@recycle:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 142  :   result.pos = min;

	mov	DWORD PTR $T5[ebp], ecx

; 143  :   result.size = lim-min;

	mov	DWORD PTR $T5[ebp+8], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	esi, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1390 :               band->block_indices =

	sub	esp, 16					; 00000010H

; 142  :   result.pos = min;

	mov	DWORD PTR $T5[ebp+4], edx

; 1390 :               band->block_indices =

	mov	eax, esp

; 143  :   result.size = lim-min;

	mov	DWORD PTR $T5[ebp+12], esi

; 1388 :               band->dims = get_child_dims(band->parent->dims,

	movups	xmm0, XMMWORD PTR $T5[ebp]
	mov	esi, DWORD PTR _band$1$[ebp]

; 1390 :               band->block_indices =

	sub	esp, 16					; 00000010H
	movups	XMMWORD PTR [eax], xmm0
	mov	eax, esp
	movups	XMMWORD PTR [esi+8], xmm0
	movups	xmm0, XMMWORD PTR [esi+68]
	movups	XMMWORD PTR [eax], xmm0
	lea	eax, DWORD PTR $T4[ebp]
	push	eax
	call	?get_partition_indices@@YA?AUkdu_dims@@U1@0@Z ; get_partition_indices
	add	esp, 36					; 00000024H
	movups	xmm0, XMMWORD PTR [eax]
	mov	al, BYTE PTR _b$2$[ebp]
	add	al, 1
	movups	XMMWORD PTR [esi+84], xmm0
	mov	BYTE PTR _b$2$[ebp], al
	cmp	al, BYTE PTR [edi+174]
	jb	$LL15@recycle
$LN14@recycle:

; 1391 :                 get_partition_indices(band->block_partition,band->dims);
; 1392 :             } // End of subband loop.
; 1393 :           res->complete_initialization();

	mov	ecx, edi
	call	?complete_initialization@kd_resolution@@QAEXXZ ; kd_resolution::complete_initialization
	mov	eax, DWORD PTR _r$1$[ebp]
	mov	edx, DWORD PTR tv2345[ebp]
	sub	eax, 1
	mov	DWORD PTR _r$1$[ebp], eax
	jns	$LL9@recycle
$LN4@recycle:

; 1291 :   for (c=0; c < num_components; c++, tc++)

	mov	edi, DWORD PTR _c$1$[ebp]
	add	edx, 188				; 000000bcH
	mov	esi, DWORD PTR _this$1$[ebp]
	inc	edi
	mov	ecx, DWORD PTR _new_structure_bytes$1$[ebp]
	mov	ebx, DWORD PTR _new_structure_bytes$2$[ebp]
	mov	DWORD PTR _c$1$[ebp], edi
	mov	DWORD PTR tv2345[ebp], edx
	cmp	edi, DWORD PTR [esi+128]
	jl	$LL6@recycle
$LN5@recycle:

; 1394 :         } // End of resolution loop.
; 1395 :     } // End of tile-component loop.
; 1396 : 
; 1397 :   if (!fully_typical)

	cmp	BYTE PTR [esi+125], 0
	jne	$LN17@recycle

; 1398 :     { // Need to re-initialize the quantization and ROI parameters
; 1399 :       kdu_params *qcd = codestream->siz->access_cluster(QCD_params);

	mov	ecx, DWORD PTR [esi]
	push	OFFSET ??_C@_03ELMDPBLM@QCD?$AA@
	mov	ecx, DWORD PTR [ecx+12]
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 1400 :       assert(qcd != NULL); qcd = qcd->access_relation(t_num,-1,0,true);

	push	1
	push	0
	push	-1
	push	DWORD PTR [esi+4]
	mov	ecx, eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 1401 :       kdu_params *rgn = codestream->siz->access_cluster(RGN_params);

	mov	ecx, DWORD PTR [esi]
	mov	ebx, eax
	push	OFFSET ??_C@_03KEJABOAE@RGN?$AA@
	mov	DWORD PTR _qcd$2$[ebp], ebx
	mov	ecx, DWORD PTR [ecx+12]
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 1402 :       assert(rgn != NULL); rgn = rgn->access_relation(t_num,-1,0,true);

	push	1
	push	0
	push	-1
	push	DWORD PTR [esi+4]
	mov	ecx, eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 1403 :       for (tc=comps, c=0; c < num_components; c++, tc++)

	mov	ecx, DWORD PTR [esi+208]
	mov	DWORD PTR _rgn$2$[ebp], eax
	xor	eax, eax
	mov	DWORD PTR _c$2$[ebp], eax
	cmp	DWORD PTR [esi+128], eax
	jle	$LN17@recycle

; 1398 :     { // Need to re-initialize the quantization and ROI parameters
; 1399 :       kdu_params *qcd = codestream->siz->access_cluster(QCD_params);

	lea	edi, DWORD PTR [ecx+56]
	mov	DWORD PTR tv2333[ebp], edi
$LL18@recycle:

; 1404 :         {
; 1405 :           kdu_params *qcc = qcd->access_relation(t_num,c,0,true);

	push	1
	push	0
	push	eax
	push	DWORD PTR [esi+4]
	mov	ecx, ebx
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 1406 :           kdu_params *rgc = rgn->access_relation(t_num,c,0,true);

	mov	ecx, DWORD PTR _rgn$2$[ebp]
	mov	ebx, eax
	push	1
	push	0
	push	DWORD PTR _c$2$[ebp]
	mov	DWORD PTR _qcc$1$[ebp], ebx
	push	DWORD PTR [esi+4]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 1407 :           assert((qcc != NULL) && (rgc != NULL));
; 1408 : 
; 1409 :           bool derived_quant;
; 1410 :           float base_delta = 0.0F;
; 1411 :           if ((!tc->reversible) && !(qcc->get(Qderived,0,0,derived_quant) &&

	cmp	BYTE PTR [edi+8], 0
	mov	ecx, eax
	mov	DWORD PTR _rgc$1$[ebp], ecx
	mov	DWORD PTR _base_delta$13[ebp], 0
	jne	SHORT $LN44@recycle
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _derived_quant$22[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08CCOBJCLJ@Qderived?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN45@recycle
	cmp	BYTE PTR _derived_quant$22[ebp], 0
	je	SHORT $LN271@recycle
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _base_delta$13[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN271@recycle
$LN45@recycle:

; 1413 :             { KDU_ERROR(e,0x05010701); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$15[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$15[ebp]
	lea	ecx, DWORD PTR _e$15[ebp]
	push	OFFSET ??_C@_0BHA@JBHJNMJO@Tile?9components?5which?5are?5compre@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1413 :             { KDU_ERROR(e,0x05010701); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 10		; 0000000aH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1421 :             }

	lea	ecx, DWORD PTR _e$15[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN271@recycle:
	mov	ecx, DWORD PTR _rgc$1$[ebp]
$LN44@recycle:

; 1422 :           int roi_levels;
; 1423 :           if ((codestream->in != NULL) || !rgc->get(Rlevels,0,0,roi_levels))

	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN47@recycle
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _roi_levels$14[ebp]
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07KGEEGGHK@Rlevels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN46@recycle
$LN47@recycle:

; 1424 :             roi_levels = 0;

	mov	DWORD PTR _roi_levels$14[ebp], 0
$LN46@recycle:

; 1425 : 
; 1426 :           // Next walk up from the lowest resolution, modifying quantization
; 1427 :           // and ROI parameters for each subband.
; 1428 :           int b, r, cumulative_subbands=0;

	xor	ecx, ecx

; 1429 :           for (r=0; r <= tc->dwt_levels; r++)

	xor	edx, edx
	mov	DWORD PTR _cumulative_subbands$1$[ebp], ecx
	mov	DWORD PTR _r$1$[ebp], edx
	cmp	DWORD PTR [edi], ecx
	jl	$LN16@recycle

; 1425 : 
; 1426 :           // Next walk up from the lowest resolution, modifying quantization
; 1427 :           // and ROI parameters for each subband.
; 1428 :           int b, r, cumulative_subbands=0;

	xor	eax, eax
	mov	DWORD PTR tv2334[ebp], eax
	npad	10
$LL21@recycle:

; 1430 :             {
; 1431 :               kd_resolution *res = tc->resolutions + r;

	mov	ebx, DWORD PTR [edi+88]
	add	ebx, eax

; 1432 :               res->propagate_roi = (res->dwt_level <= roi_levels);
; 1433 :               for (b=0; b < res->num_subbands; b++)

	mov	DWORD PTR _b$1$[ebp], 0
	mov	DWORD PTR _res$1$[ebp], ebx
	movzx	eax, BYTE PTR [ebx+13]
	cmp	eax, DWORD PTR _roi_levels$14[ebp]
	setle	al
	cmp	BYTE PTR [ebx+174], 0
	mov	BYTE PTR [ebx+172], al
	jbe	$LN23@recycle

; 1430 :             {
; 1431 :               kd_resolution *res = tc->resolutions + r;

	xor	edx, edx
	mov	DWORD PTR tv2337[ebp], ecx
	mov	DWORD PTR tv2336[ebp], edx
$LL24@recycle:

; 1434 :                 {
; 1435 :                   kd_subband *band = res->subbands + b;
; 1436 : 
; 1437 :                   // Find quantization parameters for the subband
; 1438 :                   int kmax, eps, abs_band_idx = cumulative_subbands + b;
; 1439 :                   if (tc->reversible)

	mov	eax, DWORD PTR tv2333[ebp]
	mov	edi, DWORD PTR [ebx+184]
	add	edi, edx
	cmp	BYTE PTR [eax+8], 0
	je	SHORT $LN48@recycle

; 1440 :                     {
; 1441 :                       if (!qcc->get(Qabs_ranges,abs_band_idx,0,eps))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _eps$11[ebp]
	push	eax
	push	0
	push	ecx
	mov	ecx, DWORD PTR _qcc$1$[ebp]
	push	OFFSET ??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 1442 :                         assert(0);
; 1443 :                       band->epsilon = (kdu_byte) eps;

	mov	al, BYTE PTR _eps$11[ebp]

; 1444 :                     }
; 1445 :                   else

	jmp	$LN276@recycle
$LN48@recycle:

; 1446 :                     {
; 1447 :                       float delta;
; 1448 :                       if (derived_quant)

	cmp	BYTE PTR _derived_quant$22[ebp], 0
	je	$LN51@recycle

; 1449 :                         {
; 1450 :                           int sum_depths =
; 1451 :                             res->hor_depth + (band->descriptor & 3) +
; 1452 :                             res->vert_depth + ((band->descriptor >> 8) & 3);
; 1453 :                           sum_depths -=
; 1454 :                             tc->comp_info->hor_depth[tc->dwt_levels];
; 1455 :                           sum_depths -=

	mov	edx, DWORD PTR [eax-48]
	mov	ecx, DWORD PTR [eax]
	movzx	ebx, BYTE PTR [ebx+15]
	movsx	esi, WORD PTR [edi+44]

; 1456 :                             tc->comp_info->vert_depth[tc->dwt_levels];
; 1457 : 
; 1458 :                           // Set `delta' = `base_delta' / 2^{sum_depths/2}
; 1459 :                           delta = base_delta;

	movss	xmm1, DWORD PTR _base_delta$13[ebp]
	movzx	eax, BYTE PTR [edx+ecx+54]
	sub	ebx, eax
	movzx	eax, BYTE PTR [edx+ecx+21]
	sub	ebx, eax
	movss	DWORD PTR _delta$2$[ebp], xmm1
	mov	eax, DWORD PTR _res$1$[ebp]
	movzx	eax, BYTE PTR [eax+14]
	add	ebx, eax
	mov	eax, esi
	sar	eax, 8
	and	esi, 3
	and	eax, 3
	add	ebx, eax
	add	ebx, esi

; 1460 :                           if (sum_depths & 1)

	test	bl, 1
	je	SHORT $LN53@recycle

; 1461 :                             {
; 1462 :                               sum_depths++;
; 1463 :                               delta *= (float) sqrt(2.0);

	movsd	xmm0, QWORD PTR __real@4000000000000000
	inc	ebx
	call	__libm_sse2_sqrt_precise
	movss	xmm1, DWORD PTR _delta$2$[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm1, xmm0
$LN53@recycle:

; 1464 :                             }
; 1465 :                           sum_depths >>= 1;

	sar	ebx, 1

; 1466 :                           if (sum_depths > 0)
; 1467 :                             delta /= (float)(1<<sum_depths);

	mov	eax, 1
	test	ebx, ebx
	jle	SHORT $LN54@recycle
	mov	ecx, ebx

; 1468 :                           else

	mov	ebx, DWORD PTR _res$1$[ebp]
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR _delta$20[ebp], xmm1
	jmp	SHORT $LN56@recycle
$LN54@recycle:

; 1469 :                             delta *= (float)(1<<(-sum_depths));

	neg	ebx
	mov	ecx, ebx
	mov	ebx, DWORD PTR _res$1$[ebp]
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm1, xmm0
	movss	DWORD PTR _delta$20[ebp], xmm1
	jmp	SHORT $LN56@recycle
$LN51@recycle:

; 1470 :                         }
; 1471 :                       else if (!qcc->get(Qabs_steps,abs_band_idx,0,delta))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _delta$20[ebp]
	push	eax
	push	0
	push	ecx
	mov	ecx, DWORD PTR _qcc$1$[ebp]
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	movss	xmm1, DWORD PTR _delta$20[ebp]
$LN56@recycle:

; 1472 :                         assert(0);
; 1473 :                       assert(delta > 0.0F);
; 1474 :                       band->delta = delta;
; 1475 :                       for (band->epsilon=0; delta < 1.0F; delta*=2.0F)

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, xmm1
	mov	BYTE PTR [edi+49], 0
	movss	DWORD PTR [edi+52], xmm1
	jbe	SHORT $LN26@recycle
	movss	xmm2, DWORD PTR __real@40000000
	xor	al, al
	npad	4
$LL27@recycle:
	mulss	xmm1, xmm2

; 1476 :                         band->epsilon++;

	add	al, 1
	comiss	xmm0, xmm1
	ja	SHORT $LL27@recycle

; 1472 :                         assert(0);
; 1473 :                       assert(delta > 0.0F);
; 1474 :                       band->delta = delta;
; 1475 :                       for (band->epsilon=0; delta < 1.0F; delta*=2.0F)

	movss	DWORD PTR _delta$20[ebp], xmm1
$LN276@recycle:
	mov	BYTE PTR [edi+49], al
$LN26@recycle:

; 1477 :                       assert(delta < 2.0F);
; 1478 :                     }
; 1479 : 
; 1480 :                   if (!qcc->get(Qguard,0,0,kmax))

	mov	ecx, DWORD PTR _qcc$1$[ebp]
	lea	eax, DWORD PTR _kmax$19[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06BGIMBACE@Qguard?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 1481 :                     assert(0);
; 1482 :                   band->K_max = (kdu_byte) kmax;

	mov	al, BYTE PTR _kmax$19[ebp]

; 1483 : 
; 1484 :                   if (!rgc->get(Rweight,0,0,band->roi_weight))

	lea	esi, DWORD PTR [edi+64]
	mov	ecx, DWORD PTR _rgc$1$[ebp]
	push	1
	push	1
	push	1
	push	esi
	push	0
	push	0
	push	OFFSET ??_C@_07MDGMFIIN@Rweight?$AA@
	mov	BYTE PTR [edi+50], al
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN58@recycle

; 1485 :                     band->roi_weight = -1.0F; // Indicates no ROI weights.

	mov	DWORD PTR [esi], -1082130432		; bf800000H
$LN58@recycle:

; 1486 :                   band->K_max += band->epsilon;
; 1487 :                   band->K_max -= 1;

	mov	al, BYTE PTR [edi+49]

; 1488 :                   if (!rgc->get(Rshift,0,0,kmax))

	mov	ecx, DWORD PTR _rgc$1$[ebp]
	dec	al
	add	BYTE PTR [edi+50], al
	lea	eax, DWORD PTR _kmax$19[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06LDAKCIBF@Rshift?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	$LN59@recycle

; 1489 :                     kmax = 0;

	xor	ecx, ecx
	mov	DWORD PTR _kmax$19[ebp], ecx
$LN269@recycle:
	mov	esi, DWORD PTR _this$1$[ebp]
$LN61@recycle:

; 1498 :                   band->K_max_prime = (kdu_byte)(kmax + band->K_max);

	mov	al, BYTE PTR [edi+50]
	mov	edx, DWORD PTR tv2336[ebp]
	add	al, cl
	mov	ecx, DWORD PTR tv2337[ebp]
	add	edx, 132				; 00000084H
	mov	BYTE PTR [edi+51], al
	inc	ecx
	mov	edi, DWORD PTR _b$1$[ebp]
	movzx	eax, BYTE PTR [ebx+174]
	inc	edi
	mov	DWORD PTR _b$1$[ebp], edi
	mov	DWORD PTR tv2336[ebp], edx
	mov	DWORD PTR tv2337[ebp], ecx
	cmp	edi, eax
	jl	$LL24@recycle
	mov	edi, DWORD PTR tv2333[ebp]
	mov	ecx, DWORD PTR _cumulative_subbands$1$[ebp]
	mov	edx, DWORD PTR _r$1$[ebp]
$LN23@recycle:

; 1499 :                 } // End of subband loop
; 1500 :               cumulative_subbands += res->num_subbands;

	movzx	eax, BYTE PTR [ebx+174]
	inc	edx
	add	ecx, eax
	mov	DWORD PTR _r$1$[ebp], edx
	mov	eax, DWORD PTR tv2334[ebp]
	add	eax, 604				; 0000025cH
	mov	DWORD PTR _cumulative_subbands$1$[ebp], ecx
	mov	DWORD PTR tv2334[ebp], eax
	cmp	edx, DWORD PTR [edi]
	jle	$LL21@recycle
$LN16@recycle:

; 1403 :       for (tc=comps, c=0; c < num_components; c++, tc++)

	mov	eax, DWORD PTR _c$2$[ebp]
	add	edi, 188				; 000000bcH
	mov	ebx, DWORD PTR _qcd$2$[ebp]
	inc	eax
	mov	DWORD PTR _c$2$[ebp], eax
	mov	DWORD PTR tv2333[ebp], edi
	cmp	eax, DWORD PTR [esi+128]
	jl	$LL18@recycle
$LN17@recycle:

; 1501 :             } // End of resolution loop
; 1502 :         } // End of tile-component loop
; 1503 :     } // End of (!fully_typical) case
; 1504 : 
; 1505 :   // Now set up the packet sequencing machinery.
; 1506 :   max_relevant_layers = num_layers; // May be reduced later
; 1507 :   max_relevant_packets = total_precincts * num_layers; // May be reduced later

	push	DWORD PTR [esi+148]
	mov	eax, DWORD PTR [esi+132]
	push	DWORD PTR [esi+144]
	mov	DWORD PTR [esi+140], eax
	cdq
	push	edx
	push	eax
	call	__allmul

; 1508 :   initialized = true;
; 1509 :   sequenced_relevant_packets = 0;
; 1510 :   next_input_packet_num = 0;
; 1511 :   skipping_to_sop = false;
; 1512 :   assert(sequencer == NULL);
; 1513 :   sequencer = new kd_packet_sequencer(this);

	push	176					; 000000b0H
	mov	DWORD PTR [esi+152], eax
	mov	DWORD PTR [esi+156], edx
	mov	BYTE PTR [esi+233], 1
	mov	DWORD PTR [esi+248], 0
	mov	DWORD PTR [esi+252], 0
	mov	BYTE PTR [esi+256], 0
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T9[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 12		; 0000000cH
	test	eax, eax
	je	SHORT $LN73@recycle
	push	esi
	mov	ecx, eax
	call	??0kd_packet_sequencer@@QAE@PAUkd_tile@@@Z ; kd_packet_sequencer::kd_packet_sequencer
	jmp	SHORT $LN74@recycle
$LN59@recycle:

; 1490 :                   else if ((kmax > 37) && (codestream->profile < 2))

	mov	ecx, DWORD PTR _kmax$19[ebp]
	cmp	ecx, 37					; 00000025H
	jle	$LN269@recycle
	mov	esi, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+104], 2
	jge	$LN61@recycle

; 1491 :                     { KDU_WARNING(w,0x05010702); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$3[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$3[ebp]
	lea	ecx, DWORD PTR _w$3[ebp]
	push	OFFSET ??_C@_0JM@NAEKEAHJ@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1491 :                     { KDU_WARNING(w,0x05010702); w <<

	mov	DWORD PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1496 :                       codestream->profile = 2;

	mov	eax, DWORD PTR [esi]

; 1497 :                     }

	lea	ecx, DWORD PTR _w$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [eax+104], 2
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
	mov	ecx, DWORD PTR _kmax$19[ebp]
	jmp	$LN61@recycle
$LN73@recycle:

; 1508 :   initialized = true;
; 1509 :   sequenced_relevant_packets = 0;
; 1510 :   next_input_packet_num = 0;
; 1511 :   skipping_to_sop = false;
; 1512 :   assert(sequencer == NULL);
; 1513 :   sequencer = new kd_packet_sequencer(this);

	xor	eax, eax
$LN74@recycle:

; 1514 : 
; 1515 :   new_structure_bytes += (int) sizeof(*sequencer);

	mov	ecx, DWORD PTR _new_structure_bytes$1$[ebp]
	mov	edx, DWORD PTR _new_structure_bytes$2$[ebp]
	add	ecx, 176				; 000000b0H
	mov	DWORD PTR [esi+52], eax

; 1516 :   assert(structure_bytes == 0);
; 1517 :   structure_bytes += new_structure_bytes;
; 1518 :   codestream->buf_server->augment_structure_bytes(new_structure_bytes);

	mov	eax, DWORD PTR [esi]
	adc	edx, 0
	add	DWORD PTR [esi+216], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	adc	DWORD PTR [esi+220], edx
	mov	eax, DWORD PTR [eax+24]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	add	DWORD PTR [eax+32], ecx

; 281  :         if (structure_bytes > peak_structure_bytes)

	mov	ecx, DWORD PTR [eax+32]
	adc	DWORD PTR [eax+36], edx
	mov	edx, DWORD PTR [eax+36]
	cmp	edx, DWORD PTR [eax+44]
	jl	SHORT $LN221@recycle
	jg	SHORT $LN262@recycle
	cmp	ecx, DWORD PTR [eax+40]
	jbe	SHORT $LN221@recycle
$LN262@recycle:

; 282  :           peak_structure_bytes = structure_bytes;

	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+44], edx
$LN221@recycle:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1520 :   if (!codestream->persistent)

	mov	eax, DWORD PTR [esi]
	cmp	BYTE PTR [eax+337], 0
	jne	SHORT $LN62@recycle

; 1521 :     set_elements_of_interest(); // May change `max_relevant_packets/layers'

	mov	ecx, esi
	call	?set_elements_of_interest@kd_tile@@AAEXXZ ; kd_tile::set_elements_of_interest
$LN62@recycle:

; 1522 : 
; 1523 :   if (read_failure)

	cmp	BYTE PTR _read_failure$1$[ebp], 0
	je	SHORT $LN63@recycle

; 1524 :     finished_reading();

	mov	ecx, esi
	call	?finished_reading@kd_tile@@QAE_NXZ	; kd_tile::finished_reading
$LN63@recycle:

; 1525 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	28					; 0000001cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$7:
	call	___std_terminate
	ret	0
__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$8:
	call	___std_terminate
	ret	0
__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$9:
	call	___std_terminate
	ret	0
__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$10:
	call	___std_terminate
	ret	0
__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$11:
	call	___std_terminate
	ret	0
__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$0:
	lea	ecx, DWORD PTR _e$18[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$1:
	xor	ebx, ebx
	mov	eax, DWORD PTR $T10[ebp]
	mov	ecx, 8
	mul	ecx
	seto	bl
	neg	ebx
	or	ebx, eax
	xor	eax, eax
	add	ebx, 4
	setb	al
	neg	eax
	or	eax, ebx
	push	eax
	mov	eax, DWORD PTR $T12[ebp]
	push	eax
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	ret	0
__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$2:
	lea	ecx, DWORD PTR _w$17[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$3:
	lea	ecx, DWORD PTR _w$16[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$4:
	lea	ecx, DWORD PTR _e$15[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$6:
	push	176					; 000000b0H
	mov	eax, DWORD PTR $T9[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__unwindfunclet$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z$5:
	lea	ecx, DWORD PTR _w$3[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__ehhandler$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-212]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?recycle@kd_tile@@QAEXPAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z ENDP ; kd_tile::recycle
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?initialize@kd_tile@@QAEXXZ
_TEXT	SEGMENT
$T2 = -824						; size = 16
$T3 = -808						; size = 16
$T4 = -792						; size = 4
$T5 = -788						; size = 4
$T6 = -784						; size = 16
$T7 = -768						; size = 4
$T8 = -768						; size = 4
_rgn$2$ = -764						; size = 4
_eps$9 = -760						; size = 4
_qcd$2$ = -756						; size = 4
tv3435 = -752						; size = 4
tv3434 = -748						; size = 4
_b$1$ = -744						; size = 4
_base_delta$10 = -740					; size = 4
_roi_levels$11 = -736					; size = 4
_atk_idx$12 = -732					; size = 4
_level_weight$13 = -728					; size = 4
_cod$2$ = -724						; size = 4
$T14 = -720						; size = 4
tv3432 = -720						; size = 4
_num_precincts$2$ = -716				; size = 4
_r$2$ = -716						; size = 4
_hor_splits$1$ = -712					; size = 4
$T15 = -712						; size = 4
$T16 = -712						; size = 4
$T17 = -712						; size = 4
_max_bytes$18 = -712					; size = 4
tv3486 = -708						; size = 4
tv3366 = -708						; size = 4
$T19 = -708						; size = 4
$T20 = -708						; size = 4
_c$3$ = -704						; size = 4
_kmax$21 = -700						; size = 4
_qcc$1$ = -696						; size = 4
_org$2$ = -692						; size = 4
_comp_weight$22 = -692					; size = 4
_rgc$1$ = -688						; size = 4
_min$2$ = -688						; size = 4
_branch_y$1$ = -684					; size = 4
_cumulative_subbands$1$ = -684				; size = 4
_new_structure_bytes$2$ = -680				; size = 4
_new_structure_bytes$1$ = -676				; size = 4
_use_precincts$23 = -669				; size = 1
_e$24 = -668						; size = 20
_e$25 = -668						; size = 20
_w$26 = -668						; size = 20
_w$27 = -668						; size = 20
_w$28 = -668						; size = 20
_e$29 = -668						; size = 20
_w$30 = -668						; size = 20
_w$31 = -668						; size = 20
_w$32 = -668						; size = 20
_w$33 = -668						; size = 20
_e$34 = -668						; size = 20
_delta$35 = -648					; size = 4
_tpart_flags$36 = -648					; size = 4
_extra_stage_high$37 = -644				; size = 3
_delta$2$ = -640					; size = 4
$T38 = -640						; size = 4
tv3727 = -640						; size = 4
tv3538 = -640						; size = 4
_derived_quant$39 = -635				; size = 1
_read_failure$1$ = -634					; size = 1
_can_flip$1$ = -633					; size = 1
_tc$1$ = -632						; size = 4
_branch_x$1$ = -628					; size = 4
_res$1$ = -628						; size = 4
_coc$1$ = -624						; size = 4
_this$GSCopy$1$ = -620					; size = 4
_kernels$40 = -616					; size = 600
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
?initialize@kd_tile@@QAEXXZ PROC			; kd_tile::initialize, COMDAT
; _this$ = ecx

; 687  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?initialize@kd_tile@@QAEXXZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 812				; 0000032cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], edi

; 688  :   bool read_failure = false;
; 689  : 
; 690  :   assert(!needs_reinit);
; 691  :   kdu_long new_structure_bytes = (int) sizeof(*this);
; 692  : 
; 693  :   if (!initialized)

	cmp	BYTE PTR [edi+233], 0
	mov	BYTE PTR _read_failure$1$[ebp], 0
	mov	DWORD PTR _new_structure_bytes$1$[ebp], 272 ; 00000110H
	mov	DWORD PTR _new_structure_bytes$2$[ebp], 0
	jne	SHORT $LN28@initialize

; 694  :     {
; 695  :       num_components = codestream->num_components;

	mov	ecx, DWORD PTR [edi]
	mov	eax, DWORD PTR [ecx+112]
	mov	DWORD PTR [edi+128], eax

; 696  :       next_tpart = num_tparts = 0;

	mov	DWORD PTR [edi+240], 0
	mov	DWORD PTR [edi+244], 0

; 697  :       if (codestream->in != NULL)

	mov	ecx, DWORD PTR [ecx+4]
	test	ecx, ecx
	je	SHORT $LN28@initialize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 656  :       { return source->get_capabilities(); }

	mov	ecx, DWORD PTR [ecx+540]
	mov	eax, DWORD PTR [ecx]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 699  :           if (codestream->in->get_capabilities() & KDU_SOURCE_CAP_SEEKABLE)

	test	al, 2
	je	SHORT $LN29@initialize

; 700  :             precinct_pointer_server.initialize(codestream->buf_server);

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR [edi+56]
	push	DWORD PTR [eax+24]
	call	?initialize@kd_precinct_pointer_server@@QAEXPAVkd_buf_server@@@Z ; kd_precinct_pointer_server::initialize
$LN29@initialize:

; 701  :           tpart_ptrs = tile_ref->tpart_head;

	mov	eax, DWORD PTR [edi+16]

; 702  :           read_failure = !read_tile_part_header();

	mov	ecx, edi
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [edi+20], eax
	call	?read_tile_part_header@kd_tile@@QAE_NXZ	; kd_tile::read_tile_part_header
	test	al, al
	sete	BYTE PTR _read_failure$1$[ebp]
$LN28@initialize:

; 703  :         }
; 704  :     }
; 705  : 
; 706  :   kdu_params *cod = codestream->siz->access_cluster(COD_params);

	mov	ecx, DWORD PTR [edi]
	push	OFFSET ??_C@_03LIMJJHMM@COD?$AA@
	mov	ecx, DWORD PTR [ecx+12]
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 707  :   assert(cod != NULL); cod = cod->access_relation(t_num,-1,0,true);

	push	1
	push	0
	push	-1
	push	DWORD PTR [edi+4]
	mov	ecx, eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 708  :   kdu_params *qcd = codestream->siz->access_cluster(QCD_params);

	mov	ecx, DWORD PTR [edi]
	mov	esi, eax
	push	OFFSET ??_C@_03ELMDPBLM@QCD?$AA@
	mov	DWORD PTR _cod$2$[ebp], esi
	mov	ecx, DWORD PTR [ecx+12]
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 709  :   assert(qcd != NULL); qcd = qcd->access_relation(t_num,-1,0,true);

	push	1
	push	0
	push	-1
	push	DWORD PTR [edi+4]
	mov	ecx, eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 710  :   kdu_params *rgn = codestream->siz->access_cluster(RGN_params);

	mov	ecx, DWORD PTR [edi]
	push	OFFSET ??_C@_03KEJABOAE@RGN?$AA@
	mov	DWORD PTR _qcd$2$[ebp], eax
	mov	ecx, DWORD PTR [ecx+12]
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 711  :   assert(rgn != NULL); rgn = rgn->access_relation(t_num,-1,0,true);

	push	1
	push	0
	push	-1
	push	DWORD PTR [edi+4]
	mov	ecx, eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 712  :   kdu_params *org = codestream->siz->access_cluster(ORG_params);

	mov	ecx, DWORD PTR [edi]
	push	OFFSET ??_C@_03MNMMELJE@ORG?$AA@
	mov	DWORD PTR _rgn$2$[ebp], eax
	mov	ecx, DWORD PTR [ecx+12]
	call	?access_cluster@kdu_params@@QAEPAV1@PBD@Z ; kdu_params::access_cluster

; 713  :   assert(org != NULL); org = org->access_relation(t_num,-1,0,true);

	push	1
	push	0
	push	-1
	push	DWORD PTR [edi+4]
	mov	ecx, eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 714  : 
; 715  :   // Get tile-wide COD parameters.
; 716  :   if (!(cod->get(Cuse_sop,0,0,use_sop) &&

	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR [edi+224]
	mov	ebx, eax
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_08DAJNLNLL@Cuse_sop?$AA@
	mov	ecx, esi
	mov	DWORD PTR _org$2$[ebp], ebx
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	$LN31@initialize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR [edi+225]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08NAIOMJOM@Cuse_eph?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	$LN31@initialize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR [edi+226]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04DEPIIIHA@Cycc?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN31@initialize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR [edi+192]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN31@initialize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR [edi+196]
	mov	ecx, esi
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_0BA@JFAKJNFN@Calign_blk_last?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN31@initialize
	push	1
	push	1
	push	1
	lea	eax, DWORD PTR [edi+132]
	mov	ecx, esi
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07BJCMAMHC@Clayers?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN31@initialize:

; 717  :         cod->get(Cuse_eph,0,0,use_eph) &&
; 718  :         cod->get(Cycc,0,0,use_ycc) &&
; 719  :         cod->get(Calign_blk_last,0,0,coding_origin.y) &&
; 720  :         cod->get(Calign_blk_last,0,1,coding_origin.x) &&
; 721  :         cod->get(Clayers,0,0,num_layers)))
; 722  :     assert(0);
; 723  :   if (num_layers > codestream->max_tile_layers)

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR [edi+132]
	cmp	ecx, DWORD PTR [eax+200]
	jle	SHORT $LN32@initialize

; 724  :     codestream->max_tile_layers = num_layers;

	mov	DWORD PTR [eax+200], ecx
$LN32@initialize:

; 725  :   
; 726  :   // Collect any reslength specifiers
; 727  :   int c;
; 728  :   if (reslength_checkers == NULL)

	cmp	DWORD PTR [edi+120], 0
	jne	$LN307@initialize

; 729  :     { // See if we need a `reslength_checkers' array
; 730  :       for (c=-1; c < num_components; c++)

	or	esi, -1
	cmp	DWORD PTR [edi+128], esi
	jle	SHORT $LN269@initialize
	mov	ebx, DWORD PTR _cod$2$[ebp]
$LL4@initialize:

; 731  :         {
; 732  :           int max_bytes;
; 733  :           cod_params *coc = (cod_params *) cod->access_unique(t_num,c);

	push	0
	push	esi
	push	DWORD PTR [edi+4]
	mov	ecx, ebx
	call	?access_unique@kdu_params@@QAEPAV1@HHH@Z ; kdu_params::access_unique

; 734  :           if ((coc != NULL) &&

	test	eax, eax
	je	SHORT $LN2@initialize
	push	1
	push	0
	push	0
	lea	ecx, DWORD PTR _max_bytes$18[ebp]
	push	ecx
	push	0
	push	0
	push	OFFSET ??_C@_0M@HKNEBDCB@Creslengths?$AA@
	mov	ecx, eax
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN302@initialize
$LN2@initialize:

; 729  :     { // See if we need a `reslength_checkers' array
; 730  :       for (c=-1; c < num_components; c++)

	inc	esi
	cmp	esi, DWORD PTR [edi+128]
	jl	SHORT $LL4@initialize
$LN302@initialize:
	mov	ebx, DWORD PTR _org$2$[ebp]
$LN269@initialize:

; 735  :               coc->get(Creslengths,0,0,max_bytes,false,false))
; 736  :             break;
; 737  :         }
; 738  :       if (c < num_components)

	mov	eax, DWORD PTR [edi+128]
	cmp	esi, eax
	jge	SHORT $LN35@initialize

; 739  :         reslength_checkers = new kd_reslength_checker[1+num_components];

	lea	esi, DWORD PTR [eax+1]
	xor	ecx, ecx
	mov	eax, esi
	mov	DWORD PTR $T17[ebp], esi
	mov	edx, 808				; 00000328H
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T20[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN110@initialize
	push	OFFSET ??1kd_reslength_checker@@QAE@XZ	; kd_reslength_checker::~kd_reslength_checker
	push	OFFSET ??0kd_reslength_checker@@QAE@XZ	; kd_reslength_checker::kd_reslength_checker
	push	esi
	lea	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], esi
	push	808					; 00000328H
	push	edi
	call	??_L@YGXPAXIIP6EX0@Z1@Z
	jmp	SHORT $LN111@initialize
$LN110@initialize:
	xor	edi, edi
$LN111@initialize:
	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [edx+120], edi
	mov	edi, edx
$LN35@initialize:

; 740  :     }
; 741  :   if (reslength_checkers != NULL)

	cmp	DWORD PTR [edi+120], 0
	je	SHORT $LN6@initialize
$LN307@initialize:

; 742  :     for (c=-1; c < num_components; c++)

	or	esi, -1
	cmp	DWORD PTR [edi+128], esi
	jle	SHORT $LN6@initialize
	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	edi, -808				; fffffcd8H
$LL7@initialize:

; 743  :       {
; 744  :         cod_params *coc = (cod_params *) cod->access_unique(t_num,c);

	mov	ecx, DWORD PTR _cod$2$[ebp]
	push	0
	push	esi
	push	DWORD PTR [ebx+4]
	call	?access_unique@kdu_params@@QAEPAV1@HHH@Z ; kdu_params::access_unique

; 745  :         if (reslength_checkers[c+1].init(coc))

	mov	ecx, DWORD PTR [ebx+120]
	add	ecx, 808				; 00000328H
	push	eax
	add	ecx, edi
	call	?init@kd_reslength_checker@@QAE_NPAVcod_params@@@Z ; kd_reslength_checker::init
	test	al, al
	je	SHORT $LN5@initialize

; 746  :           codestream->reslength_constraints_used = true;

	mov	eax, DWORD PTR [ebx]
	mov	BYTE PTR [eax+320], 1
$LN5@initialize:

; 742  :     for (c=-1; c < num_components; c++)

	inc	esi
	add	edi, 808				; 00000328H
	cmp	esi, DWORD PTR [ebx+128]
	jl	SHORT $LL7@initialize
	mov	ebx, DWORD PTR _org$2$[ebp]
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
$LN6@initialize:

; 747  :       }
; 748  : 
; 749  :   // Get tile-wide ORG parameters.
; 750  :   if (codestream->out != NULL)

	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax+8], 0
	je	$LN38@initialize

; 751  :     {
; 752  :       int tpart_flags;
; 753  :       if (!org->get(ORGtparts,0,0,tpart_flags))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _tpart_flags$36[ebp]
	mov	ecx, ebx
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_09CNLDEMAK@ORGtparts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	mov	ecx, DWORD PTR _tpart_flags$36[ebp]

; 754  :         tpart_flags = 0;
; 755  :       if (!org->get(ORGgen_plt,0,0,insert_plt_segments))

	lea	esi, DWORD PTR [edi+235]
	push	1
	push	1
	push	1
	xor	edx, edx
	test	al, al
	push	esi
	push	edx
	cmove	ecx, edx
	push	edx
	mov	DWORD PTR _tpart_flags$36[ebp], ecx
	mov	ecx, ebx
	push	OFFSET ??_C@_0L@DMGGEJHL@ORGgen_plt?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN40@initialize

; 756  :         insert_plt_segments = false;

	mov	BYTE PTR [esi], al
$LN40@initialize:

; 757  :       resolution_tparts = ((tpart_flags & ORGtparts_R) != 0);

	mov	ecx, DWORD PTR _tpart_flags$36[ebp]
	mov	al, cl
	and	al, 1
	mov	BYTE PTR [edi+236], al

; 758  :       component_tparts = ((tpart_flags & ORGtparts_C) != 0);

	mov	eax, ecx
	shr	eax, 2
	and	al, 1

; 759  :       layer_tparts = ((tpart_flags & ORGtparts_L) != 0);

	shr	ecx, 1
	and	cl, 1
	mov	BYTE PTR [edi+237], al
	mov	BYTE PTR [edi+238], cl
$LN38@initialize:

; 760  :     }
; 761  : 
; 762  :   // Create description of any multi-component transform
; 763  :   assert(mct_head == NULL);
; 764  :   if (codestream->uses_mct)

	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax+108], 0
	je	SHORT $LN41@initialize

; 765  :     kd_mct_stage::create_stages(mct_head,mct_tail,codestream->siz,t_num,

	push	DWORD PTR [eax+260]
	push	DWORD PTR [eax+120]
	push	DWORD PTR [eax+256]
	push	DWORD PTR [edi+128]
	push	DWORD PTR [edi+4]
	push	DWORD PTR [eax+12]
	lea	eax, DWORD PTR [edi+204]
	push	eax
	lea	eax, DWORD PTR [edi+200]
	push	eax
	call	?create_stages@kd_mct_stage@@SAXAAPAU1@0PAVkdu_params@@HHPAUkd_comp_info@@HPAUkd_output_comp_info@@@Z ; kd_mct_stage::create_stages
	add	esp, 32					; 00000020H
$LN41@initialize:

; 766  :                                 num_components,codestream->comp_info,
; 767  :                                 codestream->num_output_components,
; 768  :                                 codestream->output_comp_info);
; 769  : 
; 770  :   // Initialize appearance parameters
; 771  :   num_apparent_layers = num_layers;

	mov	eax, DWORD PTR [edi+132]

; 772  : 
; 773  :   // Build tile-components.
; 774  :   kd_tile_comp *tc =
; 775  :     comps = new kd_tile_comp[num_components];

	xor	ecx, ecx
	mov	esi, DWORD PTR [edi+128]
	mov	edx, 188				; 000000bcH
	mov	DWORD PTR [edi+136], eax
	mov	eax, esi
	mul	edx
	mov	DWORD PTR $T16[ebp], esi
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T19[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	test	eax, eax
	je	SHORT $LN112@initialize
	push	OFFSET ??1kd_tile_comp@@QAE@XZ		; kd_tile_comp::~kd_tile_comp
	push	OFFSET ??0kd_tile_comp@@QAE@XZ		; kd_tile_comp::kd_tile_comp
	mov	DWORD PTR [eax], esi
	add	eax, 4
	push	esi
	push	188					; 000000bcH
	mov	esi, eax
	mov	DWORD PTR _tc$1$[ebp], eax
	push	esi
	call	??_L@YGXPAXIIP6EX0@Z1@Z
	jmp	SHORT $LN113@initialize
$LN112@initialize:
	xor	esi, esi
	mov	DWORD PTR _tc$1$[ebp], esi
$LN113@initialize:

; 777  :   for (c=0; c < num_components; c++, tc++)

	xor	edx, edx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	mov	DWORD PTR [edi+208], esi
	mov	DWORD PTR [edi+144], 0
	mov	DWORD PTR [edi+148], 0
	mov	DWORD PTR _c$3$[ebp], edx
	cmp	DWORD PTR [edi+128], edx
	jle	$LN9@initialize
	npad	6
$LL10@initialize:

; 778  :     {
; 779  :       kdu_coords subs, min, lim;
; 780  : 
; 781  :       new_structure_bytes += (int) sizeof(*tc);

	add	DWORD PTR _new_structure_bytes$1$[ebp], 188 ; 000000bcH

; 782  : 
; 783  :       tc->enabled = true;

	mov	WORD PTR [esi+152], 257			; 00000101H
	adc	DWORD PTR _new_structure_bytes$2$[ebp], 0

; 784  :       tc->is_of_interest = true;
; 785  :       tc->G_tc = tc->G_tc_restricted = -1.0F;

	mov	DWORD PTR [esi+124], -1082130432	; bf800000H
	mov	DWORD PTR [esi+120], -1082130432	; bf800000H

; 786  :       tc->codestream = codestream;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [esi], eax

; 787  :       tc->tile = this;
; 788  :       tc->comp_info = codestream->comp_info + c;

	lea	eax, DWORD PTR [edx+edx*2]
	mov	DWORD PTR [esi+4], edi
	mov	ecx, DWORD PTR [edi]
	shl	eax, 5
	add	eax, DWORD PTR [ecx+256]

; 789  :       tc->cnum = c;

	mov	DWORD PTR [esi+12], edx

; 790  :       tc->sub_sampling = subs = tc->comp_info->sub_sampling;
; 791  :       min = dims.pos; lim = min + dims.size;

	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR [esi+8], eax
	mov	edi, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax+4]
	mov	DWORD PTR [esi+16], edi
	mov	DWORD PTR [esi+20], ecx
	mov	eax, DWORD PTR [edx+164]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	esi, DWORD PTR [edx+172]
	mov	ebx, DWORD PTR [edx+168]
	add	esi, eax
	add	ebx, DWORD PTR [edx+160]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h

; 179  :   if (num <= 0)

	test	eax, eax
	jg	SHORT $LN152@initialize

; 180  :     return -((-num)/den);

	cdq
	idiv	ecx
	jmp	SHORT $LN308@initialize
$LN152@initialize:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	ecx
	inc	eax
$LN308@initialize:
	mov	DWORD PTR _min$2$[ebp], eax

; 179  :   if (num <= 0)

	test	esi, esi
	jg	SHORT $LN156@initialize

; 180  :     return -((-num)/den);

	mov	eax, esi
	cdq
	idiv	ecx
	mov	ecx, eax
	jmp	SHORT $LN157@initialize
$LN156@initialize:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [esi-1]
	cdq
	idiv	ecx
	lea	ecx, DWORD PTR [eax+1]
$LN157@initialize:

; 179  :   if (num <= 0)

	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [edx+160]
	test	eax, eax
	jg	SHORT $LN160@initialize

; 180  :     return -((-num)/den);

	cdq
	idiv	edi
	mov	esi, eax
	jmp	SHORT $LN161@initialize
$LN160@initialize:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	edi
	lea	esi, DWORD PTR [eax+1]
$LN161@initialize:

; 179  :   if (num <= 0)

	test	ebx, ebx
	jg	SHORT $LN164@initialize

; 180  :     return -((-num)/den);

	mov	eax, ebx
	cdq
	idiv	edi
	jmp	SHORT $LN165@initialize
$LN164@initialize:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	lea	eax, DWORD PTR [ebx-1]
	cdq
	idiv	edi
	inc	eax
$LN165@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 794  :       tc->dims.pos = min; tc->dims.size = lim - min;

	mov	edi, DWORD PTR _tc$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	eax, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 794  :       tc->dims.pos = min; tc->dims.size = lim - min;

	mov	edx, DWORD PTR _min$2$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ecx, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 796  :       kdu_params *coc = cod->access_relation(t_num,c,0,true);

	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	push	1
	mov	DWORD PTR [edi+24], esi
	mov	esi, DWORD PTR _c$3$[ebp]
	push	0
	mov	DWORD PTR [edi+36], ecx
	mov	ecx, DWORD PTR _cod$2$[ebp]
	push	esi
	mov	DWORD PTR [edi+28], edx
	mov	DWORD PTR [edi+32], eax
	push	DWORD PTR [ebx+4]
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 797  :       kdu_params *qcc = qcd->access_relation(t_num,c,0,true);

	mov	ecx, DWORD PTR _qcd$2$[ebp]
	push	1
	push	0
	push	esi
	push	DWORD PTR [ebx+4]
	mov	DWORD PTR _coc$1$[ebp], eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 798  :       kdu_params *rgc = rgn->access_relation(t_num,c,0,true);

	mov	ecx, DWORD PTR _rgn$2$[ebp]
	push	1
	push	0
	push	esi
	push	DWORD PTR [ebx+4]
	mov	DWORD PTR _qcc$1$[ebp], eax
	call	?access_relation@kdu_params@@QAEPAV1@HHH_N@Z ; kdu_params::access_relation

; 799  :       assert((coc != NULL) && (qcc != NULL) && (rgc != NULL));
; 800  : 
; 801  :       bool use_precincts;
; 802  :       bool derived_quant;
; 803  :       float base_delta = 0.0F;
; 804  :       int atk_idx=0;
; 805  :       if (!(coc->get(Clevels,0,0,tc->dwt_levels) &&

	mov	ecx, DWORD PTR _coc$1$[ebp]
	lea	esi, DWORD PTR [edi+56]
	push	1
	push	1
	push	1
	push	esi
	push	0
	push	0
	push	OFFSET ??_C@_07BGFFFHMP@Clevels?$AA@
	mov	DWORD PTR _rgc$1$[ebp], eax
	mov	DWORD PTR _base_delta$10[ebp], 0
	mov	DWORD PTR _atk_idx$12[ebp], 0
	mov	DWORD PTR tv3538[ebp], esi
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN43@initialize
	mov	ecx, DWORD PTR _coc$1$[ebp]
	lea	eax, DWORD PTR [edi+64]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0M@ODOOFFGJ@Creversible?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	$LN43@initialize
	mov	ecx, DWORD PTR _coc$1$[ebp]
	lea	eax, DWORD PTR [edi+68]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08IDCJHBJK@Ckernels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	$LN43@initialize
	mov	ecx, DWORD PTR _coc$1$[ebp]
	lea	eax, DWORD PTR _use_precincts$23[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0P@LMCGKBAC@Cuse_precincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	$LN43@initialize
	mov	ecx, DWORD PTR _coc$1$[ebp]
	lea	eax, DWORD PTR [edi+132]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN43@initialize
	mov	ecx, DWORD PTR _coc$1$[ebp]
	lea	eax, DWORD PTR [edi+136]
	push	1
	push	1
	push	1
	push	eax
	push	1
	push	0
	push	OFFSET ??_C@_04HAGFJFNL@Cblk?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN43@initialize
	mov	ecx, DWORD PTR _coc$1$[ebp]
	lea	eax, DWORD PTR [edi+140]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06EGDCPANH@Cmodes?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN43@initialize
	mov	ecx, DWORD PTR _coc$1$[ebp]
	lea	eax, DWORD PTR _atk_idx$12[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_04HAOFMIPN@Catk?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN43@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 135  :     kdu_kernels() { clear(); }

	lea	ecx, DWORD PTR _kernels$40[ebp]
	call	?clear@kdu_kernels@@AAEXXZ		; kdu_kernels::clear
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 816  :       tc->initialize_kernel_parameters(atk_idx,kernels);

	lea	eax, DWORD PTR _kernels$40[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 2
	push	eax
	push	DWORD PTR _atk_idx$12[ebp]
	mov	ecx, edi
	call	?initialize_kernel_parameters@kd_tile_comp@@QAEXHAAVkdu_kernels@@@Z ; kd_tile_comp::initialize_kernel_parameters

; 817  : 
; 818  :       if ((!tc->reversible) &&

	cmp	BYTE PTR [edi+64], 0
	jne	$LN44@initialize
	mov	ecx, DWORD PTR _qcc$1$[ebp]
	lea	eax, DWORD PTR _derived_quant$39[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_08CCOBJCLJ@Qderived?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAA_N_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN45@initialize
	cmp	BYTE PTR _derived_quant$39[ebp], 0
	je	SHORT $LN44@initialize
	mov	ecx, DWORD PTR _qcc$1$[ebp]
	lea	eax, DWORD PTR _base_delta$10[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN44@initialize
$LN45@initialize:

; 821  :         { KDU_ERROR(e,2); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$34[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$34[ebp]
	lea	ecx, DWORD PTR _e$34[ebp]
	push	OFFSET ??_C@_0BHA@JBHJNMJO@Tile?9components?5which?5are?5compre@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 821  :         { KDU_ERROR(e,2); e <<

	mov	BYTE PTR __$EHRec$[ebp+8], 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 829  :         }

	lea	ecx, DWORD PTR _e$34[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN44@initialize:

; 830  :       int roi_levels;
; 831  :       if ((codestream->in != NULL) || !rgc->get(Rlevels,0,0,roi_levels))

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN47@initialize
	mov	ecx, DWORD PTR _rgc$1$[ebp]
	lea	eax, DWORD PTR _roi_levels$11[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07KGEEGGHK@Rlevels?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN46@initialize
$LN47@initialize:

; 832  :         roi_levels = 0;

	mov	DWORD PTR _roi_levels$11[ebp], 0
$LN46@initialize:

; 833  :       float comp_weight;
; 834  :       if (!coc->get(Cweight,0,0,comp_weight))

	mov	ecx, DWORD PTR _coc$1$[ebp]
	lea	eax, DWORD PTR _comp_weight$22[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_07HDHNGJDI@Cweight?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN48@initialize

; 835  :         comp_weight = 1.0F;

	mov	DWORD PTR _comp_weight$22[ebp], 1065353216 ; 3f800000H
$LN48@initialize:

; 836  :       tc->apparent_dwt_levels = tc->dwt_levels;

	mov	eax, DWORD PTR [esi]
	mov	DWORD PTR [edi+60], eax

; 837  :       if (tc->dwt_levels < codestream->min_dwt_levels)

	mov	ecx, DWORD PTR [ebx]
	cmp	eax, DWORD PTR [ecx+192]
	jge	SHORT $LN49@initialize

; 838  :         codestream->min_dwt_levels = tc->dwt_levels;

	mov	DWORD PTR [ecx+192], eax
$LN49@initialize:

; 839  :       if (tc->reversible)

	cmp	BYTE PTR [edi+64], 0
	je	SHORT $LN50@initialize

; 840  :         tc->recommended_extra_bits = 4 + ((use_ycc)?1:0);

	xor	eax, eax
	cmp	BYTE PTR [ebx+226], al
	setne	al
	add	eax, 4
	mov	DWORD PTR [edi+128], eax

; 841  :       else

	jmp	SHORT $LN51@initialize
$LN50@initialize:

; 842  :         tc->recommended_extra_bits = 7;

	mov	DWORD PTR [edi+128], 7
$LN51@initialize:

; 843  : 
; 844  :       // Run some profile consistency checks.
; 845  :       if (codestream->profile == 0)

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+104]
	test	eax, eax
	jne	SHORT $LN52@initialize

; 846  :         {
; 847  :           if ((tc->blk.x != tc->blk.y) ||

	mov	eax, DWORD PTR [edi+136]
	cmp	eax, DWORD PTR [edi+132]
	jne	SHORT $LN56@initialize
	cmp	eax, 32					; 00000020H
	je	SHORT $LN54@initialize
	cmp	eax, 64					; 00000040H
	jne	SHORT $LN56@initialize
$LN54@initialize:

; 850  :                 KDU_TXT("Profile violation detected (code-stream is "
; 851  :                 "technically illegal).  Profile-0 code-streams must have "
; 852  :                 "nominally square code-block dimensions, measuring 32x32 or "
; 853  :                 "64x64.  You should set \"Sprofile\" to 1 or 2.");
; 854  :               codestream->profile = 2; // Prevent further profile warnings.
; 855  :             }
; 856  :           else if (tc->modes & (Cmodes_BYPASS|Cmodes_RESET|Cmodes_CAUSAL))

	test	BYTE PTR [edi+140], 11			; 0000000bH
	je	$LN59@initialize

; 857  :             { KDU_WARNING(w,1); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$32[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
	mov	BYTE PTR __$EHRec$[ebp+8], 5
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0MC@OOKHAIOM@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 863  :             }

	jmp	SHORT $LN309@initialize
$LN56@initialize:

; 848  :               ((tc->blk.x != 32) && (tc->blk.x != 64)))
; 849  :             { KDU_WARNING(w,0); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$33[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
	mov	BYTE PTR __$EHRec$[ebp+8], 4
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0ML@FMBEAHIM@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 864  :         }

	jmp	SHORT $LN309@initialize
$LN52@initialize:

; 865  :       else if (codestream->profile == 1)

	cmp	eax, 1
	jne	SHORT $LN59@initialize

; 866  :         {
; 867  :           if ((tc->blk.x > 64) || (tc->blk.y > 64))

	cmp	DWORD PTR [edi+136], 64			; 00000040H
	jg	SHORT $LN60@initialize
	cmp	DWORD PTR [edi+132], 64			; 00000040H
	jle	SHORT $LN59@initialize
$LN60@initialize:

; 868  :             { KDU_WARNING(w,2); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$31[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
	mov	BYTE PTR __$EHRec$[ebp+8], 6
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	push	OFFSET ??_C@_0KN@KMCHIBHI@Profile?5violation?5detected?5?$CIcode@
$LN309@initialize:
	mov	eax, DWORD PTR _w$31[ebp]
	lea	ecx, DWORD PTR _w$31[ebp]
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 873  :               codestream->profile = 2; // Prevent further profile warnings.

	mov	eax, DWORD PTR [ebx]

; 874  :             }

	lea	ecx, DWORD PTR _w$31[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR [eax+104], 2
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN59@initialize:

; 875  :         }
; 876  :       if ((codestream->profile != 3) && (coding_origin.x || coding_origin.y))

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+104], 3
	je	SHORT $LN61@initialize
	cmp	DWORD PTR [ebx+196], 0
	jne	SHORT $LN62@initialize
	cmp	DWORD PTR [ebx+192], 0
	je	SHORT $LN61@initialize
$LN62@initialize:

; 877  :         { KDU_WARNING(w,3); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$30[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$30[ebp]
	lea	ecx, DWORD PTR _w$30[ebp]
	push	OFFSET ??_C@_0PN@ECKJOGL@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 877  :         { KDU_WARNING(w,3); w <<

	mov	BYTE PTR __$EHRec$[ebp+8], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 883  :           codestream->profile = 3;

	mov	eax, DWORD PTR [ebx]

; 884  :         }

	lea	ecx, DWORD PTR _w$30[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR [eax+104], 3
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN61@initialize:

; 885  : 
; 886  :       // Find multi-component energy gain terms, if we are a compressor
; 887  :       if (codestream->out != NULL)

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN63@initialize

; 888  :         tc->G_tc = find_multicomponent_energy_gain(c,false);

	push	0
	push	DWORD PTR _c$3$[ebp]
	mov	ecx, ebx
	call	?find_multicomponent_energy_gain@kd_tile@@AAEMH_N@Z ; kd_tile::find_multicomponent_energy_gain
	fstp	DWORD PTR [edi+120]
$LN63@initialize:

; 889  : 
; 890  :       // Build the layer_stats array
; 891  :       if (codestream->in != NULL)

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN184@initialize

; 892  :         {
; 893  :           tc->layer_stats = new kdu_long[((1+tc->dwt_levels)*num_layers)<<1];

	mov	eax, DWORD PTR [esi]
	xor	ecx, ecx
	inc	eax
	mov	edx, 8
	imul	eax, DWORD PTR [ebx+132]
	add	eax, eax
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	push	ecx
	call	??_U@YAPAXI@Z				; operator new[]
	mov	edx, eax
	add	esp, 4
	mov	DWORD PTR [edi+148], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2957 :         if (layer_stats != NULL)

	test	edx, edx
	je	SHORT $LN184@initialize

; 2958 :           {
; 2959 :             int num_entries = ((1+dwt_levels)*tile->num_layers)<<1;

	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [esi]
	inc	eax
	imul	eax, DWORD PTR [ecx+132]
	add	eax, eax

; 2960 :             memset(layer_stats,0,(size_t)(sizeof(kdu_long)*num_entries));

	shl	eax, 3
	push	eax
	push	0
	push	edx
	call	_memset
	add	esp, 12					; 0000000cH
$LN184@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 899  :       tc->resolutions = new kd_resolution[tc->dwt_levels+1];

	mov	esi, DWORD PTR [esi]
	xor	ecx, ecx
	inc	esi
	mov	edx, 604				; 0000025cH
	mov	eax, esi
	mov	DWORD PTR $T5[ebp], esi
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T4[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 8
	test	eax, eax
	je	SHORT $LN114@initialize
	push	OFFSET ??1kd_resolution@@QAE@XZ		; kd_resolution::~kd_resolution
	push	OFFSET ??0kd_resolution@@QAE@XZ		; kd_resolution::kd_resolution
	push	esi
	lea	edi, DWORD PTR [eax+4]
	mov	DWORD PTR [eax], esi
	push	604					; 0000025cH
	push	edi
	call	??_L@YGXPAXIIP6EX0@Z1@Z
	jmp	SHORT $LN115@initialize
$LN114@initialize:
	xor	edi, edi
$LN115@initialize:
	mov	esi, DWORD PTR _tc$1$[ebp]

; 900  :       for (r=tc->dwt_levels; r >= 0; r--)

	mov	ebx, DWORD PTR [esi+56]
	lea	ecx, DWORD PTR [esi+56]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR [esi+144], edi
	test	ebx, ebx
	js	$LN12@initialize
	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
$LL13@initialize:

; 901  :         {
; 902  :           kd_resolution *res = tc->resolutions + r;
; 903  : 
; 904  :           new_structure_bytes += (int) sizeof(*res);
; 905  : 
; 906  :           res->codestream = codestream;

	mov	eax, DWORD PTR [edx]
	imul	edi, ebx, 604
	add	edi, DWORD PTR [esi+144]
	add	DWORD PTR _new_structure_bytes$1$[ebp], 604 ; 0000025cH
	adc	DWORD PTR _new_structure_bytes$2$[ebp], 0
	mov	DWORD PTR [edi], eax

; 907  :           res->tile_comp = tc;

	mov	DWORD PTR [edi+4], esi

; 908  :           res->res_level = (kdu_byte) r;

	mov	BYTE PTR [edi+12], bl

; 909  :           res->dwt_level = (kdu_byte)(tc->dwt_levels - ((r==0)?0:(r-1)));

	test	ebx, ebx
	jne	SHORT $LN116@initialize
	xor	ecx, ecx
	jmp	SHORT $LN117@initialize
$LN116@initialize:
	lea	ecx, DWORD PTR [ebx-1]
$LN117@initialize:
	mov	al, BYTE PTR [esi+56]
	lea	edx, DWORD PTR [esi+56]
	sub	al, cl
	mov	BYTE PTR [edi+13], al

; 910  :           res->hor_depth = tc->comp_info->hor_depth[tc->dwt_levels-r];

	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	al, BYTE PTR [ecx+eax+21]
	mov	BYTE PTR [edi+14], al

; 911  :           res->vert_depth = tc->comp_info->vert_depth[tc->dwt_levels-r];

	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [esi+8]
	sub	ecx, ebx
	mov	al, BYTE PTR [ecx+eax+54]
	mov	BYTE PTR [edi+15], al

; 912  :           res->propagate_roi = (res->dwt_level <= roi_levels);

	movzx	eax, BYTE PTR [edi+13]
	cmp	eax, DWORD PTR _roi_levels$11[ebp]
	setle	al
	mov	BYTE PTR [edi+172], al

; 913  : 
; 914  :           if (r == tc->dwt_levels)

	cmp	ebx, DWORD PTR [edx]
	jne	SHORT $LN65@initialize

; 915  :             {
; 916  :               res->node.parent = NULL;

	mov	DWORD PTR [edi+16], 0

; 917  :               res->node.dims = tc->dims;

	movups	xmm0, XMMWORD PTR [esi+24]

; 918  :             }
; 919  :           else

	jmp	$LN310@initialize
$LN65@initialize:

; 920  :             {
; 921  :               res->node.parent = &(res[1].node);
; 922  :               res->node.parent->children[LL_BAND] = &(res->node);
; 923  :               res->node.branch_x =

	mov	ecx, DWORD PTR _tc$1$[ebp]
	lea	eax, DWORD PTR [edi+620]
	mov	DWORD PTR [edi+16], eax
	lea	esi, DWORD PTR [edi+16]
	mov	DWORD PTR [eax+76], esi
	mov	edx, DWORD PTR [edx]
	mov	ecx, DWORD PTR [ecx+8]
	sub	edx, ebx
	mov	al, BYTE PTR [edi+14]
	cmp	al, BYTE PTR [edx+ecx+20]

; 924  :                 (res->hor_depth ==
; 925  :                  tc->comp_info->hor_depth[tc->dwt_levels-r-1])?2:0;
; 926  :               res->node.branch_y =

	mov	edx, DWORD PTR tv3538[ebp]
	setne	al
	dec	al
	and	al, 2
	mov	BYTE PTR [edi+56], al
	mov	eax, DWORD PTR _tc$1$[ebp]
	mov	edx, DWORD PTR [edx]
	sub	edx, ebx
	mov	ecx, DWORD PTR [eax+8]
	mov	al, BYTE PTR [edi+15]
	cmp	al, BYTE PTR [edx+ecx+53]
	setne	al
	dec	al
	and	al, 2
	mov	BYTE PTR [edi+57], al

; 927  :                 (res->vert_depth ==
; 928  :                  tc->comp_info->vert_depth[tc->dwt_levels-r-1])?2:0;
; 929  :               res->node.dims =

	movzx	eax, al
	mov	DWORD PTR _branch_y$1$[ebp], eax
	movzx	eax, BYTE PTR [edi+56]
	mov	DWORD PTR _branch_x$1$[ebp], eax
	mov	eax, DWORD PTR [esi]
	movups	xmm1, XMMWORD PTR [eax+8]

; 122  :   kdu_coords min = parent_dims.pos;

	movaps	xmm0, xmm1
	movd	edx, xmm1
	psrldq	xmm0, 4
	movd	esi, xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	psrldq	xmm1, 8
	movd	ecx, xmm0
	movd	eax, xmm1
	add	ecx, esi
	add	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 125  :   if ((branch_x & ~1) == 0)

	test	DWORD PTR _branch_x$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN187@initialize

; 126  :     { // Parent node is split horizontally
; 127  :       min.x -= (branch_x)?high_support_max:low_support_max;
; 128  :       lim.x -= (branch_x)?high_support_min:low_support_min;
; 129  :       min.x = (min.x + 1 - branch_x) >> 1;

	sub	esi, DWORD PTR _branch_x$1$[ebp]

; 130  :       lim.x = (lim.x + 1 - branch_x) >> 1;

	sub	ecx, DWORD PTR _branch_x$1$[ebp]
	inc	esi
	inc	ecx
	sar	esi, 1
	sar	ecx, 1
$LN187@initialize:

; 131  :     }
; 132  : 
; 133  :   if ((branch_y & ~1) == 0)

	test	DWORD PTR _branch_y$1$[ebp], -2		; fffffffeH
	jne	SHORT $LN188@initialize

; 134  :     { // Parent node is split vertically
; 135  :       min.y -= (branch_y)?high_support_max:low_support_max;
; 136  :       lim.y -= (branch_y)?high_support_min:low_support_min;
; 137  :       min.y = (min.y + 1 - branch_y) >> 1;

	sub	edx, DWORD PTR _branch_y$1$[ebp]

; 138  :       lim.y = (lim.y + 1 - branch_y) >> 1;

	sub	eax, DWORD PTR _branch_y$1$[ebp]
	inc	edx
	inc	eax
	sar	edx, 1
	sar	eax, 1
$LN188@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ecx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 142  :   result.pos = min;

	mov	DWORD PTR $T6[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 142  :   result.pos = min;

	mov	DWORD PTR $T6[ebp+4], esi

; 143  :   result.size = lim-min;

	mov	DWORD PTR $T6[ebp+8], eax
	mov	DWORD PTR $T6[ebp+12], ecx

; 927  :                 (res->vert_depth ==
; 928  :                  tc->comp_info->vert_depth[tc->dwt_levels-r-1])?2:0;
; 929  :               res->node.dims =

	movups	xmm0, XMMWORD PTR $T6[ebp]
$LN310@initialize:

; 930  :                 get_child_dims(res->node.parent->dims,
; 931  :                                res->node.branch_x,res->node.branch_y);
; 932  :             }
; 933  :           res->build_decomposition_structure(coc,kernels);

	lea	eax, DWORD PTR _kernels$40[ebp]
	mov	ecx, edi
	push	eax
	push	DWORD PTR _coc$1$[ebp]
	movups	XMMWORD PTR [edi+24], xmm0
	call	?build_decomposition_structure@kd_resolution@@QAEXPAVkdu_params@@AAVkdu_kernels@@@Z ; kd_resolution::build_decomposition_structure

; 934  : 
; 935  :           // Set up precincts.
; 936  :           res->precinct_partition.pos = coding_origin;

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [ecx+192]
	mov	DWORD PTR [edi+120], eax
	mov	eax, DWORD PTR [ecx+196]
	mov	DWORD PTR [edi+124], eax

; 937  :           if (!use_precincts)

	cmp	BYTE PTR _use_precincts$23[ebp], 0
	jne	SHORT $LN67@initialize

; 938  :             {
; 939  :               res->precinct_partition.size.x = 1<<15;

	mov	DWORD PTR [edi+132], 32768		; 00008000H

; 940  :               res->precinct_partition.size.y = 1<<15;

	mov	DWORD PTR [edi+128], 32768		; 00008000H
	jmp	SHORT $LN70@initialize
$LN67@initialize:

; 941  :             }
; 942  :           else if (!(coc->get(Cprecincts,tc->dwt_levels-r,0,

	mov	esi, DWORD PTR tv3538[ebp]
	lea	eax, DWORD PTR [edi+128]
	mov	ecx, DWORD PTR _coc$1$[ebp]
	push	1
	push	1
	push	1
	push	eax
	mov	eax, DWORD PTR [esi]
	push	0
	sub	eax, ebx
	push	eax
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	je	SHORT $LN70@initialize
	mov	ecx, DWORD PTR _coc$1$[ebp]
	lea	eax, DWORD PTR [edi+132]
	push	1
	push	1
	push	1
	push	eax
	mov	eax, DWORD PTR [esi]
	push	1
	sub	eax, ebx
	push	eax
	push	OFFSET ??_C@_0L@KGBLICHL@Cprecincts?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
$LN70@initialize:

; 943  :                               res->precinct_partition.size.y) &&
; 944  :                      coc->get(Cprecincts,tc->dwt_levels-r,1,
; 945  :                               res->precinct_partition.size.x)))
; 946  :             assert(0);
; 947  :           check_coding_partition(res->precinct_partition);

	movups	xmm0, XMMWORD PTR [edi+120]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	movups	XMMWORD PTR [eax], xmm0
	call	?check_coding_partition@@YAXUkdu_dims@@@Z ; check_coding_partition

; 948  :           res->precinct_indices = res->region_indices =

	movups	xmm0, XMMWORD PTR [edi+24]
	mov	eax, esp
	sub	esp, 16					; 00000010H
	movups	XMMWORD PTR [eax], xmm0
	mov	eax, esp
	movups	xmm0, XMMWORD PTR [edi+120]
	movups	XMMWORD PTR [eax], xmm0
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	?get_partition_indices@@YA?AUkdu_dims@@U1@0@Z ; get_partition_indices
	add	esp, 36					; 00000024H
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [edi+152], xmm0
	movups	xmm0, XMMWORD PTR [eax]
	movups	XMMWORD PTR [edi+136], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [edi+148]
	imul	DWORD PTR [edi+144]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 951  :           kdu_long num_precincts = res->precinct_indices.area();

	mov	DWORD PTR _num_precincts$2$[ebp], edx
	mov	esi, eax

; 952  :           if (num_precincts > (1<<30))

	test	edx, edx
	jl	SHORT $LN71@initialize
	jg	SHORT $LN298@initialize
	cmp	esi, 1073741824				; 40000000H
	jbe	SHORT $LN71@initialize
$LN298@initialize:

; 953  :             { KDU_ERROR(e,0x07110802); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$29[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$29[ebp]
	lea	ecx, DWORD PTR _e$29[ebp]
	push	OFFSET ??_C@_0BBK@KIFKIPEK@Tile?9component?9resolution?5encoun@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 953  :             { KDU_ERROR(e,0x07110802); e <<

	mov	BYTE PTR __$EHRec$[ebp+8], 9
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 961  :             }

	lea	ecx, DWORD PTR _e$29[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN71@initialize:

; 962  :           res->precinct_refs = new kd_precinct_ref[(int)num_precincts];

	xor	ecx, ecx
	mov	DWORD PTR $T15[ebp], esi
	mov	eax, esi
	mov	edx, 8
	mul	edx
	seto	cl
	neg	ecx
	or	ecx, eax
	xor	eax, eax
	add	ecx, 4
	setb	al
	neg	eax
	or	eax, ecx
	push	eax
	call	??_U@YAPAXI@Z				; operator new[]
	add	esp, 4
	mov	DWORD PTR $T8[ebp], eax
	mov	BYTE PTR __$EHRec$[ebp+8], 10		; 0000000aH
	test	eax, eax
	je	SHORT $LN118@initialize
	push	OFFSET ??1kd_precinct_ref@@QAE@XZ	; kd_precinct_ref::~kd_precinct_ref
	push	OFFSET ??0kd_precinct_ref@@QAE@XZ	; kd_precinct_ref::kd_precinct_ref
	push	esi
	mov	DWORD PTR [eax], esi
	add	eax, 4
	push	8
	push	eax
	mov	DWORD PTR $T14[ebp], eax
	call	??_L@YGXPAXIIP6EX0@Z1@Z
	mov	eax, DWORD PTR $T14[ebp]
	jmp	SHORT $LN119@initialize
$LN118@initialize:
	xor	eax, eax
$LN119@initialize:

; 963  :           this->total_precincts += num_precincts;

	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR [edi+180], eax
	mov	eax, DWORD PTR _num_precincts$2$[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	add	DWORD PTR [edx+144], esi
	adc	DWORD PTR [edx+148], eax

; 964  :           new_structure_bytes += num_precincts * sizeof(kd_precinct_ref);

	shld	eax, esi, 3
	shl	esi, 3
	add	DWORD PTR _new_structure_bytes$1$[ebp], esi
	adc	DWORD PTR _new_structure_bytes$2$[ebp], eax

; 965  : 
; 966  :           // Run profile checks.
; 967  :           if ((r == 0) && (c < 4) && (codestream->profile < 2) &&

	test	ebx, ebx
	jne	$LN72@initialize
	cmp	DWORD PTR _c$3$[ebp], 4
	jge	$LN72@initialize
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+104], 2
	jge	SHORT $LN72@initialize
	mov	ecx, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [edi+36]
	imul	eax, DWORD PTR [ecx+20]
	cmp	eax, 128				; 00000080H
	jg	SHORT $LN73@initialize
	mov	eax, DWORD PTR [edi+32]
	imul	eax, DWORD PTR [ecx+16]
	cmp	eax, 128				; 00000080H
	jle	SHORT $LN72@initialize
$LN73@initialize:

; 972  :             { KDU_WARNING(w,4); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$28[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$28[ebp]
	lea	ecx, DWORD PTR _w$28[ebp]
	push	OFFSET ??_C@_0BBP@FFHCNMHP@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 972  :             { KDU_WARNING(w,4); w <<

	mov	BYTE PTR __$EHRec$[ebp+8], 11		; 0000000bH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 979  :               codestream->profile = 2;

	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]

; 980  :             }

	lea	ecx, DWORD PTR _w$28[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax+104], 2
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
$LN72@initialize:

; 983  :               (res->node.dims.size.y <= 128) &&

	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+104], 0
	jne	$LN11@initialize
	cmp	DWORD PTR [edi+36], 128			; 00000080H
	jg	SHORT $LN11@initialize
	cmp	DWORD PTR [edi+32], 128			; 00000080H
	jg	SHORT $LN11@initialize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [edi+148]
	imul	DWORD PTR [edi+144]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 983  :               (res->node.dims.size.y <= 128) &&

	test	edx, edx
	jl	SHORT $LN304@initialize
	jg	SHORT $LN299@initialize
	cmp	eax, 1
	jbe	SHORT $LN304@initialize
$LN299@initialize:

; 985  :             { KDU_WARNING(w,5); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$27[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$27[ebp]
	lea	ecx, DWORD PTR _w$27[ebp]
	push	OFFSET ??_C@_0MJ@MHJOJOLI@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 985  :             { KDU_WARNING(w,5); w <<

	mov	BYTE PTR __$EHRec$[ebp+8], 12		; 0000000cH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 990  :               codestream->profile = 2;

	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]

; 991  :             }

	lea	ecx, DWORD PTR _w$27[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [eax+104], 2
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
$LN304@initialize:
	mov	edx, DWORD PTR _this$GSCopy$1$[ebp]
$LN11@initialize:

; 900  :       for (r=tc->dwt_levels; r >= 0; r--)

	sub	ebx, 1
	mov	esi, DWORD PTR _tc$1$[ebp]
	jns	$LL13@initialize
	mov	ecx, DWORD PTR tv3538[ebp]
$LN12@initialize:

; 1000 :       bool can_flip = true;
; 1001 :       for (r=0; r <= tc->dwt_levels; r++)

	xor	edx, edx
	mov	DWORD PTR _cumulative_subbands$1$[ebp], 0
	mov	al, 1
	mov	DWORD PTR _r$2$[ebp], edx
	mov	BYTE PTR _can_flip$1$[ebp], al
	cmp	DWORD PTR [ecx], edx
	jl	$LN15@initialize

; 992  :         } // End of resolution loop.
; 993  : 
; 994  :       // Next, walk up from the lowest resolution, initializing the
; 995  :       // parameters for each subband and propagating `kd_resolution::can_flip'
; 996  :       // information, node and leaf counts.  The subband weights were already
; 997  :       // installed above, since they appear in order from highest to lowest
; 998  :       // resolution, rather than lowest to highest.
; 999  :       int cumulative_subbands = 0;

	xor	edi, edi
	mov	DWORD PTR tv3432[ebp], edi
	npad	9
$LL16@initialize:

; 1002 :         {
; 1003 :           kd_resolution *res = tc->resolutions + r;

	mov	ebx, DWORD PTR [esi+144]
	add	ebx, edi
	mov	DWORD PTR _res$1$[ebp], ebx

; 1004 :           if (!can_flip)

	test	al, al
	jne	SHORT $LN75@initialize

; 1005 :             res->can_flip = false;

	mov	BYTE PTR [ebx+173], al
	jmp	SHORT $LN77@initialize
$LN75@initialize:

; 1006 :           else if (!res->can_flip)

	cmp	BYTE PTR [ebx+173], 0
	jne	SHORT $LN77@initialize

; 1007 :             {
; 1008 :               can_flip = false; // Higher resolutions also cannot be flipped
; 1009 :               codestream->cannot_flip = true;

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	BYTE PTR _can_flip$1$[ebp], 0
	mov	eax, DWORD PTR [eax]
	mov	BYTE PTR [eax+224], 1
$LN77@initialize:

; 1010 :             }
; 1011 :           if (r > 0)

	test	edx, edx
	jle	SHORT $LN78@initialize

; 1012 :             {
; 1013 :               res->node.num_descendant_leaves +=

	mov	eax, DWORD PTR [esi+144]
	movzx	eax, WORD PTR [eax+edi-492]
	add	WORD PTR [ebx+112], ax

; 1014 :                 tc->resolutions[r-1].node.num_descendant_leaves;
; 1015 :               res->node.num_descendant_nodes += 1 +

	mov	eax, DWORD PTR [esi+144]
	movzx	eax, WORD PTR [eax+edi-494]
	inc	ax
	add	WORD PTR [ebx+110], ax
$LN78@initialize:

; 1016 :                 tc->resolutions[r-1].node.num_descendant_nodes;
; 1017 :             }
; 1018 : 
; 1019 :           // Get energy weighting parameters.
; 1020 :           float level_weight;
; 1021 :           if (!coc->get(Clev_weights,tc->dwt_levels-r,0,level_weight))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _level_weight$13[ebp]
	push	eax
	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR _coc$1$[ebp]
	sub	eax, edx
	push	0
	push	eax
	push	OFFSET ??_C@_0N@HICBBPMC@Clev_weights?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN301@initialize

; 1022 :             level_weight = 1.0;

	movss	xmm0, DWORD PTR __real@3f800000
	jmp	SHORT $LN79@initialize
$LN301@initialize:
	movss	xmm0, DWORD PTR _level_weight$13[ebp]
$LN79@initialize:

; 1023 :           level_weight *= comp_weight;

	mulss	xmm0, DWORD PTR _comp_weight$22[ebp]

; 1024 : 
; 1025 :           // Scan through the subbands
; 1026 :           for (b=0; b < res->num_subbands; b++)

	mov	DWORD PTR _b$1$[ebp], 0
	movss	DWORD PTR _level_weight$13[ebp], xmm0
	cmp	BYTE PTR [ebx+174], 0
	jbe	$LN18@initialize

; 1023 :           level_weight *= comp_weight;

	mov	ecx, DWORD PTR _cumulative_subbands$1$[ebp]
	xor	edx, edx
	mov	DWORD PTR tv3435[ebp], ecx
	mov	DWORD PTR tv3434[ebp], edx
	npad	8
$LL19@initialize:

; 1027 :             {
; 1028 :               kd_subband *band = res->subbands + b;

	mov	edi, DWORD PTR [ebx+184]
	add	edi, edx

; 1029 :               assert(band->resolution == res);
; 1030 : 
; 1031 :               // Find quantization parameters for the subband
; 1032 :               int kmax, eps, abs_band_idx = cumulative_subbands + b;
; 1033 :               if (tc->reversible)

	cmp	BYTE PTR [esi+64], 0
	je	SHORT $LN80@initialize

; 1034 :                 {
; 1035 :                   if (!qcc->get(Qabs_ranges,abs_band_idx,0,eps))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _eps$9[ebp]
	push	eax
	push	0
	push	ecx
	mov	ecx, DWORD PTR _qcc$1$[ebp]
	push	OFFSET ??_C@_0M@FADGJEKJ@Qabs_ranges?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 1036 :                     assert(0);
; 1037 :                   band->epsilon = (kdu_byte) eps;

	mov	al, BYTE PTR _eps$9[ebp]

; 1038 :                   band->delta = 1.0F / ((float)(1<<tc->comp_info->precision));

	movss	xmm1, DWORD PTR __real@3f800000
	mov	BYTE PTR [edi+49], al
	mov	eax, 1
	mov	ecx, DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [ecx+16]
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR [edi+52], xmm1

; 1039 :                          // Fake delta value created here ensures that the
; 1040 :                          // weights returned by `kdu_subband::get_msb_wmse'
; 1041 :                          // have the same significance for reversibly and
; 1042 :                          // irreversibly generated subband samples.
; 1043 :                 }
; 1044 :               else

	jmp	$LN21@initialize
$LN80@initialize:

; 1045 :                 {
; 1046 :                   float delta;
; 1047 :                   if (derived_quant)

	cmp	BYTE PTR _derived_quant$39[ebp], 0
	je	$LN83@initialize

; 1048 :                     {
; 1049 :                       int sum_depths =
; 1050 :                         res->hor_depth + (band->descriptor & 3) +
; 1051 :                         res->vert_depth + ((band->descriptor >> 8) & 3);
; 1052 :                       sum_depths -= tc->comp_info->hor_depth[tc->dwt_levels];
; 1053 :                       sum_depths -= tc->comp_info->vert_depth[tc->dwt_levels];

	mov	edx, DWORD PTR [esi+56]
	mov	ecx, DWORD PTR [esi+8]
	movzx	ebx, BYTE PTR [ebx+15]
	movsx	esi, WORD PTR [edi+44]

; 1054 : 
; 1055 :                       // Set `delta' = `base_delta' / 2^{sum_depths/2}
; 1056 :                       delta = base_delta;

	movss	xmm1, DWORD PTR _base_delta$10[ebp]
	movzx	eax, BYTE PTR [edx+ecx+54]
	sub	ebx, eax
	movss	DWORD PTR _delta$2$[ebp], xmm1
	movzx	eax, BYTE PTR [edx+ecx+21]
	sub	ebx, eax
	mov	eax, DWORD PTR _res$1$[ebp]
	movzx	eax, BYTE PTR [eax+14]
	add	ebx, eax
	mov	eax, esi
	sar	eax, 8
	and	esi, 3
	and	eax, 3
	add	ebx, eax
	add	ebx, esi

; 1057 :                       if (sum_depths & 1)

	test	bl, 1
	je	SHORT $LN85@initialize

; 1058 :                         {
; 1059 :                           sum_depths++;
; 1060 :                           delta *= (float) sqrt(2.0);

	movsd	xmm0, QWORD PTR __real@4000000000000000
	inc	ebx
	call	__libm_sse2_sqrt_precise
	movss	xmm1, DWORD PTR _delta$2$[ebp]
	cvtsd2ss xmm0, xmm0
	mulss	xmm1, xmm0
$LN85@initialize:

; 1061 :                         }
; 1062 :                       sum_depths >>= 1;

	sar	ebx, 1

; 1063 :                       if (sum_depths > 0)
; 1064 :                         delta /= (float)(1<<sum_depths);

	mov	eax, 1
	test	ebx, ebx
	jle	SHORT $LN86@initialize
	mov	ecx, ebx

; 1065 :                       else

	mov	ebx, DWORD PTR _res$1$[ebp]
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	divss	xmm1, xmm0
	movss	DWORD PTR _delta$35[ebp], xmm1
	jmp	SHORT $LN88@initialize
$LN86@initialize:

; 1066 :                         delta *= (float)(1<<(-sum_depths));

	neg	ebx
	mov	ecx, ebx
	mov	ebx, DWORD PTR _res$1$[ebp]
	shl	eax, cl
	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	mulss	xmm1, xmm0
	movss	DWORD PTR _delta$35[ebp], xmm1
	jmp	SHORT $LN88@initialize
$LN83@initialize:

; 1067 :                     }
; 1068 :                   else if (!qcc->get(Qabs_steps,abs_band_idx,0,delta))

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _delta$35[ebp]
	push	eax
	push	0
	push	ecx
	mov	ecx, DWORD PTR _qcc$1$[ebp]
	push	OFFSET ??_C@_0L@ELEFPJIC@Qabs_steps?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	movss	xmm1, DWORD PTR _delta$35[ebp]
$LN88@initialize:

; 1069 :                     assert(0);
; 1070 :                   assert(delta > 0.0F);
; 1071 :                   band->delta = delta;
; 1072 :                   for (band->epsilon=0; delta < 1.0F; delta*=2.0F)

	movss	xmm0, DWORD PTR __real@3f800000
	comiss	xmm0, xmm1
	mov	BYTE PTR [edi+49], 0
	movss	DWORD PTR [edi+52], xmm1
	jbe	SHORT $LN21@initialize
	movss	xmm2, DWORD PTR __real@40000000
	xor	al, al
	npad	5
$LL22@initialize:
	mulss	xmm1, xmm2

; 1073 :                     band->epsilon++;

	add	al, 1
	comiss	xmm0, xmm1
	ja	SHORT $LL22@initialize

; 1069 :                     assert(0);
; 1070 :                   assert(delta > 0.0F);
; 1071 :                   band->delta = delta;
; 1072 :                   for (band->epsilon=0; delta < 1.0F; delta*=2.0F)

	movss	DWORD PTR _delta$35[ebp], xmm1
	mov	BYTE PTR [edi+49], al
$LN21@initialize:

; 1074 :                   assert(delta < 2.0F);
; 1075 :                 }
; 1076 : 
; 1077 :               if (!qcc->get(Qguard,0,0,kmax))

	mov	ecx, DWORD PTR _qcc$1$[ebp]
	lea	eax, DWORD PTR _kmax$21[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06BGIMBACE@Qguard?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get

; 1078 :                 assert(0);
; 1079 :               band->K_max = (kdu_byte) kmax;

	mov	al, BYTE PTR _kmax$21[ebp]

; 1080 : 
; 1081 :               if (!rgc->get(Rweight,0,0,band->roi_weight))

	lea	esi, DWORD PTR [edi+64]
	mov	ecx, DWORD PTR _rgc$1$[ebp]
	push	1
	push	1
	push	1
	push	esi
	push	0
	push	0
	push	OFFSET ??_C@_07MDGMFIIN@Rweight?$AA@
	mov	BYTE PTR [edi+50], al
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN90@initialize

; 1082 :                 band->roi_weight = -1.0F; // Indicates no ROI weights.

	mov	DWORD PTR [esi], -1082130432		; bf800000H
$LN90@initialize:

; 1083 :               band->K_max += band->epsilon;
; 1084 :               band->K_max -= 1;

	mov	al, BYTE PTR [edi+49]

; 1085 :               if (!rgc->get(Rshift,0,0,kmax))

	mov	ecx, DWORD PTR _rgc$1$[ebp]
	dec	al
	add	BYTE PTR [edi+50], al
	lea	eax, DWORD PTR _kmax$21[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	0
	push	OFFSET ??_C@_06LDAKCIBF@Rshift?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAH_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN91@initialize

; 1086 :                 kmax = 0;

	xor	ecx, ecx
	mov	DWORD PTR _kmax$21[ebp], ecx
	jmp	SHORT $LN93@initialize
$LN91@initialize:

; 1087 :               else if ((kmax > 37) && (codestream->profile < 2))

	mov	ecx, DWORD PTR _kmax$21[ebp]
	cmp	ecx, 37					; 00000025H
	jle	SHORT $LN93@initialize
	mov	esi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [esi]
	cmp	DWORD PTR [eax+104], 2
	jge	SHORT $LN93@initialize

; 1088 :                 { KDU_WARNING(w,6); w <<

	push	OFFSET ??_C@_0BG@JPDDDEGK@Kakadu?5Core?5Warning?3?6?$AA@
	lea	ecx, DWORD PTR _w$26[ebp]
	call	??0kdu_warning@@QAE@PBD@Z		; kdu_warning::kdu_warning
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _w$26[ebp]
	lea	ecx, DWORD PTR _w$26[ebp]
	push	OFFSET ??_C@_0JM@NAEKEAHJ@Profile?5violation?5detected?5?$CIcode@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1088 :                 { KDU_WARNING(w,6); w <<

	mov	BYTE PTR __$EHRec$[ebp+8], 13		; 0000000dH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1093 :                   codestream->profile = 2;

	mov	eax, DWORD PTR [esi]

; 1094 :                 }

	lea	ecx, DWORD PTR _w$26[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	mov	DWORD PTR [eax+104], 2
	call	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
	mov	ecx, DWORD PTR _kmax$21[ebp]
$LN93@initialize:

; 1095 :               band->K_max_prime = (kdu_byte)(kmax + band->K_max);

	mov	al, BYTE PTR [edi+50]
	add	al, cl
	mov	BYTE PTR [edi+51], al

; 1096 :               if (codestream->in != NULL)

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN94@initialize

; 1097 :                 band->W_b = band->G_b = 0.0F;

	mov	DWORD PTR [edi+56], 0
	mov	DWORD PTR [edi+60], 0

; 1098 :               else

	jmp	$LN95@initialize
$LN94@initialize:

; 1099 :                 {
; 1100 :                   int weights_idx = 3*res->dwt_level - band->orientation;

	movzx	eax, BYTE PTR [ebx+13]

; 1101 : 
; 1102 :                   if (!coc->get(Cband_weights,weights_idx,0,band->W_b))

	lea	esi, DWORD PTR [edi+60]
	push	1
	push	1
	push	1
	lea	ecx, DWORD PTR [eax+eax*2]
	movzx	eax, BYTE PTR [edi+46]
	push	esi
	sub	ecx, eax
	push	0
	push	ecx
	mov	ecx, DWORD PTR _coc$1$[ebp]
	push	OFFSET ??_C@_0O@GLALLHKC@Cband_weights?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	test	al, al
	jne	SHORT $LN96@initialize

; 1103 :                     band->W_b = 1.0F;

	mov	DWORD PTR [esi], 1065353216		; 3f800000H
$LN96@initialize:

; 1104 :                   band->W_b *= level_weight;

	movss	xmm0, DWORD PTR _level_weight$13[ebp]
	mulss	xmm0, DWORD PTR [esi]
	movss	DWORD PTR [esi], xmm0

; 1105 :                   if (res->res_level == 0)

	cmp	BYTE PTR [ebx+12], 0
	jne	SHORT $LN97@initialize

; 1106 :                     band->W_b = comp_weight; // Don't tamper with DC band.

	movss	xmm0, DWORD PTR _comp_weight$22[ebp]
	movss	DWORD PTR [esi], xmm0
$LN97@initialize:

; 1107 : 
; 1108 :                   bool extra_stage_high[3];
; 1109 :                   extra_stage_high[0] = ((band->descriptor>>2)&1)?true:false;

	movzx	ecx, WORD PTR [edi+44]
	mov	al, cl
	sar	al, 2
	and	al, 1
	mov	BYTE PTR _extra_stage_high$37[ebp], al

; 1110 :                   extra_stage_high[1] = ((band->descriptor>>3)&1)?true:false;

	mov	al, cl
	sar	al, 3
	and	al, 1
	mov	BYTE PTR _extra_stage_high$37[ebp+1], al

; 1111 :                   extra_stage_high[2] = ((band->descriptor>>4)&1)?true:false;

	mov	al, cl
	sar	al, 4

; 1112 :                   band->G_b = (float)

	and	ecx, 3
	and	al, 1
	mov	BYTE PTR _extra_stage_high$37[ebp+2], al
	lea	eax, DWORD PTR _extra_stage_high$37[ebp]
	push	eax
	movzx	eax, BYTE PTR [ebx+14]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _kernels$40[ebp]
	call	?get_energy_gain@kdu_kernels@@QAENHHQA_N@Z ; kdu_kernels::get_energy_gain

; 1113 :                     kernels.get_energy_gain(res->hor_depth,
; 1114 :                                             band->descriptor&3,
; 1115 :                                             extra_stage_high);
; 1116 :                   extra_stage_high[0] = ((band->descriptor>>10)&1)?true:false;

	movzx	ecx, WORD PTR [edi+44]
	mov	eax, ecx
	sar	eax, 10					; 0000000aH
	and	al, 1
	mov	BYTE PTR _extra_stage_high$37[ebp], al

; 1117 :                   extra_stage_high[1] = ((band->descriptor>>11)&1)?true:false;

	mov	eax, ecx
	sar	eax, 11					; 0000000bH
	and	al, 1
	mov	BYTE PTR _extra_stage_high$37[ebp+1], al

; 1118 :                   extra_stage_high[2] = ((band->descriptor>>12)&1)?true:false;

	mov	eax, ecx
	sar	eax, 12					; 0000000cH
	and	al, 1

; 1119 :                   band->G_b *= (float)

	sar	ecx, 8
	mov	BYTE PTR _extra_stage_high$37[ebp+2], al
	and	ecx, 3
	lea	eax, DWORD PTR _extra_stage_high$37[ebp]
	push	eax
	fstp	DWORD PTR [edi+56]
	movzx	eax, BYTE PTR [ebx+15]
	push	ecx
	push	eax
	lea	ecx, DWORD PTR _kernels$40[ebp]
	call	?get_energy_gain@kdu_kernels@@QAENHHQA_N@Z ; kdu_kernels::get_energy_gain
	fstp	DWORD PTR tv3727[ebp]
	fld	DWORD PTR tv3727[ebp]
	fmul	DWORD PTR [edi+56]
	fstp	DWORD PTR [edi+56]
$LN95@initialize:

; 1120 :                     kernels.get_energy_gain(res->vert_depth,
; 1121 :                                             (band->descriptor>>8)&3,
; 1122 :                                             extra_stage_high);
; 1123 :                 }
; 1124 : 
; 1125 :               // Now determine code-block partition parameters for the subband.
; 1126 :               band->block_partition.pos = res->precinct_partition.pos;

	mov	eax, DWORD PTR [ebx+120]

; 1127 :               band->block_partition.size = tc->blk;

	mov	ecx, DWORD PTR _tc$1$[ebp]

; 1128 :               int hor_splits = (band->descriptor&3);

	movsx	esi, WORD PTR [edi+44]
	mov	DWORD PTR [edi+68], eax
	mov	eax, DWORD PTR [ebx+124]
	mov	DWORD PTR [edi+72], eax
	mov	eax, DWORD PTR [ecx+132]
	mov	DWORD PTR [edi+76], eax
	mov	eax, DWORD PTR [ecx+136]
	mov	DWORD PTR [edi+80], eax
	mov	eax, esi

; 1129 :               int vert_splits = ((band->descriptor>>8)&3);

	sar	esi, 8
	and	eax, 3
	and	esi, 3
	mov	DWORD PTR _hor_splits$1$[ebp], eax

; 1130 :               if (res->res_level > 0)

	cmp	BYTE PTR [ebx+12], 0
	jbe	SHORT $LN98@initialize

; 1131 :                 {
; 1132 :                   band->block_partition.size.x <<= hor_splits;

	mov	ecx, eax
	shl	DWORD PTR [edi+80], cl

; 1133 :                   band->block_partition.size.y <<= vert_splits;

	mov	ecx, esi
	shl	DWORD PTR [edi+76], cl
$LN98@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	eax, DWORD PTR [edi+76]
	add	eax, DWORD PTR [edi+68]
	mov	edx, DWORD PTR _res$1$[ebp]
	mov	ebx, DWORD PTR [edi+80]
	add	ebx, DWORD PTR [edi+72]
	mov	DWORD PTR $T38[ebp], eax
	mov	eax, DWORD PTR _res$1$[ebp]
	mov	ecx, DWORD PTR [eax+124]
	mov	eax, DWORD PTR [eax+132]
	add	eax, ecx
	mov	DWORD PTR tv3486[ebp], ecx
	mov	ecx, DWORD PTR _res$1$[ebp]
	mov	ecx, DWORD PTR [ecx+120]
	add	ecx, DWORD PTR [edx+128]

; 326  :       /* [SYNOPSIS]
; 327  :          Returns the product of the horizontal and vertical dimensions. */
; 328  :     void transpose()
; 329  :       { size.transpose(); pos.transpose(); }
; 330  :       /* [SYNOPSIS]
; 331  :          Swap the roles played by horizontal and vertical coordinates. */
; 332  :     kdu_dims operator&(kdu_dims &rhs) // Intersects region with RHS.
; 333  :       { kdu_dims result = *this; result &= rhs; return result; }
; 334  :       /* [SYNOPSIS]
; 335  :            Returns the intersection of the region represented by `rhs' with
; 336  :            that represented by the current object.
; 337  :       */
; 338  :     kdu_dims intersection(kdu_dims &rhs)
; 339  :       { /* [SYNOPSIS] Same as `operator&', but more appropriate for
; 340  :                       some language bindings. */
; 341  :         return (*this) & rhs;
; 342  :       }
; 343  :     kdu_dims operator&=(kdu_dims &rhs) // Returns intersection of operands
; 344  :       {
; 345  :       /* [SYNOPSIS]
; 346  :            Intersects the region represented by `rhs' with that  represented
; 347  :            by the current object.
; 348  :       */
; 349  :         kdu_coords lim = pos+size;
; 350  :         kdu_coords rhs_lim = rhs.pos + rhs.size;
; 351  :         if (lim.x > rhs_lim.x) lim.x = rhs_lim.x;

	cmp	ebx, eax
	cmovg	ebx, eax

; 352  :         if (lim.y > rhs_lim.y) lim.y  = rhs_lim.y;

	mov	eax, DWORD PTR $T38[ebp]
	cmp	eax, ecx
	cmovg	eax, ecx
	mov	DWORD PTR $T38[ebp], eax

; 353  :         if (pos.x < rhs.pos.x) pos.x = rhs.pos.x;

	mov	eax, DWORD PTR tv3486[ebp]
	cmp	DWORD PTR [edi+72], eax
	jge	SHORT $LN219@initialize
	mov	DWORD PTR [edi+72], eax
$LN219@initialize:

; 354  :         if (pos.y < rhs.pos.y) pos.y = rhs.pos.y;

	mov	ecx, DWORD PTR _res$1$[ebp]
	mov	eax, DWORD PTR [ecx+120]
	cmp	DWORD PTR [edi+68], eax
	jge	SHORT $LN220@initialize
	mov	DWORD PTR [edi+68], eax
$LN220@initialize:

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	ebx, DWORD PTR [edi+72]
	mov	eax, DWORD PTR $T38[ebp]
	sub	eax, DWORD PTR [edi+68]

; 355  :         size = lim-pos;

	mov	DWORD PTR [edi+76], eax
	mov	DWORD PTR [edi+80], ebx

; 356  :         if (size.x < 0) size.x = 0;

	test	ebx, ebx
	jge	SHORT $LN221@initialize
	mov	DWORD PTR [edi+80], 0
$LN221@initialize:

; 357  :         if (size.y < 0) size.y = 0;

	test	eax, eax
	jge	SHORT $LN222@initialize
	mov	DWORD PTR [edi+76], 0
$LN222@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1136 :               band->blocks_per_precinct.x =

	mov	eax, DWORD PTR [ecx+132]
	mov	ebx, DWORD PTR [edi+80]
	cdq
	idiv	ebx
	mov	DWORD PTR [edi+120], eax

; 1137 :                 res->precinct_partition.size.x / band->block_partition.size.x;
; 1138 :               band->blocks_per_precinct.y =

	mov	eax, DWORD PTR _res$1$[ebp]
	mov	eax, DWORD PTR [eax+128]
	cdq
	idiv	DWORD PTR [edi+76]
	mov	DWORD PTR [edi+116], eax

; 1139 :                 res->precinct_partition.size.y / band->block_partition.size.y;
; 1140 :               if (res->res_level > 0)

	mov	eax, DWORD PTR _res$1$[ebp]
	cmp	BYTE PTR [eax+12], 0
	jbe	SHORT $LN102@initialize

; 1141 :                 {
; 1142 :                   if (band->descriptor & (7<<2))

	movzx	eax, WORD PTR [edi+44]
	test	al, 28					; 0000001cH
	je	SHORT $LN100@initialize

; 1143 :                     band->block_partition.pos.x = 0;

	mov	DWORD PTR [edi+72], 0
$LN100@initialize:

; 1144 :                   if (band->descriptor & (7<<10))

	test	eax, 7168				; 00001c00H
	je	SHORT $LN101@initialize

; 1145 :                     band->block_partition.pos.y = 0;

	mov	DWORD PTR [edi+68], 0
$LN101@initialize:

; 1146 :                   band->block_partition.size.x >>= hor_splits;

	mov	ecx, DWORD PTR _hor_splits$1$[ebp]

; 1147 :                   band->block_partition.size.y >>= vert_splits;

	mov	eax, DWORD PTR [edi+76]
	sar	ebx, cl
	mov	ecx, esi
	sar	eax, cl
	mov	DWORD PTR [edi+80], ebx
	mov	DWORD PTR [edi+76], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	test	ebx, ebx
	jle	SHORT $LN238@initialize
	test	eax, eax
	jle	SHORT $LN238@initialize
	xor	al, al
	jmp	SHORT $LN239@initialize
$LN238@initialize:
	mov	al, 1
$LN239@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1148 :                   if (!band->block_partition)

	test	al, al
	je	SHORT $LN102@initialize

; 1149 :                     { KDU_ERROR(e,0x25050501); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$25[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$25[ebp]
	lea	ecx, DWORD PTR _e$25[ebp]
	push	OFFSET ??_C@_0KN@HAEBDHLJ@Precinct?5partition?5dimensions?5to@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1149 :                     { KDU_ERROR(e,0x25050501); e <<

	mov	BYTE PTR __$EHRec$[ebp+8], 14		; 0000000eH
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1154 :                     }

	lea	ecx, DWORD PTR _e$25[ebp]
	mov	BYTE PTR __$EHRec$[ebp+8], 2
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN102@initialize:

; 1155 :                 }
; 1156 :               check_coding_partition(band->block_partition);

	movups	xmm0, XMMWORD PTR [edi+68]
	sub	esp, 16					; 00000010H
	mov	eax, esp
	movups	XMMWORD PTR [eax], xmm0
	call	?check_coding_partition@@YAXUkdu_dims@@@Z ; check_coding_partition

; 1157 :               band->block_indices = 

	movups	xmm0, XMMWORD PTR [edi+8]
	mov	eax, esp
	sub	esp, 16					; 00000010H
	movups	XMMWORD PTR [eax], xmm0
	mov	eax, esp
	movups	xmm0, XMMWORD PTR [edi+68]
	movups	XMMWORD PTR [eax], xmm0
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	?get_partition_indices@@YA?AUkdu_dims@@U1@0@Z ; get_partition_indices

; 1158 :                 get_partition_indices(band->block_partition,band->dims);
; 1159 :               band->log2_blocks_per_precinct = kdu_coords(0,0);
; 1160 :               while ((1<<band->log2_blocks_per_precinct.x) <

	mov	edx, DWORD PTR [edi+120]
	add	esp, 36					; 00000024H
	movups	xmm0, XMMWORD PTR [eax]
	mov	DWORD PTR [edi+128], 0
	mov	eax, 1
	mov	ecx, DWORD PTR [edi+128]
	shl	eax, cl
	mov	DWORD PTR [edi+124], 0
	movups	XMMWORD PTR [edi+84], xmm0
	cmp	eax, edx
	jge	SHORT $LN268@initialize
	npad	1
$LL23@initialize:

; 1161 :                      band->blocks_per_precinct.x)
; 1162 :                 band->log2_blocks_per_precinct.x++;

	inc	ecx
	mov	eax, 1
	shl	eax, cl
	cmp	eax, edx
	jl	SHORT $LL23@initialize
	mov	DWORD PTR [edi+128], ecx
$LN268@initialize:

; 1163 :               while ((1<<band->log2_blocks_per_precinct.y) <

	mov	ecx, DWORD PTR [edi+124]
	mov	eax, 1
	mov	edx, DWORD PTR [edi+116]
	shl	eax, cl
	cmp	eax, edx
	jge	SHORT $LN17@initialize
$LL25@initialize:

; 1164 :                      band->blocks_per_precinct.y)
; 1165 :                 band->log2_blocks_per_precinct.y++;

	inc	ecx
	mov	eax, 1
	shl	eax, cl
	cmp	eax, edx
	jl	SHORT $LL25@initialize
	mov	DWORD PTR [edi+124], ecx
$LN17@initialize:

; 1024 : 
; 1025 :           // Scan through the subbands
; 1026 :           for (b=0; b < res->num_subbands; b++)

	mov	ebx, DWORD PTR _res$1$[ebp]
	mov	esi, DWORD PTR _b$1$[ebp]
	mov	edx, DWORD PTR tv3434[ebp]
	inc	esi
	mov	ecx, DWORD PTR tv3435[ebp]
	add	edx, 132				; 00000084H
	movzx	eax, BYTE PTR [ebx+174]
	inc	ecx
	mov	DWORD PTR _b$1$[ebp], esi
	cmp	esi, eax
	mov	esi, DWORD PTR _tc$1$[ebp]
	mov	DWORD PTR tv3434[ebp], edx
	mov	DWORD PTR tv3435[ebp], ecx
	jl	$LL19@initialize
	mov	edi, DWORD PTR tv3432[ebp]
$LN18@initialize:

; 1166 :             }
; 1167 :           cumulative_subbands += res->num_subbands;

	movzx	eax, BYTE PTR [ebx+174]

; 1168 :           res->complete_initialization();

	mov	ecx, ebx
	add	DWORD PTR _cumulative_subbands$1$[ebp], eax
	call	?complete_initialization@kd_resolution@@QAEXXZ ; kd_resolution::complete_initialization
	mov	edx, DWORD PTR _r$2$[ebp]
	lea	ecx, DWORD PTR [esi+56]
	mov	al, BYTE PTR _can_flip$1$[ebp]
	inc	edx
	add	edi, 604				; 0000025cH
	mov	DWORD PTR _r$2$[ebp], edx
	mov	DWORD PTR tv3432[ebp], edi
	cmp	edx, DWORD PTR [ecx]
	jle	$LL16@initialize
$LN15@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 147  :     ~kdu_kernels() { reset(); }

	lea	ecx, DWORD PTR _kernels$40[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], 15		; 0000000fH
	call	?reset@kdu_kernels@@AAEXXZ		; kdu_kernels::reset
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 777  :   for (c=0; c < num_components; c++, tc++)

	mov	edx, DWORD PTR _c$3$[ebp]
	add	esi, 188				; 000000bcH
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	inc	edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h

; 147  :     ~kdu_kernels() { reset(); }

	mov	DWORD PTR __$EHRec$[ebp+8], -1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 777  :   for (c=0; c < num_components; c++, tc++)

	mov	DWORD PTR _c$3$[ebp], edx
	mov	DWORD PTR _tc$1$[ebp], esi
	cmp	edx, DWORD PTR [edi+128]
	jl	$LL10@initialize
$LN9@initialize:

; 1169 :         }
; 1170 :     } // End of tile-component loop.
; 1171 : 
; 1172 :   // Perform any parameter consistency checks.
; 1173 : 
; 1174 :   if (use_ycc)

	cmp	BYTE PTR [edi+226], 0
	je	$LN104@initialize

; 1175 :     {
; 1176 :      if ((num_components < 3) ||
; 1177 :          (comps[0].reversible != comps[1].reversible) ||
; 1178 :          (comps[1].reversible != comps[2].reversible) ||
; 1179 :          (comps[0].sub_sampling != comps[1].sub_sampling) ||

	cmp	DWORD PTR [edi+128], 3
	jl	SHORT $LN253@initialize
	mov	ecx, DWORD PTR [edi+208]
	mov	al, BYTE PTR [ecx+252]
	cmp	BYTE PTR [ecx+64], al
	jne	SHORT $LN253@initialize
	cmp	al, BYTE PTR [ecx+440]
	jne	SHORT $LN253@initialize
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 258  :       { return (x!=rhs.x) || (y!=rhs.y); }

	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR [ecx+208]
	jne	SHORT $LN253@initialize
	mov	eax, DWORD PTR [ecx+16]
	cmp	eax, DWORD PTR [ecx+204]
	jne	SHORT $LN253@initialize
	mov	eax, DWORD PTR [ecx+208]
	cmp	eax, DWORD PTR [ecx+396]
	jne	SHORT $LN253@initialize
	mov	eax, DWORD PTR [ecx+204]
	cmp	eax, DWORD PTR [ecx+392]
	je	SHORT $LN104@initialize
$LN253@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1181 :        { KDU_ERROR(e,4); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$24[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$24[ebp]
	lea	ecx, DWORD PTR _e$24[ebp]
	push	OFFSET ??_C@_0GC@GCDNIPCG@Illegal?5colour?5transform?5specifi@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1181 :        { KDU_ERROR(e,4); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 16		; 00000010H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1184 :        }

	lea	ecx, DWORD PTR _e$24[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN104@initialize:

; 1185 :     }
; 1186 : 
; 1187 :   // Now set up the packet sequencing machinery. Note that packet
; 1188 :   // sequencing is performed incrementally, rather than up front.
; 1189 : 
; 1190 :   max_relevant_layers = num_layers; // May be reduced later
; 1191 :   max_relevant_packets = total_precincts * num_layers; // May be reduced later

	push	DWORD PTR [edi+148]
	mov	eax, DWORD PTR [edi+132]
	push	DWORD PTR [edi+144]
	mov	DWORD PTR [edi+140], eax
	cdq
	push	edx
	push	eax
	call	__allmul

; 1192 :   initialized = true;
; 1193 :   sequenced_relevant_packets = 0;
; 1194 :   next_input_packet_num = 0;
; 1195 :   skipping_to_sop = false;
; 1196 :   sequencer = new kd_packet_sequencer(this);

	push	176					; 000000b0H
	mov	DWORD PTR [edi+152], eax
	mov	DWORD PTR [edi+156], edx
	mov	BYTE PTR [edi+233], 1
	mov	DWORD PTR [edi+248], 0
	mov	DWORD PTR [edi+252], 0
	mov	BYTE PTR [edi+256], 0
	call	??2@YAPAXI@Z				; operator new
	add	esp, 4
	mov	DWORD PTR $T7[ebp], eax
	mov	DWORD PTR __$EHRec$[ebp+8], 17		; 00000011H
	test	eax, eax
	je	SHORT $LN120@initialize
	push	edi
	mov	ecx, eax
	call	??0kd_packet_sequencer@@QAE@PAUkd_tile@@@Z ; kd_packet_sequencer::kd_packet_sequencer
	jmp	SHORT $LN121@initialize
$LN120@initialize:
	xor	eax, eax
$LN121@initialize:

; 1197 : 
; 1198 :   new_structure_bytes += (int) sizeof(*sequencer);

	mov	ecx, DWORD PTR _new_structure_bytes$1$[ebp]
	mov	edx, DWORD PTR _new_structure_bytes$2$[ebp]
	add	ecx, 176				; 000000b0H
	mov	DWORD PTR [edi+52], eax

; 1199 :   assert(structure_bytes == 0);
; 1200 :   structure_bytes += new_structure_bytes;
; 1201 :   codestream->buf_server->augment_structure_bytes(new_structure_bytes);

	mov	eax, DWORD PTR [edi]
	adc	edx, 0
	add	DWORD PTR [edi+216], ecx
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	adc	DWORD PTR [edi+220], edx
	mov	eax, DWORD PTR [eax+24]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	add	DWORD PTR [eax+32], ecx

; 281  :         if (structure_bytes > peak_structure_bytes)

	mov	ecx, DWORD PTR [eax+32]
	adc	DWORD PTR [eax+36], edx
	mov	edx, DWORD PTR [eax+36]
	cmp	edx, DWORD PTR [eax+44]
	jl	SHORT $LN258@initialize
	jg	SHORT $LN300@initialize
	cmp	ecx, DWORD PTR [eax+40]
	jbe	SHORT $LN258@initialize
$LN300@initialize:

; 282  :           peak_structure_bytes = structure_bytes;

	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+44], edx
$LN258@initialize:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 1203 :   if (!codestream->persistent)

	mov	eax, DWORD PTR [edi]
	cmp	BYTE PTR [eax+337], 0
	jne	SHORT $LN106@initialize

; 1204 :     set_elements_of_interest(); // May change `max_relevant_packets/layers'

	mov	ecx, edi
	call	?set_elements_of_interest@kd_tile@@AAEXXZ ; kd_tile::set_elements_of_interest
$LN106@initialize:

; 1205 :   if (read_failure)

	cmp	BYTE PTR _read_failure$1$[ebp], 0
	je	SHORT $LN107@initialize

; 1206 :     finished_reading();

	mov	ecx, edi
	call	?finished_reading@kd_tile@@QAE_NXZ	; kd_tile::finished_reading
$LN107@initialize:

; 1207 : 
; 1208 :   fully_typical = is_typical = codestream->siz->check_typical_tile(t_num);

	mov	ecx, DWORD PTR [edi]
	push	0
	push	DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [ecx+12]
	call	?check_typical_tile@kdu_params@@QAE_NHPBD@Z ; kdu_params::check_typical_tile
	mov	BYTE PTR [edi+124], al
	mov	BYTE PTR [edi+125], al

; 1209 :   if (!fully_typical)

	test	al, al
	jne	SHORT $LN108@initialize

; 1210 :     is_typical =

	mov	ecx, DWORD PTR [edi]
	push	OFFSET ??_C@_07HDMBGKJA@QCD?3RGN?$AA@
	push	DWORD PTR [edi+4]
	mov	ecx, DWORD PTR [ecx+12]
	call	?check_typical_tile@kdu_params@@QAE_NHPBD@Z ; kdu_params::check_typical_tile
	mov	BYTE PTR [edi+124], al
$LN108@initialize:

; 1211 :       codestream->siz->check_typical_tile(t_num,(QCD_params ":" RGN_params));
; 1212 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$0:
	xor	ebx, ebx
	mov	eax, DWORD PTR $T17[ebp]
	mov	ecx, 808				; 00000328H
	mul	ecx
	seto	bl
	neg	ebx
	or	ebx, eax
	xor	eax, eax
	add	ebx, 4
	setb	al
	neg	eax
	or	eax, ebx
	push	eax
	mov	eax, DWORD PTR $T20[ebp]
	push	eax
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	ret	0
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$1:
	xor	ebx, ebx
	mov	eax, DWORD PTR $T16[ebp]
	mov	ecx, 188				; 000000bcH
	mul	ecx
	seto	bl
	neg	ebx
	or	ebx, eax
	xor	eax, eax
	add	ebx, 4
	setb	al
	neg	eax
	or	eax, ebx
	push	eax
	mov	eax, DWORD PTR $T19[ebp]
	push	eax
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	ret	0
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$2:
	lea	ecx, DWORD PTR _kernels$40[ebp]
	jmp	??1kdu_kernels@@QAE@XZ			; kdu_kernels::~kdu_kernels
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$3:
	lea	ecx, DWORD PTR _e$34[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$5:
	lea	ecx, DWORD PTR _w$32[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$4:
	lea	ecx, DWORD PTR _w$33[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$6:
	lea	ecx, DWORD PTR _w$31[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$7:
	lea	ecx, DWORD PTR _w$30[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$8:
	xor	ebx, ebx
	mov	eax, DWORD PTR $T5[ebp]
	mov	ecx, 604				; 0000025cH
	mul	ecx
	seto	bl
	neg	ebx
	or	ebx, eax
	xor	eax, eax
	add	ebx, 4
	setb	al
	neg	eax
	or	eax, ebx
	push	eax
	mov	eax, DWORD PTR $T4[ebp]
	push	eax
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	ret	0
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$9:
	lea	ecx, DWORD PTR _e$29[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$10:
	xor	ebx, ebx
	mov	eax, DWORD PTR $T15[ebp]
	mov	ecx, 8
	mul	ecx
	seto	bl
	neg	ebx
	or	ebx, eax
	xor	eax, eax
	add	ebx, 4
	setb	al
	neg	eax
	or	eax, ebx
	push	eax
	mov	eax, DWORD PTR $T8[ebp]
	push	eax
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	ret	0
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$11:
	lea	ecx, DWORD PTR _w$28[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$12:
	lea	ecx, DWORD PTR _w$27[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$13:
	lea	ecx, DWORD PTR _w$26[ebp]
	jmp	??1kdu_warning@@UAE@XZ			; kdu_warning::~kdu_warning
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$14:
	lea	ecx, DWORD PTR _e$25[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$17:
	call	___std_terminate
	ret	0
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$15:
	lea	ecx, DWORD PTR _e$24[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?initialize@kd_tile@@QAEXXZ$16:
	push	176					; 000000b0H
	mov	eax, DWORD PTR $T7[ebp]
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	ret	0
__ehhandler$?initialize@kd_tile@@QAEXXZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-828]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?initialize@kd_tile@@QAEXXZ
	jmp	___CxxFrameHandler3
text$x	ENDS
?initialize@kd_tile@@QAEXXZ ENDP			; kd_tile::initialize
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?release@kd_tile@@QAEXXZ
_TEXT	SEGMENT
_this$GSCopy$1$ = -120					; size = 4
_tc$1$ = -116						; size = 4
_res$1$ = -112						; size = 4
_num_precincts$1$ = -108				; size = 4
_this$1$ = -104						; size = 4
tv643 = -100						; size = 4
_r$1$ = -96						; size = 4
tv642 = -92						; size = 4
_c$1$ = -88						; size = 4
_text$1 = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
?release@kd_tile@@QAEXXZ PROC				; kd_tile::release, COMDAT
; _this$ = ecx

; 597  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 120				; 00000078H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], ebx

; 598  :   assert((tile_ref != NULL) && (this != codestream->active_tile));
; 599  :   if ((codestream->in == NULL) || empty_shell || !is_typical)

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+4], 0
	je	$LN14@release
	cmp	BYTE PTR [ebx+227], 0
	jne	$LN14@release
	cmp	BYTE PTR [ebx+124], 0
	je	$LN14@release

; 600  :     {
; 601  :       delete this;
; 602  :       return;
; 603  :     }
; 604  : 
; 605  :   // If we get here, we are committed to entering the tile on the released
; 606  :   // typical tile cache.  To do this, we first need to delete all the
; 607  :   // elements which are specific to an individual tile.
; 608  :   tpart_ptrs = NULL;
; 609  : 
; 610  :   if (ppt_markers != NULL)

	push	esi
	mov	esi, DWORD PTR [ebx+44]
	mov	DWORD PTR [ebx+20], 0
	test	esi, esi
	je	SHORT $LN15@release

; 611  :     {
; 612  :       delete ppt_markers;
; 613  :       ppt_markers = NULL;

	mov	ecx, esi
	call	??1kd_pp_markers@@QAE@XZ		; kd_pp_markers::~kd_pp_markers
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
	mov	DWORD PTR [ebx+44], 0
$LN15@release:

; 614  :     }
; 615  :   if (packed_headers != NULL)

	mov	ecx, DWORD PTR [ebx+48]
	test	ecx, ecx
	je	SHORT $LN16@release

; 616  :     {
; 617  :       delete packed_headers;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]

; 618  :       packed_headers = NULL;

	mov	DWORD PTR [ebx+48], 0
$LN16@release:

; 619  :     }
; 620  :   if (sequencer != NULL)

	mov	eax, DWORD PTR [ebx+52]
	test	eax, eax
	je	SHORT $LN17@release

; 621  :     {
; 622  :       delete sequencer;

	push	176					; 000000b0H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8

; 623  :       sequencer = NULL;

	mov	DWORD PTR [ebx+52], 0
$LN17@release:

; 624  :     }
; 625  :   precinct_pointer_server.restart();

	lea	ecx, DWORD PTR [ebx+56]
	call	?restart@kd_precinct_pointer_server@@QAEXXZ ; kd_precinct_pointer_server::restart

; 626  : 
; 627  :   for (int c=0; c < num_components; c++)

	xor	eax, eax
	mov	DWORD PTR _c$1$[ebp], eax
	cmp	DWORD PTR [ebx+128], eax
	jle	$LN3@release

; 624  :     }
; 625  :   precinct_pointer_server.restart();

	xor	ecx, ecx
	mov	DWORD PTR tv642[ebp], ecx
	push	edi
$LL4@release:

; 628  :     {
; 629  :       kd_tile_comp *tc = comps + c;

	mov	esi, DWORD PTR [ebx+208]
	add	esi, ecx
	mov	DWORD PTR _tc$1$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2957 :         if (layer_stats != NULL)

	mov	edx, DWORD PTR [esi+148]
	test	edx, edx
	je	SHORT $LN43@release

; 2958 :           {
; 2959 :             int num_entries = ((1+dwt_levels)*tile->num_layers)<<1;
; 2960 :             memset(layer_stats,0,(size_t)(sizeof(kdu_long)*num_entries));

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi+56]
	inc	ecx
	imul	ecx, DWORD PTR [eax+132]
	shl	ecx, 4
	push	ecx
	push	0
	push	edx
	call	_memset
	mov	eax, DWORD PTR _c$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR tv642[ebp]
$LN43@release:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 631  :       for (int r=0; r <= tc->dwt_levels; r++)

	xor	edx, edx
	mov	DWORD PTR _r$1$[ebp], edx
	cmp	DWORD PTR [esi+56], edx
	jl	$LN2@release
	xor	eax, eax
	mov	DWORD PTR tv643[ebp], eax
	npad	5
$LL7@release:

; 632  :         {
; 633  :           kd_resolution *res = tc->resolutions + r;

	mov	ecx, DWORD PTR [esi+144]

; 635  :           for (int p=0; p < num_precincts; p++)

	xor	ebx, ebx
	add	ecx, eax
	mov	DWORD PTR _res$1$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [ecx+148]
	imul	eax, DWORD PTR [ecx+144]
	mov	DWORD PTR _num_precincts$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 635  :           for (int p=0; p < num_precincts; p++)

	test	eax, eax
	jle	$LN5@release
	npad	11
$LL10@release:
	mov	eax, DWORD PTR [ecx+180]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4671 :   if (state && !(state & 1))

	mov	ecx, DWORD PTR [eax+ebx*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 635  :           for (int p=0; p < num_precincts; p++)

	lea	edi, DWORD PTR [eax+ebx*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4671 :   if (state && !(state & 1))

	mov	eax, ecx
	or	eax, DWORD PTR [edi+4]
	je	SHORT $LN54@release
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN54@release

; 4672 :     {
; 4673 :       kd_precinct *precinct = (kd_precinct *) _kdu_long_to_addr(state);

	mov	esi, DWORD PTR [edi]

; 4674 :       precinct->ref = NULL; // Satisfy the test in `kd_precinct::closing'

	mov	DWORD PTR [esi+4], ecx

; 4675 :       precinct->closing();

	mov	ecx, esi
	call	?closing@kd_precinct@@QAEXXZ		; kd_precinct::closing

; 2961 :           }
; 2962 :       }
; 2963 :   public: // Links and Identification
; 2964 :     kd_codestream *codestream;
; 2965 :     kd_tile *tile;
; 2966 :     kd_comp_info *comp_info; // Ptr to relevant `codestream->comp_info' entry
; 2967 :     int cnum;
; 2968 : 
; 2969 :   public: // Dimensions and Parameters
; 2970 :     kdu_coords sub_sampling;
; 2971 :     kdu_dims dims;
; 2972 :     kdu_dims region;
; 2973 :     int dwt_levels, apparent_dwt_levels;
; 2974 :     bool reversible;
; 2975 :     int kernel_id; // Ckernels_W5X3, Ckernels_W9X7 or Ckernels_ATK
; 2976 :     bool kernel_symmetric, kernel_symmetric_extension;
; 2977 :     int kernel_num_steps;
; 2978 :     kdu_kernel_step_info *kernel_step_info, *kernel_step_info_flipped;
; 2979 :     float *kernel_coefficients, *kernel_coefficients_flipped;
; 2980 :     float kernel_low_scale; // Amount to scale low-pass lifting analysis output
; 2981 :     float kernel_high_scale; // Amount to scale hi-pass lifting analysis output
; 2982 :     int low_support_min, low_support_max; // low-pass synthesis impulse support
; 2983 :     int high_support_min, high_support_max; // high-pass synth impulse support
; 2984 :     float G_tc; // Global multi-component energy gain term; -ve if not known
; 2985 :     float G_tc_restricted; // Multi-component energy gain term based only on
; 2986 :             // those output components currently of interest; -ve if not known
; 2987 :     int recommended_extra_bits;
; 2988 :     kdu_coords blk; // Nominal code-block dimensions.
; 2989 :     int modes; // Block coder modes.  Flags defined in scope `cod_params'
; 2990 : 
; 2991 :   public: // Arrays
; 2992 :     kd_resolution *resolutions; // Contains 1+`dwt_levels' entries.
; 2993 :     kdu_long *layer_stats; // Contains `num_layers' pairs per resolution,
; 2994 :       // starting from the lowest resolution (`res_level'=0); each pair holds
; 2995 :       // number of parsed packets for the layer-resolution, followed by
; 2996 :       // number of parsed packet bytes for the layer-resolution.  Available
; 2997 :       // only for input codestreams; populated by `kd_precinct::read_packet'.
; 2998 : 
; 2999 :   public: // Flags and Other State Variables
; 3000 :     bool enabled; // See below
; 3001 :     bool is_of_interest; // See below
; 3002 :     kdu_coords grid_min; // These fields are used by "kd_packet_sequencer"
; 3003 :     kdu_coords grid_inc; // for spatially oriented progressions.
; 3004 :     kdu_coords saved_grid_min; // For "kd_packet_sequencer::save_state"
; 3005 :     kdu_coords saved_grid_inc; // For "kd_packet_sequencer::save_state"
; 3006 :   };
; 3007 :   /* Notes:
; 3008 :         `recommended_extra_bits' may be added to the sample bit-depth
; 3009 :      (precision) for this component to determine an appropriate number
; 3010 :      of bits for internal representations associated with the data
; 3011 :      processing path.
; 3012 :         In the reversible path, the value is set to the maximum bit-depth
; 3013 :      expansion factor, as reported in Table 17.4 of the book by Taubman and
; 3014 :      Marcellin, adding an extra 1 bit if the RCT has been used -- note that it
; 3015 :      is not desirable for luminance and chrominance components to have
; 3016 :      different numeric representations, since that would significantly
; 3017 :      complicate the colour transform procedure.
; 3018 :         In the irreversible path, the value is set to 7, which means
; 3019 :      that 16-bit representations are judged sufficient for 9 bit
; 3020 :      imagery or less.  Of course, the impact of selecting a reduced
; 3021 :      representation precision is only reduced accuracy in the
; 3022 :      irreversible processing path.
; 3023 :         The `enabled' flag is used to efficiently identify the tile-components
; 3024 :      which are enabled.  Remember that a tile-component may be disabled,
; 3025 :      either because the corresponding codestream image component is not
; 3026 :      apparent (only when the `kd_codestream::component_access_mode' is
; 3027 :      `KDU_WANT_CODESTREAM_COMPONENTS'), or because the tile-component
; 3028 :      is not involved in the construction of an apparent output image
; 3029 :      component (when the `kd_codestream::component_access_mode' is
; 3030 :      `KDU_WANT_OUTPUT_COMPONENTS').  In the latter case, all codestream
; 3031 :      image components are apparent, but disabled ones cannot be
; 3032 :      accessed -- this is important, since in the latter case the set
; 3033 :      of enabled components may vary from tile to tile.
; 3034 :         The `is_of_interest' flag is used to store the identify of components
; 3035 :      which are marked as being of interest, by calls to
; 3036 :      `kdu_tile::set_components_of_interest'.  This is done only when the
; 3037 :      component access mode is `KDU_WANT_CODESTREAM_COMPONENTS' or the
; 3038 :      `mct_head' member is NULL.  Otherwise, the components of interest are
; 3039 :      passed directly to the `kd_mct_stage::apply_output_restrictions'
; 3040 :      function.  Note that the `is_of_interest' flags do not generally
; 3041 :      belong to the component in which they are stored.  They are just
; 3042 :      copies of the information supplied to
; 3043 :      `kdu_tile::set_components_of_interest', without any attempt to apply
; 3044 :      any component index permutations which might be relevant. */
; 3045 : 
; 3046 : /*****************************************************************************/
; 3047 : /*                            kd_precinct_ref                                */
; 3048 : /*****************************************************************************/
; 3049 : 
; 3050 :   /* Objects of this class provide the vehicle through which precincts
; 3051 :      references are instantiated and removed from the array of precinct
; 3052 :      references maintained by the `kd_resolution' object.  It is important
; 3053 :      that the state information be small.  In particular, it has the same
; 3054 :      size as `kdu_long', which should never be smaller than the size of
; 3055 :      a memory pointer, but may be larger -- see the declaration of
; 3056 :      `kdu_long' in "elementary.h".  For precincts whose seek addresses are
; 3057 :      deduced from PLT marker segments in the code-stream, or precincts which
; 3058 :      are maintained by a caching data source, or precincts which are used by
; 3059 :      codestream objects created for interchange, this object provides
; 3060 :      facilities for recycling a disused precinct's resources while keeping its
; 3061 :      unique address around for rapid reloading in the event that it
; 3062 :      is required at a later point. */
; 3063 : 
; 3064 : class kd_precinct_ref {
; 3065 :   public: // Member functions
; 3066 :     kd_precinct_ref()
; 3067 :       { state = 0; }
; 3068 :     ~kd_precinct_ref()
; 3069 :       { if (!((state == 0) || (state & 1))) close(); }
; 3070 :     bool parsed_and_unloaded()
; 3071 :       { return ((state & 3) == 3) && (state != 3); }
; 3072 :       /* Returns true if the precinct is addressable (i.e., dynamically
; 3073 :          loadable) and it has been parsed and subsequently unloaded from
; 3074 :          memory. */
; 3075 :     kd_precinct *deref()
; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }
; 3077 :       /* Returns NULL unless the reference identifies a valid `kd_precinct'
; 3078 :          object, which is already loaded in memory. */
; 3079 :     kd_precinct *active_deref();
; 3080 :       /* Returns NULL unless the reference identifies a valid `kd_precinct'
; 3081 :          object, which is already loaded in memory and is in the active
; 3082 :          state. */
; 3083 :     kd_precinct *open(kd_resolution *res, kdu_coords pos_idx,
; 3084 :                       bool need_activate);
; 3085 :       /* Attempts to open the precinct at the indicated position within the
; 3086 :          array of precincts maintained by the indicated resolution object.
; 3087 :          `pos_idx' holds the horizontal and vertical position of the
; 3088 :          precinct (starting from 0) within the array of precincts for
; 3089 :          the given resolution.  That is, `pos_idx' holds a relative, not
; 3090 :          an absolute precinct index.
; 3091 :             If the precinct is known to be unloadable (this happens if the
; 3092 :          precinct has previously been opened and has then been permanently
; 3093 :          closed), the function returns NULL.
; 3094 :             If the precinct currently exists in memory (the `state' variable
; 3095 :          contains a valid pointer to the precinct), the function returns a
; 3096 :          pointer to that precinct; however, if `need_activate' is true
; 3097 :          and the precincts's `released' flag is true, `kd_precinct::activate'
; 3098 :          is called before returning the `kd_precinct' pointer.  When the
; 3099 :          codestream object was created for input or for interchange, the
; 3100 :          `need_activate' argument should be set to true only when the
; 3101 :          precinct is being opened in order to access code-block data.  In
; 3102 :          that case, the precinct must belong to an open tile and lie within
; 3103 :          the application's current region of interest, meaning that it will
; 3104 :          be released again when the tile is closed.  For codestream objects
; 3105 :          created for output, the argument should have no effect, since
; 3106 :          output precincts are not actually released.
; 3107 :             Otherwise, the function obtains a new `kd_precinct' object from
; 3108 :          the code-stream's precinct server and calls its `initialize'
; 3109 :          function.  If the `state' variable held the precinct's unique
; 3110 :          address value on entry, that address is written into the newly
; 3111 :          instantiated `kd_precinct' object's `unique_address' field, and
; 3112 :          the P bit (see notes on `state' below) is copied to the precinct's
; 3113 :          KD_PFLAG_PARSED flag.  If compressed data comes from a cached source,
; 3114 :          or the codestream object was created for interchange (no compressed
; 3115 :          data sources or targets), the newly created precinct is automatically
; 3116 :          marked as addressable, with its `unique_address' set to the
; 3117 :          precinct's unique identifier, as described in the comments appearing
; 3118 :          with the declaration of `kd_precinct::unique_address'.  For
; 3119 :          precincts which can be addressed using a seek address (for seekable
; 3120 :          compressed data sources), the seek address is installed using
; 3121 :          `set_address' from within the `kd_packet_sequencer::next_in_sequence'
; 3122 :          function.
; 3123 :             It is worth noting that this function may cause other precincts
; 3124 :          to be unloaded from memory, in order to conserve memory resources.
; 3125 :          If this happens, only precincts which have been released and
; 3126 :          which do not intersect with the current region of interest will be
; 3127 :          unloaded. */
; 3128 :     void close();
; 3129 :       /* Closes the active `kd_precinct' object whose pointer is in
; 3130 :          `state', calling its `closing' member function and recycling its
; 3131 :          storage.  If the precinct is marked as addressable, its
; 3132 :          `unique_address' member and KD_PFLAG_PARSED flag are recorded in
; 3133 :          `state' using the convention outlined in the notes below, allowing
; 3134 :          the precinct to be re-opened at a later point.
; 3135 :             In many cases, you are better off calling the `release' member
; 3136 :          function instead of `close' (see below).
; 3137 :             Note that this function may be safely invoked even when the
; 3138 :          precinct is not currently active -- it does nothing unless `state'
; 3139 :          holds a valid precinct address. */
; 3140 :     void close_and_reset();
; 3141 :       /* This function is used only by `kdu_tile::parse_all_relevant_packets'
; 3142 :          and then only if it is asked to parse everything from scratch.  The
; 3143 :          behaviour is similar to calling `close', except that the internal
; 3144 :          `state' record is left with its P flag reset, so that when the
; 3145 :          precinct is reloaded, its packet statistics will be entered into
; 3146 :          the `kd_tile_comp::layer_stats' array -- the caller invariably
; 3147 :          resets this array. */
; 3148 :     void release();
; 3149 :       /* This function should be called once a precinct is no longer
; 3150 :          required, in preference to the `close' function.  If the system is
; 3151 :          running low on resources, the function may unload the precinct from
; 3152 :          memory to recycle its resources.  Alternatively, the function is at
; 3153 :          liberty to leave the precinct in memory, moving it to a list of
; 3154 :          inactive precincts which are subject to unloading at some point in
; 3155 :          the future, when resources may be running low.  Non-addressable or
; 3156 :          cached precincts are unloaded immediately, since they are
; 3157 :          guaranteed never to be re-opened once `release' has been called. */
; 3158 :     void clear();
; 3159 :       /* This function recycles the storage associated with any existing
; 3160 :          precinct and sets the internal `state' variable to 0.  It is called
; 3161 :          when the code-stream management machinery is restarted. */
; 3162 :     bool is_desequenced();
; 3163 :       /* This function is intended for use within
; 3164 :          `kd_packet_sequencer::next_in_sequence', for checking whether
; 3165 :          or not the precinct which is returned by that function needs
; 3166 :          to have its contents read from a compressed data source in
; 3167 :          order to desequence a new packet.  Opening precincts can be a time
; 3168 :          consuming task, especially when there are an enormous number of
; 3169 :          precincts (this can happen when working with huge untiled images,
; 3170 :          especially in geospatial applications).  This function takes
; 3171 :          advantage of the fact that there is no need to actually open a
; 3172 :          precinct which is not already loaded into memory.  The fact that this
; 3173 :          function is called first by the packet desequencer, allows a precinct
; 3174 :          which has already been fully generated to be closed immediately
; 3175 :          during packet generation mode.
; 3176 :             The function works as follows.  If the precinct is already loaded
; 3177 :          in memory, its `sequenced' flag is accessed directly.   Otherwise,
; 3178 :          if the reference `state' variable identifies a valid unique
; 3179 :          address for the precinct, it is known to be addressable and
; 3180 :          therefore must have already been fully desequenced.  Also, if the
; 3181 :          `state' variable indicates that the precinct is unloadable, or that
; 3182 :          it has been closed in packet generation mode, it is interpreted as
; 3183 :          sequenced, in the sense that the application cannot sequence further
; 3184 :          packets for the precinct.  Otherwise, the `state' variable must hold
; 3185 :          0 (see below), from which we deduce that the precinct has not yet
; 3186 :          been sequenced. */
; 3187 :     bool set_address(kd_resolution *res, kdu_coords pos_idx,
; 3188 :                      kdu_long seek_address);
; 3189 :       /* Called from within `kd_packet_sequencer::next_in_sequence', this
; 3190 :          function installs a seek address for a precinct whose packets are
; 3191 :          contiguous within the code-stream and have valid pointer information
; 3192 :          stored in PLT marker segments.  Subsequent calls to `is_sequenced'
; 3193 :          will return true.  The precinct itself may either be open or closed
; 3194 :          when this function is called.  The `pos_idx' argument is provided
; 3195 :          for computing the relevance of this precinct to the application.  It
; 3196 :          holds a relative precinct index, having the same interpretation as
; 3197 :          that passed to `kd_precinct::initialize' and `kdu_precinct_ref::open'.
; 3198 :             It can happen that this function causes the tile, and hence the
; 3199 :          precinct reference, to be destroyed.  This happens if the call to
; 3200 :          this function renders the resolution or tile completely parsed,
; 3201 :          and it is known that the application has no need for any further
; 3202 :          access to the tile.  In this case, and only in this case, the
; 3203 :          function returns false, meaning that the caller must not make
; 3204 :          any further attempt to access the tile or any of its resources. */
; 3205 :   private: // Utility functions
; 3206 :     kd_precinct *instantiate_precinct(kd_resolution *res, kdu_coords pos_idx);
; 3207 :       /* Called from `open' if the `kd_precinct' object is not in memory at
; 3208 :          the time and can legitimately be created at this point. */
; 3209 :   private: // Data
; 3210 :     kdu_long state;
; 3211 :   };
; 3212 :   /* Notes:
; 3213 :         `state' holds 0 if no information is yet available concerning the
; 3214 :      precinct associated with this reference.
; 3215 :         If the precinct is currently active in memory, `state' holds the
; 3216 :      address in memory (pointer) of the `kd_precinct' structure.
; 3217 :         If the precinct is known to be addressable, `state' holds an odd
; 3218 :      integer, equal to 4*A + 2*P + 1, where A is the precinct's
; 3219 :      `unique_address' value and P is a flag, equal to 1 if the precinct
; 3220 :      has been loaded and parsed previously.
; 3221 :         The `unique_address' value has the same definition as the
; 3222 :      corresponding data member in `kd_precinct'.
; 3223 :         This P flag plays the same role as the KD_PFLAG_PARSED bit in
; 3224 :      `kd_precinct::flags'.  It is used to avoid collecting layer size
; 3225 :      statistics twice for the same precinct which could otherwise happen
; 3226 :      when precincts get swapped in and out of memory on demand.
; 3227 :         A value of `state'=1 means that the precinct can be re-instantiated,
; 3228 :      but that it is known to contain no packets whatsoever.
; 3229 :         If a previously active precinct's resources have been recycled and
; 3230 :      re-loading is not possible, `state' is assigned the special value of 3. */
; 3231 : 
; 3232 : /*****************************************************************************/
; 3233 : /*                               kd_leaf_node                                */
; 3234 : /*****************************************************************************/
; 3235 : 
; 3236 : struct kd_leaf_node {
; 3237 :     public: // Data
; 3238 :       kd_node *parent; // Every leaf node has a non-leaf parent node
; 3239 :       kd_resolution *resolution; // Always points to the owning resolution
; 3240 :       kdu_dims dims; // Dimensions & location of the image at this node
; 3241 :       kdu_dims region; // See below
; 3242 :       kdu_byte branch_x, branch_y; // See below
; 3243 :       bool is_leaf; // False if this object is the base of `kd_node'
; 3244 :   };
; 3245 :   /* Notes:
; 3246 :         This structure is the base of the richer `kd_node' structure.  The
; 3247 :      key difference is that leaf nodes have no children, so we do not waste
; 3248 :      storage recording pointers to them.
; 3249 :         The `branch_x' and `branch_y' members describe how this node is
; 3250 :      derived from its parent node, if any.  `branch_x' holds 0 if horizontal
; 3251 :      low-pass filtering and decimation were used to obtain the node from its
; 3252 :      parent; it holds 1 if horizontal high-pass filtering and decimation were
; 3253 :      used; it holds 2 if no filtering or decimation were involved in the
; 3254 :      horizontal direction.  `branch_y' plays a similar role in describing the
; 3255 :      vertical filtering and decimation processes.  If `parent' is NULL,
; 3256 :      the `branch_x' and `branch_y' members have no meaning.
; 3257 :         This structure manages two different, yet related regions
; 3258 :      (location, plus dimensions) which deserve some explanation here.
; 3259 :      * The `dims' member serves the usual role of identifying the location and
; 3260 :        dimensions of the image, as it appears on entry into this node,
; 3261 :        during forward transformation (analysis).  For primary nodes,
; 3262 :        these are the dimensions and location of the tile-component-resolution
; 3263 :        within its canvas.
; 3264 :      * `region' identifies a subset of the `dims' region, containing
; 3265 :        all of the node's samples which are involved in the synthesis of the
; 3266 :        current region of interest, as specified in the most recent call to
; 3267 :        `kdu_codestream::apply_input_restrictions'. */
; 3268 : 
; 3269 : /*****************************************************************************/
; 3270 : /*                                 kd_node                                   */
; 3271 : /*****************************************************************************/
; 3272 : 
; 3273 : struct kd_node : public kd_leaf_node {
; 3274 :     public: // Member functions
; 3275 :       void adjust_cover(kdu_dims child_cover,
; 3276 :                         int child_branch_x, int child_branch_y);
; 3277 :         /* This function is used to find the `region_cover' members.  In
; 3278 :            a downward sweep through the decomposition branches associated
; 3279 :            with a given resolution level, the `region_cover' members are all
; 3280 :            set to empty regions.  We then assign each leaf node (subband)
; 3281 :            a region cover (not actually recorded in the leaf node) equal to
; 3282 :            its region of interest and work back up the tree from the
; 3283 :            leaves to the primary node of the resolution in question, calling
; 3284 :            this function to grow the region cover so as to encompass the
; 3285 :            smallest region which covers each of its children. */
; 3286 :     public: // Data
; 3287 :       kdu_dims region_cover; // See below
; 3288 :       kdu_dims prec_dims; // Temp storage for calculating precinct dimensions
; 3289 :       kd_leaf_node *children[4]; // Indexed by `LL_BAND' through `HH_BAND'
; 3290 :       kdu_byte num_hor_steps, num_vert_steps; // See below
; 3291 :       kdu_uint16 num_descendant_nodes;
; 3292 :       kdu_uint16 num_descendant_leaves;
; 3293 :       float *bibo_gains; // See below
; 3294 :   };
; 3295 :   /* Notes:
; 3296 :         This object is used to construct descriptions of all non-leaf
; 3297 :      nodes in the DWT decomposition structure.  Each node in the structure
; 3298 :      may be decomposed horizontally, vertically or both.  If it is decomposed
; 3299 :      in the horizontal direction, `children[HL_BAND]' will be non-NULL.  If it
; 3300 :      is decomposed in the vertical direction, `children[LH_BAND]' will be
; 3301 :      non-NULL.  If it is decomposed in both directions, `children[HH_BAND]'
; 3302 :      will also be non-NULL.  If it is decomposed at all, `children[LL_BAND]'
; 3303 :      will always be non-NULL.
; 3304 :         The decomposition structure consists of a collection of primary
; 3305 :      nodes, each of which is embedded within a `kd_resolution' object.
; 3306 :      In the case of the simple Mallat structure, each primary node has
; 3307 :      4 children, with the LL child embedded within the next lower
; 3308 :      resolution object and the remaining children embedded within
; 3309 :      `kd_subband' objects.  In wavelet packet decomposition structures,
; 3310 :      detail subbands produced by a primary node may, themselves, be
; 3311 :      decomposed further into subbands.
; 3312 :         The actual object pointed to by each non-NULL member of the `children'
; 3313 :      array may need to be cast to type `kd_node', rather than `kd_leaf_node'
; 3314 :      if the `kd_leaf_node::is_leaf' member is false.
; 3315 :         The `children[LL_BAND]' entry of a primary node always points to
; 3316 :      the node which is embedded within the next lower resolution
; 3317 :      `kd_resolution' object, except at the lowest resolution of all.
; 3318 :      The lowest `kd_resolution' object's embedded node has only one
; 3319 :      child, with `children[LL_BAND]' pointing to the single (LL) subband
; 3320 :      belonging to that resolution.
; 3321 :         The `num_hor_steps' and `num_vert_steps' members identify the number
; 3322 :      of horizontal and vertical lifting steps associated with the horizontal
; 3323 :      and vertical transform operations applied at this node to produce its
; 3324 :      children.  One or both of these may be 0, either because the transform
; 3325 :      is trivial (lazy wavelet) or because the node is split only in the
; 3326 :      horizontal direction, only in the vertical direction, or is not split
; 3327 :      at all.
; 3328 :         The `num_descendant_nodes' member holds a count of the total number
; 3329 :      of nodes (leaf nodes and non-leaf nodes) which may be reached via the
; 3330 :      `children' array.  The `num_descendant_leaves' member holds a count of
; 3331 :      the number of these descendant nodes which are leaves.  Neither of these
; 3332 :      counts includes the current node.  Clearly there is no need to
; 3333 :      maintain this information with leaf nodes, since the counts would both
; 3334 :      be 0 in this case.
; 3335 :         The `bibo_gains' member point to an array with
; 3336 :      2+`num_hor_steps'+`num_vert_steps' entries.  The first 1+`num_hor_steps'
; 3337 :      entries describe BIBO gains for the horizontal transform performed
; 3338 :      at this node.  The remaining `+`num_vert_steps' entries describe BIBO
; 3339 :      gains for the vertical transform performed at this node.  Within each
; 3340 :      of these 2 sets of BIBO gains the first entry holds the BIBO gain from
; 3341 :      the original input image to the image which is presented at the input
; 3342 :      to this node.  Subsequent entries hold the BIBO gains from the original
; 3343 :      input image to the image which is presented at the output of each
; 3344 :      successive analysis lifting step.  Al BIBO gains are assessed relative to
; 3345 :      the nominal transform normalization, in which reversible lifting steps
; 3346 :      are applied as-is, while irreversible lifting steps are followed by the
; 3347 :      relevant `kd_tile_comp::low_scale' and `kd_tile_comp::high_scale' values.
; 3348 :         The interpretation of `region_cover' is similar to that of
; 3349 :      `kd_leaf_node::region', with a subtle, yet important twist.  In order to
; 3350 :      reconstruct each sample in `region', it is necessary to decode a
; 3351 :      particular set of samples from the subbands which are associated with
; 3352 :      this node.  Each of these subband samples has a mapping onto the
; 3353 :      coordinate system associated with the node, following the usual rules of
; 3354 :      the canvas coordinate system.  `res_cover' holds the smallest region
; 3355 :      which contains all of these mapped subband sample locations, except that
; 3356 :      the LL subband branch is included only if this is not a primary node.
; 3357 :      This ensures that the primary node embedded inside each `kd_resolution'
; 3358 :      object will have a `region_cover' which spans the nominal locations of
; 3359 :      all subband samples of interest, which are represented by codestream
; 3360 :      packets associated with that resolution. */
; 3361 : 
; 3362 : /*****************************************************************************/
; 3363 : /*                                kd_subband                                 */
; 3364 : /*****************************************************************************/
; 3365 : 
; 3366 : struct kd_subband : public kd_leaf_node {
; 3367 :     // State structure for the "kdu_subband" interface
; 3368 :   public: // Identification
; 3369 :     kdu_int16 descriptor; // See `cod_params::expand_decomp_bands'
; 3370 :     kdu_byte orientation; // One of LL_BAND, HL_BAND, LH_BAND or HH_BAND.
; 3371 :                      // This is the orientation of the primary subband from
; 3372 :                      // which we are derived within the same resolution level.
; 3373 :     kdu_byte sequence_idx; // Index within the `kd_resolution::subbands' array
; 3374 :                      // This is also the order in which subbands contribute
; 3375 :                      // code-blocks to codestream packets.
; 3376 :     kdu_byte transpose_sequence_idx; // Index of the real subband which appears
; 3377 :                       // to have this `sequence_idx' value when
; 3378 :                       // `kdu_codestream::change_appearance' has been used to
; 3379 :                       // transpose the codestream's appearance.
; 3380 :   public: // Dimensions and Parameters
; 3381 :     kdu_byte epsilon; // Ranging parameter.
; 3382 :     kdu_byte K_max; // Maximum magnitude bit-planes, not including ROI upshift
; 3383 :     kdu_byte K_max_prime; // Max magnitude bit-planes, including ROI upshift
; 3384 :     float delta; // Step size, normalized for image data range of -0.5 to 0.5
; 3385 :     float G_b; // Subband energy gain factor.
; 3386 :     float W_b; // Subband amplitude weight; needs squaring to get energy weight
; 3387 :     float roi_weight; // Extra amplitude weight for ROI foreground blocks.
; 3388 :     kdu_dims block_partition; // Holds the coding origin and dimensions.
; 3389 :     kdu_dims block_indices; // Holds the range of valid block indices.
; 3390 :     kdu_dims region_indices;  // Same as `block_indices', but restricted to
; 3391 :                               // blocks which overlap the region of interest.
; 3392 :     kdu_coords blocks_per_precinct; // precinct size / block size
; 3393 :     kdu_coords log2_blocks_per_precinct; // log2 of precinct size/block size
; 3394 :   };
; 3395 :   /* Notes:
; 3396 :         It may come as a surprise to notice that this object has no
; 3397 :      direct connection to code-blocks.  To access a code-block, the object
; 3398 :      first determines the precinct to which it belongs, creating that
; 3399 :      precinct if necessary; this, in turn, creates its precinct-bands and
; 3400 :      the associated code-blocks.  In this way, no memory whatsoever need be
; 3401 :      dedicated to code-blocks which lie in unaccessed precincts. */
; 3402 : 
; 3403 : /*****************************************************************************/
; 3404 : /*                              kd_resolution                                */
; 3405 : /*****************************************************************************/
; 3406 : 
; 3407 : struct kd_resolution { // State structure for the "kdu_resolution" interface
; 3408 :   public: // Member functions
; 3409 :     kd_resolution()
; 3410 :       {
; 3411 :         codestream = NULL; tile_comp = NULL; rescomp = NULL;
; 3412 :         precinct_refs = NULL; subbands = subband_handle = NULL; num_subbands=0;
; 3413 :         num_intermediate_nodes = 0; intermediate_nodes = NULL;
; 3414 :         can_flip = true;  node.bibo_gains = NULL;
; 3415 :       }
; 3416 :     ~kd_resolution()
; 3417 :       {
; 3418 :         if (node.bibo_gains != NULL) delete[] node.bibo_gains;
; 3419 :         for (int n=0; n < (int) num_intermediate_nodes; n++)
; 3420 :           if (intermediate_nodes[n].bibo_gains != NULL)
; 3421 :             delete[] intermediate_nodes[n].bibo_gains;
; 3422 :         if (precinct_refs != NULL) delete[] precinct_refs;
; 3423 :         if (subband_handle != NULL) delete[] subband_handle;
; 3424 :         if (intermediate_nodes != NULL) delete[] intermediate_nodes;
; 3425 :       }
; 3426 :     void build_decomposition_structure(kdu_params *coc, kdu_kernels &kernels);
; 3427 :       /* This function creates the `subbands' and `intermediate_nodes'
; 3428 :          arrays and fills in all the relevant pointers.  It uses `kernels'
; 3429 :          to create and fill in the `kdu_node::hor_bibo_gains' and
; 3430 :          `kdu_node::vert_bibo_gains' arrays, where required. */
; 3431 :     void complete_initialization();
; 3432 :       /* Called from within `kd_tile::initialize' to finish the initialization
; 3433 :          process, after all of the key parameters have been set.  Currently,
; 3434 :          the only task performed here is the initialization of the
; 3435 :          `max_blocks_per_precinct' member. */
; 3436 :   public: // Links and Identification
; 3437 :     kd_codestream *codestream;
; 3438 :     kd_tile_comp *tile_comp;
; 3439 :     kd_global_rescomp *rescomp;
; 3440 :     kdu_byte res_level; // Runs from 0 (LL band) to `num_dwt_levels'
; 3441 :     kdu_byte dwt_level; // Runs from `num_dwt_levels' (res level 0 and 1) to 1
; 3442 :     kdu_byte hor_depth; // From relevant entry of `kd_comp_info::hor_depth'
; 3443 :     kdu_byte vert_depth; // From relevant entry of `kd_comp_info::vert_depth'
; 3444 : 
; 3445 :   public: // Embedded node
; 3446 :     kd_node node; // Each resolution is a primary node in the decomposition
; 3447 : 
; 3448 :   public: // Dimensions and Parameters
; 3449 :     kdu_dims precinct_partition; // Holds the coding origin and dimensions.
; 3450 :     kdu_dims precinct_indices; // Holds the range of valid precinct indices.
; 3451 :     kdu_dims region_indices; // Holds range of indices for precincts whose
; 3452 :                              // code-blocks contribute to region of interest.
; 3453 :   public: // Derived quantities
; 3454 :     int max_blocks_per_precinct; // See discussion under `kd_precinct_band'
; 3455 :     bool propagate_roi; // True if ROI masks to be propagated to descendants
; 3456 : 
; 3457 :     bool can_flip; // Set to false if this level contains subband decomposition
; 3458 :                    // styles which are incompatible with view flipping.
; 3459 : 
; 3460 :   public: // Arrays
; 3461 :     kdu_byte num_subbands; // Excludes the LL band unless `res_level'=0
; 3462 :     kdu_byte num_intermediate_nodes; // Enough for all non-leaf nodes descended
; 3463 :                                  // from the primary node in this object.
; 3464 :     kd_node *intermediate_nodes; // Array with `num_intermediate_nodes' entries
; 3465 :     kd_precinct_ref *precinct_refs;
; 3466 :     kd_subband *subbands; // Points to `subband_store' or `subband_handle'.
; 3467 :     kd_subband *subband_handle; // For dynamically allocated subbands
; 3468 :     kd_subband subband_store[3]; // Avoid dynamic allocation for common case
; 3469 : 
; 3470 :   public: // Flags and Other State Variables
; 3471 :     kdu_coords current_sequencer_pos; // Used by `kd_packet_sequencer'.
; 3472 :     kdu_coords saved_current_sequencer_pos; // For saving the sequencer state
; 3473 :   };
; 3474 :   /* Notes:
; 3475 :         The `current_sequencer_pos' coordinates are used to sequence
; 3476 :      spatially oriented packet progressions.  They maintain the
; 3477 :      indices (starting from [0,0], rather than `precinct_indices.pos')
; 3478 :      of the precinct which is currently being sequenced.
; 3479 :         The `region_indices' member holds the smallest range of precinct
; 3480 :      indices, such that the code-blocks contained within these precincts
; 3481 :      are sufficient to reconstruct all samples inside `node.region'.
; 3482 :      Equivalently, the range in `precinct_indices' yields the set of
; 3483 :      precincts which intersect with `node.region_cover'.
; 3484 :         It is worth noting that the area of intersection between each
; 3485 :      precinct's region on the resolution and the `node.region_cover' region
; 3486 :      is used to compute the information returned by
; 3487 :      `kdu_resolution::get_precinct_relevance'. */
; 3488 : 
; 3489 : /*****************************************************************************/
; 3490 : /*                             kd_header_in                                  */
; 3491 : /*****************************************************************************/
; 3492 : 
; 3493 : class kd_header_in {
; 3494 :   /* Manages the reading of packet header bytes from the code-stream, along
; 3495 :      with bit stuffing and unpacking. */
; 3496 :   public: // Member functions
; 3497 :     kd_header_in(kd_input *source)
; 3498 :       { this->source = source; bits_left=0; byte=0; header_bytes=0; }
; 3499 :     int get_bit() // throws its own "this" pointer if the source is exhausted.
; 3500 :       {
; 3501 :         if (bits_left==0)
; 3502 :           {
; 3503 :             bits_left = (byte==0xFF)?7:8;
; 3504 :             if (!source->get(byte))
; 3505 :               { bits_left = 0; throw this; }
; 3506 :             header_bytes++;
; 3507 :           }
; 3508 :         bits_left--;
; 3509 :         return (byte >> bits_left) & 1;
; 3510 :       }
; 3511 :     kdu_uint32 get_bits(int num_bits) // thorws(kd_header_in *)
; 3512 :       { kdu_uint32 result = 0;
; 3513 :         while (num_bits > 0)
; 3514 :           {
; 3515 :             if (bits_left==0)
; 3516 :               {
; 3517 :                 bits_left = (byte==0xFF)?7:8;
; 3518 :                 if (!source->get(byte))
; 3519 :                   { bits_left = 0; throw this; }
; 3520 :                 header_bytes++;
; 3521 :               }
; 3522 :             int xfer_bits = (num_bits<bits_left)?num_bits:bits_left;
; 3523 :             bits_left -= xfer_bits;
; 3524 :             num_bits -= xfer_bits;
; 3525 :             result <<= xfer_bits;
; 3526 :             result |= ((byte >> bits_left) & ~(0xFF << xfer_bits));
; 3527 :           }
; 3528 :         return result;
; 3529 :       }
; 3530 :     int finish()
; 3531 :       { // Call this when the header is all read, to consume any stuffing byte
; 3532 :         // Returns total header length
; 3533 :         if ((bits_left == 0) && (byte == 0xFF))
; 3534 :           {
; 3535 :             bits_left = 7;
; 3536 :             if (!source->get(byte))
; 3537 :               throw this;
; 3538 :             header_bytes++;
; 3539 :           }
; 3540 :         return header_bytes;
; 3541 :       }
; 3542 :   private: // Data
; 3543 :     kd_input *source; // Provides the input mechanism.
; 3544 :     kdu_byte byte;
; 3545 :     int bits_left;
; 3546 :     int header_bytes;
; 3547 :   };
; 3548 : 
; 3549 : /*****************************************************************************/
; 3550 : /*                                kd_header_out                              */
; 3551 : /*****************************************************************************/
; 3552 : 
; 3553 : class kd_header_out {
; 3554 :   /* Manages the simulated and real output of packet header bytes. */
; 3555 :   public: // Member functions
; 3556 :     kd_header_out(kdu_output *out=NULL) // Null for simulating header
; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }
; 3558 :     void put_bit(int bit)
; 3559 :       { // Output a header bit
; 3560 :         assert(bit == (bit & 1));
; 3561 :         if (bits_left == 0)
; 3562 :           { if (out != NULL) out->put(byte);
; 3563 :             completed_bytes++;
; 3564 :             bits_left = (byte==0xFF)?7:8;
; 3565 :             byte = 0; }
; 3566 :         byte += byte + bit;
; 3567 :         bits_left--;
; 3568 :       }
; 3569 :     void put_bits(kdu_int32 val, int num_bits)
; 3570 :       { // Output the least significant `num_bits' of `val'
; 3571 :         while (num_bits > 0)
; 3572 :           put_bit((val >> (--num_bits)) & 1);
; 3573 :       }
; 3574 :     int finish()
; 3575 :       { // Returns the total number of bytes consumed by the packet header.
; 3576 :         if (bits_left < 8)
; 3577 :           {
; 3578 :             byte <<= bits_left;
; 3579 :             if (out != NULL)
; 3580 :               out->put(byte);
; 3581 :             completed_bytes++;
; 3582 :             if (byte == 0xFF)
; 3583 :               { // Need the stuffing byte.
; 3584 :                 if (out != NULL)
; 3585 :                   out->put((kdu_byte) 0);
; 3586 :                 completed_bytes++;
; 3587 :               }
; 3588 :           }
; 3589 :         return completed_bytes;
; 3590 :       }
; 3591 :   private: // Data
; 3592 :     kdu_byte byte;
; 3593 :     int bits_left;
; 3594 :     int completed_bytes;
; 3595 :     kdu_output *out;
; 3596 :   };
; 3597 : 
; 3598 : /*****************************************************************************/
; 3599 : /*                                 kd_block                                  */
; 3600 : /*****************************************************************************/
; 3601 : 
; 3602 : class kd_block {
; 3603 :   /* For a very small size (only 24 bytes on 32-bit machines), this class
; 3604 :      defines a lot of member functions!. */
; 3605 :   // --------------------------------------------------------------------------
; 3606 :   public: // Lifecycle member functions
; 3607 :     void cleanup(kd_buf_server *buf_server)
; 3608 :       {
; 3609 :         while ((current_buf=first_buf) != NULL)
; 3610 :           { first_buf=current_buf->next;  buf_server->release(current_buf); }
; 3611 :         set_discard(); // Discard from any packets parsed in the future
; 3612 :       }
; 3613 :     kd_code_buffer *cleanup()
; 3614 :       { // As above, but returns the linked list of buffers
; 3615 :         kd_code_buffer *result = first_buf;  first_buf = current_buf = NULL;
; 3616 :         set_discard();
; 3617 :         return result;
; 3618 :       }
; 3619 : 
; 3620 :   // --------------------------------------------------------------------------
; 3621 :   public: // Packet manipulation member functions
; 3622 :     int parse_packet_header(kd_header_in &head, kd_buf_server *buf_server,
; 3623 :                             int layer_idx); // Throws (kdu_uint16 code)
; 3624 :       /* Parses bits in the packet header corresponding to the current
; 3625 :          block for the current layer (this must be the next layer for which
; 3626 :          information has not yet been parsed).  The function returns the
; 3627 :          number of new body bytes contributed by the code-block in this layer
; 3628 :          and also stores this value internally to be used in subsequent calls
; 3629 :          to the `read_body_bytes' member function.
; 3630 :             The `kd_header_in' object may throw an exception if the packet
; 3631 :          data terminates unexpectedly.  Moreover, to assist in locating and
; 3632 :          possibly recovering from errors, the present function may throw a
; 3633 :          16-bit unsigned integer exception code, which is either the value of
; 3634 :          an illegal marker code encountered in the packet header, or one of
; 3635 :          the special exception codes, KDU_EXCEPTION_PRECISION or
; 3636 :          KDU_EXCEPTION_ILLEGAL_LAYER. */
; 3637 :     void read_body_bytes(kd_input *source, kd_buf_server *buf_server,
; 3638 :                          bool in_memory_source)
; 3639 :       { /* This function should be called after parsing the header of a
; 3640 :            packet.  It reads the code-bytes contributed by the code-block to
; 3641 :            this packet.  If `in_memory_source' is true, only the address of
; 3642 :            the code-bytes is recorded, and then only if the length of the
; 3643 :            code-byte segment is non-zero. */
; 3644 :         if (this->temp_length > 0)
; 3645 :           {
; 3646 :             if (num_passes == 255)
; 3647 :               { // Read and discard the code-bytes.
; 3648 :                 assert(first_buf == NULL);  source->ignore(this->temp_length);
; 3649 :               }
; 3650 :             else if (in_memory_source)
; 3651 :               {
; 3652 :                 kdu_byte *addr;
; 3653 :                 this->num_bytes += source->pseudo_read(addr,this->temp_length);
; 3654 :                 put_address(addr,buf_server);
; 3655 :               }
; 3656 :             else
; 3657 :               this->num_bytes +=
; 3658 :                 source->read(current_buf,buf_pos,buf_server,this->temp_length);
; 3659 :             this->temp_length = 0;
; 3660 :           }
; 3661 :       }
; 3662 :     void retrieve_data(kdu_block *block, int max_layers, int discard_passes,
; 3663 :                        bool in_memory_source);
; 3664 :       /* Retrieves compressed code-bytes, number of coding passes and codeword
; 3665 :          segment lengths from the current code-block and stores them in the
; 3666 :          `block' object.  All fields which are common for compression and
; 3667 :          decompression have already been filled out by the caller.  The
; 3668 :          byte buffer is allocated so as to be large enough to allow a
; 3669 :          2 byte marker code to be appended to the compressed data,
; 3670 :          if desired -- see declaration of "kdu_subband::open_block".
; 3671 :             The `max_layers' argument identifies the maximum number of
; 3672 :          quality layers for which code-block contributions are to be
; 3673 :          retrieved.
; 3674 :             The `discard_passes' argument indicates the number of additional
; 3675 :          coding passes to be removed, if any.
; 3676 :             If `in_memory_source' is true, the layer code bytes are not
; 3677 :          stored in the `kd_code_buffer' list embedded inside `block'.  Instead,
; 3678 :          the `kd_code_buffer' list stores only the header information for
; 3679 :          each layer, along with the address of the code bytes, which reside
; 3680 :          in the memory block managed by an in-memory compressed data source
; 3681 :          (one which offers the `KDU_SOURCE_CAP_IN_MEMORY') capability.  In
; 3682 :          this case, we retrieve the address and then perform a simple memory
; 3683 :          block copy operation to efficiently retrieve the code bytes for
; 3684 :          each layer. */
; 3685 :     void store_data(kdu_block *block, kd_buf_server *buf_server);
; 3686 :       /* Stores compressed code-bytes, pass length and pass slope information
; 3687 :          from the `block' object into the current code-block.  This function
; 3688 :          is invoked by "kdu_subband::close_block" when the containing
; 3689 :          codestream object was not constructed for input.  Also reflects
; 3690 :          the `msbs_w' value into higher nodes in the tag tree. */
; 3691 :     void store_data(kdu_block *block, kd_thread_buf_server *thread_buf_server);
; 3692 :       /* Same as the above function, but uses `kd_thread_buf_server::get'
; 3693 :          rather than `kd_buf_server::get' to get new code buffers.  This
; 3694 :          version is used to save code-block state in multi-threaded
; 3695 :          environments so as to minimize cache coherency bottlenecks and the
; 3696 :          need to lock shared resources. */
; 3697 :     void transfer_data(kd_block &src)
; 3698 :       { /* Like `store_data', but gets results from another block.  Exploits
; 3699 :            the layout of the object to copy only whole pointers or whole
; 3700 :            32-bit words, even where these represent multiple fields. */
; 3701 :         current_buf = first_buf = src.first_buf;
; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);
; 3703 :         src.current_buf = src.first_buf = NULL;
; 3704 :       }
; 3705 :     bool trim_data(kdu_uint16 slope_threshold, kd_buf_server *buf_server);
; 3706 :       /* This function serves two purposes: it helps reduce the amount of
; 3707 :          compressed data which must be buffered in memory while compressing
; 3708 :          an image; and it allows individual block contributions to be
; 3709 :          discarded during packet construction in order to tightly fit the
; 3710 :          generated bit-rate to the target compressed bit-rate.
; 3711 :             The function sets all coding pass slopes which are less than or
; 3712 :          equal to the supplied slope threshold to 0 and then discards all
; 3713 :          code bytes which could not possibly be included in the final
; 3714 :          code-stream, as a result of this modification.
; 3715 :             If anything was discarded, the function returns true.  Otherwise,
; 3716 :          it returns false. */
; 3717 :     int start_packet(int layer_idx, kdu_uint16 slope_threshold);
; 3718 :       /* Call this function only during rate allocation or packet generation.
; 3719 :          Before the first call to this function, you must reset the tag tree
; 3720 :          (see the "reset_output_tree" member function).  If you are calling
; 3721 :          the function multiple times with the same layer for rate allocation
; 3722 :          purposes, you must use "save_output_tree" and "restore_output_tree"
; 3723 :          as described below.
; 3724 :             The function leaves behind information about the number of new
; 3725 :          coding passes and the number of new code bytes which would be
; 3726 :          contributed by this code-block if the supplied threshold were actually
; 3727 :          used.  The final contributing coding pass must have a non-zero
; 3728 :          distortion-length slope which is strictly greater than the slope
; 3729 :          threshold.  It also updates the tag tree structure to reflect any
; 3730 :          new knowledge about the first layer to which this code-block would
; 3731 :          contribute.  This information is picked up by "write_packet_header".
; 3732 :             The function's return value is the total number of new code-bytes
; 3733 :          contributed by the block.  This allows the PCRD-opt algorithm to
; 3734 :          determine roughly the right slope threshold before committing to the
; 3735 :          work of simulating packet header generation. */
; 3736 :     void write_packet_header(kd_header_out &head, int layer_idx,
; 3737 :                              bool simulate);
; 3738 :       /* Call this function only after a `start_packet' call.  It writes
; 3739 :          (or simulates the writing of) packet header information corresponding
; 3740 :          to the code-block inclusion information set up by `start_packet'.
; 3741 :          If `simulate' is true, some internal state adjustments are delayed
; 3742 :          until the next call to "save_output_tree", so multiple calls to
; 3743 :          "start_packet" and "write_packet_header" may be issued with the same
; 3744 :          layer index to determine an optimal slope threshold.  Otherwise,
; 3745 :          if `simulate' is false, the internal state information is fully
; 3746 :          updated and the "save_output_tree" and "restore_output_tree" functions
; 3747 :          need not and should not be called. */
; 3748 :     void write_body_bytes(kdu_output *dest);
; 3749 :       /* This function should be called after a non-simulated
; 3750 :          "write_packet_header" call to output the newly included body bytes.
; 3751 :          The actual number of bytes to be written was left behind by
; 3752 :          the preceding "start_packet" call in the `temp_length' field. */
; 3753 :   // --------------------------------------------------------------------------
; 3754 :   public: // Static functions used to operate on tag-trees built from kd_block
; 3755 :     static kd_block *build_tree(kdu_coords size, kdu_byte * &mem_block);
; 3756 :       /* Builds a full tag tree returning a pointer to the upper left hand
; 3757 :          corner leaf node.  Apart from the `up_down' navigation pointers,
; 3758 :          all fields are initialized to 0.  This is appropriate for tag tree
; 3759 :          decoding, but encoders will need to call "reset_output_tree" and
; 3760 :          use "start_packet" to install appropriate node values.
; 3761 :             The tag tree is not allocated from the heap.  Instead, it is
; 3762 :          allocated from an existing memory block, identified by the `mem_block'
; 3763 :          argument.  This memory block is assumed to be large enough to hold
; 3764 :          the array of `kd_block' structures.  Upon return, the `mem_block'
; 3765 :          value is advanced by an amount equal to the size of the tag tree
; 3766 :          array. */
; 3767 :     static void reset_output_tree(kd_block *tree, kdu_coords size);
; 3768 :       /* Call this function immediately before simulating or actually
; 3769 :          generating any packet data for the relevant code-blocks.  Once
; 3770 :          the PCRD-opt algorithm has completed, you should call this function
; 3771 :          a second time to prepare for actual packet output.  The function
; 3772 :          initializes the threshold state variables, `layer_w_bar' and
; 3773 :          `msbs_w_bar' to 0, and the value state variables, `layer_w' and
; 3774 :          `msbs_w' to their maximum representable values.  The succession of
; 3775 :          "start_packet" calls will update the value variables `layer_w'
; 3776 :          and `msbs_w' in such a way that the tag tree coding process runs
; 3777 :          correctly in each subsequent call to "write_packet_header". */
; 3778 :     static void save_output_tree(kd_block *tree, kdu_coords size);
; 3779 :       /* Call this only during rate allocation, before moving on to a new
; 3780 :          layer.  The function saves the current state (`msbs_wbar' and
; 3781 :          `layer_wbar') of each node in the tag tree.  For leaf nodes, it also
; 3782 :          commits the number of new coding passes found in the last call to
; 3783 :          "start_packet". */
; 3784 :     static void restore_output_tree(kd_block *tree, kdu_coords size);
; 3785 :       /* Call this during rate allocation before supplying a new slope
; 3786 :          threshold for the same layer index, in a new "start_packet" call.
; 3787 :          The function restores the `msbs_w_bar' and `layer_w_bar' values
; 3788 :          previously saved by "save_output_tree". */
; 3789 :   // --------------------------------------------------------------------------
; 3790 :   public: // State identification functions
; 3791 :     void set_discard()
; 3792 :       { /* Use this function only with input-oriented operations.  It informs
; 3793 :            the object that none of the code-blocks associated with this
; 3794 :            block will ever be accessed, so that it is free to skip over them
; 3795 :            when reading a packet.  This can save a lot of memory if you have
; 3796 :            a defined region of interest for decompression. */
; 3797 :         num_passes = 255;
; 3798 :       }
; 3799 :     bool empty()
; 3800 :       { // Returns true if the block has no code-bytes yet.
; 3801 :         return first_buf == NULL;
; 3802 :       }
; 3803 :     void set_modes(int modes)
; 3804 :       {
; 3805 :         assert(modes == (modes & 0xFF));
; 3806 :         this->modes = (kdu_byte) modes;
; 3807 :       }
; 3808 :   // --------------------------------------------------------------------------
; 3809 :   private: // Convenience functions for transferring data to/from code buffers.
; 3810 :     void start_buffering(kd_buf_server *buf_server) // Call before `put_byte'
; 3811 :       { assert(first_buf == NULL);
; 3812 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3813 :     void start_buffering(kd_thread_buf_server *buf_server)
; 3814 :       { assert(first_buf == NULL);
; 3815 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3816 :     void put_byte(kdu_byte val, kd_buf_server *buf_server)
; 3817 :       {
; 3818 :         assert(current_buf != NULL);
; 3819 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3820 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3821 :         current_buf->buf[buf_pos++] = val;
; 3822 :       }
; 3823 :     void put_word(int val, kd_buf_server *buf_server)
; 3824 :       {
; 3825 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3826 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))
; 3827 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3828 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;
; 3829 :         buf_pos += 2;
; 3830 :       }
; 3831 :     void put_address(kdu_byte *addr, kd_buf_server *buf_server)
; 3832 :       {
; 3833 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3834 :         if (buf_pos > (KD_CODE_BUFFER_LEN-KDU_POINTER_BYTES))
; 3835 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3836 : 
; 3837 :         ((kdu_byte **)(current_buf->buf+buf_pos))[0] = addr;
; 3838 :         buf_pos += KDU_POINTER_BYTES;
; 3839 :       }
; 3840 :     void put_byte(kdu_byte val, kd_thread_buf_server *buf_server)
; 3841 :       {
; 3842 :         assert(current_buf != NULL);
; 3843 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3844 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3845 :         current_buf->buf[buf_pos++] = val;
; 3846 :       }
; 3847 :     void put_word(int val, kd_thread_buf_server *buf_server)
; 3848 :       {
; 3849 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3850 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))
; 3851 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3852 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;
; 3853 :         buf_pos += 2;
; 3854 :       }
; 3855 :     void put_address(kdu_byte *addr, kd_thread_buf_server *buf_server)
; 3856 :       {
; 3857 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3858 :         if (buf_pos > (KD_CODE_BUFFER_LEN-KDU_POINTER_BYTES))
; 3859 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3860 : 
; 3861 :         ((kdu_byte **)(current_buf->buf+buf_pos))[0] = addr;
; 3862 :         buf_pos += KDU_POINTER_BYTES;
; 3863 :       }
; 3864 :     kdu_byte get_byte()
; 3865 :       {
; 3866 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3867 :           { buf_pos=0; current_buf=current_buf->next;
; 3868 :             assert(current_buf != NULL); }
; 3869 :         return current_buf->buf[buf_pos++];
; 3870 :       }
; 3871 :     int get_word()
; 3872 :       {
; 3873 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3874 :         buf_pos += 2; // Advance the buffer pointer
; 3875 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3876 :           { buf_pos=2; current_buf=current_buf->next;
; 3877 :             assert(current_buf != NULL); }
; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];
; 3879 :       }
; 3880 :     kdu_byte *get_address()
; 3881 :       {
; 3882 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3883 :         buf_pos += KDU_POINTER_BYTES; // Advance the buffer pointer
; 3884 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3885 :           { buf_pos=KDU_POINTER_BYTES; current_buf=current_buf->next;
; 3886 :             assert(current_buf != NULL); }
; 3887 :         return ((kdu_byte **)(current_buf->buf+buf_pos))[-1];
; 3888 :       }
; 3889 :     void skip_word()
; 3890 :       {
; 3891 :         buf_pos += 2 + (buf_pos & 1); // Align and advance the buffer pointer
; 3892 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3893 :           { buf_pos=2; current_buf=current_buf->next;
; 3894 :             assert(current_buf != NULL); }
; 3895 :       }
; 3896 :     void skip_address()
; 3897 :       {
; 3898 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3899 :         buf_pos += KDU_POINTER_BYTES; // Advance the buffer pointer
; 3900 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3901 :           { buf_pos=KDU_POINTER_BYTES; current_buf=current_buf->next;
; 3902 :             assert(current_buf != NULL); }
; 3903 :       }
; 3904 :   // --------------------------------------------------------------------------
; 3905 :   private: // Data (lots of unions to make it as small as possible!)
; 3906 :     union {
; 3907 :       kd_code_buffer *first_buf;
; 3908 :       kdu_uint16 save_layer_w; // Used for saving non-leaf node state
; 3909 :       };
; 3910 :     union {
; 3911 :       kd_code_buffer *current_buf;
; 3912 :       kdu_uint16 save_layer_wbar; // Used for saving_non-leaf node state
; 3913 :       };
; 3914 :     union {
; 3915 :       kdu_byte buf_pos; // Location of next read/write byte in `current_buf'.
; 3916 :       kdu_byte save_msbs_wbar; // Used for saving non-leaf node state
; 3917 :       };
; 3918 :     kdu_byte msbs_w;
; 3919 :     kdu_byte num_passes;
; 3920 :     kdu_byte pass_idx;
; 3921 :     union {
; 3922 :       kdu_uint16 layer_w; // Used only when `pass_idx'=0
; 3923 :       kdu_uint16 body_bytes_offset; // Used in packet output if `pass_idx' > 0
; 3924 :       kdu_byte save_beta; // Used during output simulation if `pass_idx' > 0
; 3925 :       };
; 3926 :     union {
; 3927 :       kdu_uint16 layer_wbar;
; 3928 :       kdu_uint16 num_bytes; // Used only for input operations
; 3929 :       kdu_byte pending_new_passes; // Used only for output operations
; 3930 :       };
; 3931 :     union {
; 3932 :       kdu_byte msbs_wbar;
; 3933 :       kdu_byte beta;
; 3934 :       };
; 3935 :     kdu_byte modes;
; 3936 :     kdu_uint16 temp_length; // Temporary storage of length quantities.
; 3937 :     kd_block *up_down;
; 3938 :   };
; 3939 :   /* Notes:
; 3940 :         This structure has been designed to provide sufficient state
; 3941 :      information for each code-block to perform packet header parsing as
; 3942 :      well as block encoding and decoding.  For coding purposes, the information
; 3943 :      represented by the structure is generally transferred to or from a
; 3944 :      much less tightly packed representation for speed of execution of the
; 3945 :      block coding routines.  As it stands, the total size of this structure
; 3946 :      should be 24 bytes on a 32-bit architecture. An array of code-blocks is
; 3947 :      maintained by each precinct-band.  The array contains one entry for
; 3948 :      every block in the relevant precinct-band, but also contains additional
; 3949 :      entries to be used as tag-tree nodes.  The total number of such extra
; 3950 :      nodes is about 1/3 the number of code-blocks and should not be a
; 3951 :      significant cause of concern for overall memory consumption. There is
; 3952 :      also substantial benefit to be had by locating the tag tree nodes in
; 3953 :      the same contiguous memory block.  Notice that the structure contains
; 3954 :      no reference back to the precinct-band to which it belongs.  When
; 3955 :      necessary, this reference must be supplied separately to interested
; 3956 :      functions. One consequence of this memory saving step is that the
; 3957 :      object's destructor cannot do anything useful.  It only checks to make
; 3958 :      sure that the explicit `cleanup' function has already been called.
; 3959 :         If a block is to be discarded (since it does not intersect with a
; 3960 :      user-specified region of interest), the `num_passes' field will hold
; 3961 :      the otherwise impossible value, 255.
; 3962 :         The `first_buf', `current_buf' and `buf_pos' fields constitute the
; 3963 :      compressed data buffer management mechanism, which is used to store all
; 3964 :      quantities whose length is unpredictable a priori. In particular, a
; 3965 :      linked list of `kd_code_buffer' structures is provided, which grows on
; 3966 :      demand through access to the codestream object's embedded `buffering'
; 3967 :      object.  Data is stored in these buffers in the following formats:
; 3968 :            * Input Format -- [<layer #> (<#bytes> <#passes> ...)] data [<...
; 3969 :              That is, for each layer to which the code-block makes a non-empty
; 3970 :              contribution, we record first the layer number (2 bytes) and
; 3971 :              then one or more #bytes/#passes pairs.  #bytes is represented
; 3972 :              using 2 bytes, while #passes is represented using only 1 byte.
; 3973 :              There is one such 3 byte pair for each layer and one additional
; 3974 :              3 byte pair for each codeword segment terminating pass which
; 3975 :              is not the final pass contributed in the layer.  In this way,
; 3976 :              sufficient information is provided to recover all termination
; 3977 :              lengths, as well as to build layer associations.  The most
; 3978 :              significant bit of the #bytes field is used as a marker to
; 3979 :              indicate whether or not this is the last such field prior to
; 3980 :              the appearance of the code bytes contributed by that layer.  A
; 3981 :              1 means that there are more fields to go before the code bytes
; 3982 :              appear.
; 3983 :            * In-memory Format --[<layer #>(<#bytes> <#passes>...)] <addr> [<...
; 3984 :              This format is used as an alternative to the Input Format above,
; 3985 :              in the special case when the compressed data source supports the
; 3986 :              `KDU_SOURCE_CAP_IN_MEMORY' capability, so that
; 3987 :              `kd_codestream::in_memory_source' is true.  In this case, the
; 3988 :              "data" field is replaced by the address where the data can be
; 3989 :              found in the memory block managed by the compressed data source.
; 3990 :              Moreover, if the number of code-bytes associated with a layer
; 3991 :              is zero, the <addr> field is missing.
; 3992 :            * Output Format -- [<RD slope> <#bytes>] ... [<RD ...] data
; 3993 :              That is, all of the header information for all coding passes
; 3994 :              appears up front, followed by all of the code bytes associated
; 3995 :              with those coding passes.  The reason for putting all the
; 3996 :              header information up front is that it facilitates the
; 3997 :              identification of appropriate layer contributions by the
; 3998 :              rate control algorithm.  Each coding pass has a 4 byte header,
; 3999 :              with 2 bytes for the distortion-length slope value and 2 bytes
; 4000 :              for the number of code-bytes for the pass.
; 4001 :      The particular format which is used to store data depends upon the
; 4002 :      member functions which are used, since these implicitly determine
; 4003 :      whether the codestream object is being used for input or output.
; 4004 :         The `modes' field holds the block coder mode fields.  Some of these
; 4005 :      are required even for correct packet header parsing, regardless of whether
; 4006 :      the block is to be actually decoded.
; 4007 :         `msbs_w' and `msbs_wbar' are the state information required
; 4008 :      for tag-tree coding of the number of missing MSB's for a code-block
; 4009 :      which is about to make its first non-empty contribution to the
; 4010 :      code-stream. Similarly, `layer_w' and `layer_wbar' hold the state
; 4011 :      information required for tag-tree coding of the layer index in which a
; 4012 :      code-block first contributes to the code-stream.  The operation of
; 4013 :      tag-tree coding and the `w' and `wbar' terminology are explained in
; 4014 :      Section 8.4 of the book by Taubman and Marcellin.
; 4015 :         The `beta' field shares storage with `msbs_wbar'.  This is not
; 4016 :      required until the number of missing MSB's has been encoded or decoded,
; 4017 :      at which point we initialize `beta' to 3 (see the JPEG2000 standard or
; 4018 :      Section 12.5.4 of the book by Taubman and Marcellin).  A useful
; 4019 :      consequence of this behaviour is that `beta' may be tested at any
; 4020 :      point of the packet header encoding or decoding process to determine
; 4021 :      whether or not the code-block has yet contributed to the code-stream
; 4022 :      -- the value will be non-zero if and only if it has done so.
; 4023 :         The `num_bytes' field shares storage with `layer_wbar'.  It
; 4024 :      identifies the total number of bytes included by the code-block in
; 4025 :      all packets read or written so far.  The value is taken to be 0 if
; 4026 :      the code-block has not yet contributed to any packets (`beta'=0),
; 4027 :      during which time the `layer_wbar' state variable is in use.
; 4028 :         The `up_down' field is used to efficiently navigate the tag-tree
; 4029 :      structure.  When the tag tree is not actually being navigated, the
; 4030 :      field points up to the current node's parent in the tag tree.  The
; 4031 :      root mode is readily identified by the fact that it has a NULL `up_down'
; 4032 :      pointer. During navigation, the tag-tree coder first walks from a
; 4033 :      leaf node up to the root, modifying the `up_down' pointers as it goes
; 4034 :      so that each successive parent's `up_down' field points bacl down to the
; 4035 :      child from which the parent was reached.  The coder then walks back down
; 4036 :      from the root to the original leaf node, restoring the `up_down' fields to
; 4037 :      their original `up' state. */
; 4038 : 
; 4039 : /*****************************************************************************/
; 4040 : /*                             kd_precinct_band                              */
; 4041 : /*****************************************************************************/
; 4042 : 
; 4043 : struct kd_precinct_band {
; 4044 :   /* Used to store state information for an element of the precinct partition
; 4045 :      within a single subband.  Once we get down to precincts and ultimately
; 4046 :      code-blocks, we have to be careful not to waste too much memory, since
; 4047 :      an image may have a very large number of these.  Moreover, it may be
; 4048 :      necessary to maintain tag-trees and other state information even for
; 4049 :      precincts which do not lie within our region of interest, so that the
; 4050 :      relevant packet headers can be parsed -- otherwise, we may have no way
; 4051 :      of knowing how to skip over packets which are not interesting to us. */
; 4052 :     kd_subband *subband;
; 4053 :     kdu_dims block_indices; /* Range of code-block indices for this precinct.
; 4054 :         This is a subset of the `block_indices' specified by the `subband'. */
; 4055 :     kd_block *blocks;
; 4056 :   };
; 4057 :   /* Notes:
; 4058 :      In order to make the representation of this object as efficient as
; 4059 :      possible, the two tag trees and all additional information required to
; 4060 :      correctly parse packet headers is maintained within the code-block
; 4061 :      array itself.  The `blocks' array consists of one element for each
; 4062 :      code-block, organized in raster fashion, plus additional elements to
; 4063 :      represent higher nodes in the tag-tree structure.  See the comments
; 4064 :      associated with the definition of `kd_block' for more information on
; 4065 :      this.
; 4066 :         In practice, the `blocks' array is not allocated separately on the
; 4067 :      heap.  Instead, the block of memory allocated to hold the `kd_precinct'
; 4068 :      structure is augmented by an amount sufficient to hold all of the
; 4069 :      code-blocks for all of the subbands in the precinct.  This is
; 4070 :      accomplished by the custom `kd_precinct::new' operator, which is
; 4071 :      informed of the maximum number of code-blocks required by any precinct
; 4072 :      within the containing `kd_resolution' object.  This value is maintained
; 4073 :      by the `kd_resolution::max_blocks_per_precinct" data member.  The
; 4074 :      `blocks' fields are initialized to the NULL state by the
; 4075 :      `kd_precinct::initialize' member function and are later set to point
; 4076 :      into appropriate locations in the precinct's memory block during
; 4077 :      tag-tree construction. */
; 4078 : 
; 4079 : /*****************************************************************************/
; 4080 : /*                                kd_precinct                                */
; 4081 : /*****************************************************************************/
; 4082 : 
; 4083 :   /* Precincts and all of their subordinate entities (precinct-bands and
; 4084 :      code-blocks) are maintained by a code-stream wide precinct server
; 4085 :      object, which allows for efficient allocation and recycling of the
; 4086 :      memory resources. The constructor is invoked from within the server,
; 4087 :      while the `initialize' and `release' functions are invoked from
; 4088 :      within the `kd_precinct_ref' class which manages references to
; 4089 :      precincts from within the `kd_resolution' object. */
; 4090 : 
; 4091 : // Interpretation of the following flags is given with the `flags' member:
; 4092 : #define KD_PFLAG_GENERATING  0x0001
; 4093 : #define KD_PFLAG_CORRUPTED   0x0002
; 4094 : #define KD_PFLAG_DESEQUENCED 0x0004
; 4095 : #define KD_PFLAG_ADDRESSABLE 0x0008
; 4096 : #define KD_PFLAG_RELEASED    0x0010
; 4097 : #define KD_PFLAG_INACTIVE    0x0020
; 4098 : #define KD_PFLAG_RELEVANT    0x0040
; 4099 : #define KD_PFLAG_SIGNIFICANT 0x0080
; 4100 : #define KD_PFLAG_PARSED      0x0100
; 4101 : 
; 4102 : struct kd_precinct {
; 4103 :   public: // Member functions
; 4104 :     void initialize(kd_resolution *resolution, kdu_coords pos_idx);
; 4105 :       /* Called from within `kd_precinct_ref::open' to configure a newly
; 4106 :          allocated (or recycled) object.  `pos_idx' holds the horizontal and
; 4107 :          vertical position of the precinct (starting from 0) within the array
; 4108 :          of precincts for the relevant resolution level.  Thus, `pos_idx'
; 4109 :          holds a relative index, rather than an absolute index. */
; 4110 :     void activate();
; 4111 :       /* This function is called from within `kd_precinct_ref::open' to
; 4112 :          re-activate a previously released precinct, which has not actually
; 4113 :          been unloaded from memory.  Substantially less work is required in
; 4114 :          this case, and the function must be careful to respect the current
; 4115 :          contents of the precinct's code-blocks.  The function sets the
; 4116 :          `num_required_layers' field for this activation (may change between
; 4117 :          successive `kd_tile::open' calls) and also sets the
; 4118 :          `num_outstanding_blocks' field to the total number of code-blocks
; 4119 :          which lie within the current region of interest. */
; 4120 :     void closing();
; 4121 :       /* Called from within `kd_precinct_ref::close' immediately prior to
; 4122 :          recycling the storage associated with the precinct, its precinct-bands
; 4123 :          and their code-blocks.  This function should release any resources
; 4124 :          which are specific to this particular precinct.  These resources
; 4125 :          include any non-NULL `layer_bytes' array and any code-byte buffers.
; 4126 :          Note that the `kd_precinct_ref::close' function may be called
; 4127 :          indirectly while opening a different precinct, if the current
; 4128 :          precinct has already been released.  This enables open calls to
; 4129 :          deal with resource limitations by unloading precincts which are not
; 4130 :          currently active. */
; 4131 :     void release()
; 4132 :       /* Used only for input codestream objects, this function is called once
; 4133 :          all code-blocks within the current region of interest have been
; 4134 :          consumed.  The function sets `num_outstanding_blocks' to 0, although
; 4135 :          in most cases this function will be called because
; 4136 :          `num_outstanding_blocks' has just become 0 (only exception is when
; 4137 :          a tile is being closed).  Also sets `released' to true.  If the
; 4138 :          KD_PFLAG_DESEQUENCED flag is false, the function returns without
; 4139 :          modifying the precinct in any other way.
; 4140 :             The `kd_precinct_ref::release' function is called to formally
; 4141 :          release the precinct's resources (this might not unload them from
; 4142 :          memory) if the codestream mode is non-persistent or if the precinct
; 4143 :          is addressable.  In the latter case, the precinct's contents can
; 4144 :          be reloaded from the compressed source if necessary.
; 4145 :             This function shall not be used with codestream objects
; 4146 :          opened for output or for interchange (no compressed data source and
; 4147 :          no compressed data target). */
; 4148 :       {
; 4149 :         assert(resolution->codestream->in != NULL);
; 4150 :         num_outstanding_blocks = 0;
; 4151 :         flags |= KD_PFLAG_RELEASED;
; 4152 :           // released = true;
; 4153 :         if ((flags & KD_PFLAG_ADDRESSABLE) ||
; 4154 :             ((flags & KD_PFLAG_DESEQUENCED) &&
; 4155 :                 // if (addressable ||
; 4156 :                 //     (desequenced &&
; 4157 :              !resolution->codestream->persistent))
; 4158 :           ref->release(); // May unload us from memory!
; 4159 :       }
; 4160 :     void finished_desequencing()
; 4161 :       /* Called once we can be sure that no more packets will be available
; 4162 :          for this precinct.  In practice, the function is called when the
; 4163 :          last packet has been desequenced or when the containing tile has
; 4164 :          been completely read.  If no packets at all have been desequenced for
; 4165 :          the precinct when this function is called (must have been invoked
; 4166 :          from within `kd_tile::finished_reading'), the precinct is marked
; 4167 :          as addressable, with an address of 0.  This is because it is safe
; 4168 :          to unload such a precinct and then reload it again regardless of
; 4169 :          the services offered by the compressed data source -- there is no
; 4170 :          data actually available from the compressed source for the
; 4171 :          precinct anyway, so reloading is a no-op.
; 4172 :             It should be noted that this function may unload the precinct
; 4173 :          from memory if it is determined that all code-blocks in the
; 4174 :          region of interest (there may be none) have already been consumed. */
; 4175 :       {
; 4176 :         if (flags & KD_PFLAG_DESEQUENCED)
; 4177 :           return;
; 4178 :         flags |= KD_PFLAG_DESEQUENCED;
; 4179 :           // desequenced = true;
; 4180 :         if (next_layer_idx == 0)
; 4181 :           {
; 4182 :             flags |= KD_PFLAG_ADDRESSABLE;
; 4183 :               // addressable = true;
; 4184 :             unique_address = 0;
; 4185 :           }
; 4186 :         if (num_outstanding_blocks == 0)
; 4187 :           release();
; 4188 :       }
; 4189 :     bool desequence_packet()
; 4190 :       /* This function should be called when a non-NULL `kd_precinct_ref'
; 4191 :          pointer is returned by `kd_packet_sequencer::next_in_sequence' and
; 4192 :          its `kd_precinct_ref::is_sequenced' function returns false.
; 4193 :          The function invokes `read_packet' and, if successful, increments
; 4194 :          the precinct's `next_layer_idx' field and the containing tile's
; 4195 :          `num_sequenced_packets' field.
; 4196 :             The function returns false if `read_packet' returns false,
; 4197 :          in which case, more tile-parts must be read (if there are any) to
; 4198 :          recover the information required to desequence the packet.
; 4199 :             Before returning true, the function checks to see whether all
; 4200 :          packets for the tile have been sequenced.  If so, the tile's
; 4201 :          `finished_reading' function is called. */
; 4202 :       {
; 4203 :         kd_tile *tile = resolution->tile_comp->tile;
; 4204 :         assert(!(flags & (KD_PFLAG_DESEQUENCED | KD_PFLAG_ADDRESSABLE)));
; 4205 :         if (!read_packet()) return false;
; 4206 :         next_layer_idx++;
; 4207 :         if (next_layer_idx == tile->num_layers)
; 4208 :           finished_desequencing();
; 4209 :         tile->next_input_packet_num++;
; 4210 :         if ((flags & KD_PFLAG_RELEVANT) &&
; 4211 :             (next_layer_idx <= tile->max_relevant_layers))
; 4212 :           {
; 4213 :             tile->sequenced_relevant_packets++;
; 4214 :             if (tile->sequenced_relevant_packets==tile->max_relevant_packets)
; 4215 :               tile->finished_reading();
; 4216 :           }
; 4217 :         return true;
; 4218 :       }
; 4219 :     void load_required_packets()
; 4220 :       /* If the precinct is addressable, this function uses its
; 4221 :          `unique_address' to position the compressed data source at the
; 4222 :          beginning of the precinct's first packet; it then loads all required
; 4223 :          packets from the compressed source.  Otherwise, the function does
; 4224 :          nothing at all -- reading is presumed to have occurred during packet
; 4225 :          desequencing. */
; 4226 :       {
; 4227 :         if ((!(flags & KD_PFLAG_ADDRESSABLE)) ||
; 4228 :             (unique_address == 0) || (num_packets_read != 0))
; 4229 :           return;
; 4230 :         assert((flags & KD_PFLAG_DESEQUENCED) &&
; 4231 :                (next_layer_idx >= required_layers));
; 4232 :         resolution->codestream->in->seek(unique_address);
; 4233 :         while (num_packets_read < required_layers)
; 4234 :           if (!read_packet())
; 4235 :             break;
; 4236 :       }
; 4237 :     kdu_long simulate_packet(kdu_long &header_bytes,
; 4238 :                              int layer_idx, kdu_uint16 slope_threshold,
; 4239 :                              bool finalize_layer, bool last_layer,
; 4240 :                              kdu_long max_bytes=KDU_LONG_HUGE,
; 4241 :                              bool trim_to_limit=false);
; 4242 :       /* Implements the functionality of `kd_codestream::simulate_output'
; 4243 :          for a single precinct.  Note that the total number of packet bytes
; 4244 :          is left behind in the internal `layer_bytes' array.  This allows the
; 4245 :          determination of tile-part length fields later on when we come to
; 4246 :          construct the code-stream.  The function returns this total number
; 4247 :          of bytes.  It also returns the number of packet header bytes via
; 4248 :          `header_bytes' (the function return value includes the cost of these
; 4249 :          header bytes).
; 4250 :             If the `max_bytes' limit is exceeded, the function may return
; 4251 :          prematurely, without having completed the simulation.  This is
; 4252 :          unacceptable when finalizing a layer, so you must be sure that
; 4253 :          `max_bytes' is sufficient in that case.
; 4254 :             If `trim_to_limit' is true, `finalize_layer' and `last_layer'
; 4255 :          must also both be true.  The function then trims away all coding
; 4256 :          passes from the precinct's code-blocks which are associated with
; 4257 :          slope values of `slope_threshold'+1 or less, until the limit
; 4258 :          associated with `max_bytes' is satisfied.  This functionality is
; 4259 :          used to implement the `sloppy_bytes' capabilities advertised by the
; 4260 :          `kd_codestream::simulate_output' function. */
; 4261 :     kdu_long write_packet(kdu_uint16 slope_threshold, bool empty_packet=false);
; 4262 :       /* Writes out the next packet for this precinct, using the supplied
; 4263 :          distortion-length slope threshold.  Increments the `next_layer_idx'
; 4264 :          field as well as the containing tile's `num_sequenced_packets'
; 4265 :          field when done.  If `empty_packet' is true, an empty packet should
; 4266 :          be issued, having a length of 1 byte, plus the length of any required
; 4267 :          EPH marker (no SOP marker will be attached to empty packets).  The
; 4268 :          function returns the total number of bytes output for the packet. */
; 4269 :   private: // Member functions
; 4270 :     bool read_packet();
; 4271 :       /* Reads a new layer of this precinct sequentially from the
; 4272 :          compressed data source, incrementing the `num_packets_read' member.
; 4273 :          Note that packet reading may be interleaved with acesses to the
; 4274 :          precinct's code-blocks for various reasons.  For example, we
; 4275 :          may initially open a tile with only a limited number of required
; 4276 :          layers, using its code-block data to decompress an approximate
; 4277 :          representation of the image.  We may then find that the additional
; 4278 :          packets need to be loaded in order to advance to other precincts
; 4279 :          in the code-stream.
; 4280 :             The function returns false if an SOT marker (or an EOC marker) is
; 4281 :          encountered.  Note that when an SOT marker is encountered, its
; 4282 :          segment is fully read into the codestream marker service and the
; 4283 :          precinct's tile must be active (otherwise an error message will be
; 4284 :          generated).  Before returning false in this way, the function sets
; 4285 :          the `active_tile' pointer in the codestream object to NULL.  The
; 4286 :          caller may determine the cause of failure by invoking the codestream
; 4287 :          marker service's `get_code' function, which will return one of SOT,
; 4288 :          EOC or 0, where 0 occurs only if the code-stream has been
; 4289 :          exhausted. */
; 4290 :     bool handle_corrupt_packet();
; 4291 :       /* This function implements alternate processing for the `read_packet'
; 4292 :          function in the event that a packet is found to be corrupt.  It is
; 4293 :          called whenever packet corruption is detected, including when the
; 4294 :          precinct is known to have had previously corrupt packets. The function
; 4295 :          manipulates the containing tile's `skipping_to_sop' and
; 4296 :          `next_sop_sequence_num' fields, advancing to the next SOP or SOT
; 4297 :          marker if necessary (the function may be called after detecting an
; 4298 :          SOP marker already, whose sequence number is not as expected).  If
; 4299 :          an SOT marker is encountered, the function renders the current tile
; 4300 :          inactive and returns false (this is the behaviour expected of
; 4301 :          `read_packet').  Otherwise, it updates the precinct and tile state to
; 4302 :          identify the packet as having been read. */
; 4303 :   public: // Public Links and Identification
; 4304 :     kd_resolution *resolution;
; 4305 :     kd_precinct_ref *ref; // Element of `resolution->precinct_refs' array
; 4306 : 
; 4307 :   public: // Mode flags used for decompression and/or interchange
; 4308 :     int flags; // The following flags are defined.
; 4309 :        // KD_PFLAG_GENERATING -- after 1'st call to `kd_precinct::get_packets'
; 4310 :        // KD_PFLAG_CORRUPTED -- if error occurred during packet reading
; 4311 :        // KD_PFLAG_DESEQUENCED -- if all packets have been desequenced
; 4312 :        // KD_PFLAG_ADDRESSABLE -- if seekable, cached or used for interchange
; 4313 :        // KD_PFLAG_RELEASED -- if `activate' must be called to revive state
; 4314 :        // KD_PFLAG_INACTIVE -- if resides on `kd_precict_server's inactive list
; 4315 :        // KD_PFLAG_RELEVANT -- always true if codestream is for non-persistent
; 4316 :        //     input; otherwise, true only if precinct belongs to the relevant
; 4317 :        //     set of precincts of a relevant tile-component-resolution
; 4318 :        // KD_PFLAG_SIGNIFICANT -- if any code-block bytes have been generated
; 4319 :        //     by `kdu_precinct::size_packets' or `kdu_precinct::get_packets'
; 4320 :        // KD_PFLAG_PARSED -- if the precinct was parsed previously and then
; 4321 :        //     unloaded; prevents multiple accumulation of packet length stats
; 4322 :   public: // State variables
; 4323 :     int required_layers; /* Actual number of layers for output codestream;
; 4324 :                 max apparent layers for input or interchange codestream. */
; 4325 :     int next_layer_idx; // Next layer to be sequenced or generated.
; 4326 :     union { // First field used for input; second interchange; third for output
; 4327 :         int num_packets_read; // Incremented when packets read or interchanged
; 4328 :         int cumulative_bytes; // Size of all packets generated so far.
; 4329 :         int saved_next_layer_idx; // Used by "kd_packet_sequencer::save_state"
; 4330 :       };
; 4331 : 
; 4332 :   public: // Activation state variables
; 4333 :     int num_outstanding_blocks; // See notes below.
; 4334 :     union { // First field used only in reading; second only in writing.
; 4335 :         kdu_long unique_address; // See below
; 4336 :         kdu_long *packet_bytes; // Lengths generated during simulated output
; 4337 :       };
; 4338 :   public: // code-block containers
; 4339 :     kd_precinct_band *subbands; // In practice, this member points into the
; 4340 :        // same block of memory which is allocated to hold the precinct so
; 4341 :        // as to encourage memory locality and allow for manipulation of all
; 4342 :        // aspects of a precinct, including all of its code-blocks, via a
; 4343 :        // single heap block.  Note that the number of entries in this array
; 4344 :        // is given by `resolution->num_subbands'.
; 4345 : 
; 4346 :   public: // See below for an explanation of these links
; 4347 :     kd_precinct *next; // Next in free, inactive or generated list
; 4348 :     kd_precinct *prev; // Previous in inactive or generated list
; 4349 :     kd_precinct_size_class *size_class; // For correctly releasing storage
; 4350 :   };
; 4351 :   /* Notes:
; 4352 :         `unique_address' is valid if and only if the precinct is marked as
; 4353 :      addressable, meaning that the precinct has a unique address from which it
; 4354 :      may be loaded (for input codestream objects) or identified (for
; 4355 :      interchange codestream objects).  If addressable, the `unique_address'
; 4356 :      will be 0 if and only if the precinct is known to be empty, meaning that
; 4357 :      reloading the precinct does not require any actual data transfers from a
; 4358 :      compressed data source.
; 4359 :         Except as described above, when used with seekable compressed data
; 4360 :      sources, the `unique_address' member holds a positive quantity which
; 4361 :      identifies an offset into the code-stream at which the precinct's
; 4362 :      packets may be found.  In the case of cached sources (those advertising
; 4363 :      the KDU_SOURCE_CAP_CACHED capability) or codestream objects created for
; 4364 :      interchange (no compressed data source or target), the `unique_address'
; 4365 :      will be negative and -(1+`unique_address') is the precinct's unique
; 4366 :      identifier, as passed to the `kdu_compressed_source::set_precinct_scope'
; 4367 :      function, or returned by the `kdu_precinct::get_unique_id' function.
; 4368 :         The `num_outstanding_blocks' member is used to monitor the number of
; 4369 :      code-blocks from the application's region of interest which have still
; 4370 :      to be consumed (input codestreams) or the number of code-blocks which
; 4371 :      have still to be written in order to complete the precinct (output
; 4372 :      and interchange codestreams).
; 4373 :         The `next' and `prev' links may be used to manage the precinct's
; 4374 :      location in one of three different lists.  The first list is the
; 4375 :      singly-linked free list maintained by `kd_precinct_size_class', from
; 4376 :      which the `kd_precinct_server' object re-issues previously released
; 4377 :      resources.
; 4378 :         The second list on which this structure may find itself is the
; 4379 :      doubly-linked list of currently inactive precincts, which is managed by
; 4380 :      the `kd_precinct_server' object.  Precincts which find themselves on this
; 4381 :      list have been released, but their resources have not yet been recycled.
; 4382 :      They may be successfully re-activated, if their resources have not been
; 4383 :      re-issued to another precinct.  Precincts on this list may be identified
; 4384 :      by the `inactive' flag.  Every inactive precinct necessarily also has
; 4385 :      its `released' member set to true, but the converse is not necessarily
; 4386 :      true.  This is because precincts which have been partially parsed
; 4387 :      in a context for which they were not directly relevant, will be marked
; 4388 :      as released, even though they are not inactive.
; 4389 :         The third list on which this structure may find itself is the
; 4390 :      doubly-linked list of generated precincts managed by the
; 4391 :      `kd_global_rescomp' structure.  This list contains all precincts
; 4392 :      from a given resolution of a given image component, across all tiles,
; 4393 :      which have been fully generated, but not yet flushed out to the
; 4394 :      code-stream.   The list is used to manage incremental rate allocation
; 4395 :      when processing large images.  Elements on this list have not yet
; 4396 :      been closed. */
; 4397 : 
; 4398 : /*****************************************************************************/
; 4399 : /*                         kd_precinct_size_class                            */
; 4400 : /*****************************************************************************/
; 4401 : 
; 4402 :   /* For an explanation of the role played by precinct size classes, see
; 4403 :      the discussion appearing below the declaration of `kd_precinct_server'. */
; 4404 : 
; 4405 : class kd_precinct_size_class {
; 4406 :   public: // Member functions
; 4407 :     kd_precinct_size_class(int max_blocks, int num_subbands,
; 4408 :                            kd_precinct_server *server,
; 4409 :                            kd_buf_server *buf_server)
; 4410 :       {
; 4411 :         this->max_blocks = max_blocks;
; 4412 :         this->num_subbands = num_subbands;
; 4413 :         this->server = server;  this->buf_server = buf_server;
; 4414 :         total_precincts = 0; free_list = NULL; next = NULL;
; 4415 :         alloc_bytes = (int) sizeof(kd_precinct);
; 4416 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4417 :         alloc_bytes += num_subbands * (int) sizeof(kd_precinct_band);
; 4418 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4419 :         alloc_bytes += 4 + max_blocks * (int) sizeof(kd_block);
; 4420 :       }
; 4421 :     ~kd_precinct_size_class()
; 4422 :       { kd_precinct *tmp;
; 4423 :         while ((tmp=free_list) != NULL)
; 4424 :           { free_list = tmp->next; free(tmp); total_precincts--; }
; 4425 :         assert(total_precincts == 0);
; 4426 :       }
; 4427 :     kd_precinct *get()
; 4428 :       {
; 4429 :         if (free_list == NULL)
; 4430 :           augment_free_list();
; 4431 :         kd_precinct *result = free_list; free_list = free_list->next;
; 4432 :         result->next = result->prev = NULL;
; 4433 :         buf_server->augment_structure_bytes(alloc_bytes);
; 4434 :         return result;
; 4435 :       }
; 4436 :     void release(kd_precinct *precinct)
; 4437 :       {
; 4438 :         if (precinct->flags & KD_PFLAG_INACTIVE)

	test	BYTE PTR [esi+8], 32			; 00000020H

; 4676 :       precinct->size_class->release(precinct);

	mov	edx, DWORD PTR [esi+52]
	mov	DWORD PTR _this$1$[ebp], edx

; 2961 :           }
; 2962 :       }
; 2963 :   public: // Links and Identification
; 2964 :     kd_codestream *codestream;
; 2965 :     kd_tile *tile;
; 2966 :     kd_comp_info *comp_info; // Ptr to relevant `codestream->comp_info' entry
; 2967 :     int cnum;
; 2968 : 
; 2969 :   public: // Dimensions and Parameters
; 2970 :     kdu_coords sub_sampling;
; 2971 :     kdu_dims dims;
; 2972 :     kdu_dims region;
; 2973 :     int dwt_levels, apparent_dwt_levels;
; 2974 :     bool reversible;
; 2975 :     int kernel_id; // Ckernels_W5X3, Ckernels_W9X7 or Ckernels_ATK
; 2976 :     bool kernel_symmetric, kernel_symmetric_extension;
; 2977 :     int kernel_num_steps;
; 2978 :     kdu_kernel_step_info *kernel_step_info, *kernel_step_info_flipped;
; 2979 :     float *kernel_coefficients, *kernel_coefficients_flipped;
; 2980 :     float kernel_low_scale; // Amount to scale low-pass lifting analysis output
; 2981 :     float kernel_high_scale; // Amount to scale hi-pass lifting analysis output
; 2982 :     int low_support_min, low_support_max; // low-pass synthesis impulse support
; 2983 :     int high_support_min, high_support_max; // high-pass synth impulse support
; 2984 :     float G_tc; // Global multi-component energy gain term; -ve if not known
; 2985 :     float G_tc_restricted; // Multi-component energy gain term based only on
; 2986 :             // those output components currently of interest; -ve if not known
; 2987 :     int recommended_extra_bits;
; 2988 :     kdu_coords blk; // Nominal code-block dimensions.
; 2989 :     int modes; // Block coder modes.  Flags defined in scope `cod_params'
; 2990 : 
; 2991 :   public: // Arrays
; 2992 :     kd_resolution *resolutions; // Contains 1+`dwt_levels' entries.
; 2993 :     kdu_long *layer_stats; // Contains `num_layers' pairs per resolution,
; 2994 :       // starting from the lowest resolution (`res_level'=0); each pair holds
; 2995 :       // number of parsed packets for the layer-resolution, followed by
; 2996 :       // number of parsed packet bytes for the layer-resolution.  Available
; 2997 :       // only for input codestreams; populated by `kd_precinct::read_packet'.
; 2998 : 
; 2999 :   public: // Flags and Other State Variables
; 3000 :     bool enabled; // See below
; 3001 :     bool is_of_interest; // See below
; 3002 :     kdu_coords grid_min; // These fields are used by "kd_packet_sequencer"
; 3003 :     kdu_coords grid_inc; // for spatially oriented progressions.
; 3004 :     kdu_coords saved_grid_min; // For "kd_packet_sequencer::save_state"
; 3005 :     kdu_coords saved_grid_inc; // For "kd_packet_sequencer::save_state"
; 3006 :   };
; 3007 :   /* Notes:
; 3008 :         `recommended_extra_bits' may be added to the sample bit-depth
; 3009 :      (precision) for this component to determine an appropriate number
; 3010 :      of bits for internal representations associated with the data
; 3011 :      processing path.
; 3012 :         In the reversible path, the value is set to the maximum bit-depth
; 3013 :      expansion factor, as reported in Table 17.4 of the book by Taubman and
; 3014 :      Marcellin, adding an extra 1 bit if the RCT has been used -- note that it
; 3015 :      is not desirable for luminance and chrominance components to have
; 3016 :      different numeric representations, since that would significantly
; 3017 :      complicate the colour transform procedure.
; 3018 :         In the irreversible path, the value is set to 7, which means
; 3019 :      that 16-bit representations are judged sufficient for 9 bit
; 3020 :      imagery or less.  Of course, the impact of selecting a reduced
; 3021 :      representation precision is only reduced accuracy in the
; 3022 :      irreversible processing path.
; 3023 :         The `enabled' flag is used to efficiently identify the tile-components
; 3024 :      which are enabled.  Remember that a tile-component may be disabled,
; 3025 :      either because the corresponding codestream image component is not
; 3026 :      apparent (only when the `kd_codestream::component_access_mode' is
; 3027 :      `KDU_WANT_CODESTREAM_COMPONENTS'), or because the tile-component
; 3028 :      is not involved in the construction of an apparent output image
; 3029 :      component (when the `kd_codestream::component_access_mode' is
; 3030 :      `KDU_WANT_OUTPUT_COMPONENTS').  In the latter case, all codestream
; 3031 :      image components are apparent, but disabled ones cannot be
; 3032 :      accessed -- this is important, since in the latter case the set
; 3033 :      of enabled components may vary from tile to tile.
; 3034 :         The `is_of_interest' flag is used to store the identify of components
; 3035 :      which are marked as being of interest, by calls to
; 3036 :      `kdu_tile::set_components_of_interest'.  This is done only when the
; 3037 :      component access mode is `KDU_WANT_CODESTREAM_COMPONENTS' or the
; 3038 :      `mct_head' member is NULL.  Otherwise, the components of interest are
; 3039 :      passed directly to the `kd_mct_stage::apply_output_restrictions'
; 3040 :      function.  Note that the `is_of_interest' flags do not generally
; 3041 :      belong to the component in which they are stored.  They are just
; 3042 :      copies of the information supplied to
; 3043 :      `kdu_tile::set_components_of_interest', without any attempt to apply
; 3044 :      any component index permutations which might be relevant. */
; 3045 : 
; 3046 : /*****************************************************************************/
; 3047 : /*                            kd_precinct_ref                                */
; 3048 : /*****************************************************************************/
; 3049 : 
; 3050 :   /* Objects of this class provide the vehicle through which precincts
; 3051 :      references are instantiated and removed from the array of precinct
; 3052 :      references maintained by the `kd_resolution' object.  It is important
; 3053 :      that the state information be small.  In particular, it has the same
; 3054 :      size as `kdu_long', which should never be smaller than the size of
; 3055 :      a memory pointer, but may be larger -- see the declaration of
; 3056 :      `kdu_long' in "elementary.h".  For precincts whose seek addresses are
; 3057 :      deduced from PLT marker segments in the code-stream, or precincts which
; 3058 :      are maintained by a caching data source, or precincts which are used by
; 3059 :      codestream objects created for interchange, this object provides
; 3060 :      facilities for recycling a disused precinct's resources while keeping its
; 3061 :      unique address around for rapid reloading in the event that it
; 3062 :      is required at a later point. */
; 3063 : 
; 3064 : class kd_precinct_ref {
; 3065 :   public: // Member functions
; 3066 :     kd_precinct_ref()
; 3067 :       { state = 0; }
; 3068 :     ~kd_precinct_ref()
; 3069 :       { if (!((state == 0) || (state & 1))) close(); }
; 3070 :     bool parsed_and_unloaded()
; 3071 :       { return ((state & 3) == 3) && (state != 3); }
; 3072 :       /* Returns true if the precinct is addressable (i.e., dynamically
; 3073 :          loadable) and it has been parsed and subsequently unloaded from
; 3074 :          memory. */
; 3075 :     kd_precinct *deref()
; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }
; 3077 :       /* Returns NULL unless the reference identifies a valid `kd_precinct'
; 3078 :          object, which is already loaded in memory. */
; 3079 :     kd_precinct *active_deref();
; 3080 :       /* Returns NULL unless the reference identifies a valid `kd_precinct'
; 3081 :          object, which is already loaded in memory and is in the active
; 3082 :          state. */
; 3083 :     kd_precinct *open(kd_resolution *res, kdu_coords pos_idx,
; 3084 :                       bool need_activate);
; 3085 :       /* Attempts to open the precinct at the indicated position within the
; 3086 :          array of precincts maintained by the indicated resolution object.
; 3087 :          `pos_idx' holds the horizontal and vertical position of the
; 3088 :          precinct (starting from 0) within the array of precincts for
; 3089 :          the given resolution.  That is, `pos_idx' holds a relative, not
; 3090 :          an absolute precinct index.
; 3091 :             If the precinct is known to be unloadable (this happens if the
; 3092 :          precinct has previously been opened and has then been permanently
; 3093 :          closed), the function returns NULL.
; 3094 :             If the precinct currently exists in memory (the `state' variable
; 3095 :          contains a valid pointer to the precinct), the function returns a
; 3096 :          pointer to that precinct; however, if `need_activate' is true
; 3097 :          and the precincts's `released' flag is true, `kd_precinct::activate'
; 3098 :          is called before returning the `kd_precinct' pointer.  When the
; 3099 :          codestream object was created for input or for interchange, the
; 3100 :          `need_activate' argument should be set to true only when the
; 3101 :          precinct is being opened in order to access code-block data.  In
; 3102 :          that case, the precinct must belong to an open tile and lie within
; 3103 :          the application's current region of interest, meaning that it will
; 3104 :          be released again when the tile is closed.  For codestream objects
; 3105 :          created for output, the argument should have no effect, since
; 3106 :          output precincts are not actually released.
; 3107 :             Otherwise, the function obtains a new `kd_precinct' object from
; 3108 :          the code-stream's precinct server and calls its `initialize'
; 3109 :          function.  If the `state' variable held the precinct's unique
; 3110 :          address value on entry, that address is written into the newly
; 3111 :          instantiated `kd_precinct' object's `unique_address' field, and
; 3112 :          the P bit (see notes on `state' below) is copied to the precinct's
; 3113 :          KD_PFLAG_PARSED flag.  If compressed data comes from a cached source,
; 3114 :          or the codestream object was created for interchange (no compressed
; 3115 :          data sources or targets), the newly created precinct is automatically
; 3116 :          marked as addressable, with its `unique_address' set to the
; 3117 :          precinct's unique identifier, as described in the comments appearing
; 3118 :          with the declaration of `kd_precinct::unique_address'.  For
; 3119 :          precincts which can be addressed using a seek address (for seekable
; 3120 :          compressed data sources), the seek address is installed using
; 3121 :          `set_address' from within the `kd_packet_sequencer::next_in_sequence'
; 3122 :          function.
; 3123 :             It is worth noting that this function may cause other precincts
; 3124 :          to be unloaded from memory, in order to conserve memory resources.
; 3125 :          If this happens, only precincts which have been released and
; 3126 :          which do not intersect with the current region of interest will be
; 3127 :          unloaded. */
; 3128 :     void close();
; 3129 :       /* Closes the active `kd_precinct' object whose pointer is in
; 3130 :          `state', calling its `closing' member function and recycling its
; 3131 :          storage.  If the precinct is marked as addressable, its
; 3132 :          `unique_address' member and KD_PFLAG_PARSED flag are recorded in
; 3133 :          `state' using the convention outlined in the notes below, allowing
; 3134 :          the precinct to be re-opened at a later point.
; 3135 :             In many cases, you are better off calling the `release' member
; 3136 :          function instead of `close' (see below).
; 3137 :             Note that this function may be safely invoked even when the
; 3138 :          precinct is not currently active -- it does nothing unless `state'
; 3139 :          holds a valid precinct address. */
; 3140 :     void close_and_reset();
; 3141 :       /* This function is used only by `kdu_tile::parse_all_relevant_packets'
; 3142 :          and then only if it is asked to parse everything from scratch.  The
; 3143 :          behaviour is similar to calling `close', except that the internal
; 3144 :          `state' record is left with its P flag reset, so that when the
; 3145 :          precinct is reloaded, its packet statistics will be entered into
; 3146 :          the `kd_tile_comp::layer_stats' array -- the caller invariably
; 3147 :          resets this array. */
; 3148 :     void release();
; 3149 :       /* This function should be called once a precinct is no longer
; 3150 :          required, in preference to the `close' function.  If the system is
; 3151 :          running low on resources, the function may unload the precinct from
; 3152 :          memory to recycle its resources.  Alternatively, the function is at
; 3153 :          liberty to leave the precinct in memory, moving it to a list of
; 3154 :          inactive precincts which are subject to unloading at some point in
; 3155 :          the future, when resources may be running low.  Non-addressable or
; 3156 :          cached precincts are unloaded immediately, since they are
; 3157 :          guaranteed never to be re-opened once `release' has been called. */
; 3158 :     void clear();
; 3159 :       /* This function recycles the storage associated with any existing
; 3160 :          precinct and sets the internal `state' variable to 0.  It is called
; 3161 :          when the code-stream management machinery is restarted. */
; 3162 :     bool is_desequenced();
; 3163 :       /* This function is intended for use within
; 3164 :          `kd_packet_sequencer::next_in_sequence', for checking whether
; 3165 :          or not the precinct which is returned by that function needs
; 3166 :          to have its contents read from a compressed data source in
; 3167 :          order to desequence a new packet.  Opening precincts can be a time
; 3168 :          consuming task, especially when there are an enormous number of
; 3169 :          precincts (this can happen when working with huge untiled images,
; 3170 :          especially in geospatial applications).  This function takes
; 3171 :          advantage of the fact that there is no need to actually open a
; 3172 :          precinct which is not already loaded into memory.  The fact that this
; 3173 :          function is called first by the packet desequencer, allows a precinct
; 3174 :          which has already been fully generated to be closed immediately
; 3175 :          during packet generation mode.
; 3176 :             The function works as follows.  If the precinct is already loaded
; 3177 :          in memory, its `sequenced' flag is accessed directly.   Otherwise,
; 3178 :          if the reference `state' variable identifies a valid unique
; 3179 :          address for the precinct, it is known to be addressable and
; 3180 :          therefore must have already been fully desequenced.  Also, if the
; 3181 :          `state' variable indicates that the precinct is unloadable, or that
; 3182 :          it has been closed in packet generation mode, it is interpreted as
; 3183 :          sequenced, in the sense that the application cannot sequence further
; 3184 :          packets for the precinct.  Otherwise, the `state' variable must hold
; 3185 :          0 (see below), from which we deduce that the precinct has not yet
; 3186 :          been sequenced. */
; 3187 :     bool set_address(kd_resolution *res, kdu_coords pos_idx,
; 3188 :                      kdu_long seek_address);
; 3189 :       /* Called from within `kd_packet_sequencer::next_in_sequence', this
; 3190 :          function installs a seek address for a precinct whose packets are
; 3191 :          contiguous within the code-stream and have valid pointer information
; 3192 :          stored in PLT marker segments.  Subsequent calls to `is_sequenced'
; 3193 :          will return true.  The precinct itself may either be open or closed
; 3194 :          when this function is called.  The `pos_idx' argument is provided
; 3195 :          for computing the relevance of this precinct to the application.  It
; 3196 :          holds a relative precinct index, having the same interpretation as
; 3197 :          that passed to `kd_precinct::initialize' and `kdu_precinct_ref::open'.
; 3198 :             It can happen that this function causes the tile, and hence the
; 3199 :          precinct reference, to be destroyed.  This happens if the call to
; 3200 :          this function renders the resolution or tile completely parsed,
; 3201 :          and it is known that the application has no need for any further
; 3202 :          access to the tile.  In this case, and only in this case, the
; 3203 :          function returns false, meaning that the caller must not make
; 3204 :          any further attempt to access the tile or any of its resources. */
; 3205 :   private: // Utility functions
; 3206 :     kd_precinct *instantiate_precinct(kd_resolution *res, kdu_coords pos_idx);
; 3207 :       /* Called from `open' if the `kd_precinct' object is not in memory at
; 3208 :          the time and can legitimately be created at this point. */
; 3209 :   private: // Data
; 3210 :     kdu_long state;
; 3211 :   };
; 3212 :   /* Notes:
; 3213 :         `state' holds 0 if no information is yet available concerning the
; 3214 :      precinct associated with this reference.
; 3215 :         If the precinct is currently active in memory, `state' holds the
; 3216 :      address in memory (pointer) of the `kd_precinct' structure.
; 3217 :         If the precinct is known to be addressable, `state' holds an odd
; 3218 :      integer, equal to 4*A + 2*P + 1, where A is the precinct's
; 3219 :      `unique_address' value and P is a flag, equal to 1 if the precinct
; 3220 :      has been loaded and parsed previously.
; 3221 :         The `unique_address' value has the same definition as the
; 3222 :      corresponding data member in `kd_precinct'.
; 3223 :         This P flag plays the same role as the KD_PFLAG_PARSED bit in
; 3224 :      `kd_precinct::flags'.  It is used to avoid collecting layer size
; 3225 :      statistics twice for the same precinct which could otherwise happen
; 3226 :      when precincts get swapped in and out of memory on demand.
; 3227 :         A value of `state'=1 means that the precinct can be re-instantiated,
; 3228 :      but that it is known to contain no packets whatsoever.
; 3229 :         If a previously active precinct's resources have been recycled and
; 3230 :      re-loading is not possible, `state' is assigned the special value of 3. */
; 3231 : 
; 3232 : /*****************************************************************************/
; 3233 : /*                               kd_leaf_node                                */
; 3234 : /*****************************************************************************/
; 3235 : 
; 3236 : struct kd_leaf_node {
; 3237 :     public: // Data
; 3238 :       kd_node *parent; // Every leaf node has a non-leaf parent node
; 3239 :       kd_resolution *resolution; // Always points to the owning resolution
; 3240 :       kdu_dims dims; // Dimensions & location of the image at this node
; 3241 :       kdu_dims region; // See below
; 3242 :       kdu_byte branch_x, branch_y; // See below
; 3243 :       bool is_leaf; // False if this object is the base of `kd_node'
; 3244 :   };
; 3245 :   /* Notes:
; 3246 :         This structure is the base of the richer `kd_node' structure.  The
; 3247 :      key difference is that leaf nodes have no children, so we do not waste
; 3248 :      storage recording pointers to them.
; 3249 :         The `branch_x' and `branch_y' members describe how this node is
; 3250 :      derived from its parent node, if any.  `branch_x' holds 0 if horizontal
; 3251 :      low-pass filtering and decimation were used to obtain the node from its
; 3252 :      parent; it holds 1 if horizontal high-pass filtering and decimation were
; 3253 :      used; it holds 2 if no filtering or decimation were involved in the
; 3254 :      horizontal direction.  `branch_y' plays a similar role in describing the
; 3255 :      vertical filtering and decimation processes.  If `parent' is NULL,
; 3256 :      the `branch_x' and `branch_y' members have no meaning.
; 3257 :         This structure manages two different, yet related regions
; 3258 :      (location, plus dimensions) which deserve some explanation here.
; 3259 :      * The `dims' member serves the usual role of identifying the location and
; 3260 :        dimensions of the image, as it appears on entry into this node,
; 3261 :        during forward transformation (analysis).  For primary nodes,
; 3262 :        these are the dimensions and location of the tile-component-resolution
; 3263 :        within its canvas.
; 3264 :      * `region' identifies a subset of the `dims' region, containing
; 3265 :        all of the node's samples which are involved in the synthesis of the
; 3266 :        current region of interest, as specified in the most recent call to
; 3267 :        `kdu_codestream::apply_input_restrictions'. */
; 3268 : 
; 3269 : /*****************************************************************************/
; 3270 : /*                                 kd_node                                   */
; 3271 : /*****************************************************************************/
; 3272 : 
; 3273 : struct kd_node : public kd_leaf_node {
; 3274 :     public: // Member functions
; 3275 :       void adjust_cover(kdu_dims child_cover,
; 3276 :                         int child_branch_x, int child_branch_y);
; 3277 :         /* This function is used to find the `region_cover' members.  In
; 3278 :            a downward sweep through the decomposition branches associated
; 3279 :            with a given resolution level, the `region_cover' members are all
; 3280 :            set to empty regions.  We then assign each leaf node (subband)
; 3281 :            a region cover (not actually recorded in the leaf node) equal to
; 3282 :            its region of interest and work back up the tree from the
; 3283 :            leaves to the primary node of the resolution in question, calling
; 3284 :            this function to grow the region cover so as to encompass the
; 3285 :            smallest region which covers each of its children. */
; 3286 :     public: // Data
; 3287 :       kdu_dims region_cover; // See below
; 3288 :       kdu_dims prec_dims; // Temp storage for calculating precinct dimensions
; 3289 :       kd_leaf_node *children[4]; // Indexed by `LL_BAND' through `HH_BAND'
; 3290 :       kdu_byte num_hor_steps, num_vert_steps; // See below
; 3291 :       kdu_uint16 num_descendant_nodes;
; 3292 :       kdu_uint16 num_descendant_leaves;
; 3293 :       float *bibo_gains; // See below
; 3294 :   };
; 3295 :   /* Notes:
; 3296 :         This object is used to construct descriptions of all non-leaf
; 3297 :      nodes in the DWT decomposition structure.  Each node in the structure
; 3298 :      may be decomposed horizontally, vertically or both.  If it is decomposed
; 3299 :      in the horizontal direction, `children[HL_BAND]' will be non-NULL.  If it
; 3300 :      is decomposed in the vertical direction, `children[LH_BAND]' will be
; 3301 :      non-NULL.  If it is decomposed in both directions, `children[HH_BAND]'
; 3302 :      will also be non-NULL.  If it is decomposed at all, `children[LL_BAND]'
; 3303 :      will always be non-NULL.
; 3304 :         The decomposition structure consists of a collection of primary
; 3305 :      nodes, each of which is embedded within a `kd_resolution' object.
; 3306 :      In the case of the simple Mallat structure, each primary node has
; 3307 :      4 children, with the LL child embedded within the next lower
; 3308 :      resolution object and the remaining children embedded within
; 3309 :      `kd_subband' objects.  In wavelet packet decomposition structures,
; 3310 :      detail subbands produced by a primary node may, themselves, be
; 3311 :      decomposed further into subbands.
; 3312 :         The actual object pointed to by each non-NULL member of the `children'
; 3313 :      array may need to be cast to type `kd_node', rather than `kd_leaf_node'
; 3314 :      if the `kd_leaf_node::is_leaf' member is false.
; 3315 :         The `children[LL_BAND]' entry of a primary node always points to
; 3316 :      the node which is embedded within the next lower resolution
; 3317 :      `kd_resolution' object, except at the lowest resolution of all.
; 3318 :      The lowest `kd_resolution' object's embedded node has only one
; 3319 :      child, with `children[LL_BAND]' pointing to the single (LL) subband
; 3320 :      belonging to that resolution.
; 3321 :         The `num_hor_steps' and `num_vert_steps' members identify the number
; 3322 :      of horizontal and vertical lifting steps associated with the horizontal
; 3323 :      and vertical transform operations applied at this node to produce its
; 3324 :      children.  One or both of these may be 0, either because the transform
; 3325 :      is trivial (lazy wavelet) or because the node is split only in the
; 3326 :      horizontal direction, only in the vertical direction, or is not split
; 3327 :      at all.
; 3328 :         The `num_descendant_nodes' member holds a count of the total number
; 3329 :      of nodes (leaf nodes and non-leaf nodes) which may be reached via the
; 3330 :      `children' array.  The `num_descendant_leaves' member holds a count of
; 3331 :      the number of these descendant nodes which are leaves.  Neither of these
; 3332 :      counts includes the current node.  Clearly there is no need to
; 3333 :      maintain this information with leaf nodes, since the counts would both
; 3334 :      be 0 in this case.
; 3335 :         The `bibo_gains' member point to an array with
; 3336 :      2+`num_hor_steps'+`num_vert_steps' entries.  The first 1+`num_hor_steps'
; 3337 :      entries describe BIBO gains for the horizontal transform performed
; 3338 :      at this node.  The remaining `+`num_vert_steps' entries describe BIBO
; 3339 :      gains for the vertical transform performed at this node.  Within each
; 3340 :      of these 2 sets of BIBO gains the first entry holds the BIBO gain from
; 3341 :      the original input image to the image which is presented at the input
; 3342 :      to this node.  Subsequent entries hold the BIBO gains from the original
; 3343 :      input image to the image which is presented at the output of each
; 3344 :      successive analysis lifting step.  Al BIBO gains are assessed relative to
; 3345 :      the nominal transform normalization, in which reversible lifting steps
; 3346 :      are applied as-is, while irreversible lifting steps are followed by the
; 3347 :      relevant `kd_tile_comp::low_scale' and `kd_tile_comp::high_scale' values.
; 3348 :         The interpretation of `region_cover' is similar to that of
; 3349 :      `kd_leaf_node::region', with a subtle, yet important twist.  In order to
; 3350 :      reconstruct each sample in `region', it is necessary to decode a
; 3351 :      particular set of samples from the subbands which are associated with
; 3352 :      this node.  Each of these subband samples has a mapping onto the
; 3353 :      coordinate system associated with the node, following the usual rules of
; 3354 :      the canvas coordinate system.  `res_cover' holds the smallest region
; 3355 :      which contains all of these mapped subband sample locations, except that
; 3356 :      the LL subband branch is included only if this is not a primary node.
; 3357 :      This ensures that the primary node embedded inside each `kd_resolution'
; 3358 :      object will have a `region_cover' which spans the nominal locations of
; 3359 :      all subband samples of interest, which are represented by codestream
; 3360 :      packets associated with that resolution. */
; 3361 : 
; 3362 : /*****************************************************************************/
; 3363 : /*                                kd_subband                                 */
; 3364 : /*****************************************************************************/
; 3365 : 
; 3366 : struct kd_subband : public kd_leaf_node {
; 3367 :     // State structure for the "kdu_subband" interface
; 3368 :   public: // Identification
; 3369 :     kdu_int16 descriptor; // See `cod_params::expand_decomp_bands'
; 3370 :     kdu_byte orientation; // One of LL_BAND, HL_BAND, LH_BAND or HH_BAND.
; 3371 :                      // This is the orientation of the primary subband from
; 3372 :                      // which we are derived within the same resolution level.
; 3373 :     kdu_byte sequence_idx; // Index within the `kd_resolution::subbands' array
; 3374 :                      // This is also the order in which subbands contribute
; 3375 :                      // code-blocks to codestream packets.
; 3376 :     kdu_byte transpose_sequence_idx; // Index of the real subband which appears
; 3377 :                       // to have this `sequence_idx' value when
; 3378 :                       // `kdu_codestream::change_appearance' has been used to
; 3379 :                       // transpose the codestream's appearance.
; 3380 :   public: // Dimensions and Parameters
; 3381 :     kdu_byte epsilon; // Ranging parameter.
; 3382 :     kdu_byte K_max; // Maximum magnitude bit-planes, not including ROI upshift
; 3383 :     kdu_byte K_max_prime; // Max magnitude bit-planes, including ROI upshift
; 3384 :     float delta; // Step size, normalized for image data range of -0.5 to 0.5
; 3385 :     float G_b; // Subband energy gain factor.
; 3386 :     float W_b; // Subband amplitude weight; needs squaring to get energy weight
; 3387 :     float roi_weight; // Extra amplitude weight for ROI foreground blocks.
; 3388 :     kdu_dims block_partition; // Holds the coding origin and dimensions.
; 3389 :     kdu_dims block_indices; // Holds the range of valid block indices.
; 3390 :     kdu_dims region_indices;  // Same as `block_indices', but restricted to
; 3391 :                               // blocks which overlap the region of interest.
; 3392 :     kdu_coords blocks_per_precinct; // precinct size / block size
; 3393 :     kdu_coords log2_blocks_per_precinct; // log2 of precinct size/block size
; 3394 :   };
; 3395 :   /* Notes:
; 3396 :         It may come as a surprise to notice that this object has no
; 3397 :      direct connection to code-blocks.  To access a code-block, the object
; 3398 :      first determines the precinct to which it belongs, creating that
; 3399 :      precinct if necessary; this, in turn, creates its precinct-bands and
; 3400 :      the associated code-blocks.  In this way, no memory whatsoever need be
; 3401 :      dedicated to code-blocks which lie in unaccessed precincts. */
; 3402 : 
; 3403 : /*****************************************************************************/
; 3404 : /*                              kd_resolution                                */
; 3405 : /*****************************************************************************/
; 3406 : 
; 3407 : struct kd_resolution { // State structure for the "kdu_resolution" interface
; 3408 :   public: // Member functions
; 3409 :     kd_resolution()
; 3410 :       {
; 3411 :         codestream = NULL; tile_comp = NULL; rescomp = NULL;
; 3412 :         precinct_refs = NULL; subbands = subband_handle = NULL; num_subbands=0;
; 3413 :         num_intermediate_nodes = 0; intermediate_nodes = NULL;
; 3414 :         can_flip = true;  node.bibo_gains = NULL;
; 3415 :       }
; 3416 :     ~kd_resolution()
; 3417 :       {
; 3418 :         if (node.bibo_gains != NULL) delete[] node.bibo_gains;
; 3419 :         for (int n=0; n < (int) num_intermediate_nodes; n++)
; 3420 :           if (intermediate_nodes[n].bibo_gains != NULL)
; 3421 :             delete[] intermediate_nodes[n].bibo_gains;
; 3422 :         if (precinct_refs != NULL) delete[] precinct_refs;
; 3423 :         if (subband_handle != NULL) delete[] subband_handle;
; 3424 :         if (intermediate_nodes != NULL) delete[] intermediate_nodes;
; 3425 :       }
; 3426 :     void build_decomposition_structure(kdu_params *coc, kdu_kernels &kernels);
; 3427 :       /* This function creates the `subbands' and `intermediate_nodes'
; 3428 :          arrays and fills in all the relevant pointers.  It uses `kernels'
; 3429 :          to create and fill in the `kdu_node::hor_bibo_gains' and
; 3430 :          `kdu_node::vert_bibo_gains' arrays, where required. */
; 3431 :     void complete_initialization();
; 3432 :       /* Called from within `kd_tile::initialize' to finish the initialization
; 3433 :          process, after all of the key parameters have been set.  Currently,
; 3434 :          the only task performed here is the initialization of the
; 3435 :          `max_blocks_per_precinct' member. */
; 3436 :   public: // Links and Identification
; 3437 :     kd_codestream *codestream;
; 3438 :     kd_tile_comp *tile_comp;
; 3439 :     kd_global_rescomp *rescomp;
; 3440 :     kdu_byte res_level; // Runs from 0 (LL band) to `num_dwt_levels'
; 3441 :     kdu_byte dwt_level; // Runs from `num_dwt_levels' (res level 0 and 1) to 1
; 3442 :     kdu_byte hor_depth; // From relevant entry of `kd_comp_info::hor_depth'
; 3443 :     kdu_byte vert_depth; // From relevant entry of `kd_comp_info::vert_depth'
; 3444 : 
; 3445 :   public: // Embedded node
; 3446 :     kd_node node; // Each resolution is a primary node in the decomposition
; 3447 : 
; 3448 :   public: // Dimensions and Parameters
; 3449 :     kdu_dims precinct_partition; // Holds the coding origin and dimensions.
; 3450 :     kdu_dims precinct_indices; // Holds the range of valid precinct indices.
; 3451 :     kdu_dims region_indices; // Holds range of indices for precincts whose
; 3452 :                              // code-blocks contribute to region of interest.
; 3453 :   public: // Derived quantities
; 3454 :     int max_blocks_per_precinct; // See discussion under `kd_precinct_band'
; 3455 :     bool propagate_roi; // True if ROI masks to be propagated to descendants
; 3456 : 
; 3457 :     bool can_flip; // Set to false if this level contains subband decomposition
; 3458 :                    // styles which are incompatible with view flipping.
; 3459 : 
; 3460 :   public: // Arrays
; 3461 :     kdu_byte num_subbands; // Excludes the LL band unless `res_level'=0
; 3462 :     kdu_byte num_intermediate_nodes; // Enough for all non-leaf nodes descended
; 3463 :                                  // from the primary node in this object.
; 3464 :     kd_node *intermediate_nodes; // Array with `num_intermediate_nodes' entries
; 3465 :     kd_precinct_ref *precinct_refs;
; 3466 :     kd_subband *subbands; // Points to `subband_store' or `subband_handle'.
; 3467 :     kd_subband *subband_handle; // For dynamically allocated subbands
; 3468 :     kd_subband subband_store[3]; // Avoid dynamic allocation for common case
; 3469 : 
; 3470 :   public: // Flags and Other State Variables
; 3471 :     kdu_coords current_sequencer_pos; // Used by `kd_packet_sequencer'.
; 3472 :     kdu_coords saved_current_sequencer_pos; // For saving the sequencer state
; 3473 :   };
; 3474 :   /* Notes:
; 3475 :         The `current_sequencer_pos' coordinates are used to sequence
; 3476 :      spatially oriented packet progressions.  They maintain the
; 3477 :      indices (starting from [0,0], rather than `precinct_indices.pos')
; 3478 :      of the precinct which is currently being sequenced.
; 3479 :         The `region_indices' member holds the smallest range of precinct
; 3480 :      indices, such that the code-blocks contained within these precincts
; 3481 :      are sufficient to reconstruct all samples inside `node.region'.
; 3482 :      Equivalently, the range in `precinct_indices' yields the set of
; 3483 :      precincts which intersect with `node.region_cover'.
; 3484 :         It is worth noting that the area of intersection between each
; 3485 :      precinct's region on the resolution and the `node.region_cover' region
; 3486 :      is used to compute the information returned by
; 3487 :      `kdu_resolution::get_precinct_relevance'. */
; 3488 : 
; 3489 : /*****************************************************************************/
; 3490 : /*                             kd_header_in                                  */
; 3491 : /*****************************************************************************/
; 3492 : 
; 3493 : class kd_header_in {
; 3494 :   /* Manages the reading of packet header bytes from the code-stream, along
; 3495 :      with bit stuffing and unpacking. */
; 3496 :   public: // Member functions
; 3497 :     kd_header_in(kd_input *source)
; 3498 :       { this->source = source; bits_left=0; byte=0; header_bytes=0; }
; 3499 :     int get_bit() // throws its own "this" pointer if the source is exhausted.
; 3500 :       {
; 3501 :         if (bits_left==0)
; 3502 :           {
; 3503 :             bits_left = (byte==0xFF)?7:8;
; 3504 :             if (!source->get(byte))
; 3505 :               { bits_left = 0; throw this; }
; 3506 :             header_bytes++;
; 3507 :           }
; 3508 :         bits_left--;
; 3509 :         return (byte >> bits_left) & 1;
; 3510 :       }
; 3511 :     kdu_uint32 get_bits(int num_bits) // thorws(kd_header_in *)
; 3512 :       { kdu_uint32 result = 0;
; 3513 :         while (num_bits > 0)
; 3514 :           {
; 3515 :             if (bits_left==0)
; 3516 :               {
; 3517 :                 bits_left = (byte==0xFF)?7:8;
; 3518 :                 if (!source->get(byte))
; 3519 :                   { bits_left = 0; throw this; }
; 3520 :                 header_bytes++;
; 3521 :               }
; 3522 :             int xfer_bits = (num_bits<bits_left)?num_bits:bits_left;
; 3523 :             bits_left -= xfer_bits;
; 3524 :             num_bits -= xfer_bits;
; 3525 :             result <<= xfer_bits;
; 3526 :             result |= ((byte >> bits_left) & ~(0xFF << xfer_bits));
; 3527 :           }
; 3528 :         return result;
; 3529 :       }
; 3530 :     int finish()
; 3531 :       { // Call this when the header is all read, to consume any stuffing byte
; 3532 :         // Returns total header length
; 3533 :         if ((bits_left == 0) && (byte == 0xFF))
; 3534 :           {
; 3535 :             bits_left = 7;
; 3536 :             if (!source->get(byte))
; 3537 :               throw this;
; 3538 :             header_bytes++;
; 3539 :           }
; 3540 :         return header_bytes;
; 3541 :       }
; 3542 :   private: // Data
; 3543 :     kd_input *source; // Provides the input mechanism.
; 3544 :     kdu_byte byte;
; 3545 :     int bits_left;
; 3546 :     int header_bytes;
; 3547 :   };
; 3548 : 
; 3549 : /*****************************************************************************/
; 3550 : /*                                kd_header_out                              */
; 3551 : /*****************************************************************************/
; 3552 : 
; 3553 : class kd_header_out {
; 3554 :   /* Manages the simulated and real output of packet header bytes. */
; 3555 :   public: // Member functions
; 3556 :     kd_header_out(kdu_output *out=NULL) // Null for simulating header
; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }
; 3558 :     void put_bit(int bit)
; 3559 :       { // Output a header bit
; 3560 :         assert(bit == (bit & 1));
; 3561 :         if (bits_left == 0)
; 3562 :           { if (out != NULL) out->put(byte);
; 3563 :             completed_bytes++;
; 3564 :             bits_left = (byte==0xFF)?7:8;
; 3565 :             byte = 0; }
; 3566 :         byte += byte + bit;
; 3567 :         bits_left--;
; 3568 :       }
; 3569 :     void put_bits(kdu_int32 val, int num_bits)
; 3570 :       { // Output the least significant `num_bits' of `val'
; 3571 :         while (num_bits > 0)
; 3572 :           put_bit((val >> (--num_bits)) & 1);
; 3573 :       }
; 3574 :     int finish()
; 3575 :       { // Returns the total number of bytes consumed by the packet header.
; 3576 :         if (bits_left < 8)
; 3577 :           {
; 3578 :             byte <<= bits_left;
; 3579 :             if (out != NULL)
; 3580 :               out->put(byte);
; 3581 :             completed_bytes++;
; 3582 :             if (byte == 0xFF)
; 3583 :               { // Need the stuffing byte.
; 3584 :                 if (out != NULL)
; 3585 :                   out->put((kdu_byte) 0);
; 3586 :                 completed_bytes++;
; 3587 :               }
; 3588 :           }
; 3589 :         return completed_bytes;
; 3590 :       }
; 3591 :   private: // Data
; 3592 :     kdu_byte byte;
; 3593 :     int bits_left;
; 3594 :     int completed_bytes;
; 3595 :     kdu_output *out;
; 3596 :   };
; 3597 : 
; 3598 : /*****************************************************************************/
; 3599 : /*                                 kd_block                                  */
; 3600 : /*****************************************************************************/
; 3601 : 
; 3602 : class kd_block {
; 3603 :   /* For a very small size (only 24 bytes on 32-bit machines), this class
; 3604 :      defines a lot of member functions!. */
; 3605 :   // --------------------------------------------------------------------------
; 3606 :   public: // Lifecycle member functions
; 3607 :     void cleanup(kd_buf_server *buf_server)
; 3608 :       {
; 3609 :         while ((current_buf=first_buf) != NULL)
; 3610 :           { first_buf=current_buf->next;  buf_server->release(current_buf); }
; 3611 :         set_discard(); // Discard from any packets parsed in the future
; 3612 :       }
; 3613 :     kd_code_buffer *cleanup()
; 3614 :       { // As above, but returns the linked list of buffers
; 3615 :         kd_code_buffer *result = first_buf;  first_buf = current_buf = NULL;
; 3616 :         set_discard();
; 3617 :         return result;
; 3618 :       }
; 3619 : 
; 3620 :   // --------------------------------------------------------------------------
; 3621 :   public: // Packet manipulation member functions
; 3622 :     int parse_packet_header(kd_header_in &head, kd_buf_server *buf_server,
; 3623 :                             int layer_idx); // Throws (kdu_uint16 code)
; 3624 :       /* Parses bits in the packet header corresponding to the current
; 3625 :          block for the current layer (this must be the next layer for which
; 3626 :          information has not yet been parsed).  The function returns the
; 3627 :          number of new body bytes contributed by the code-block in this layer
; 3628 :          and also stores this value internally to be used in subsequent calls
; 3629 :          to the `read_body_bytes' member function.
; 3630 :             The `kd_header_in' object may throw an exception if the packet
; 3631 :          data terminates unexpectedly.  Moreover, to assist in locating and
; 3632 :          possibly recovering from errors, the present function may throw a
; 3633 :          16-bit unsigned integer exception code, which is either the value of
; 3634 :          an illegal marker code encountered in the packet header, or one of
; 3635 :          the special exception codes, KDU_EXCEPTION_PRECISION or
; 3636 :          KDU_EXCEPTION_ILLEGAL_LAYER. */
; 3637 :     void read_body_bytes(kd_input *source, kd_buf_server *buf_server,
; 3638 :                          bool in_memory_source)
; 3639 :       { /* This function should be called after parsing the header of a
; 3640 :            packet.  It reads the code-bytes contributed by the code-block to
; 3641 :            this packet.  If `in_memory_source' is true, only the address of
; 3642 :            the code-bytes is recorded, and then only if the length of the
; 3643 :            code-byte segment is non-zero. */
; 3644 :         if (this->temp_length > 0)
; 3645 :           {
; 3646 :             if (num_passes == 255)
; 3647 :               { // Read and discard the code-bytes.
; 3648 :                 assert(first_buf == NULL);  source->ignore(this->temp_length);
; 3649 :               }
; 3650 :             else if (in_memory_source)
; 3651 :               {
; 3652 :                 kdu_byte *addr;
; 3653 :                 this->num_bytes += source->pseudo_read(addr,this->temp_length);
; 3654 :                 put_address(addr,buf_server);
; 3655 :               }
; 3656 :             else
; 3657 :               this->num_bytes +=
; 3658 :                 source->read(current_buf,buf_pos,buf_server,this->temp_length);
; 3659 :             this->temp_length = 0;
; 3660 :           }
; 3661 :       }
; 3662 :     void retrieve_data(kdu_block *block, int max_layers, int discard_passes,
; 3663 :                        bool in_memory_source);
; 3664 :       /* Retrieves compressed code-bytes, number of coding passes and codeword
; 3665 :          segment lengths from the current code-block and stores them in the
; 3666 :          `block' object.  All fields which are common for compression and
; 3667 :          decompression have already been filled out by the caller.  The
; 3668 :          byte buffer is allocated so as to be large enough to allow a
; 3669 :          2 byte marker code to be appended to the compressed data,
; 3670 :          if desired -- see declaration of "kdu_subband::open_block".
; 3671 :             The `max_layers' argument identifies the maximum number of
; 3672 :          quality layers for which code-block contributions are to be
; 3673 :          retrieved.
; 3674 :             The `discard_passes' argument indicates the number of additional
; 3675 :          coding passes to be removed, if any.
; 3676 :             If `in_memory_source' is true, the layer code bytes are not
; 3677 :          stored in the `kd_code_buffer' list embedded inside `block'.  Instead,
; 3678 :          the `kd_code_buffer' list stores only the header information for
; 3679 :          each layer, along with the address of the code bytes, which reside
; 3680 :          in the memory block managed by an in-memory compressed data source
; 3681 :          (one which offers the `KDU_SOURCE_CAP_IN_MEMORY') capability.  In
; 3682 :          this case, we retrieve the address and then perform a simple memory
; 3683 :          block copy operation to efficiently retrieve the code bytes for
; 3684 :          each layer. */
; 3685 :     void store_data(kdu_block *block, kd_buf_server *buf_server);
; 3686 :       /* Stores compressed code-bytes, pass length and pass slope information
; 3687 :          from the `block' object into the current code-block.  This function
; 3688 :          is invoked by "kdu_subband::close_block" when the containing
; 3689 :          codestream object was not constructed for input.  Also reflects
; 3690 :          the `msbs_w' value into higher nodes in the tag tree. */
; 3691 :     void store_data(kdu_block *block, kd_thread_buf_server *thread_buf_server);
; 3692 :       /* Same as the above function, but uses `kd_thread_buf_server::get'
; 3693 :          rather than `kd_buf_server::get' to get new code buffers.  This
; 3694 :          version is used to save code-block state in multi-threaded
; 3695 :          environments so as to minimize cache coherency bottlenecks and the
; 3696 :          need to lock shared resources. */
; 3697 :     void transfer_data(kd_block &src)
; 3698 :       { /* Like `store_data', but gets results from another block.  Exploits
; 3699 :            the layout of the object to copy only whole pointers or whole
; 3700 :            32-bit words, even where these represent multiple fields. */
; 3701 :         current_buf = first_buf = src.first_buf;
; 3702 :         *((kdu_int32 *) &buf_pos) = *((kdu_int32 *) &src.buf_pos);
; 3703 :         src.current_buf = src.first_buf = NULL;
; 3704 :       }
; 3705 :     bool trim_data(kdu_uint16 slope_threshold, kd_buf_server *buf_server);
; 3706 :       /* This function serves two purposes: it helps reduce the amount of
; 3707 :          compressed data which must be buffered in memory while compressing
; 3708 :          an image; and it allows individual block contributions to be
; 3709 :          discarded during packet construction in order to tightly fit the
; 3710 :          generated bit-rate to the target compressed bit-rate.
; 3711 :             The function sets all coding pass slopes which are less than or
; 3712 :          equal to the supplied slope threshold to 0 and then discards all
; 3713 :          code bytes which could not possibly be included in the final
; 3714 :          code-stream, as a result of this modification.
; 3715 :             If anything was discarded, the function returns true.  Otherwise,
; 3716 :          it returns false. */
; 3717 :     int start_packet(int layer_idx, kdu_uint16 slope_threshold);
; 3718 :       /* Call this function only during rate allocation or packet generation.
; 3719 :          Before the first call to this function, you must reset the tag tree
; 3720 :          (see the "reset_output_tree" member function).  If you are calling
; 3721 :          the function multiple times with the same layer for rate allocation
; 3722 :          purposes, you must use "save_output_tree" and "restore_output_tree"
; 3723 :          as described below.
; 3724 :             The function leaves behind information about the number of new
; 3725 :          coding passes and the number of new code bytes which would be
; 3726 :          contributed by this code-block if the supplied threshold were actually
; 3727 :          used.  The final contributing coding pass must have a non-zero
; 3728 :          distortion-length slope which is strictly greater than the slope
; 3729 :          threshold.  It also updates the tag tree structure to reflect any
; 3730 :          new knowledge about the first layer to which this code-block would
; 3731 :          contribute.  This information is picked up by "write_packet_header".
; 3732 :             The function's return value is the total number of new code-bytes
; 3733 :          contributed by the block.  This allows the PCRD-opt algorithm to
; 3734 :          determine roughly the right slope threshold before committing to the
; 3735 :          work of simulating packet header generation. */
; 3736 :     void write_packet_header(kd_header_out &head, int layer_idx,
; 3737 :                              bool simulate);
; 3738 :       /* Call this function only after a `start_packet' call.  It writes
; 3739 :          (or simulates the writing of) packet header information corresponding
; 3740 :          to the code-block inclusion information set up by `start_packet'.
; 3741 :          If `simulate' is true, some internal state adjustments are delayed
; 3742 :          until the next call to "save_output_tree", so multiple calls to
; 3743 :          "start_packet" and "write_packet_header" may be issued with the same
; 3744 :          layer index to determine an optimal slope threshold.  Otherwise,
; 3745 :          if `simulate' is false, the internal state information is fully
; 3746 :          updated and the "save_output_tree" and "restore_output_tree" functions
; 3747 :          need not and should not be called. */
; 3748 :     void write_body_bytes(kdu_output *dest);
; 3749 :       /* This function should be called after a non-simulated
; 3750 :          "write_packet_header" call to output the newly included body bytes.
; 3751 :          The actual number of bytes to be written was left behind by
; 3752 :          the preceding "start_packet" call in the `temp_length' field. */
; 3753 :   // --------------------------------------------------------------------------
; 3754 :   public: // Static functions used to operate on tag-trees built from kd_block
; 3755 :     static kd_block *build_tree(kdu_coords size, kdu_byte * &mem_block);
; 3756 :       /* Builds a full tag tree returning a pointer to the upper left hand
; 3757 :          corner leaf node.  Apart from the `up_down' navigation pointers,
; 3758 :          all fields are initialized to 0.  This is appropriate for tag tree
; 3759 :          decoding, but encoders will need to call "reset_output_tree" and
; 3760 :          use "start_packet" to install appropriate node values.
; 3761 :             The tag tree is not allocated from the heap.  Instead, it is
; 3762 :          allocated from an existing memory block, identified by the `mem_block'
; 3763 :          argument.  This memory block is assumed to be large enough to hold
; 3764 :          the array of `kd_block' structures.  Upon return, the `mem_block'
; 3765 :          value is advanced by an amount equal to the size of the tag tree
; 3766 :          array. */
; 3767 :     static void reset_output_tree(kd_block *tree, kdu_coords size);
; 3768 :       /* Call this function immediately before simulating or actually
; 3769 :          generating any packet data for the relevant code-blocks.  Once
; 3770 :          the PCRD-opt algorithm has completed, you should call this function
; 3771 :          a second time to prepare for actual packet output.  The function
; 3772 :          initializes the threshold state variables, `layer_w_bar' and
; 3773 :          `msbs_w_bar' to 0, and the value state variables, `layer_w' and
; 3774 :          `msbs_w' to their maximum representable values.  The succession of
; 3775 :          "start_packet" calls will update the value variables `layer_w'
; 3776 :          and `msbs_w' in such a way that the tag tree coding process runs
; 3777 :          correctly in each subsequent call to "write_packet_header". */
; 3778 :     static void save_output_tree(kd_block *tree, kdu_coords size);
; 3779 :       /* Call this only during rate allocation, before moving on to a new
; 3780 :          layer.  The function saves the current state (`msbs_wbar' and
; 3781 :          `layer_wbar') of each node in the tag tree.  For leaf nodes, it also
; 3782 :          commits the number of new coding passes found in the last call to
; 3783 :          "start_packet". */
; 3784 :     static void restore_output_tree(kd_block *tree, kdu_coords size);
; 3785 :       /* Call this during rate allocation before supplying a new slope
; 3786 :          threshold for the same layer index, in a new "start_packet" call.
; 3787 :          The function restores the `msbs_w_bar' and `layer_w_bar' values
; 3788 :          previously saved by "save_output_tree". */
; 3789 :   // --------------------------------------------------------------------------
; 3790 :   public: // State identification functions
; 3791 :     void set_discard()
; 3792 :       { /* Use this function only with input-oriented operations.  It informs
; 3793 :            the object that none of the code-blocks associated with this
; 3794 :            block will ever be accessed, so that it is free to skip over them
; 3795 :            when reading a packet.  This can save a lot of memory if you have
; 3796 :            a defined region of interest for decompression. */
; 3797 :         num_passes = 255;
; 3798 :       }
; 3799 :     bool empty()
; 3800 :       { // Returns true if the block has no code-bytes yet.
; 3801 :         return first_buf == NULL;
; 3802 :       }
; 3803 :     void set_modes(int modes)
; 3804 :       {
; 3805 :         assert(modes == (modes & 0xFF));
; 3806 :         this->modes = (kdu_byte) modes;
; 3807 :       }
; 3808 :   // --------------------------------------------------------------------------
; 3809 :   private: // Convenience functions for transferring data to/from code buffers.
; 3810 :     void start_buffering(kd_buf_server *buf_server) // Call before `put_byte'
; 3811 :       { assert(first_buf == NULL);
; 3812 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3813 :     void start_buffering(kd_thread_buf_server *buf_server)
; 3814 :       { assert(first_buf == NULL);
; 3815 :         first_buf = current_buf = buf_server->get(); buf_pos = 0; }
; 3816 :     void put_byte(kdu_byte val, kd_buf_server *buf_server)
; 3817 :       {
; 3818 :         assert(current_buf != NULL);
; 3819 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3820 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3821 :         current_buf->buf[buf_pos++] = val;
; 3822 :       }
; 3823 :     void put_word(int val, kd_buf_server *buf_server)
; 3824 :       {
; 3825 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3826 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))
; 3827 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3828 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;
; 3829 :         buf_pos += 2;
; 3830 :       }
; 3831 :     void put_address(kdu_byte *addr, kd_buf_server *buf_server)
; 3832 :       {
; 3833 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3834 :         if (buf_pos > (KD_CODE_BUFFER_LEN-KDU_POINTER_BYTES))
; 3835 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3836 : 
; 3837 :         ((kdu_byte **)(current_buf->buf+buf_pos))[0] = addr;
; 3838 :         buf_pos += KDU_POINTER_BYTES;
; 3839 :       }
; 3840 :     void put_byte(kdu_byte val, kd_thread_buf_server *buf_server)
; 3841 :       {
; 3842 :         assert(current_buf != NULL);
; 3843 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3844 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3845 :         current_buf->buf[buf_pos++] = val;
; 3846 :       }
; 3847 :     void put_word(int val, kd_thread_buf_server *buf_server)
; 3848 :       {
; 3849 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3850 :         if (buf_pos > (KD_CODE_BUFFER_LEN-2))
; 3851 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3852 :         ((kdu_uint16 *)(current_buf->buf+buf_pos))[0] = (kdu_uint16) val;
; 3853 :         buf_pos += 2;
; 3854 :       }
; 3855 :     void put_address(kdu_byte *addr, kd_thread_buf_server *buf_server)
; 3856 :       {
; 3857 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3858 :         if (buf_pos > (KD_CODE_BUFFER_LEN-KDU_POINTER_BYTES))
; 3859 :           { buf_pos=0; current_buf=current_buf->next=buf_server->get(); }
; 3860 : 
; 3861 :         ((kdu_byte **)(current_buf->buf+buf_pos))[0] = addr;
; 3862 :         buf_pos += KDU_POINTER_BYTES;
; 3863 :       }
; 3864 :     kdu_byte get_byte()
; 3865 :       {
; 3866 :         if (buf_pos==KD_CODE_BUFFER_LEN)
; 3867 :           { buf_pos=0; current_buf=current_buf->next;
; 3868 :             assert(current_buf != NULL); }
; 3869 :         return current_buf->buf[buf_pos++];
; 3870 :       }
; 3871 :     int get_word()
; 3872 :       {
; 3873 :         buf_pos += (buf_pos & 1); // Align the buffer pointer
; 3874 :         buf_pos += 2; // Advance the buffer pointer
; 3875 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3876 :           { buf_pos=2; current_buf=current_buf->next;
; 3877 :             assert(current_buf != NULL); }
; 3878 :         return ((kdu_uint16 *)(current_buf->buf+buf_pos))[-1];
; 3879 :       }
; 3880 :     kdu_byte *get_address()
; 3881 :       {
; 3882 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3883 :         buf_pos += KDU_POINTER_BYTES; // Advance the buffer pointer
; 3884 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3885 :           { buf_pos=KDU_POINTER_BYTES; current_buf=current_buf->next;
; 3886 :             assert(current_buf != NULL); }
; 3887 :         return ((kdu_byte **)(current_buf->buf+buf_pos))[-1];
; 3888 :       }
; 3889 :     void skip_word()
; 3890 :       {
; 3891 :         buf_pos += 2 + (buf_pos & 1); // Align and advance the buffer pointer
; 3892 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3893 :           { buf_pos=2; current_buf=current_buf->next;
; 3894 :             assert(current_buf != NULL); }
; 3895 :       }
; 3896 :     void skip_address()
; 3897 :       {
; 3898 :         buf_pos += (-buf_pos)&(KDU_POINTER_BYTES-1); // Align the buf pointer
; 3899 :         buf_pos += KDU_POINTER_BYTES; // Advance the buffer pointer
; 3900 :         if (buf_pos > KD_CODE_BUFFER_LEN)
; 3901 :           { buf_pos=KDU_POINTER_BYTES; current_buf=current_buf->next;
; 3902 :             assert(current_buf != NULL); }
; 3903 :       }
; 3904 :   // --------------------------------------------------------------------------
; 3905 :   private: // Data (lots of unions to make it as small as possible!)
; 3906 :     union {
; 3907 :       kd_code_buffer *first_buf;
; 3908 :       kdu_uint16 save_layer_w; // Used for saving non-leaf node state
; 3909 :       };
; 3910 :     union {
; 3911 :       kd_code_buffer *current_buf;
; 3912 :       kdu_uint16 save_layer_wbar; // Used for saving_non-leaf node state
; 3913 :       };
; 3914 :     union {
; 3915 :       kdu_byte buf_pos; // Location of next read/write byte in `current_buf'.
; 3916 :       kdu_byte save_msbs_wbar; // Used for saving non-leaf node state
; 3917 :       };
; 3918 :     kdu_byte msbs_w;
; 3919 :     kdu_byte num_passes;
; 3920 :     kdu_byte pass_idx;
; 3921 :     union {
; 3922 :       kdu_uint16 layer_w; // Used only when `pass_idx'=0
; 3923 :       kdu_uint16 body_bytes_offset; // Used in packet output if `pass_idx' > 0
; 3924 :       kdu_byte save_beta; // Used during output simulation if `pass_idx' > 0
; 3925 :       };
; 3926 :     union {
; 3927 :       kdu_uint16 layer_wbar;
; 3928 :       kdu_uint16 num_bytes; // Used only for input operations
; 3929 :       kdu_byte pending_new_passes; // Used only for output operations
; 3930 :       };
; 3931 :     union {
; 3932 :       kdu_byte msbs_wbar;
; 3933 :       kdu_byte beta;
; 3934 :       };
; 3935 :     kdu_byte modes;
; 3936 :     kdu_uint16 temp_length; // Temporary storage of length quantities.
; 3937 :     kd_block *up_down;
; 3938 :   };
; 3939 :   /* Notes:
; 3940 :         This structure has been designed to provide sufficient state
; 3941 :      information for each code-block to perform packet header parsing as
; 3942 :      well as block encoding and decoding.  For coding purposes, the information
; 3943 :      represented by the structure is generally transferred to or from a
; 3944 :      much less tightly packed representation for speed of execution of the
; 3945 :      block coding routines.  As it stands, the total size of this structure
; 3946 :      should be 24 bytes on a 32-bit architecture. An array of code-blocks is
; 3947 :      maintained by each precinct-band.  The array contains one entry for
; 3948 :      every block in the relevant precinct-band, but also contains additional
; 3949 :      entries to be used as tag-tree nodes.  The total number of such extra
; 3950 :      nodes is about 1/3 the number of code-blocks and should not be a
; 3951 :      significant cause of concern for overall memory consumption. There is
; 3952 :      also substantial benefit to be had by locating the tag tree nodes in
; 3953 :      the same contiguous memory block.  Notice that the structure contains
; 3954 :      no reference back to the precinct-band to which it belongs.  When
; 3955 :      necessary, this reference must be supplied separately to interested
; 3956 :      functions. One consequence of this memory saving step is that the
; 3957 :      object's destructor cannot do anything useful.  It only checks to make
; 3958 :      sure that the explicit `cleanup' function has already been called.
; 3959 :         If a block is to be discarded (since it does not intersect with a
; 3960 :      user-specified region of interest), the `num_passes' field will hold
; 3961 :      the otherwise impossible value, 255.
; 3962 :         The `first_buf', `current_buf' and `buf_pos' fields constitute the
; 3963 :      compressed data buffer management mechanism, which is used to store all
; 3964 :      quantities whose length is unpredictable a priori. In particular, a
; 3965 :      linked list of `kd_code_buffer' structures is provided, which grows on
; 3966 :      demand through access to the codestream object's embedded `buffering'
; 3967 :      object.  Data is stored in these buffers in the following formats:
; 3968 :            * Input Format -- [<layer #> (<#bytes> <#passes> ...)] data [<...
; 3969 :              That is, for each layer to which the code-block makes a non-empty
; 3970 :              contribution, we record first the layer number (2 bytes) and
; 3971 :              then one or more #bytes/#passes pairs.  #bytes is represented
; 3972 :              using 2 bytes, while #passes is represented using only 1 byte.
; 3973 :              There is one such 3 byte pair for each layer and one additional
; 3974 :              3 byte pair for each codeword segment terminating pass which
; 3975 :              is not the final pass contributed in the layer.  In this way,
; 3976 :              sufficient information is provided to recover all termination
; 3977 :              lengths, as well as to build layer associations.  The most
; 3978 :              significant bit of the #bytes field is used as a marker to
; 3979 :              indicate whether or not this is the last such field prior to
; 3980 :              the appearance of the code bytes contributed by that layer.  A
; 3981 :              1 means that there are more fields to go before the code bytes
; 3982 :              appear.
; 3983 :            * In-memory Format --[<layer #>(<#bytes> <#passes>...)] <addr> [<...
; 3984 :              This format is used as an alternative to the Input Format above,
; 3985 :              in the special case when the compressed data source supports the
; 3986 :              `KDU_SOURCE_CAP_IN_MEMORY' capability, so that
; 3987 :              `kd_codestream::in_memory_source' is true.  In this case, the
; 3988 :              "data" field is replaced by the address where the data can be
; 3989 :              found in the memory block managed by the compressed data source.
; 3990 :              Moreover, if the number of code-bytes associated with a layer
; 3991 :              is zero, the <addr> field is missing.
; 3992 :            * Output Format -- [<RD slope> <#bytes>] ... [<RD ...] data
; 3993 :              That is, all of the header information for all coding passes
; 3994 :              appears up front, followed by all of the code bytes associated
; 3995 :              with those coding passes.  The reason for putting all the
; 3996 :              header information up front is that it facilitates the
; 3997 :              identification of appropriate layer contributions by the
; 3998 :              rate control algorithm.  Each coding pass has a 4 byte header,
; 3999 :              with 2 bytes for the distortion-length slope value and 2 bytes
; 4000 :              for the number of code-bytes for the pass.
; 4001 :      The particular format which is used to store data depends upon the
; 4002 :      member functions which are used, since these implicitly determine
; 4003 :      whether the codestream object is being used for input or output.
; 4004 :         The `modes' field holds the block coder mode fields.  Some of these
; 4005 :      are required even for correct packet header parsing, regardless of whether
; 4006 :      the block is to be actually decoded.
; 4007 :         `msbs_w' and `msbs_wbar' are the state information required
; 4008 :      for tag-tree coding of the number of missing MSB's for a code-block
; 4009 :      which is about to make its first non-empty contribution to the
; 4010 :      code-stream. Similarly, `layer_w' and `layer_wbar' hold the state
; 4011 :      information required for tag-tree coding of the layer index in which a
; 4012 :      code-block first contributes to the code-stream.  The operation of
; 4013 :      tag-tree coding and the `w' and `wbar' terminology are explained in
; 4014 :      Section 8.4 of the book by Taubman and Marcellin.
; 4015 :         The `beta' field shares storage with `msbs_wbar'.  This is not
; 4016 :      required until the number of missing MSB's has been encoded or decoded,
; 4017 :      at which point we initialize `beta' to 3 (see the JPEG2000 standard or
; 4018 :      Section 12.5.4 of the book by Taubman and Marcellin).  A useful
; 4019 :      consequence of this behaviour is that `beta' may be tested at any
; 4020 :      point of the packet header encoding or decoding process to determine
; 4021 :      whether or not the code-block has yet contributed to the code-stream
; 4022 :      -- the value will be non-zero if and only if it has done so.
; 4023 :         The `num_bytes' field shares storage with `layer_wbar'.  It
; 4024 :      identifies the total number of bytes included by the code-block in
; 4025 :      all packets read or written so far.  The value is taken to be 0 if
; 4026 :      the code-block has not yet contributed to any packets (`beta'=0),
; 4027 :      during which time the `layer_wbar' state variable is in use.
; 4028 :         The `up_down' field is used to efficiently navigate the tag-tree
; 4029 :      structure.  When the tag tree is not actually being navigated, the
; 4030 :      field points up to the current node's parent in the tag tree.  The
; 4031 :      root mode is readily identified by the fact that it has a NULL `up_down'
; 4032 :      pointer. During navigation, the tag-tree coder first walks from a
; 4033 :      leaf node up to the root, modifying the `up_down' pointers as it goes
; 4034 :      so that each successive parent's `up_down' field points bacl down to the
; 4035 :      child from which the parent was reached.  The coder then walks back down
; 4036 :      from the root to the original leaf node, restoring the `up_down' fields to
; 4037 :      their original `up' state. */
; 4038 : 
; 4039 : /*****************************************************************************/
; 4040 : /*                             kd_precinct_band                              */
; 4041 : /*****************************************************************************/
; 4042 : 
; 4043 : struct kd_precinct_band {
; 4044 :   /* Used to store state information for an element of the precinct partition
; 4045 :      within a single subband.  Once we get down to precincts and ultimately
; 4046 :      code-blocks, we have to be careful not to waste too much memory, since
; 4047 :      an image may have a very large number of these.  Moreover, it may be
; 4048 :      necessary to maintain tag-trees and other state information even for
; 4049 :      precincts which do not lie within our region of interest, so that the
; 4050 :      relevant packet headers can be parsed -- otherwise, we may have no way
; 4051 :      of knowing how to skip over packets which are not interesting to us. */
; 4052 :     kd_subband *subband;
; 4053 :     kdu_dims block_indices; /* Range of code-block indices for this precinct.
; 4054 :         This is a subset of the `block_indices' specified by the `subband'. */
; 4055 :     kd_block *blocks;
; 4056 :   };
; 4057 :   /* Notes:
; 4058 :      In order to make the representation of this object as efficient as
; 4059 :      possible, the two tag trees and all additional information required to
; 4060 :      correctly parse packet headers is maintained within the code-block
; 4061 :      array itself.  The `blocks' array consists of one element for each
; 4062 :      code-block, organized in raster fashion, plus additional elements to
; 4063 :      represent higher nodes in the tag-tree structure.  See the comments
; 4064 :      associated with the definition of `kd_block' for more information on
; 4065 :      this.
; 4066 :         In practice, the `blocks' array is not allocated separately on the
; 4067 :      heap.  Instead, the block of memory allocated to hold the `kd_precinct'
; 4068 :      structure is augmented by an amount sufficient to hold all of the
; 4069 :      code-blocks for all of the subbands in the precinct.  This is
; 4070 :      accomplished by the custom `kd_precinct::new' operator, which is
; 4071 :      informed of the maximum number of code-blocks required by any precinct
; 4072 :      within the containing `kd_resolution' object.  This value is maintained
; 4073 :      by the `kd_resolution::max_blocks_per_precinct" data member.  The
; 4074 :      `blocks' fields are initialized to the NULL state by the
; 4075 :      `kd_precinct::initialize' member function and are later set to point
; 4076 :      into appropriate locations in the precinct's memory block during
; 4077 :      tag-tree construction. */
; 4078 : 
; 4079 : /*****************************************************************************/
; 4080 : /*                                kd_precinct                                */
; 4081 : /*****************************************************************************/
; 4082 : 
; 4083 :   /* Precincts and all of their subordinate entities (precinct-bands and
; 4084 :      code-blocks) are maintained by a code-stream wide precinct server
; 4085 :      object, which allows for efficient allocation and recycling of the
; 4086 :      memory resources. The constructor is invoked from within the server,
; 4087 :      while the `initialize' and `release' functions are invoked from
; 4088 :      within the `kd_precinct_ref' class which manages references to
; 4089 :      precincts from within the `kd_resolution' object. */
; 4090 : 
; 4091 : // Interpretation of the following flags is given with the `flags' member:
; 4092 : #define KD_PFLAG_GENERATING  0x0001
; 4093 : #define KD_PFLAG_CORRUPTED   0x0002
; 4094 : #define KD_PFLAG_DESEQUENCED 0x0004
; 4095 : #define KD_PFLAG_ADDRESSABLE 0x0008
; 4096 : #define KD_PFLAG_RELEASED    0x0010
; 4097 : #define KD_PFLAG_INACTIVE    0x0020
; 4098 : #define KD_PFLAG_RELEVANT    0x0040
; 4099 : #define KD_PFLAG_SIGNIFICANT 0x0080
; 4100 : #define KD_PFLAG_PARSED      0x0100
; 4101 : 
; 4102 : struct kd_precinct {
; 4103 :   public: // Member functions
; 4104 :     void initialize(kd_resolution *resolution, kdu_coords pos_idx);
; 4105 :       /* Called from within `kd_precinct_ref::open' to configure a newly
; 4106 :          allocated (or recycled) object.  `pos_idx' holds the horizontal and
; 4107 :          vertical position of the precinct (starting from 0) within the array
; 4108 :          of precincts for the relevant resolution level.  Thus, `pos_idx'
; 4109 :          holds a relative index, rather than an absolute index. */
; 4110 :     void activate();
; 4111 :       /* This function is called from within `kd_precinct_ref::open' to
; 4112 :          re-activate a previously released precinct, which has not actually
; 4113 :          been unloaded from memory.  Substantially less work is required in
; 4114 :          this case, and the function must be careful to respect the current
; 4115 :          contents of the precinct's code-blocks.  The function sets the
; 4116 :          `num_required_layers' field for this activation (may change between
; 4117 :          successive `kd_tile::open' calls) and also sets the
; 4118 :          `num_outstanding_blocks' field to the total number of code-blocks
; 4119 :          which lie within the current region of interest. */
; 4120 :     void closing();
; 4121 :       /* Called from within `kd_precinct_ref::close' immediately prior to
; 4122 :          recycling the storage associated with the precinct, its precinct-bands
; 4123 :          and their code-blocks.  This function should release any resources
; 4124 :          which are specific to this particular precinct.  These resources
; 4125 :          include any non-NULL `layer_bytes' array and any code-byte buffers.
; 4126 :          Note that the `kd_precinct_ref::close' function may be called
; 4127 :          indirectly while opening a different precinct, if the current
; 4128 :          precinct has already been released.  This enables open calls to
; 4129 :          deal with resource limitations by unloading precincts which are not
; 4130 :          currently active. */
; 4131 :     void release()
; 4132 :       /* Used only for input codestream objects, this function is called once
; 4133 :          all code-blocks within the current region of interest have been
; 4134 :          consumed.  The function sets `num_outstanding_blocks' to 0, although
; 4135 :          in most cases this function will be called because
; 4136 :          `num_outstanding_blocks' has just become 0 (only exception is when
; 4137 :          a tile is being closed).  Also sets `released' to true.  If the
; 4138 :          KD_PFLAG_DESEQUENCED flag is false, the function returns without
; 4139 :          modifying the precinct in any other way.
; 4140 :             The `kd_precinct_ref::release' function is called to formally
; 4141 :          release the precinct's resources (this might not unload them from
; 4142 :          memory) if the codestream mode is non-persistent or if the precinct
; 4143 :          is addressable.  In the latter case, the precinct's contents can
; 4144 :          be reloaded from the compressed source if necessary.
; 4145 :             This function shall not be used with codestream objects
; 4146 :          opened for output or for interchange (no compressed data source and
; 4147 :          no compressed data target). */
; 4148 :       {
; 4149 :         assert(resolution->codestream->in != NULL);
; 4150 :         num_outstanding_blocks = 0;
; 4151 :         flags |= KD_PFLAG_RELEASED;
; 4152 :           // released = true;
; 4153 :         if ((flags & KD_PFLAG_ADDRESSABLE) ||
; 4154 :             ((flags & KD_PFLAG_DESEQUENCED) &&
; 4155 :                 // if (addressable ||
; 4156 :                 //     (desequenced &&
; 4157 :              !resolution->codestream->persistent))
; 4158 :           ref->release(); // May unload us from memory!
; 4159 :       }
; 4160 :     void finished_desequencing()
; 4161 :       /* Called once we can be sure that no more packets will be available
; 4162 :          for this precinct.  In practice, the function is called when the
; 4163 :          last packet has been desequenced or when the containing tile has
; 4164 :          been completely read.  If no packets at all have been desequenced for
; 4165 :          the precinct when this function is called (must have been invoked
; 4166 :          from within `kd_tile::finished_reading'), the precinct is marked
; 4167 :          as addressable, with an address of 0.  This is because it is safe
; 4168 :          to unload such a precinct and then reload it again regardless of
; 4169 :          the services offered by the compressed data source -- there is no
; 4170 :          data actually available from the compressed source for the
; 4171 :          precinct anyway, so reloading is a no-op.
; 4172 :             It should be noted that this function may unload the precinct
; 4173 :          from memory if it is determined that all code-blocks in the
; 4174 :          region of interest (there may be none) have already been consumed. */
; 4175 :       {
; 4176 :         if (flags & KD_PFLAG_DESEQUENCED)
; 4177 :           return;
; 4178 :         flags |= KD_PFLAG_DESEQUENCED;
; 4179 :           // desequenced = true;
; 4180 :         if (next_layer_idx == 0)
; 4181 :           {
; 4182 :             flags |= KD_PFLAG_ADDRESSABLE;
; 4183 :               // addressable = true;
; 4184 :             unique_address = 0;
; 4185 :           }
; 4186 :         if (num_outstanding_blocks == 0)
; 4187 :           release();
; 4188 :       }
; 4189 :     bool desequence_packet()
; 4190 :       /* This function should be called when a non-NULL `kd_precinct_ref'
; 4191 :          pointer is returned by `kd_packet_sequencer::next_in_sequence' and
; 4192 :          its `kd_precinct_ref::is_sequenced' function returns false.
; 4193 :          The function invokes `read_packet' and, if successful, increments
; 4194 :          the precinct's `next_layer_idx' field and the containing tile's
; 4195 :          `num_sequenced_packets' field.
; 4196 :             The function returns false if `read_packet' returns false,
; 4197 :          in which case, more tile-parts must be read (if there are any) to
; 4198 :          recover the information required to desequence the packet.
; 4199 :             Before returning true, the function checks to see whether all
; 4200 :          packets for the tile have been sequenced.  If so, the tile's
; 4201 :          `finished_reading' function is called. */
; 4202 :       {
; 4203 :         kd_tile *tile = resolution->tile_comp->tile;
; 4204 :         assert(!(flags & (KD_PFLAG_DESEQUENCED | KD_PFLAG_ADDRESSABLE)));
; 4205 :         if (!read_packet()) return false;
; 4206 :         next_layer_idx++;
; 4207 :         if (next_layer_idx == tile->num_layers)
; 4208 :           finished_desequencing();
; 4209 :         tile->next_input_packet_num++;
; 4210 :         if ((flags & KD_PFLAG_RELEVANT) &&
; 4211 :             (next_layer_idx <= tile->max_relevant_layers))
; 4212 :           {
; 4213 :             tile->sequenced_relevant_packets++;
; 4214 :             if (tile->sequenced_relevant_packets==tile->max_relevant_packets)
; 4215 :               tile->finished_reading();
; 4216 :           }
; 4217 :         return true;
; 4218 :       }
; 4219 :     void load_required_packets()
; 4220 :       /* If the precinct is addressable, this function uses its
; 4221 :          `unique_address' to position the compressed data source at the
; 4222 :          beginning of the precinct's first packet; it then loads all required
; 4223 :          packets from the compressed source.  Otherwise, the function does
; 4224 :          nothing at all -- reading is presumed to have occurred during packet
; 4225 :          desequencing. */
; 4226 :       {
; 4227 :         if ((!(flags & KD_PFLAG_ADDRESSABLE)) ||
; 4228 :             (unique_address == 0) || (num_packets_read != 0))
; 4229 :           return;
; 4230 :         assert((flags & KD_PFLAG_DESEQUENCED) &&
; 4231 :                (next_layer_idx >= required_layers));
; 4232 :         resolution->codestream->in->seek(unique_address);
; 4233 :         while (num_packets_read < required_layers)
; 4234 :           if (!read_packet())
; 4235 :             break;
; 4236 :       }
; 4237 :     kdu_long simulate_packet(kdu_long &header_bytes,
; 4238 :                              int layer_idx, kdu_uint16 slope_threshold,
; 4239 :                              bool finalize_layer, bool last_layer,
; 4240 :                              kdu_long max_bytes=KDU_LONG_HUGE,
; 4241 :                              bool trim_to_limit=false);
; 4242 :       /* Implements the functionality of `kd_codestream::simulate_output'
; 4243 :          for a single precinct.  Note that the total number of packet bytes
; 4244 :          is left behind in the internal `layer_bytes' array.  This allows the
; 4245 :          determination of tile-part length fields later on when we come to
; 4246 :          construct the code-stream.  The function returns this total number
; 4247 :          of bytes.  It also returns the number of packet header bytes via
; 4248 :          `header_bytes' (the function return value includes the cost of these
; 4249 :          header bytes).
; 4250 :             If the `max_bytes' limit is exceeded, the function may return
; 4251 :          prematurely, without having completed the simulation.  This is
; 4252 :          unacceptable when finalizing a layer, so you must be sure that
; 4253 :          `max_bytes' is sufficient in that case.
; 4254 :             If `trim_to_limit' is true, `finalize_layer' and `last_layer'
; 4255 :          must also both be true.  The function then trims away all coding
; 4256 :          passes from the precinct's code-blocks which are associated with
; 4257 :          slope values of `slope_threshold'+1 or less, until the limit
; 4258 :          associated with `max_bytes' is satisfied.  This functionality is
; 4259 :          used to implement the `sloppy_bytes' capabilities advertised by the
; 4260 :          `kd_codestream::simulate_output' function. */
; 4261 :     kdu_long write_packet(kdu_uint16 slope_threshold, bool empty_packet=false);
; 4262 :       /* Writes out the next packet for this precinct, using the supplied
; 4263 :          distortion-length slope threshold.  Increments the `next_layer_idx'
; 4264 :          field as well as the containing tile's `num_sequenced_packets'
; 4265 :          field when done.  If `empty_packet' is true, an empty packet should
; 4266 :          be issued, having a length of 1 byte, plus the length of any required
; 4267 :          EPH marker (no SOP marker will be attached to empty packets).  The
; 4268 :          function returns the total number of bytes output for the packet. */
; 4269 :   private: // Member functions
; 4270 :     bool read_packet();
; 4271 :       /* Reads a new layer of this precinct sequentially from the
; 4272 :          compressed data source, incrementing the `num_packets_read' member.
; 4273 :          Note that packet reading may be interleaved with acesses to the
; 4274 :          precinct's code-blocks for various reasons.  For example, we
; 4275 :          may initially open a tile with only a limited number of required
; 4276 :          layers, using its code-block data to decompress an approximate
; 4277 :          representation of the image.  We may then find that the additional
; 4278 :          packets need to be loaded in order to advance to other precincts
; 4279 :          in the code-stream.
; 4280 :             The function returns false if an SOT marker (or an EOC marker) is
; 4281 :          encountered.  Note that when an SOT marker is encountered, its
; 4282 :          segment is fully read into the codestream marker service and the
; 4283 :          precinct's tile must be active (otherwise an error message will be
; 4284 :          generated).  Before returning false in this way, the function sets
; 4285 :          the `active_tile' pointer in the codestream object to NULL.  The
; 4286 :          caller may determine the cause of failure by invoking the codestream
; 4287 :          marker service's `get_code' function, which will return one of SOT,
; 4288 :          EOC or 0, where 0 occurs only if the code-stream has been
; 4289 :          exhausted. */
; 4290 :     bool handle_corrupt_packet();
; 4291 :       /* This function implements alternate processing for the `read_packet'
; 4292 :          function in the event that a packet is found to be corrupt.  It is
; 4293 :          called whenever packet corruption is detected, including when the
; 4294 :          precinct is known to have had previously corrupt packets. The function
; 4295 :          manipulates the containing tile's `skipping_to_sop' and
; 4296 :          `next_sop_sequence_num' fields, advancing to the next SOP or SOT
; 4297 :          marker if necessary (the function may be called after detecting an
; 4298 :          SOP marker already, whose sequence number is not as expected).  If
; 4299 :          an SOT marker is encountered, the function renders the current tile
; 4300 :          inactive and returns false (this is the behaviour expected of
; 4301 :          `read_packet').  Otherwise, it updates the precinct and tile state to
; 4302 :          identify the packet as having been read. */
; 4303 :   public: // Public Links and Identification
; 4304 :     kd_resolution *resolution;
; 4305 :     kd_precinct_ref *ref; // Element of `resolution->precinct_refs' array
; 4306 : 
; 4307 :   public: // Mode flags used for decompression and/or interchange
; 4308 :     int flags; // The following flags are defined.
; 4309 :        // KD_PFLAG_GENERATING -- after 1'st call to `kd_precinct::get_packets'
; 4310 :        // KD_PFLAG_CORRUPTED -- if error occurred during packet reading
; 4311 :        // KD_PFLAG_DESEQUENCED -- if all packets have been desequenced
; 4312 :        // KD_PFLAG_ADDRESSABLE -- if seekable, cached or used for interchange
; 4313 :        // KD_PFLAG_RELEASED -- if `activate' must be called to revive state
; 4314 :        // KD_PFLAG_INACTIVE -- if resides on `kd_precict_server's inactive list
; 4315 :        // KD_PFLAG_RELEVANT -- always true if codestream is for non-persistent
; 4316 :        //     input; otherwise, true only if precinct belongs to the relevant
; 4317 :        //     set of precincts of a relevant tile-component-resolution
; 4318 :        // KD_PFLAG_SIGNIFICANT -- if any code-block bytes have been generated
; 4319 :        //     by `kdu_precinct::size_packets' or `kdu_precinct::get_packets'
; 4320 :        // KD_PFLAG_PARSED -- if the precinct was parsed previously and then
; 4321 :        //     unloaded; prevents multiple accumulation of packet length stats
; 4322 :   public: // State variables
; 4323 :     int required_layers; /* Actual number of layers for output codestream;
; 4324 :                 max apparent layers for input or interchange codestream. */
; 4325 :     int next_layer_idx; // Next layer to be sequenced or generated.
; 4326 :     union { // First field used for input; second interchange; third for output
; 4327 :         int num_packets_read; // Incremented when packets read or interchanged
; 4328 :         int cumulative_bytes; // Size of all packets generated so far.
; 4329 :         int saved_next_layer_idx; // Used by "kd_packet_sequencer::save_state"
; 4330 :       };
; 4331 : 
; 4332 :   public: // Activation state variables
; 4333 :     int num_outstanding_blocks; // See notes below.
; 4334 :     union { // First field used only in reading; second only in writing.
; 4335 :         kdu_long unique_address; // See below
; 4336 :         kdu_long *packet_bytes; // Lengths generated during simulated output
; 4337 :       };
; 4338 :   public: // code-block containers
; 4339 :     kd_precinct_band *subbands; // In practice, this member points into the
; 4340 :        // same block of memory which is allocated to hold the precinct so
; 4341 :        // as to encourage memory locality and allow for manipulation of all
; 4342 :        // aspects of a precinct, including all of its code-blocks, via a
; 4343 :        // single heap block.  Note that the number of entries in this array
; 4344 :        // is given by `resolution->num_subbands'.
; 4345 : 
; 4346 :   public: // See below for an explanation of these links
; 4347 :     kd_precinct *next; // Next in free, inactive or generated list
; 4348 :     kd_precinct *prev; // Previous in inactive or generated list
; 4349 :     kd_precinct_size_class *size_class; // For correctly releasing storage
; 4350 :   };
; 4351 :   /* Notes:
; 4352 :         `unique_address' is valid if and only if the precinct is marked as
; 4353 :      addressable, meaning that the precinct has a unique address from which it
; 4354 :      may be loaded (for input codestream objects) or identified (for
; 4355 :      interchange codestream objects).  If addressable, the `unique_address'
; 4356 :      will be 0 if and only if the precinct is known to be empty, meaning that
; 4357 :      reloading the precinct does not require any actual data transfers from a
; 4358 :      compressed data source.
; 4359 :         Except as described above, when used with seekable compressed data
; 4360 :      sources, the `unique_address' member holds a positive quantity which
; 4361 :      identifies an offset into the code-stream at which the precinct's
; 4362 :      packets may be found.  In the case of cached sources (those advertising
; 4363 :      the KDU_SOURCE_CAP_CACHED capability) or codestream objects created for
; 4364 :      interchange (no compressed data source or target), the `unique_address'
; 4365 :      will be negative and -(1+`unique_address') is the precinct's unique
; 4366 :      identifier, as passed to the `kdu_compressed_source::set_precinct_scope'
; 4367 :      function, or returned by the `kdu_precinct::get_unique_id' function.
; 4368 :         The `num_outstanding_blocks' member is used to monitor the number of
; 4369 :      code-blocks from the application's region of interest which have still
; 4370 :      to be consumed (input codestreams) or the number of code-blocks which
; 4371 :      have still to be written in order to complete the precinct (output
; 4372 :      and interchange codestreams).
; 4373 :         The `next' and `prev' links may be used to manage the precinct's
; 4374 :      location in one of three different lists.  The first list is the
; 4375 :      singly-linked free list maintained by `kd_precinct_size_class', from
; 4376 :      which the `kd_precinct_server' object re-issues previously released
; 4377 :      resources.
; 4378 :         The second list on which this structure may find itself is the
; 4379 :      doubly-linked list of currently inactive precincts, which is managed by
; 4380 :      the `kd_precinct_server' object.  Precincts which find themselves on this
; 4381 :      list have been released, but their resources have not yet been recycled.
; 4382 :      They may be successfully re-activated, if their resources have not been
; 4383 :      re-issued to another precinct.  Precincts on this list may be identified
; 4384 :      by the `inactive' flag.  Every inactive precinct necessarily also has
; 4385 :      its `released' member set to true, but the converse is not necessarily
; 4386 :      true.  This is because precincts which have been partially parsed
; 4387 :      in a context for which they were not directly relevant, will be marked
; 4388 :      as released, even though they are not inactive.
; 4389 :         The third list on which this structure may find itself is the
; 4390 :      doubly-linked list of generated precincts managed by the
; 4391 :      `kd_global_rescomp' structure.  This list contains all precincts
; 4392 :      from a given resolution of a given image component, across all tiles,
; 4393 :      which have been fully generated, but not yet flushed out to the
; 4394 :      code-stream.   The list is used to manage incremental rate allocation
; 4395 :      when processing large images.  Elements on this list have not yet
; 4396 :      been closed. */
; 4397 : 
; 4398 : /*****************************************************************************/
; 4399 : /*                         kd_precinct_size_class                            */
; 4400 : /*****************************************************************************/
; 4401 : 
; 4402 :   /* For an explanation of the role played by precinct size classes, see
; 4403 :      the discussion appearing below the declaration of `kd_precinct_server'. */
; 4404 : 
; 4405 : class kd_precinct_size_class {
; 4406 :   public: // Member functions
; 4407 :     kd_precinct_size_class(int max_blocks, int num_subbands,
; 4408 :                            kd_precinct_server *server,
; 4409 :                            kd_buf_server *buf_server)
; 4410 :       {
; 4411 :         this->max_blocks = max_blocks;
; 4412 :         this->num_subbands = num_subbands;
; 4413 :         this->server = server;  this->buf_server = buf_server;
; 4414 :         total_precincts = 0; free_list = NULL; next = NULL;
; 4415 :         alloc_bytes = (int) sizeof(kd_precinct);
; 4416 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4417 :         alloc_bytes += num_subbands * (int) sizeof(kd_precinct_band);
; 4418 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4419 :         alloc_bytes += 4 + max_blocks * (int) sizeof(kd_block);
; 4420 :       }
; 4421 :     ~kd_precinct_size_class()
; 4422 :       { kd_precinct *tmp;
; 4423 :         while ((tmp=free_list) != NULL)
; 4424 :           { free_list = tmp->next; free(tmp); total_precincts--; }
; 4425 :         assert(total_precincts == 0);
; 4426 :       }
; 4427 :     kd_precinct *get()
; 4428 :       {
; 4429 :         if (free_list == NULL)
; 4430 :           augment_free_list();
; 4431 :         kd_precinct *result = free_list; free_list = free_list->next;
; 4432 :         result->next = result->prev = NULL;
; 4433 :         buf_server->augment_structure_bytes(alloc_bytes);
; 4434 :         return result;
; 4435 :       }
; 4436 :     void release(kd_precinct *precinct)
; 4437 :       {
; 4438 :         if (precinct->flags & KD_PFLAG_INACTIVE)

	je	SHORT $LN51@release

; 4439 :           withdraw_from_inactive_list(precinct);

	push	esi
	mov	ecx, edx
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list
	mov	edx, DWORD PTR _this$1$[ebp]
$LN51@release:

; 4440 :         precinct->next = free_list;

	mov	eax, DWORD PTR [edx+32]
	mov	DWORD PTR [esi+44], eax

; 4442 :         buf_server->augment_structure_bytes(-alloc_bytes);

	mov	ecx, DWORD PTR [edx+4]

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	mov	eax, DWORD PTR [edx+16]

; 4441 :         free_list = precinct;

	mov	DWORD PTR [edx+32], esi

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	neg	eax

; 4442 :         buf_server->augment_structure_bytes(-alloc_bytes);

	cdq

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	add	DWORD PTR [ecx+32], eax

; 281  :         if (structure_bytes > peak_structure_bytes)

	mov	eax, DWORD PTR [ecx+32]
	adc	DWORD PTR [ecx+36], edx
	mov	edx, DWORD PTR [ecx+36]
	cmp	edx, DWORD PTR [ecx+44]
	jl	SHORT $LN54@release
	jg	SHORT $LN81@release
	cmp	eax, DWORD PTR [ecx+40]
	jbe	SHORT $LN54@release
$LN81@release:

; 282  :           peak_structure_bytes = structure_bytes;

	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+44], edx
$LN54@release:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 635  :           for (int p=0; p < num_precincts; p++)

	mov	ecx, DWORD PTR _res$1$[ebp]
	inc	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4678 :   state = 0;

	mov	DWORD PTR [edi], 0
	mov	DWORD PTR [edi+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 635  :           for (int p=0; p < num_precincts; p++)

	cmp	ebx, DWORD PTR _num_precincts$1$[ebp]
	jl	$LL10@release
	mov	esi, DWORD PTR _tc$1$[ebp]
	mov	edx, DWORD PTR _r$1$[ebp]
$LN5@release:

; 631  :       for (int r=0; r <= tc->dwt_levels; r++)

	mov	eax, DWORD PTR tv643[ebp]
	inc	edx
	add	eax, 604				; 0000025cH
	mov	DWORD PTR _r$1$[ebp], edx
	mov	DWORD PTR tv643[ebp], eax
	cmp	edx, DWORD PTR [esi+56]
	jle	$LL7@release
	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR _c$1$[ebp]
	mov	ecx, DWORD PTR tv642[ebp]
$LN2@release:

; 626  : 
; 627  :   for (int c=0; c < num_components; c++)

	inc	eax
	add	ecx, 188				; 000000bcH
	mov	DWORD PTR _c$1$[ebp], eax
	mov	DWORD PTR tv642[ebp], ecx
	cmp	eax, DWORD PTR [ebx+128]
	jl	$LL4@release
	pop	edi
$LN3@release:

; 636  :             res->precinct_refs[p].clear();
; 637  :         }
; 638  :     }
; 639  : 
; 640  :   if ((codestream->textualize_out != NULL) && !empty_shell)

	mov	eax, DWORD PTR [ebx]
	mov	esi, DWORD PTR [eax]
	test	esi, esi
	je	SHORT $LN18@release
	cmp	BYTE PTR [ebx+227], 0
	jne	$LN72@release
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_0BN@MCFNCJCD@?6?$DO?$DO?5New?5attributes?5for?5tile?5?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR [esi+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR [ebx+4]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$1[ebp]
	push	eax
	call	_sprintf

; 263  :         put_text(text); return *this; }

	mov	eax, DWORD PTR [esi]
	lea	ecx, DWORD PTR _text$1[ebp]
	add	esp, 12					; 0000000cH
	push	ecx
	mov	ecx, esi
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	OFFSET ??_C@_02NDKNKOCB@?3?6?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 644  :       codestream->siz->textualize_attributes(out,t_num,t_num);

	mov	eax, DWORD PTR [ebx+4]
	mov	ecx, DWORD PTR [ebx]
	push	1
	push	eax
	push	eax
	mov	ecx, DWORD PTR [ecx+12]
	push	esi
	call	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@HH_N@Z ; kdu_params::textualize_attributes

; 645  :       out.flush();

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	push	0
	call	DWORD PTR [eax+12]
$LN18@release:

; 646  :     }
; 647  : 
; 648  :   if (!(empty_shell || is_unloadable))

	cmp	BYTE PTR [ebx+227], 0
	jne	SHORT $LN72@release
	cmp	BYTE PTR [ebx+230], 0
	jne	SHORT $LN84@release

; 649  :     {
; 650  :       int cluster = 1;
; 651  :       kdu_params *csp;
; 652  : 
; 653  :       while ((csp=codestream->siz->access_cluster(cluster++)) != NULL)

	mov	ecx, DWORD PTR [ebx]
	mov	esi, 1
	push	esi
	mov	ecx, DWORD PTR [ecx+12]
	call	?access_cluster@kdu_params@@QAEPAV1@H@Z	; kdu_params::access_cluster
	test	eax, eax
	je	SHORT $LN72@release
$LL11@release:

; 654  :         if ((csp=csp->access_unique(t_num,-1)) != NULL)

	push	0
	push	-1
	push	DWORD PTR [ebx+4]
	mov	ecx, eax
	inc	esi
	call	?access_unique@kdu_params@@QAEPAV1@HHH@Z ; kdu_params::access_unique
	test	eax, eax
	je	SHORT $LN32@release

; 655  :           delete csp;

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx+4]
$LN32@release:

; 649  :     {
; 650  :       int cluster = 1;
; 651  :       kdu_params *csp;
; 652  : 
; 653  :       while ((csp=codestream->siz->access_cluster(cluster++)) != NULL)

	mov	ecx, DWORD PTR [ebx]
	push	esi
	mov	ecx, DWORD PTR [ecx+12]
	call	?access_cluster@kdu_params@@QAEPAV1@H@Z	; kdu_params::access_cluster
	test	eax, eax
	jne	SHORT $LL11@release
$LN72@release:

; 656  :     }
; 657  : 
; 658  :   assert(tile_ref->tile == this);
; 659  :   if (is_unloadable)

	cmp	BYTE PTR [ebx+230], 0
$LN84@release:
	pop	esi
	je	SHORT $LN21@release

; 660  :     {
; 661  :       withdraw_from_unloadable_list();

	mov	ecx, ebx
	call	?withdraw_from_unloadable_list@kd_tile@@AAEXXZ ; kd_tile::withdraw_from_unloadable_list

; 662  :       tile_ref->tile = NULL;

	mov	eax, DWORD PTR [ebx+16]
	mov	DWORD PTR [eax+8], 0
	jmp	SHORT $LN24@release
$LN21@release:

; 663  :     }
; 664  :   else if (empty_shell)

	cmp	BYTE PTR [ebx+227], 0

; 665  :     tile_ref->tile = NULL;

	mov	eax, DWORD PTR [ebx+16]
	je	SHORT $LN23@release
	mov	DWORD PTR [eax+8], 0

; 666  :   else

	jmp	SHORT $LN24@release
$LN23@release:

; 667  :     tile_ref->tile = KD_EXPIRED_TILE;

	mov	DWORD PTR [eax+8], -1
$LN24@release:

; 668  : 
; 669  :   codestream->buf_server->augment_structure_bytes(-structure_bytes);

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax+24]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	mov	eax, DWORD PTR [ebx+216]
	sub	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR [ebx+220]
	sbb	DWORD PTR [ecx+36], eax

; 281  :         if (structure_bytes > peak_structure_bytes)

	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [ecx+32]
	cmp	edx, DWORD PTR [ecx+44]
	jl	SHORT $LN63@release
	jg	SHORT $LN82@release
	cmp	eax, DWORD PTR [ecx+40]
	jbe	SHORT $LN63@release
$LN82@release:

; 282  :           peak_structure_bytes = structure_bytes;

	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+44], edx
$LN63@release:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 677  :   typical_next = codestream->typical_tile_cache;

	mov	ecx, DWORD PTR [ebx]
	mov	DWORD PTR [ebx+216], 0
	mov	DWORD PTR [ebx+220], 0
	mov	DWORD PTR [ebx+16], 0
	mov	DWORD PTR [ebx+4], -1
	mov	eax, DWORD PTR [ecx+412]
	mov	DWORD PTR [ebx+40], eax

; 678  :   codestream->typical_tile_cache = this;

	mov	DWORD PTR [ecx+412], ebx
	pop	ebx

; 679  : }

	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
$LN14@release:
	call	??1kd_tile@@QAE@XZ			; kd_tile::~kd_tile
	push	272					; 00000110H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	add	esp, 8
	xor	ecx, ebp
	pop	ebx
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
?release@kd_tile@@QAEXXZ ENDP				; kd_tile::release
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ??1kd_tile@@QAE@XZ
_TEXT	SEGMENT
_text$2 = -96						; size = 80
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
??1kd_tile@@QAE@XZ PROC					; kd_tile::~kd_tile, COMDAT
; _this$ = ecx

; 527  : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_tile@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 528  :   assert(this != codestream->active_tile);
; 529  : 
; 530  :   if (is_in_progress)

	cmp	BYTE PTR [esi+228], 0
	je	SHORT $LN6@kd_tile

; 531  :     remove_from_in_progress_list(); // Should not happen; just for safety

	call	?remove_from_in_progress_list@kd_tile@@QAEXXZ ; kd_tile::remove_from_in_progress_list
$LN6@kd_tile:

; 532  : 
; 533  :   if (ppt_markers != NULL)

	mov	edi, DWORD PTR [esi+44]
	test	edi, edi
	je	SHORT $LN36@kd_tile
	mov	ecx, edi
	call	??1kd_pp_markers@@QAE@XZ		; kd_pp_markers::~kd_pp_markers
	push	8
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN36@kd_tile:

; 534  :     delete ppt_markers;
; 535  : 
; 536  :   if (packed_headers != NULL)

	mov	ecx, DWORD PTR [esi+48]
	test	ecx, ecx
	je	SHORT $LN25@kd_tile

; 537  :     delete packed_headers;

	mov	eax, DWORD PTR [ecx]
	push	1
	call	DWORD PTR [eax]
$LN25@kd_tile:

; 538  :   
; 539  :   if (reslength_checkers != NULL)

	mov	eax, DWORD PTR [esi+120]
	test	eax, eax
	je	SHORT $LN27@kd_tile
	push	OFFSET ??1kd_reslength_checker@@QAE@XZ	; kd_reslength_checker::~kd_reslength_checker
	push	DWORD PTR [eax-4]
	lea	edi, DWORD PTR [eax-4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	808					; 00000328H
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	imul	eax, DWORD PTR [edi], 808
	add	eax, 4
	push	eax
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
	mov	DWORD PTR __$EHRec$[ebp+8], -1
$LN27@kd_tile:

; 540  :     delete[] reslength_checkers;
; 541  : 
; 542  :   if ((tile_ref != NULL) &&
; 543  :       (codestream->textualize_out != NULL) && !empty_shell)

	cmp	DWORD PTR [esi+16], 0
	je	$LN93@kd_tile
	mov	eax, DWORD PTR [esi]
	mov	edi, DWORD PTR [eax]
	test	edi, edi
	je	SHORT $LN10@kd_tile
	cmp	BYTE PTR [esi+227], 0
	jne	SHORT $LN10@kd_tile
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	OFFSET ??_C@_0BN@MCFNCJCD@?6?$DO?$DO?5New?5attributes?5for?5tile?5?$AA@
	call	DWORD PTR [eax+8]

; 258  :     kdu_message &operator<<(char ch)
; 259  :       { char text[2]; text[0]=ch; text[1]='\0'; put_text(text); return *this; }
; 260  :     kdu_message &operator<<(int val)
; 261  :       { char text[80];
; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	cmp	BYTE PTR [edi+4], 0
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	push	DWORD PTR [esi+4]
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$2[ebp]
	push	eax
	call	_sprintf

; 263  :         put_text(text); return *this; }

	mov	eax, DWORD PTR [edi]
	lea	ecx, DWORD PTR _text$2[ebp]
	add	esp, 12					; 0000000cH
	push	ecx
	mov	ecx, edi
	call	DWORD PTR [eax+8]

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	OFFSET ??_C@_02NDKNKOCB@?3?6?$AA@
	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 547  :       codestream->siz->textualize_attributes(out,t_num,t_num);

	mov	eax, DWORD PTR [esi+4]
	mov	ecx, DWORD PTR [esi]
	push	1
	push	eax
	push	eax
	mov	ecx, DWORD PTR [ecx+12]
	push	edi
	call	?textualize_attributes@kdu_params@@QAEXAAVkdu_message@@HH_N@Z ; kdu_params::textualize_attributes

; 548  :       out.flush();

	mov	eax, DWORD PTR [edi]
	mov	ecx, edi
	push	0
	call	DWORD PTR [eax+12]
$LN10@kd_tile:

; 549  :     }
; 550  : 
; 551  :   if ((tile_ref != NULL) && !(empty_shell || is_unloadable))

	cmp	DWORD PTR [esi+16], 0
	je	SHORT $LN93@kd_tile
	cmp	BYTE PTR [esi+227], 0
	jne	SHORT $LN93@kd_tile
	cmp	BYTE PTR [esi+230], 0
	jne	SHORT $LN93@kd_tile

; 552  :     {
; 553  :       int cluster = 1;
; 554  :       kdu_params *csp;
; 555  : 
; 556  :       while ((csp=codestream->siz->access_cluster(cluster++)) != NULL)

	mov	ecx, DWORD PTR [esi]
	mov	edi, 1
	push	edi
	mov	ecx, DWORD PTR [ecx+12]
	call	?access_cluster@kdu_params@@QAEPAV1@H@Z	; kdu_params::access_cluster
	test	eax, eax
	je	SHORT $LN93@kd_tile
$LL2@kd_tile:

; 557  :         if ((csp=csp->access_unique(t_num,-1)) != NULL)

	push	0
	push	-1
	push	DWORD PTR [esi+4]
	mov	ecx, eax
	inc	edi
	call	?access_unique@kdu_params@@QAEPAV1@HHH@Z ; kdu_params::access_unique
	test	eax, eax
	je	SHORT $LN29@kd_tile

; 558  :           delete csp;

	mov	edx, DWORD PTR [eax]
	mov	ecx, eax
	push	1
	call	DWORD PTR [edx+4]
$LN29@kd_tile:

; 552  :     {
; 553  :       int cluster = 1;
; 554  :       kdu_params *csp;
; 555  : 
; 556  :       while ((csp=codestream->siz->access_cluster(cluster++)) != NULL)

	mov	ecx, DWORD PTR [esi]
	push	edi
	mov	ecx, DWORD PTR [ecx+12]
	call	?access_cluster@kdu_params@@QAEPAV1@H@Z	; kdu_params::access_cluster
	test	eax, eax
	jne	SHORT $LL2@kd_tile
$LN93@kd_tile:

; 559  :     }
; 560  : 
; 561  :   if (sequencer != NULL)

	mov	eax, DWORD PTR [esi+52]
	test	eax, eax
	je	SHORT $LN13@kd_tile

; 562  :     delete sequencer;

	push	176					; 000000b0H
	push	eax
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN13@kd_tile:

; 563  :   if (comps != NULL)

	mov	eax, DWORD PTR [esi+208]
	test	eax, eax
	je	SHORT $LN58@kd_tile
	push	OFFSET ??1kd_tile_comp@@QAE@XZ		; kd_tile_comp::~kd_tile_comp
	push	DWORD PTR [eax-4]
	lea	edi, DWORD PTR [eax-4]
	mov	DWORD PTR __$EHRec$[ebp+8], 1
	push	188					; 000000bcH
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	imul	eax, DWORD PTR [edi], 188
	add	eax, 4
	push	eax
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN58@kd_tile:

; 565  :   while ((mct_tail=mct_head) != NULL)

	mov	eax, DWORD PTR [esi+200]
	mov	DWORD PTR [esi+204], eax
	test	eax, eax
	je	$LN5@kd_tile
	npad	13
$LL4@kd_tile:

; 566  :     {
; 567  :       mct_head = mct_tail->next_stage;

	mov	eax, DWORD PTR [esi+204]

; 568  :       delete mct_tail;

	mov	ebx, DWORD PTR [esi+204]
	mov	eax, DWORD PTR [eax+36]
	mov	DWORD PTR [esi+200], eax
	test	ebx, ebx
	je	SHORT $LN62@kd_tile
	mov	DWORD PTR __$EHRec$[ebp+8], 2
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2136 :         if (input_required_indices != NULL)

	mov	eax, DWORD PTR [ebx+8]
	test	eax, eax
	je	SHORT $LN66@kd_tile

; 2137 :           delete[] input_required_indices;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN66@kd_tile:

; 2138 :         if (output_comp_info != NULL) delete[] output_comp_info;

	mov	eax, DWORD PTR [ebx+20]
	test	eax, eax
	je	SHORT $LN67@kd_tile
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN67@kd_tile:

; 2139 :         if (blocks != NULL) delete[] blocks;

	mov	eax, DWORD PTR [ebx+28]
	test	eax, eax
	je	SHORT $LN76@kd_tile
	push	OFFSET ??1kd_mct_block@@QAE@XZ		; kd_mct_block::~kd_mct_block
	push	DWORD PTR [eax-4]
	lea	edi, DWORD PTR [eax-4]
	mov	BYTE PTR __$EHRec$[ebp+8], 4
	push	108					; 0000006cH
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	imul	eax, DWORD PTR [edi], 108
	add	eax, 4
	push	eax
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN76@kd_tile:
	push	40					; 00000028H
	push	ebx
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN62@kd_tile:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 565  :   while ((mct_tail=mct_head) != NULL)

	mov	eax, DWORD PTR [esi+200]
	mov	DWORD PTR [esi+204], eax
	test	eax, eax
	jne	$LL4@kd_tile
$LN5@kd_tile:

; 569  :     }
; 570  : 
; 571  :   if (tile_ref != NULL)
; 572  :     assert(tile_ref->tile == this);
; 573  :   if (is_unloadable)

	cmp	BYTE PTR [esi+230], 0
	je	SHORT $LN16@kd_tile

; 574  :     {
; 575  :       assert(tile_ref != NULL); // Released tiles not on the unloadable list
; 576  :       withdraw_from_unloadable_list();

	mov	ecx, esi
	call	?withdraw_from_unloadable_list@kd_tile@@AAEXXZ ; kd_tile::withdraw_from_unloadable_list

; 577  :       tile_ref->tile = NULL;

	mov	eax, DWORD PTR [esi+16]
	mov	DWORD PTR [eax+8], 0
	jmp	SHORT $LN20@kd_tile
$LN16@kd_tile:

; 578  :     }
; 579  :   else if (empty_shell)

	cmp	BYTE PTR [esi+227], 0

; 580  :     {
; 581  :       assert(tile_ref != NULL);
; 582  :       tile_ref->tile = NULL;

	mov	eax, DWORD PTR [esi+16]
	je	SHORT $LN18@kd_tile
	mov	DWORD PTR [eax+8], 0
	jmp	SHORT $LN20@kd_tile
$LN18@kd_tile:

; 583  :     }
; 584  :   else if (tile_ref != NULL)

	test	eax, eax
	je	SHORT $LN20@kd_tile

; 585  :     tile_ref->tile = KD_EXPIRED_TILE;

	mov	DWORD PTR [eax+8], -1
$LN20@kd_tile:

; 586  : 
; 587  :   if (tile_ref != NULL)

	cmp	DWORD PTR [esi+16], 0
	je	SHORT $LN80@kd_tile

; 588  :     codestream->buf_server->augment_structure_bytes(-structure_bytes);

	mov	eax, DWORD PTR [esi]
	mov	ecx, DWORD PTR [esi+216]
	mov	edx, DWORD PTR [esi+220]
	neg	ecx
	mov	eax, DWORD PTR [eax+24]
	adc	edx, 0
	neg	edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	add	DWORD PTR [eax+32], ecx

; 281  :         if (structure_bytes > peak_structure_bytes)

	mov	ecx, DWORD PTR [eax+32]
	adc	DWORD PTR [eax+36], edx
	mov	edx, DWORD PTR [eax+36]
	cmp	edx, DWORD PTR [eax+44]
	jl	SHORT $LN80@kd_tile
	jg	SHORT $LN101@kd_tile
	cmp	ecx, DWORD PTR [eax+40]
	jbe	SHORT $LN80@kd_tile
$LN101@kd_tile:

; 282  :           peak_structure_bytes = structure_bytes;

	mov	DWORD PTR [eax+40], ecx
	mov	DWORD PTR [eax+44], edx
$LN80@kd_tile:

; 1151 :     void restart()
; 1152 :       { disable(); } // Called if the code-stream is restarted.
; 1153 :     bool is_active()
; 1154 :       { return (buf_server != NULL); }
; 1155 :     void initialize(kd_buf_server *buf_server)
; 1156 :       /* Call this function when constructing the tile to which the
; 1157 :          object is attached, unless the code-stream is being read from
; 1158 :          a non-seekable source, in which case you should leave the object
; 1159 :          uninitialized and none of the other functions will have any effect. */
; 1160 :       { assert(this->buf_server == NULL); this->buf_server = buf_server;
; 1161 :         head = tail = NULL; head_pos = tail_pos = available_addresses = 0;
; 1162 :         next_address = 0; tpart_bytes_left = 0; num_layers = 0;
; 1163 :         something_served = final_tpart_with_unknown_length = false;
; 1164 :         next_znum = 0; packets_left_in_precinct=0; }
; 1165 :     void add_plt_marker(kd_marker &marker, kdu_params *cod_params,
; 1166 :                         kdu_params *poc_params);
; 1167 :       /* Call this function whenever a PLT marker segment is encountered,
; 1168 :          while parsing a tile-part header.  The `cod_params' and `poc_params'
; 1169 :          arguments must point to the relevant tile's COD and POC parameter
; 1170 :          objects.  The function uses these to determine whether or not the
; 1171 :          pointer information can be used.  In particular, it is used only
; 1172 :          if the current progression order sequences all packets of any
; 1173 :          given precinct together and if the POC object indicates that there
; 1174 :          will be no progression order changes.  These conditions are checked
; 1175 :          again after each tile-part header has been loaded (see the
; 1176 :          `start_tpart_body' member function).  The reason for the conditions
; 1177 :          is that at most one seek address can be maintained for any given
; 1178 :          precinct. */
; 1179 :     void start_tpart_body(kdu_long start_address, kdu_uint32 tpart_body_length,
; 1180 :                           kdu_params *cod_params, kdu_params *poc_params,
; 1181 :                           bool packed_headers,
; 1182 :                           bool final_tpart_with_unknown_length);
; 1183 :       /* This function must be called before addresses can be recovered for
; 1184 :          precincts whose packets appear in the current tile-part.  The
; 1185 :          `start_address' and `tpart_body_length' arguments identify the
; 1186 :          absolute seeking address of the first byte in the body of the
; 1187 :          tile-part and the total number of body bytes in the tile-part.
; 1188 :          These will be used to determine which packets belong to the
; 1189 :          tile-part.  If this is the last tile-part of the tile and its
; 1190 :          length is unknown, the `final_tpart_with_unknown_length' argument
; 1191 :          should be true, and `tpart_body_length' is ignored.
; 1192 :             This function may determine that precinct address information
; 1193 :          cannot be served up for the current tile, for one of a number of
; 1194 :          This is generally because the packets of each precinct are found
; 1195 :          not to be contiguous within the tile-part, or because the presence
; 1196 :          of POC information renders this a likely problem.  If the
; 1197 :          number of quality layers is found to have changed from the point
; 1198 :          when packet length information was first converted into precinct
; 1199 :          lengths and addresses, we must also conclude that address information
; 1200 :          is not available.  A further reason for discarding packet length
; 1201 :          information is if packet headers have been packed into marker
; 1202 :          segments, since this requires that the packets be processed in order
; 1203 :          and once one by one.  If any such determination is made before any
; 1204 :          precinct addresses have been served up, the object is simply
; 1205 :          disabled so that calls to `get_precinct_address' will return 0.
; 1206 :          Otherwise, a terminal error is generated.  In this event, the
; 1207 :          code-stream might need to be opened again with seeking disabled
; 1208 :          so that the present object will never be initialized. */
; 1209 :     kdu_long get_precinct_address()
; 1210 :       { return ((buf_server==NULL)?((kdu_long) 0):pop_address()); }
; 1211 :       /* Returns the address of the next precinct (in the sequence determined
; 1212 :          by the current progression order) in the tile.  This address may be
; 1213 :          used to seek to the relevant location when reading the precinct's
; 1214 :          packets.
; 1215 :             The function returns 0 if seeking is not possible, if
; 1216 :          packet length information cannot be found in the code-stream,
; 1217 :          or if packet length information is not usable for one of a number
; 1218 :          of reasons.  As explained above, packet length information is usable
; 1219 :          only if the packets of a precinct all appear consecutively so that
; 1220 :          each precinct is characterized by only one seeking address.
; 1221 :             The function returns -1 if seeking is possible, but the first
; 1222 :          packet of the precinct belongs to a tile-part which has not yet been
; 1223 :          opened.  In this event, the `kd_tile::read_tile_part_header' member
; 1224 :          function will have to be called until the information becomes
; 1225 :          available. */
; 1226 :   private: // Helper functions
; 1227 :     kdu_long pop_address();
; 1228 :       /* Does all the work of `get_precinct_address'. */
; 1229 :     void disable()
; 1230 :       { // Call to discard contents and cease recording new PLT info.
; 1231 :         if (buf_server == NULL) return;

	cmp	DWORD PTR [esi+56], 0

; 283  :       }
; 284  :     kdu_long augment_cache_threshold(kdu_long increment)
; 285  :       { // Use to adjust the cache threshold either up or down
; 286  :         return (cache_threshold_bytes += increment);
; 287  :       }
; 288  :     bool cache_threshold_exceeded()
; 289  :       { return (cache_threshold_bytes <
; 290  :                 (structure_bytes + num_allocated_pages *
; 291  :                  (KD_CODE_BUFFER_LEN*KDU_CODE_BUFFERS_PER_PAGE))); }
; 292  :       /* This function is called from the `kd_precinct_server::get' function
; 293  :          before it serves up a new precinct container, whenever one or more
; 294  :          precincts are currently on its inactive list.  The function returns
; 295  :          true if the cache threshold has been exceeded, meaning that one or
; 296  :          more inactive precincts should be closed (unloaded from
; 297  :          memory, along with all their associated code buffers).  For more
; 298  :          on this, consult the comments appearing below the declaration of
; 299  :          the `kd_precinct_server' class.
; 300  :             The function is also called whenever a new tile-part is started,
; 301  :          to determine whether there are unloadable tiles which should be
; 302  :          unloaded to bring memory consumption below the cache threshold. */
; 303  :     void attach_thread_buf_server(kd_thread_buf_server *tbs);
; 304  :     void detach_thread_buf_server(kd_thread_buf_server *tbs);
; 305  :       /* The above two functions may be called only with the
; 306  :          `KD_THREADLOCK_GENERAL' mutex already locked by the caller.  They
; 307  :          are used only in multi-threading applications. */
; 308  :   private: // Definitions
; 309  :       struct kd_code_alloc {
; 310  :           kd_code_alloc *next;
; 311  :           kdu_byte block[1]; // Actual structure is allocated to be a much
; 312  :                              // larger memory block, from which aligned
; 313  :                              // virtual cache pages are extracted.
; 314  :         };
; 315  :   private: // Helper functions
; 316  :     void alloc_pages();
; 317  :       /* This function is called when there is insufficient remaining
; 318  :          storage on the free list. */
; 319  :   private: // Data
; 320  :     kd_code_alloc *alloc; // Linked list of allocated memory blocks
; 321  :     kd_code_buffer *free_head;
; 322  :     kdu_long total_pages;
; 323  :     kdu_long num_allocated_pages; // Number of fully allocated pages
; 324  :     kdu_long peak_allocated_pages;
; 325  :     kdu_long structure_bytes; // Bytes in tile/comp/subband/precinct structures
; 326  :     kdu_long peak_structure_bytes;
; 327  :     kdu_long cache_threshold_bytes;
; 328  :     int num_users; // Number of users currently sharing the object.
; 329  :     kd_thread_buf_server *attached_thread_buf_servers;
; 330  :   };
; 331  : 
; 332  : /*****************************************************************************/
; 333  : /*                           kd_thread_buf_server                            */
; 334  : /*****************************************************************************/
; 335  : 
; 336  : #define KD_THREAD_PEAK_STORE_FAC 4
; 337  : 
; 338  : class kd_thread_buf_server {
; 339  :   public: // Member functions
; 340  :     void init(kd_thread_env *env) { this->env=env; reset(); }
; 341  :     void set_codestream_buf_server(kd_buf_server *buf_server);
; 342  :       /* This function is used to nominate a particular codestream's
; 343  :          `kd_buf_server' object as the ultimate source of all future
; 344  :          buffers served by the present object.  If we are already
; 345  :          attached to a different codestream `buf_server', we must
; 346  :          first detach, releasing any buffers in our local store to
; 347  :          the codestream `buf_server' from which they came.  These
; 348  :          operations are all guarded by the KD_THREADLOCK_GENERAL mutex,
; 349  :          but the present function is always invoked from a context in
; 350  :          which the mutex is not locked.  If `buf_server' is NULL, the
; 351  :          function simply detaches us from any codestream `buf_server'
; 352  :          to which we might presently be attached. */
; 353  :     bool is_attached() { return (ultimate_buf_server != NULL); }
; 354  :       /* Returns true if the last call to `set_codestream_buf_server'
; 355  :          specified a non-NULL codestream `buf_server'. */
; 356  :     void detach_while_holding_general_lock()
; 357  :       { /* Called by `discard_all', so we don't have to unlock and then
; 358  :            relock the `KD_THREADLOCK_GENERAL' mutex. */
; 359  :         if (ultimate_buf_server != NULL)
; 360  :           ultimate_buf_server->detach_thread_buf_server(this);
; 361  :       }
; 362  :     kd_code_buffer *get()
; 363  :       { /* Behaves like `kd_buf_server::get', but allocates initially
; 364  :            from the thread's local buffer store, getting extra data from the
; 365  :            codestream specified in the most recent call to
; 366  :            `set_codestream_buf_server' where required.  This function must
; 367  :            not be called while holding any lock, since it may need to
; 368  :            temporarily instantiate a lock to get extra storage from the
; 369  :            underlying codestream. */
; 370  :         if (head == NULL) augment_local_store(false);
; 371  :         kd_code_buffer *result = head;
; 372  :         if ((head = result->next) == NULL)
; 373  :           tail = NULL;
; 374  :         result->next = NULL;
; 375  :         num_available_buffers--;
; 376  :         return result;
; 377  :       }
; 378  :     void adjust_peak_buffers();
; 379  :       /* This function is called from within `kd_thread_env::flush' to
; 380  :          adjust the value of `peak_buffers', which records the maximum
; 381  :          number of buffers we would like to make available locally
; 382  :          in this thread buffer server.  The calculation uses the fact that
; 383  :          `ref_available_buffers'-`num_available_buffers' equals the number
; 384  :          of buffers which have been obtained via `get', since the last call
; 385  :          to this function.  This quantity is multiplied by a factor
; 386  :          `KD_THREAD_PEAK_STORE_FAC' to obtain a reasonable value for
; 387  :          `peak_buffer', the value of which is adjusted only ever upwards. */
; 388  :     void augment_local_store(bool general_lock_held);
; 389  :       /* This function is used to allocate new buffers from the underlying
; 390  :          codestream, specified in the last call to `set_codestream'.
; 391  :          If `adjust_peak_buffers' has never been called, the
; 392  :          function allocates `KD_THREAD_PEAK_STORE_FAC' times the number of
; 393  :          buffers which have already been served via `get'.  Otherwise, it
; 394  :          allocates exactly `peak_buffers' new buffers.
; 395  :             If `general_lock_held' is false, the `KD_THREADLOCK_GENERAL'
; 396  :          lock is not currently held and must be acquired prior to actually
; 397  :          allocating any new buffers (and released again before returning,
; 398  :          of course).  The function is called in this way only when a call
; 399  :          to `get' finds that the local store of buffers has been
; 400  :          completely exhausted.
; 401  :             The function is called with `general_lock_held' equal to true
; 402  :          from within `kd_thread_env::flush' to take advantage of the fact
; 403  :          that the general lock is already held for other reasons -- i.e.,
; 404  :          to piggy-back the activity of refilling the local buffer store
; 405  :          onto other activities which required the lock. */
; 406  :   private: // Helper functions
; 407  :     friend class kd_buf_server;
; 408  :     void reset()
; 409  :       { // Called by `kd_buf_server::detach_thread_buf_server' after removing
; 410  :         // us from its attached thread buffer list.  This function is also
; 411  :         // used to do most of the work of our own constructor.
; 412  :         ultimate_buf_server = NULL;
; 413  :         next_attached = prev_attached = NULL;
; 414  :         ref_available_buffers = 0;
; 415  :         peak_buffers = 0;
; 416  :         num_available_buffers = 0;
; 417  :         head = tail = NULL;
; 418  :       }
; 419  :   private: // Data
; 420  :     kd_thread_env *env;
; 421  :     int peak_buffers; // See the `adjust_peak_buffers' function.
; 422  :     int num_available_buffers; // Number of buffers on the `head' list.
; 423  :     int ref_available_buffers; // Adjusted so that `ref_available_buffers' -
; 424  :          // `num_available_buffers' is always equal to the number of buffers
; 425  :          // allocated via `get' since the last call to `adjust_peak_buffers'.
; 426  :     kd_code_buffer *head;
; 427  :     kd_code_buffer *tail;
; 428  :     kd_buf_server *ultimate_buf_server; // All buffers are allocated from here
; 429  :     kd_thread_buf_server *next_attached; // Used to build a doubly linked list
; 430  :     kd_thread_buf_server *prev_attached; // of objects which are all attached
; 431  :                      // to the same `ultimate_buf_server'.
; 432  :   };
; 433  : 
; 434  : /*****************************************************************************/
; 435  : /*                             kd_compressed_output                          */
; 436  : /*****************************************************************************/
; 437  : 
; 438  : class kd_compressed_output : public kdu_output {
; 439  :   public: // Member functions
; 440  :     kd_compressed_output(kdu_compressed_target *target)
; 441  :       { this->target=target; flushed_bytes = 0; }
; 442  :     virtual ~kd_compressed_output()
; 443  :       { flush_buf(); }
; 444  :     kdu_compressed_target *access_tgt()
; 445  :       { /* You may call this function to access the underlying `target'
; 446  :            object, but you should never manipulate that object if you
; 447  :            have written anything to the present object, without re-accessing
; 448  :            it. */
; 449  :            flush_buf();  return target;
; 450  :       }
; 451  :     kdu_long get_bytes_written()
; 452  :       { return (flushed_bytes + (next_buf-buffer)); }
; 453  :     void flush()
; 454  :       { flush_buf(); }
; 455  :   protected: // Virtual functions which implement required services.
; 456  :     virtual void flush_buf()
; 457  :       {
; 458  :         if (next_buf > buffer)
; 459  :           target->write(buffer,(int)(next_buf-buffer));
; 460  :         flushed_bytes += next_buf - buffer;
; 461  :         next_buf = buffer;
; 462  :       }
; 463  :   private: // Data
; 464  :     kdu_compressed_target *target;
; 465  :     kdu_long flushed_bytes;
; 466  :   };
; 467  : 
; 468  : /*****************************************************************************/
; 469  : /*                                kd_input                                   */
; 470  : /*****************************************************************************/
; 471  : 
; 472  : #define KD_IBUF_SIZE 512
; 473  : #define KD_IBUF_PUTBACK 6 // Maximum number of bytes you can put back.
; 474  : 
; 475  : class kd_input {
; 476  :   /* This abstract base class must be derived to construct meaningful
; 477  :      input devices.  Currently, we have two derived classes in mind: one
; 478  :      for reading from the code-stream and one for recovering packet
; 479  :      headers from PPM or PPT markers.  Since there may be many low level
; 480  :      byte-oriented transactions, we emphasize efficiency for such
; 481  :      transactions. */
; 482  :   public: // Member functions
; 483  :     kd_input()
; 484  :       { first_unread = first_unwritten = buffer+KD_IBUF_PUTBACK;
; 485  :         exhausted = fully_buffered = throw_markers = false; }
; 486  :     virtual ~kd_input() { return; }
; 487  :     bool is_fully_buffered() { return fully_buffered; }
; 488  :     void enable_marker_throwing(bool reject_all=false)
; 489  :       { /* If `reject_all' is false, subsequent reads will throw an exception
; 490  :            if a bona fide SOP or SOT marker is found. In this case, the
; 491  :            function will check to make sure that the length field is correct,
; 492  :            putting the length field and marker code bytes back to the source
; 493  :            before throwing the exception, so that the catch statement can read
; 494  :            them again.
; 495  :               If `reject_all' is true, subsequent reads will throw an
; 496  :            exception if any marker code in the range FF90 to FFFF is found.
; 497  :            Again, the marker code itself is put back onto the stream before
; 498  :            throwing the exception.
; 499  :               Marker throwing is disabled before throwing an exception for
; 500  :            either of the above reasons.
; 501  :               Note that code-stream reading may be slowed down
; 502  :            when this marker throwing is enabled.  For this reason, the
; 503  :            capability is best used only when error resilience or error
; 504  :            detection capabilities are required. */
; 505  :         this->reject_all = reject_all; throw_markers = true; have_FF = false;
; 506  :       }
; 507  :     bool disable_marker_throwing()
; 508  :       { /* Disable marker exception throwing.  Returns true unless the
; 509  :            last byte which was read was an FF, in which case the function
; 510  :            returns false.  This allows the caller to catch markers which
; 511  :            were partially read.  Any code-stream segment which is not
; 512  :            permitted to contain a marker code in the range FF90 through FFFF
; 513  :            is also not permitted to terminate with an FF. */
; 514  :         if (!throw_markers) return true;
; 515  :         throw_markers = false; // Must not touch `reject_all' here.
; 516  :         if (exhausted) have_FF = false;
; 517  :         return !have_FF;
; 518  :       }
; 519  :     void terminate_prematurely()
; 520  :       { /* This function may be called in non-resilient mode if an EOC marker
; 521  :            is encountered before the stream physically ends. */
; 522  :         exhausted = true;
; 523  :       }
; 524  :     bool failed()
; 525  :       { /* Returns true if any of the input functions, `get', `read' or
; 526  :            `ignore' failed to completely fulfill its objective due to
; 527  :            exhaustion of the relevant source. */
; 528  :         return exhausted;
; 529  :       }
; 530  :     bool get(kdu_byte &byte) // throws (kdu_uint16 code): unexpected marker
; 531  :       { /* Access a single byte, returning false if and only if the source is
; 532  :            exhausted, in which case future calls to `failed' return true. */
; 533  :         if (exhausted || ((first_unread==first_unwritten) && !load_buf()))
; 534  :           return false; // If `load_buf' fails it sets `exhausted' for us.
; 535  :         byte = *(first_unread++);
; 536  :         if (throw_markers)
; 537  :           {
; 538  :             if (have_FF && (byte > 0x8F))
; 539  :               process_unexpected_marker(byte);
; 540  :             have_FF = (byte==0xFF);
; 541  :           }
; 542  :         return true;
; 543  :       }
; 544  :     void putback(kdu_byte byte)
; 545  :       { /* You may put back more than 1 byte, but you may not call this
; 546  :            function if a previous read has ever failed.  It is also illegal
; 547  :            to call this function while marker throwing is enabled. */
; 548  :         assert(!exhausted);
; 549  :         assert(!throw_markers);
; 550  :         first_unread--;
; 551  :         if (!fully_buffered)
; 552  :           {
; 553  :             assert(first_unread >= buffer);
; 554  :             *first_unread = byte;
; 555  :           }
; 556  :       }
; 557  :     void putback(kdu_uint16 code)
; 558  :       { /* This function is designed to improve the readability of code
; 559  :            which puts marker codes back to the input object from which they
; 560  :            were read. */
; 561  :         assert(!exhausted);
; 562  :         assert(!throw_markers);
; 563  :         first_unread-=2;
; 564  :         if (!fully_buffered)
; 565  :           {
; 566  :             assert(first_unread >= buffer);
; 567  :             first_unread[0] = (kdu_byte)(code>>8);
; 568  :             first_unread[1] = (kdu_byte) code;
; 569  :           }
; 570  :       }
; 571  :     int pseudo_read(kdu_byte * &addr, int count)
; 572  :       { /* This function should be called only for `fully_buffered' sources.
; 573  :            It behaves like `read', except that it does not actually read
; 574  :            any bytes.  Instead, it puts the address of the block of data
; 575  :            that would have been read into the variable referenced by the
; 576  :            `addr' argument. */
; 577  :         assert(fully_buffered);
; 578  :         addr = first_unread;
; 579  :         if (throw_markers)
; 580  :           return read(addr,count); // Slower path, looks for markers
; 581  :         first_unread += count;
; 582  :         if (first_unread > first_unwritten)
; 583  :           {
; 584  :             count -= (int)(first_unread - first_unwritten);
; 585  :             first_unread = first_unwritten; exhausted = true;
; 586  :           }
; 587  :         return count;
; 588  :       }
; 589  :     int read(kdu_byte *buf, int count);
; 590  :       /* More efficient than `get' when the number of bytes to be read is
; 591  :          more than 2 or 3.  Returns the number of bytes actually read.  If
; 592  :          less than `count', future calls to `failed' will return true.  Note
; 593  :          that this function is less efficient if marker throwing is enabled. */
; 594  :     int read(kd_code_buffer * &cbuf, kdu_byte &buf_pos,
; 595  :              kd_buf_server *buf_server, int length);
; 596  :       /* Same as the above function, except that the requested bytes are
; 597  :          written to a linked list of `kd_code_buffer' buffers, headed by
; 598  :          `cbuf', where the `buf_pos' indicates the next free byte in the
; 599  :          `cbuf' buffer.  The function automatically grows the linked list
; 600  :          of buffers, as required, using `buf_server->get()'.  Upon return,
; 601  :          the `cbuf' and `buf_pos' variables are advanced to refer to the
; 602  :          most recently written `kd_code_buffer' object and the already
; 603  :          written prefix of that object, respectively.  The function
; 604  :          returns the actual number of bytes transferred in this way, which
; 605  :          is equal to `length' unless the ultimate source of data ran dry. */
; 606  :     virtual kdu_long ignore(kdu_long count);
; 607  :       /* Skips over the indicated number of bytes, returning the number of
; 608  :          bytes actually skipped.  If less than `count', future calls to
; 609  :          `failed' will return true.  The function may be overridden by
; 610  :          derived classes which support seeking. */
; 611  :   protected: // Data and functions used for buffer management.
; 612  :     virtual bool load_buf() = 0;
; 613  :       /* Returns false and sets `exhausted' to true if the source is unable
; 614  :          to provide any more data.  Otherwise, augments the internal buffer
; 615  :          and returns true.  Buffer manipulation must conform to the following
; 616  :          conventions.  The `first_unread' pointer should be set to
; 617  :          `buffer'+KD_IBUF_PUTBACK and then bytes should be loaded into the
; 618  :          remaining KD_IBUF_SIZE bytes of the `buffer' array. The
; 619  :          `first_unwritten' pointer should then be set to point just beyond
; 620  :          the last byte actually written into the buffer.  The only exception
; 621  :          to the above conventions is for fully buffered sources, in which
; 622  :          the entire data source lies in a contiguous external memory buffer.
; 623  :          In this case, the internal `buffer' is not used; the first call to
; 624  :          `load_buf' sets `first_unread' to point to the start of the external
; 625  :          memory buffer and `first_unwritten' to point just beyond the external
; 626  :          memory buffer.  In this case, the `fully_buffered' flag should be
; 627  :          set to true, which signals to the `putback' functions that it is
; 628  :          sufficient for them to adjust the `first_unread' pointer, without
; 629  :          actually writing anything. */
; 630  :     kdu_byte buffer[KD_IBUF_SIZE+KD_IBUF_PUTBACK];
; 631  :     kdu_byte *first_unread; // Points to next byte to retrieve from buffer.
; 632  :     kdu_byte *first_unwritten; // Points beyond last available byte in buffer
; 633  :     bool fully_buffered;
; 634  :     bool exhausted;
; 635  :     bool throw_markers; // If true, must look for unexpected markers.
; 636  :   private: // Functions
; 637  :     void process_unexpected_marker(kdu_byte last_byte);
; 638  :       /* This function is called when marker throwing is enabled and a
; 639  :          marker code in the range FF90 through FFFF has been found.  The
; 640  :          least significant byte of the marker code is supplied as the
; 641  :          `last_byte' argument.  The function determines whether to throw
; 642  :          the exception or not.  If not, reading continues unaffected. */
; 643  :   private: // Data
; 644  :     bool have_FF; // Valid only with `throw_markers'. Means last byte was FF.
; 645  :     bool reject_all; // If `false' marker throwing is only for SOP's and SOT's
; 646  :   };
; 647  :   
; 648  : /*****************************************************************************/
; 649  : /*                             kd_compressed_input                           */
; 650  : /*****************************************************************************/
; 651  : 
; 652  : class kd_compressed_input : public kd_input {
; 653  :   public: // Member functions
; 654  :     kd_compressed_input(kdu_compressed_source *source);
; 655  :     int get_capabilities()
; 656  :       { return source->get_capabilities(); }
; 657  :     bool set_tileheader_scope(int tnum, int num_tiles);
; 658  :       /* Generates an error through `kdu_error' if the embedded source does
; 659  :          not support the `KDU_SOURCE_CAP_CACHED' capability.  This function
; 660  :          simply calls the source's own `set_tileheader_scope' function and
; 661  :          clears the internal state variables (especially, the `exhausted'
; 662  :          member) so that subsequent reads will recover bytes from the indicated
; 663  :          tile's header.  For more information, refer to the comments appearing
; 664  :          with `kdu_compressed_source::set_tileheader_scope'. */
; 665  :     kdu_long get_offset()
; 666  :       { /* Returns the address of the next byte which will be returned by the
; 667  :            base object's `get' function.  If seeking is enabled, the source
; 668  :            may be repositioned to this point by supplying this address as the
; 669  :            `unique_address' argument to `seek'.  Even if seeking is not
; 670  :            enabled, `get_offset' will return the correct address and this may
; 671  :            be used to determine appropriate arguments for the `ignore' member
; 672  :            function declared below.  May not be called if the source is in
; 673  :            anything other than code-stream scope. */
; 674  :         assert(!special_scope);
; 675  :         return cur_offset + last_loaded_bytes - (first_unwritten-first_unread);
; 676  :       }
; 677  :     void seek(kdu_long unique_address);
; 678  :       /* If `unique_address' is non-negative, it is treated as a code-stream
; 679  :          offset and the function seeks to a point `unique_address' bytes past
; 680  :          the beginning of the code-stream (SOC marker), using the embedded
; 681  :          `kdu_compressed_source' object's `seek' function.  In this case,
; 682  :          a terminal error is generated if the source does not
; 683  :          offer the KDU_SOURCE_CAP_SEEKABLE capability.
; 684  :             If `unique_address' is negative, the function treats
; 685  :          -(1+`unique_address') as the unique identifier associated with a
; 686  :          cached precinct, supplying this identifier to the embedded
; 687  :          `kdu_compressed_source' object's `set_precinct_scope' function.  In
; 688  :          this case, a terminal error is generated if the source does not
; 689  :          offer the KDU_SOURCE_CAP_CACHEABLE capability.
; 690  :             In either case, the function may clear or set the "exhausted"
; 691  :          state, so that the base object's `failed' member function may return
; 692  :          false, having previously returned true, or vice-versa. */
; 693  :     kdu_long ignore(kdu_long count); // Overrides `kd_input::ignore'.
; 694  :     void set_max_bytes(kdu_long limit);
; 695  :       /* No effect except when reading in code-stream scope. */
; 696  :     kdu_long get_bytes_read();
; 697  :       /* Returns the smallest initial prefix of the source stream which
; 698  :          contains all of the bytes consumed from `kd_input'.  Note that more
; 699  :          bytes may have been read from the compressed data source and
; 700  :          buffered internally, without having been actually used.
; 701  :             For cached sources (those advertising the KDU_SOURCE_CAP_CACHED
; 702  :          capability), the function's return value will be 0, unless we
; 703  :          are still reading the main header. */
; 704  :     kdu_long get_suspended_bytes();
; 705  :       /* Returns the total number of bytes which have been read in the
; 706  :          suspended state.  The returned value may be subtracted from
; 707  :          the value returned by `get_bytes_read' to determine the total
; 708  :          number of bytes which have been read in a non-suspended state.
; 709  :          Byte limits apply only to non-suspended reads. */
; 710  :     void set_suspend(bool state)
; 711  :       {
; 712  :         if (special_scope) return;
; 713  :         if ((suspend_ptr == NULL) && state)
; 714  :           { // Enter suspended mode
; 715  :             suspend_ptr = first_unread;
; 716  :             if (alt_first_unwritten != NULL)
; 717  :               {
; 718  :                 assert(alt_first_unwritten > first_unwritten);
; 719  :                 last_loaded_bytes += alt_first_unwritten - first_unwritten;
; 720  :                 first_unwritten = alt_first_unwritten;
; 721  :                 alt_first_unwritten = NULL;
; 722  :               }
; 723  :           }
; 724  :         else if ((suspend_ptr != NULL) && !state)
; 725  :           { // Leave suspended mode
; 726  :             suspended_bytes += first_unread-suspend_ptr;  suspend_ptr = NULL;
; 727  :             kdu_long limit = suspended_bytes + max_bytes_allowed - cur_offset;
; 728  :             if (limit < last_loaded_bytes)
; 729  :               { // We have already loaded the buffer with too many bytes
; 730  :                 alt_first_unwritten = first_unwritten;
; 731  :                 first_unwritten -= (last_loaded_bytes - limit);
; 732  :                 last_loaded_bytes = limit;
; 733  :                 if (first_unwritten < first_unread)
; 734  :                   { // We have already read past the end.
; 735  :                     exhausted = true;
; 736  :                     suspended_bytes -= (first_unread-first_unwritten);
; 737  :                     first_unwritten = first_unread;
; 738  :                     alt_first_unwritten = NULL;
; 739  :                   }
; 740  :               }
; 741  :           }
; 742  :       }
; 743  :   protected: // Virtual functions which implement required services.
; 744  :     virtual bool load_buf();
; 745  :   private: // Data
; 746  :     kdu_compressed_source *source;
; 747  :     kdu_long cur_offset; // Offset from start of code-stream
; 748  :     kdu_long max_bytes_allowed; // Source may have fewer bytes than this
; 749  :     kdu_long max_address_read; // Address of last byte read from base object.
; 750  :     kdu_long suspended_bytes; // Bytes read while in suspended mode.
; 751  :     kdu_long last_loaded_bytes; // Num bytes added by last call to `load_buf'
; 752  :     kdu_byte *suspend_ptr; // Points into the buffer
; 753  :     kdu_byte *alt_first_unwritten; // See below
; 754  :     bool special_scope; // True for anything other than code-stream scope.
; 755  :   };
; 756  :   /* Notes:
; 757  :         The `cur_offset' member holds the offset from the start of the
; 758  :      code-stream to the first nominal byte in the input buffer; i.e., the
; 759  :      byte at kd_input::buffer + KD_IBUF_PUTBACK.  The actual number of bytes
; 760  :      which have been read from `source' is larger by the amount
; 761  :      `kd_input::first_unwritten' - (`kd_input::buffer'+KD_IBUF_PUTBACK).
; 762  :         The object may be placed in a suspended mode while reading data
; 763  :      which belongs to code-stream packets which lie outside the current
; 764  :      resolution, components or layers of interest.  This allows the
; 765  :      application to set a byte limit which applies only to the relevant
; 766  :      data which would be left if the irrelevant data were first parsed
; 767  :      out of the code-stream.  The object is in suspended mode if and only
; 768  :      if `suspend_ptr' is non-NULL.  In this case, `suspend_ptr' holds the
; 769  :      value of `kd_input::first_unread' immediately prior to the point at
; 770  :      which the object entered the suspended mode.  The total number of
; 771  :      bytes consumed while in the suspended mode is maintained by the
; 772  :      `suspended_bytes' member, but use the function, `get_suspended_bytes'
; 773  :      to evaluate a reliable count of the number of suspended bytes, which
; 774  :      takes into account activity within the `kd_input' object of which
; 775  :      the derived object might not be aware.
; 776  :         The `alt_first_unwritten' member is used to keep track of bytes in
; 777  :      the buffer which may be inaccessible while in the regular (non-suspended)
; 778  :      mode, which may need to be made accessible while the object is in the
; 779  :      suspended mode.  This member holds NULL until exiting the suspended mode
; 780  :      requires `first_unwritten' to be truncated to account for a byte limit.
; 781  :      At that point, it is set to the value of the `first_unwritten' member
; 782  :      prior to truncation.  When the object enters the suspended mode, any
; 783  :      non-NULL `alt_first_unwritten' value is copied to `first_unwritten'. */
; 784  : 
; 785  : /*****************************************************************************/
; 786  : /*                               kd_pph_input                                */
; 787  : /*****************************************************************************/
; 788  : 
; 789  : class kd_pph_input : public kd_input {
; 790  :   /* Alternate input for packet header bytes, which is used in conjunction
; 791  :      with the PPM and PPT marker segments. */
; 792  :   public: // Member functions
; 793  :     kd_pph_input(kd_buf_server *server)
; 794  :       { buf_server = server; first_buf = read_buf = write_buf = NULL; }
; 795  :     virtual ~kd_pph_input();
; 796  :     void add_bytes(kdu_byte *data, int num_bytes);
; 797  :       /* This function is called when unpacking a PPM or PPT marker, to
; 798  :          augment the current object. */
; 799  :   protected: // Virtual functions which implement required services.
; 800  :     virtual bool load_buf();
; 801  :   private: // Data
; 802  :     kd_code_buffer *first_buf;
; 803  :     kd_code_buffer *read_buf, *write_buf;
; 804  :     int read_pos, write_pos;
; 805  :     kd_buf_server *buf_server;
; 806  :   };
; 807  :   /* Notes:
; 808  :         `first_buf' points to the first in a linked list of buffers used to
; 809  :      temporarily store PPM or PPT marker segment bytes.
; 810  :         `read_buf' points to the element in the linked list of code buffers
; 811  :      which is currently being read; `read_pos' points to the next element of
; 812  :      the current buffer which will be read. This may be equal to
; 813  :      KD_CODE_BUFFER_LEN, in which case the next element in the code buffer
; 814  :      list must be accessed when the next read attempt occurs.
; 815  :         `write_buf' points to the last element in the linked list of code
; 816  :      buffers and `write_pos' identifies the first unwritten byte in this
; 817  :      element.  `write_pos' may equal KD_CODE_BUFFER_LEN, in which case a
; 818  :      new element will need to be added before further data can be written.
; 819  :         `buf_server' points to the object which is used to add and release
; 820  :      code buffer elements.  This is a shared resource. */
; 821  : 
; 822  : /*****************************************************************************/
; 823  : /*                                kd_marker                                  */
; 824  : /*****************************************************************************/
; 825  : 
; 826  : class kd_marker {
; 827  :   /* Objects of this class are used to read and store code-stream marker
; 828  :      segments. The most efficient way to use the class is to construct a
; 829  :      single serving object which is used to read the markers one by one and
; 830  :      then copy any markers which need to be preserved into new instances of
; 831  :      the class, using the copy constructor.  This concentrates wasted buffer
; 832  :      space in the one server marker which actually reads from the input
; 833  :      code-stream. */
; 834  :   public: // Member functions
; 835  :     kd_marker(kd_input *input, kd_codestream *cs)
; 836  :       { this->source = input; this->codestream = cs;
; 837  :         code = 0; length = 0; max_length = 0; buf = NULL;
; 838  :         encountered_skip_code = false; }
; 839  :     kd_marker(const kd_marker &orig);
; 840  :       /* Copies any marker segment stored in `orig'. Note that the `source'
; 841  :          pointer is not copied, meaning that the `read' member function may
; 842  :          not be invoked on the copy. */
; 843  :     ~kd_marker() { if (buf != NULL) delete[] buf; }
; 844  :     kd_marker *move(kd_input *input, kd_codestream *cs)
; 845  :       { this->source = input; this->codestream = cs; return this; }
; 846  :         /* This function is used when a `kd_marker' object must be moved
; 847  :          to a different codestream, or to work with a different source of
; 848  :          data. */
; 849  :     void print_current_code(kdu_message &out)
; 850  :       { /* Prints a text string identifying the current marker code. */
; 851  :         print_marker_code(this->code,out);
; 852  :       }
; 853  :     bool read(bool exclude_stuff_bytes=false, bool skip_to_marker=false);
; 854  :       /* Reads a new marker (or marker segment) from the `kd_input' object
; 855  :          supplied during construction.
; 856  :              Returns true if successful.  Causes of failure may be: 1) the
; 857  :          code-stream source is exhausted; 2) a valid marker code was not found;
; 858  :          or 3) an SOP or SOT marker code was found, but followed by an invalid
; 859  :          length field.  This third cause of failure is important since it
; 860  :          prevents the function from attempting to consume an invalid SOP or
; 861  :          SOT marker segment, in the process of which it might consume any
; 862  :          number of useful packets, having their own SOP markers.
; 863  :               A valid marker code must commence with an FF.  If
; 864  :          `exclude_stuff_bytes' is true then the second byte of a valid marker
; 865  :          code must be strictly greater than 0x8F.  Otherwise, the second byte
; 866  :          is arbitrary.  If `skip_to_marker' is true, the function consumes
; 867  :          bytes indefinitely, until the source is exhausted or a valid marker
; 868  :          code is found.  In this case, the function returns false only if the
; 869  :          source is exhausted. Otherwise, the function expects to find a valid
; 870  :          marker code immediately.
; 871  :              As a convenience feature, the function automatically skips over
; 872  :          any EOC marker it encounters.  This has two advantages: 1) we can
; 873  :          detect the end of the code-stream without having to explicitly check
; 874  :          for an EOC marker; 2) we should not be overly troubled by EOC
; 875  :          markers which arise due to corruption of the code-stream (this has
; 876  :          quite a high likelihood of occurring if the code-stream is subject
; 877  :          to corruption).
; 878  :              In the event that the source is not exhausted but a valid
; 879  :          marker code is not found, the function puts back any bytes it consumed
; 880  :          before returning false.  This allows the caller to continue reading
; 881  :          from the point where the function was first called. */
; 882  :     kdu_uint16 get_code() { return code; }
; 883  :       /* Returns 0 if no actual marker is available yet. */
; 884  :     int get_length() { return length; }
; 885  :       /* Returns length of marker segment (not including the length specifier).
; 886  :          Returns 0 if no actual marker available, or if the marker is a
; 887  :          delimiter (no segment). */
; 888  :     kdu_byte *get_bytes() { return buf; }
; 889  :       /* Returns pointer to marker segment bytes immediately following the
; 890  :          length specifier. */
; 891  :     void clear() { code = 0; length = 0; encountered_skip_code = false; }
; 892  :       /* Erase internal state so that not marker is advertised.  This is
; 893  :          useful if the marker has already been inspected and found to be
; 894  :          not useful. */
; 895  :   private: // Data
; 896  :     kd_input *source; // If NULL, `read' may not be used.
; 897  :     kd_codestream *codestream;
; 898  :     kdu_uint16 code;
; 899  :     int length;
; 900  :     int max_length; // Number of bytes which the buffer can store.
; 901  :     kdu_byte *buf;
; 902  :     bool encountered_skip_code;
; 903  :   };
; 904  : 
; 905  : /*****************************************************************************/
; 906  : /*                                 kd_pp_markers                             */
; 907  : /*****************************************************************************/
; 908  : 
; 909  : class kd_pp_markers {
; 910  :   public: // Member functions
; 911  :     kd_pp_markers()
; 912  :       { list = NULL; }
; 913  :     ~kd_pp_markers();
; 914  :     void add_marker(kd_marker &copy_source); 
; 915  :       /* Copies the `kd_marker' object into a new `kd_pp_marker_list'
; 916  :          element, inserting it into the evolving list on the basis of its
; 917  :          Zppm or Zppt index.  Markers need not be added in order. */
; 918  :     void transfer_tpart(kd_pph_input *pph_input);
; 919  :       /* Transfers an entire tile-part of packed packet header data from
; 920  :          the internal marker list to the `pph_input' object, which may
; 921  :          then be used as a source object for packet header reading.  If the
; 922  :          object is managing a list of PPM markers, the function expects to
; 923  :          find the total number of bytes associated with the next tile-part
; 924  :          embedded in the current marker segment.  Otherwise, all marker
; 925  :          segments are dumped into the `pph_input' object.  Marker segments
; 926  :          whose data have been consumed are deleted automatically. */
; 927  :     void ignore_tpart();
; 928  :       /* Same as `transfer_tpart' except that the data are simply discarded.
; 929  :          This is useful when discarding a tile for which PPM marker information
; 930  :          has been provided. */
; 931  :   private: // Definitions
; 932  : 
; 933  :       class kd_pp_marker_list : public kd_marker {
; 934  :         public: // Member functions
; 935  :           kd_pp_marker_list(kd_marker &copy_source) : kd_marker(copy_source)
; 936  :             { next = NULL; }
; 937  :         public: // Data
; 938  :           kd_pp_marker_list *next;
; 939  :           int znum;
; 940  :           int bytes_read;
; 941  :         };
; 942  : 
; 943  :   private: // Convenience functions
; 944  :     void advance_list();
; 945  :   private: // Data
; 946  :     bool is_ppm; // Otherwise, list contains PPT markers.
; 947  :     kd_pp_marker_list *list;
; 948  :   };
; 949  : 
; 950  : /*****************************************************************************/
; 951  : /*                            kd_tpart_pointer                               */
; 952  : /*****************************************************************************/
; 953  : 
; 954  : struct kd_tpart_pointer {
; 955  :     kdu_long address; // Offset relative to the start of the code-stream.
; 956  :     kd_tpart_pointer *next; // For building linked lists.
; 957  :   };
; 958  : 
; 959  : /*****************************************************************************/
; 960  : /*                               kd_tile_ref                                 */
; 961  : /*****************************************************************************/
; 962  : 
; 963  : struct kd_tile_ref {
; 964  :     kd_tpart_pointer *tpart_head;
; 965  :     kd_tpart_pointer *tpart_tail;
; 966  :     kd_tile *tile;
; 967  :   };
; 968  :   /* Notes:
; 969  :        This structure is used to build an array of references to each tile
; 970  :        in the code-stream.  The array is allocated when the codestream is
; 971  :        constructed, but the actual `kd_tile' objects are only instantiated
; 972  :        when needed and destroyed as soon as possible.
; 973  :           The `tpart_head' and `tpart_tail' members manage a list of
; 974  :        addresses to tile-parts of the tile.  The list may be constructed
; 975  :        by reading TLM marker segments in the main code-stream header, or it
; 976  :        may be constructed dynamically as tile-parts are encountered within
; 977  :        the code-stream, enabling them to be re-opened at a later point if
; 978  :        the compressed data-source supports seeking.  The list should be
; 979  :        empty if the source does not support seeking.
; 980  :           Once we are sure that all tile-part addresses have been found
; 981  :        for the tile, the `tpart_tail' member is set to NULL.
; 982  :           Once a tile has been opened and destroyed in non-persistent mode,
; 983  :        the `tile' pointer value is set to KD_EXPIRED_TILE, marking it
; 984  :        as unusable. */
; 985  : 
; 986  : /*****************************************************************************/
; 987  : /*                              kd_tlm_generator                             */
; 988  : /*****************************************************************************/
; 989  : 
; 990  : class kd_tlm_generator {
; 991  :   public: // Member functions
; 992  :     kd_tlm_generator()
; 993  :       {
; 994  :         num_tiles = max_tparts = num_elts = 0; elts = NULL;
; 995  :         tile_data_bytes=0;
; 996  :       }
; 997  :     ~kd_tlm_generator() { if (elts != NULL) delete[] elts; }
; 998  :     bool init(int num_tiles, int max_tparts);
; 999  :       /* Call this function after construction or `clear' in order to
; 1000 :          initialize the object in preparation for generating TLM marker
; 1001 :          segments.  If the number of tiles or tile-parts identified here
; 1002 :          cannot be accommodated by a legal set of TLM marker segments, the
; 1003 :          function returns false and `exists' will continue to return false.
; 1004 :          Otherwise, the object is initialized and subsequent calls to
; 1005 :          `exists' will return true.  Note that the number of tiles given
; 1006 :          here is the total number in the entire code-stream.  This might
; 1007 :          be more than the number of tiles being compressed in the
; 1008 :          current fragment, in which case the `elts' array will not be
; 1009 :          full by the time `write_tlms' is called. */
; 1010 :     bool exists() { return (num_tiles > 0); }
; 1011 :     bool operator!() { return (num_tiles == 0); }
; 1012 :     void clear()
; 1013 :       {
; 1014 :         num_tiles = max_tparts = num_elts = 0;
; 1015 :         tile_data_bytes = 0;
; 1016 :         if (elts != NULL)
; 1017 :           { delete[] elts; elts = NULL; }
; 1018 :       }
; 1019 :     int get_max_tparts() { return max_tparts; }
; 1020 :       /* Returns the parameter recorded with the `ORGgen_tlm' parameter
; 1021 :          attribute, which triggered the creation of this object.  The
; 1022 :          value returned here is guaranteed to lie in the range 1 to 255. */
; 1023 :     int get_tlm_bytes() { return tlm_bytes; }
; 1024 :       /* Returns the total number of bytes occupied by TLM marker segments.
; 1025 :          This value is computed immediately by the object's constructor; it
; 1026 :          does not depend on the actual tile-part length values added later
; 1027 :          via `add_tpart_length'. */
; 1028 :     void write_dummy_tlms(kd_compressed_output *out);
; 1029 :       /* Writes a properly sized set of TLM marker segments to the `out'
; 1030 :          object, except that all tile-part lengths are set equal to 0.  It
; 1031 :          is most important that the TLM marker segments appear at the very
; 1032 :          end of the main codestream header, since a pointer to the start
; 1033 :          of the TLM data will later be generated on the basis of the
; 1034 :          amount of tile-data which has been written, plus the size of the
; 1035 :          TLM data. */
; 1036 :     void add_tpart_length(int tnum, kdu_long length);
; 1037 :       /* Call this function as the tile-part length information becomes
; 1038 :          available while generating the code-stream.  The actual marker
; 1039 :          TLM marker segments can be written only once all tile-part lengths
; 1040 :          have been added. */
; 1041 :     void write_tlms(kdu_compressed_target *tgt,
; 1042 :                     int prev_tiles_written, kdu_long prev_tile_bytes_written);
; 1043 :       /* This function writes the final TLM marker segments.  The `tgt'
; 1044 :          object's `start_rewrite' and `end_rewrite' functions are used to
; 1045 :          reposition the output stream over the previously written dummy
; 1046 :          TLM marker segments and rewrite them with valid tile-part length
; 1047 :          values.  The `prev_tiles_written' and `prev_tile_bytes_written'
; 1048 :          arguments are identical to the values originally supplied to
; 1049 :          `kdu_codestream::create'.  They are used to determine the
; 1050 :          location of the TLM marker information which must be written,
; 1051 :          since some of it may have previously been written when compressing
; 1052 :          different codestream fragments. */
; 1053 :   private: // Structures
; 1054 :       struct kd_tlm_elt {
; 1055 :           kdu_uint16 tnum;
; 1056 :           kdu_uint32 length;
; 1057 :         };
; 1058 :   private: // Data
; 1059 :     int num_tiles;
; 1060 :     int max_tparts;
; 1061 :     int tlm_bytes; // Total number of bytes occupied by TLM marker segments
; 1062 :     int num_elts; // num_tiles * max_tparts
; 1063 :     int elt_ctr; // Pointer to next unfilled entry in `elts'
; 1064 :     kdu_long tile_data_bytes; // sum of all the tile-part lengths added so far
; 1065 :     kd_tlm_elt *elts; // One element for each tile-part, in sequence.
; 1066 :   };
; 1067 : 
; 1068 : /*****************************************************************************/
; 1069 : /*                         kd_tpart_pointer_server                           */
; 1070 : /*****************************************************************************/
; 1071 : 
; 1072 : class kd_tpart_pointer_server {
; 1073 :   public: // Member functions
; 1074 :     kd_tpart_pointer_server()
; 1075 :       {
; 1076 :         groups = NULL; free_list = NULL; tlm_markers = NULL;
; 1077 :         translated_tlm_markers = false;
; 1078 :       }
; 1079 :     ~kd_tpart_pointer_server();
; 1080 :     bool using_tlm_info() { return translated_tlm_markers; }
; 1081 :       /* Returns true if TLM data was used to construct tile-part
; 1082 :          address lists in the most recent call to `translate_markers'. */
; 1083 :     void add_tlm_marker(kd_marker &marker);
; 1084 :       /* Call this function whenever a TLM marker segment is encountered,
; 1085 :          while parsing the main header. */
; 1086 :     void translate_markers(kdu_long first_sot_address,
; 1087 :                            int num_tiles, kd_tile_ref *tile_refs);
; 1088 :       /* Call this function when the main header has been completely read,
; 1089 :          passing in the seek position associated with the first byte of
; 1090 :          the first SOT marker in the code-stream.  This is the location of
; 1091 :          the SOT marker, relative to the start of the code-stream.  It is
; 1092 :          used to convert tile-part lengths into absolute addresses for
; 1093 :          each tile-part.  If no TLM marker segments have been read, the
; 1094 :          function does nothing.  Otherwise, it fills in the tile-part
; 1095 :          address list in each of the `num_tiles' entries of the
; 1096 :          `tile_refs' array.  If the available TLM information is
; 1097 :          insufficient to fully initialize the addresses of all tile-parts
; 1098 :          of each tile, the function issues a warning (since is is strictly
; 1099 :          illegal to have only partial TLM information). */
; 1100 :     void add_tpart(kd_tile_ref *tile_ref, kdu_long sot_address);
; 1101 :       /* Call this function when a new tile-part is encountered in a
; 1102 :          persistent seekable compressed data source, where the tile-part
; 1103 :          address was not already in the list of known tile-part addresses
; 1104 :          for the tile.  This allows the tile to be loaded or reloaded at
; 1105 :          a later time without reparsing the entire code-stream. */
; 1106 :   private: // Definitions
; 1107 : 
; 1108 : #     define KD_POINTER_GROUP_SIZE 32
; 1109 :       struct kd_pointer_group {
; 1110 :           kd_tpart_pointer elements[KD_POINTER_GROUP_SIZE];
; 1111 :           kd_pointer_group *next;
; 1112 :         };
; 1113 :         /* The purpose of this structure is to avoid an unnecessarily large
; 1114 :            number of calls to `new' and `delete'. */
; 1115 : 
; 1116 :       class kd_tlm_marker_list : public kd_marker {
; 1117 :         public: // Member functions
; 1118 :           kd_tlm_marker_list(kd_marker &copy_source) : kd_marker(copy_source)
; 1119 :             { next = NULL; }
; 1120 :         public: // Data
; 1121 :           kd_tlm_marker_list *next;
; 1122 :           int znum; // TLM sequence number used for concatenating info.
; 1123 :         };
; 1124 :         /* Objects of this class are used to store TLM marker segments in
; 1125 :            a list, so that they can be correctly ordered and their contents
; 1126 :            extracted. */
; 1127 : 
; 1128 :   private: // Data
; 1129 :     kd_tlm_marker_list *tlm_markers; // List of TLM marker segments.
; 1130 :     kd_pointer_group *groups; // List of pointer record groups allocated.
; 1131 :     kd_tpart_pointer *free_list; // List of empty pointer records not yet used
; 1132 :     bool translated_tlm_markers;
; 1133 :   };
; 1134 :   /* Notes:
; 1135 :        This object serves two roles: 1) it collects, resequences and
; 1136 :        translates TLM marker segments from the code-stream's main header;
; 1137 :        and 2) it manages the allocation of tile-part address lists, so as
; 1138 :        to avoid excessive memory fragmentation.  The storage for these
; 1139 :        lists is deallocated only when the present object is destroyed. */
; 1140 : 
; 1141 : /*****************************************************************************/
; 1142 : /*                          kd_precinct_pointer_server                       */
; 1143 : /*****************************************************************************/
; 1144 : 
; 1145 : class kd_precinct_pointer_server {
; 1146 :   public: // Member functions
; 1147 :     kd_precinct_pointer_server()
; 1148 :       { buf_server = NULL; }
; 1149 :     ~kd_precinct_pointer_server()
; 1150 :       { disable(); }

	mov	DWORD PTR __$EHRec$[ebp+8], 5

; 1151 :     void restart()
; 1152 :       { disable(); } // Called if the code-stream is restarted.
; 1153 :     bool is_active()
; 1154 :       { return (buf_server != NULL); }
; 1155 :     void initialize(kd_buf_server *buf_server)
; 1156 :       /* Call this function when constructing the tile to which the
; 1157 :          object is attached, unless the code-stream is being read from
; 1158 :          a non-seekable source, in which case you should leave the object
; 1159 :          uninitialized and none of the other functions will have any effect. */
; 1160 :       { assert(this->buf_server == NULL); this->buf_server = buf_server;
; 1161 :         head = tail = NULL; head_pos = tail_pos = available_addresses = 0;
; 1162 :         next_address = 0; tpart_bytes_left = 0; num_layers = 0;
; 1163 :         something_served = final_tpart_with_unknown_length = false;
; 1164 :         next_znum = 0; packets_left_in_precinct=0; }
; 1165 :     void add_plt_marker(kd_marker &marker, kdu_params *cod_params,
; 1166 :                         kdu_params *poc_params);
; 1167 :       /* Call this function whenever a PLT marker segment is encountered,
; 1168 :          while parsing a tile-part header.  The `cod_params' and `poc_params'
; 1169 :          arguments must point to the relevant tile's COD and POC parameter
; 1170 :          objects.  The function uses these to determine whether or not the
; 1171 :          pointer information can be used.  In particular, it is used only
; 1172 :          if the current progression order sequences all packets of any
; 1173 :          given precinct together and if the POC object indicates that there
; 1174 :          will be no progression order changes.  These conditions are checked
; 1175 :          again after each tile-part header has been loaded (see the
; 1176 :          `start_tpart_body' member function).  The reason for the conditions
; 1177 :          is that at most one seek address can be maintained for any given
; 1178 :          precinct. */
; 1179 :     void start_tpart_body(kdu_long start_address, kdu_uint32 tpart_body_length,
; 1180 :                           kdu_params *cod_params, kdu_params *poc_params,
; 1181 :                           bool packed_headers,
; 1182 :                           bool final_tpart_with_unknown_length);
; 1183 :       /* This function must be called before addresses can be recovered for
; 1184 :          precincts whose packets appear in the current tile-part.  The
; 1185 :          `start_address' and `tpart_body_length' arguments identify the
; 1186 :          absolute seeking address of the first byte in the body of the
; 1187 :          tile-part and the total number of body bytes in the tile-part.
; 1188 :          These will be used to determine which packets belong to the
; 1189 :          tile-part.  If this is the last tile-part of the tile and its
; 1190 :          length is unknown, the `final_tpart_with_unknown_length' argument
; 1191 :          should be true, and `tpart_body_length' is ignored.
; 1192 :             This function may determine that precinct address information
; 1193 :          cannot be served up for the current tile, for one of a number of
; 1194 :          This is generally because the packets of each precinct are found
; 1195 :          not to be contiguous within the tile-part, or because the presence
; 1196 :          of POC information renders this a likely problem.  If the
; 1197 :          number of quality layers is found to have changed from the point
; 1198 :          when packet length information was first converted into precinct
; 1199 :          lengths and addresses, we must also conclude that address information
; 1200 :          is not available.  A further reason for discarding packet length
; 1201 :          information is if packet headers have been packed into marker
; 1202 :          segments, since this requires that the packets be processed in order
; 1203 :          and once one by one.  If any such determination is made before any
; 1204 :          precinct addresses have been served up, the object is simply
; 1205 :          disabled so that calls to `get_precinct_address' will return 0.
; 1206 :          Otherwise, a terminal error is generated.  In this event, the
; 1207 :          code-stream might need to be opened again with seeking disabled
; 1208 :          so that the present object will never be initialized. */
; 1209 :     kdu_long get_precinct_address()
; 1210 :       { return ((buf_server==NULL)?((kdu_long) 0):pop_address()); }
; 1211 :       /* Returns the address of the next precinct (in the sequence determined
; 1212 :          by the current progression order) in the tile.  This address may be
; 1213 :          used to seek to the relevant location when reading the precinct's
; 1214 :          packets.
; 1215 :             The function returns 0 if seeking is not possible, if
; 1216 :          packet length information cannot be found in the code-stream,
; 1217 :          or if packet length information is not usable for one of a number
; 1218 :          of reasons.  As explained above, packet length information is usable
; 1219 :          only if the packets of a precinct all appear consecutively so that
; 1220 :          each precinct is characterized by only one seeking address.
; 1221 :             The function returns -1 if seeking is possible, but the first
; 1222 :          packet of the precinct belongs to a tile-part which has not yet been
; 1223 :          opened.  In this event, the `kd_tile::read_tile_part_header' member
; 1224 :          function will have to be called until the information becomes
; 1225 :          available. */
; 1226 :   private: // Helper functions
; 1227 :     kdu_long pop_address();
; 1228 :       /* Does all the work of `get_precinct_address'. */
; 1229 :     void disable()
; 1230 :       { // Call to discard contents and cease recording new PLT info.
; 1231 :         if (buf_server == NULL) return;

	je	SHORT $LN85@kd_tile

; 1232 :         while ((tail=head) != NULL)

	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [esi+64], eax
	test	eax, eax
	je	SHORT $LN87@kd_tile
	npad	4
$LL86@kd_tile:

; 1233 :           { head = tail->next; buf_server->release(tail); }

	mov	eax, DWORD PTR [esi+64]
	push	DWORD PTR [esi+64]
	mov	ecx, DWORD PTR [esi+56]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+60], eax
	call	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ; kd_buf_server::release
	mov	eax, DWORD PTR [esi+60]
	mov	DWORD PTR [esi+64], eax
	test	eax, eax
	jne	SHORT $LL86@kd_tile
$LN87@kd_tile:

; 1234 :         buf_server = NULL;

	mov	DWORD PTR [esi+56], 0
$LN85@kd_tile:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 589  : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1kd_tile@@QAE@XZ$1:
	call	___std_terminate
	ret	0
__unwindfunclet$??1kd_tile@@QAE@XZ$3:
	call	___std_terminate
	ret	0
__unwindfunclet$??1kd_tile@@QAE@XZ$4:
	call	___std_terminate
	ret	0
__unwindfunclet$??1kd_tile@@QAE@XZ$5:
	call	___std_terminate
	ret	0
__unwindfunclet$??1kd_tile@@QAE@XZ$6:
	call	___std_terminate
	ret	0
__unwindfunclet$??1kd_tile@@QAE@XZ$7:
	call	___std_terminate
	ret	0
__ehhandler$??1kd_tile@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-100]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_tile@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_tile@@QAE@XZ ENDP					; kd_tile::~kd_tile
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ??0kd_tile@@QAE@PAUkd_codestream@@PAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_codestream$ = 8					; size = 4
_tref$ = 12						; size = 4
_idx$ = 16						; size = 8
_dims$ = 24						; size = 16
??0kd_tile@@QAE@PAUkd_codestream@@PAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z PROC ; kd_tile::kd_tile, COMDAT
; _this$ = ecx

; 489  : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 492  :   this->tile_ref = tref;  assert(tref->tile == NULL);

	mov	eax, DWORD PTR _tref$[ebp]

; 493  :   this->t_idx = idx;

	mov	edx, DWORD PTR _idx$[ebp]

; 500  :   this->dims = dims;

	movups	xmm0, XMMWORD PTR _dims$[ebp]
	push	esi
	mov	esi, DWORD PTR _codestream$[ebp]
	push	edi
	mov	edi, ecx
	mov	ecx, DWORD PTR _idx$[ebp+4]
	mov	DWORD PTR _this$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [edi+8], 0
	mov	DWORD PTR [edi+12], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1148 :       { buf_server = NULL; }

	mov	DWORD PTR [edi+56], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [edi+160], 0
	mov	DWORD PTR [edi+164], 0
	mov	DWORD PTR [edi+168], 0
	mov	DWORD PTR [edi+172], 0
	mov	DWORD PTR [edi+176], 0
	mov	DWORD PTR [edi+180], 0
	mov	DWORD PTR [edi+184], 0
	mov	DWORD PTR [edi+188], 0
	mov	DWORD PTR [edi+192], 0
	mov	DWORD PTR [edi+196], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 492  :   this->tile_ref = tref;  assert(tref->tile == NULL);

	mov	DWORD PTR [edi+16], eax
	mov	DWORD PTR [edi], esi
	mov	DWORD PTR [edi+216], 0
	mov	DWORD PTR [edi+220], 0

; 493  :   this->t_idx = idx;

	mov	DWORD PTR [edi+8], edx
	mov	DWORD PTR [edi+12], ecx

; 494  :   this->t_num = idx.x + idx.y*codestream->tile_span.x;

	mov	eax, DWORD PTR [esi+168]
	imul	eax, edx

; 495  :   this->is_typical = false; // Cannot be typical until initialized

	mov	WORD PTR [edi+124], 0

; 496  :   this->fully_typical = false; // As above
; 497  :   this->is_in_progress = false;

	mov	WORD PTR [edi+228], 0

; 498  :   this->is_addressable = false;

	mov	DWORD PTR [edi+231], 0

; 499  :   tpart_ptrs = NULL; // Start pointers in `initialize' or `reinitialize'

	mov	DWORD PTR [edi+20], 0
	add	eax, ecx

; 501  : 
; 502  :   region.size = kdu_coords(0,0);

	mov	DWORD PTR [edi+184], 0
	mov	DWORD PTR [edi+4], eax

; 503  :   ppt_markers = NULL;
; 504  :   packed_headers = NULL;
; 505  :   sequencer = NULL;
; 506  :   reslength_checkers = NULL;
; 507  :   mct_head = mct_tail = NULL;
; 508  :   comps = NULL;
; 509  : 
; 510  :   typical_next = NULL;
; 511  :   in_progress_next = in_progress_prev = NULL;
; 512  :   unloadable_next = unloadable_prev = NULL;
; 513  :   initialized = is_open = is_unloadable = closed = exhausted = false;
; 514  :   needs_reinit = empty_shell = false;
; 515  :   insert_plt_segments = false;
; 516  :   resolution_tparts = component_tparts = layer_tparts = false;
; 517  :   num_tparts = next_tpart = sequenced_relevant_packets = 0;
; 518  :   skipping_to_sop = false;
; 519  :   next_input_packet_num = next_sop_sequence_num = 0;
; 520  : }

	mov	eax, edi
	movups	XMMWORD PTR [edi+160], xmm0
	mov	DWORD PTR [edi+188], 0
	mov	DWORD PTR [edi+44], 0
	mov	DWORD PTR [edi+48], 0
	mov	DWORD PTR [edi+52], 0
	mov	DWORD PTR [edi+120], 0
	mov	DWORD PTR [edi+204], 0
	mov	DWORD PTR [edi+200], 0
	mov	DWORD PTR [edi+208], 0
	mov	DWORD PTR [edi+40], 0
	mov	DWORD PTR [edi+28], 0
	mov	DWORD PTR [edi+24], 0
	mov	DWORD PTR [edi+36], 0
	mov	DWORD PTR [edi+32], 0
	mov	BYTE PTR [edi+268], 0
	mov	BYTE PTR [edi+230], 0
	mov	BYTE PTR [edi+227], 0
	mov	DWORD PTR [edi+235], 0
	mov	DWORD PTR [edi+248], 0
	mov	DWORD PTR [edi+244], 0
	mov	DWORD PTR [edi+240], 0
	mov	BYTE PTR [edi+256], 0
	mov	DWORD PTR [edi+260], 0
	mov	DWORD PTR [edi+252], 0
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
??0kd_tile@@QAE@PAUkd_codestream@@PAUkd_tile_ref@@Ukdu_coords@@Ukdu_dims@@@Z ENDP ; kd_tile::kd_tile
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Gkd_mct_stage@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Gkd_mct_stage@@QAEPAXI@Z PROC			; kd_mct_stage::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Gkd_mct_stage@@QAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 2136 :         if (input_required_indices != NULL)

	mov	eax, DWORD PTR [edi+8]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	test	eax, eax
	je	SHORT $LN5@scalar

; 2137 :           delete[] input_required_indices;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@scalar:

; 2138 :         if (output_comp_info != NULL) delete[] output_comp_info;

	mov	eax, DWORD PTR [edi+20]
	test	eax, eax
	je	SHORT $LN6@scalar
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@scalar:

; 2139 :         if (blocks != NULL) delete[] blocks;

	mov	eax, DWORD PTR [edi+28]
	test	eax, eax
	je	SHORT $LN15@scalar
	push	OFFSET ??1kd_mct_block@@QAE@XZ		; kd_mct_block::~kd_mct_block
	push	DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]
	mov	BYTE PTR __$EHRec$[ebp+8], 1
	push	108					; 0000006cH
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	imul	eax, DWORD PTR [esi], 108
	add	eax, 4
	push	eax
	push	esi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN15@scalar:
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN18@scalar
	push	40					; 00000028H
	push	edi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN18@scalar:
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??_Gkd_mct_stage@@QAEPAXI@Z$0:
	call	___std_terminate
	ret	0
__unwindfunclet$??_Gkd_mct_stage@@QAEPAXI@Z$1:
	call	___std_terminate
	ret	0
__ehhandler$??_Gkd_mct_stage@@QAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-12]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Gkd_mct_stage@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Gkd_mct_stage@@QAEPAXI@Z ENDP			; kd_mct_stage::`scalar deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_mct_stage@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kd_mct_stage@@QAE@XZ PROC				; kd_mct_stage::~kd_mct_stage, COMDAT
; _this$ = ecx

; 2135 :       {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_mct_stage@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 2136 :         if (input_required_indices != NULL)

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN2@kd_mct_sta

; 2137 :           delete[] input_required_indices;

	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@kd_mct_sta:

; 2138 :         if (output_comp_info != NULL) delete[] output_comp_info;

	mov	eax, DWORD PTR [esi+20]
	test	eax, eax
	je	SHORT $LN3@kd_mct_sta
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@kd_mct_sta:

; 2139 :         if (blocks != NULL) delete[] blocks;

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN11@kd_mct_sta
	push	OFFSET ??1kd_mct_block@@QAE@XZ		; kd_mct_block::~kd_mct_block
	push	DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	108					; 0000006cH
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	imul	eax, DWORD PTR [esi], 108
	add	eax, 4
	push	eax
	push	esi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN11@kd_mct_sta:

; 2140 :       }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1kd_mct_stage@@QAE@XZ$0:
	call	___std_terminate
	ret	0
__ehhandler$??1kd_mct_stage@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_mct_stage@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_mct_stage@@QAE@XZ ENDP				; kd_mct_stage::~kd_mct_stage
; Function compile flags: /Ogtp
;	COMDAT ??_Ekd_mct_block@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Ekd_mct_block@@QAEPAXI@Z PROC			; kd_mct_block::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Ekd_mct_block@@QAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ebx, DWORD PTR ___flags$[ebp]
	test	bl, 2
	je	SHORT $LN2@vector
	push	OFFSET ??1kd_mct_block@@QAE@XZ		; kd_mct_block::~kd_mct_block
	push	DWORD PTR [esi-4]
	lea	edi, DWORD PTR [esi-4]
	push	108					; 0000006cH
	push	esi
	call	??_M@YGXPAXIIP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN3@vector
	imul	ecx, DWORD PTR [edi], 108
	add	ecx, 4
	push	ecx
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN3@vector:
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@vector:
	call	??1kd_mct_block@@QAE@XZ			; kd_mct_block::~kd_mct_block
	test	bl, 1
	je	SHORT $LN4@vector
	push	108					; 0000006cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@vector:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Ekd_mct_block@@QAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Ekd_mct_block@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Ekd_mct_block@@QAEPAXI@Z ENDP			; kd_mct_block::`vector deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_mct_block@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kd_mct_block@@QAE@XZ PROC				; kd_mct_block::~kd_mct_block, COMDAT
; _this$ = ecx

; 1916 :       {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_mct_block@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1917 :         if (input_indices != NULL) delete[] input_indices;

	mov	eax, DWORD PTR [esi+12]
	test	eax, eax
	je	SHORT $LN2@kd_mct_blo
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN2@kd_mct_blo:

; 1918 :         if (inputs_required != NULL) delete[] inputs_required;

	mov	eax, DWORD PTR [esi+16]
	test	eax, eax
	je	SHORT $LN3@kd_mct_blo
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN3@kd_mct_blo:

; 1919 :         if (output_indices != NULL) delete[] output_indices;

	mov	eax, DWORD PTR [esi+28]
	test	eax, eax
	je	SHORT $LN4@kd_mct_blo
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN4@kd_mct_blo:

; 1920 :         if (dwt_step_info != NULL) delete[] dwt_step_info;

	mov	eax, DWORD PTR [esi+72]
	test	eax, eax
	je	SHORT $LN5@kd_mct_blo
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN5@kd_mct_blo:

; 1921 :         if (dwt_coefficients != NULL) delete[] dwt_coefficients;

	mov	eax, DWORD PTR [esi+76]
	test	eax, eax
	je	SHORT $LN6@kd_mct_blo
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN6@kd_mct_blo:

; 1922 :         if (scratch != NULL) delete[] scratch;

	mov	eax, DWORD PTR [esi+104]
	test	eax, eax
	je	SHORT $LN7@kd_mct_blo
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@kd_mct_blo:

; 1923 :         if (ss_models != NULL) delete[] ss_models;

	mov	eax, DWORD PTR [esi+32]
	test	eax, eax
	je	SHORT $LN15@kd_mct_blo
	push	OFFSET ??1kd_mct_ss_model@@QAE@XZ	; kd_mct_ss_model::~kd_mct_ss_model
	push	DWORD PTR [eax-4]
	lea	esi, DWORD PTR [eax-4]
	mov	DWORD PTR __$EHRec$[ebp+8], 0
	push	12					; 0000000cH
	push	eax
	call	??_M@YGXPAXIIP6EX0@Z@Z
	mov	eax, DWORD PTR [esi]
	lea	eax, DWORD PTR [eax+eax*2]
	lea	eax, DWORD PTR [eax*4+4]
	push	eax
	push	esi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN15@kd_mct_blo:

; 1924 :       }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$??1kd_mct_block@@QAE@XZ$0:
	call	___std_terminate
	ret	0
__ehhandler$??1kd_mct_block@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_mct_block@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_mct_block@@QAE@XZ ENDP				; kd_mct_block::~kd_mct_block
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Ekd_mct_ss_model@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Ekd_mct_ss_model@@QAEPAXI@Z PROC			; kd_mct_ss_model::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Ekd_mct_ss_model@@QAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ebx, DWORD PTR ___flags$[ebp]
	test	bl, 2
	je	SHORT $LN2@vector
	push	OFFSET ??1kd_mct_ss_model@@QAE@XZ	; kd_mct_ss_model::~kd_mct_ss_model
	push	DWORD PTR [esi-4]
	lea	edi, DWORD PTR [esi-4]
	push	12					; 0000000cH
	push	esi
	call	??_M@YGXPAXIIP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN3@vector
	mov	ecx, DWORD PTR [edi]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	lea	ecx, DWORD PTR [ecx*4+4]
	push	ecx
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN3@vector:
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@vector:

; 1898 :     ~kd_mct_ss_model() { if (ss_handle != NULL) delete[] ss_handle; }

	mov	eax, DWORD PTR [esi+8]
	test	eax, eax
	je	SHORT $LN7@vector
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@vector:
	test	bl, 1
	je	SHORT $LN4@vector
	push	12					; 0000000cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@vector:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Ekd_mct_ss_model@@QAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Ekd_mct_ss_model@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Ekd_mct_ss_model@@QAEPAXI@Z ENDP			; kd_mct_ss_model::`vector deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_mct_ss_model@@QAE@XZ
_TEXT	SEGMENT
??1kd_mct_ss_model@@QAE@XZ PROC				; kd_mct_ss_model::~kd_mct_ss_model, COMDAT
; _this$ = ecx

; 1898 :     ~kd_mct_ss_model() { if (ss_handle != NULL) delete[] ss_handle; }

	mov	eax, DWORD PTR [ecx+8]
	test	eax, eax
	je	SHORT $LN2@kd_mct_ss_
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN2@kd_mct_ss_:
	ret	0
??1kd_mct_ss_model@@QAE@XZ ENDP				; kd_mct_ss_model::~kd_mct_ss_model
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Ekd_reslength_checker@@QAEPAXI@Z
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
___flags$ = 8						; size = 4
??_Ekd_reslength_checker@@QAEPAXI@Z PROC		; kd_reslength_checker::`vector deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??_Ekd_reslength_checker@@QAEPAXI@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx
	mov	ebx, DWORD PTR ___flags$[ebp]
	test	bl, 2
	je	SHORT $LN2@vector
	push	OFFSET ??1kd_reslength_checker@@QAE@XZ	; kd_reslength_checker::~kd_reslength_checker
	push	DWORD PTR [esi-4]
	lea	edi, DWORD PTR [esi-4]
	push	808					; 00000328H
	push	esi
	call	??_M@YGXPAXIIP6EX0@Z@Z
	test	bl, 1
	je	SHORT $LN3@vector
	imul	ecx, DWORD PTR [edi], 808
	add	ecx, 4
	push	ecx
	push	edi
	call	??_V@YAXPAXI@Z				; operator delete[]
	add	esp, 8
$LN3@vector:
	mov	eax, edi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
$LN2@vector:

; 1631 :     ~kd_reslength_checker() { if (specs != NULL) delete[] specs; }

	mov	eax, DWORD PTR [esi+4]
	test	eax, eax
	je	SHORT $LN7@vector
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	add	esp, 4
$LN7@vector:
	test	bl, 1
	je	SHORT $LN4@vector
	push	808					; 00000328H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@vector:
	mov	eax, esi
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	4
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??_Ekd_reslength_checker@@QAEPAXI@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-16]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??_Ekd_reslength_checker@@QAEPAXI@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
??_Ekd_reslength_checker@@QAEPAXI@Z ENDP		; kd_reslength_checker::`vector deleting destructor'
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_reslength_checker@@QAE@XZ
_TEXT	SEGMENT
??1kd_reslength_checker@@QAE@XZ PROC			; kd_reslength_checker::~kd_reslength_checker, COMDAT
; _this$ = ecx

; 1631 :     ~kd_reslength_checker() { if (specs != NULL) delete[] specs; }

	mov	eax, DWORD PTR [ecx+4]
	test	eax, eax
	je	SHORT $LN2@kd_resleng
	push	eax
	call	??_V@YAXPAX@Z				; operator delete[]
	pop	ecx
$LN2@kd_resleng:
	ret	0
??1kd_reslength_checker@@QAE@XZ ENDP			; kd_reslength_checker::~kd_reslength_checker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_reslength_checker@@QAE@XZ
_TEXT	SEGMENT
??0kd_reslength_checker@@QAE@XZ PROC			; kd_reslength_checker::kd_reslength_checker, COMDAT
; _this$ = ecx

; 1630 :     kd_reslength_checker() { memset(this,0,sizeof(*this)); }

	push	esi
	push	808					; 00000328H
	mov	esi, ecx
	push	0
	push	esi
	call	_memset
	add	esp, 12					; 0000000cH
	mov	eax, esi
	pop	esi
	ret	0
??0kd_reslength_checker@@QAE@XZ ENDP			; kd_reslength_checker::kd_reslength_checker
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kd_packet_sequencer_state@kd_packet_sequencer@@QAE@XZ
_TEXT	SEGMENT
??0kd_packet_sequencer_state@kd_packet_sequencer@@QAE@XZ PROC ; kd_packet_sequencer::kd_packet_sequencer_state::kd_packet_sequencer_state, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+36], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+40], 0
	mov	DWORD PTR [ecx+44], 0
	mov	DWORD PTR [ecx+48], 0
	mov	DWORD PTR [ecx+52], 0
	mov	DWORD PTR [ecx+56], 0
	mov	DWORD PTR [ecx+60], 0
	mov	DWORD PTR [ecx+64], 0
	ret	0
??0kd_packet_sequencer_state@kd_packet_sequencer@@QAE@XZ ENDP ; kd_packet_sequencer::kd_packet_sequencer_state::kd_packet_sequencer_state
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_packet_sequencer@@QAE@PAUkd_tile@@@Z
_TEXT	SEGMENT
_tile$ = 8						; size = 4
??0kd_packet_sequencer@@QAE@PAUkd_tile@@@Z PROC		; kd_packet_sequencer::kd_packet_sequencer, COMDAT
; _this$ = ecx

; 1508 :     kd_packet_sequencer(kd_tile *tile)

	push	ebp
	mov	ebp, esp

; 1510 :         this->tile = tile;

	mov	eax, DWORD PTR _tile$[ebp]
	push	esi
	mov	esi, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [esi+12], 0
	mov	DWORD PTR [esi+16], 0
	mov	DWORD PTR [esi+60], 0
	mov	DWORD PTR [esi+64], 0
	mov	DWORD PTR [esi+68], 0
	mov	DWORD PTR [esi+72], 0
	mov	DWORD PTR [esi+76], 0
	mov	DWORD PTR [esi+80], 0
	mov	DWORD PTR [esi+84], 0
	mov	DWORD PTR [esi+88], 0
	mov	DWORD PTR [esi+136], 0
	mov	DWORD PTR [esi+140], 0
	mov	DWORD PTR [esi+144], 0
	mov	DWORD PTR [esi+148], 0
	mov	DWORD PTR [esi+152], 0
	mov	DWORD PTR [esi+156], 0
	mov	DWORD PTR [esi+160], 0
	mov	DWORD PTR [esi+164], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1510 :         this->tile = tile;

	mov	DWORD PTR [esi], eax

; 1511 :         init();

	call	?init@kd_packet_sequencer@@QAEXXZ	; kd_packet_sequencer::init

; 1512 :       }

	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??0kd_packet_sequencer@@QAE@PAUkd_tile@@@Z ENDP		; kd_packet_sequencer::kd_packet_sequencer
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_conservative_slope_threshold@kd_compressed_stats@@QAEG_N@Z
_TEXT	SEGMENT
_assume_all_coded$ = 8					; size = 1
?get_conservative_slope_threshold@kd_compressed_stats@@QAEG_N@Z PROC ; kd_compressed_stats::get_conservative_slope_threshold, COMDAT
; _this$ = ecx

; 1397 :       { /* The slope threshold generated by PCRD-opt is unlikely to be

	push	ebp
	mov	ebp, esp

; 1398 :            smaller than that returned here -- remember that smaller thresholds
; 1399 :            mean that more compressed data are included in the code-stream.
; 1400 :            If `assume_all_coded' is true, the slope threshold is based on the
; 1401 :            assumption that no bytes will be generated for any further samples.
; 1402 :            Otherwise, the assumption is that future samples will have the
; 1403 :            same average compressibility as those already coded.  Note that
; 1404 :            since compressors tend to output a higher proportion of high
; 1405 :            frequency subband samples than low frequency subband samples at
; 1406 :            any point up to the end of the image, the actual compressibility
; 1407 :            of future samples can be expected to be lower on average, making
; 1408 :            our estimate more conservative. */
; 1409 :         int val =
; 1410 :           (assume_all_coded)?remaining_slope_threshold:block_slope_threshold;

	cmp	BYTE PTR _assume_all_coded$[ebp], 0
	je	SHORT $LN3@get_conser
	mov	ecx, DWORD PTR [ecx+32820]

; 1411 :         val = (val<<4)-1;
; 1412 :         return (kdu_uint16)((val>0)?val:1);

	mov	eax, 1
	shl	ecx, 4
	dec	ecx
	test	ecx, ecx
	cmovg	eax, ecx

; 1413 :       }

	pop	ebp
	ret	4
$LN3@get_conser:

; 1398 :            smaller than that returned here -- remember that smaller thresholds
; 1399 :            mean that more compressed data are included in the code-stream.
; 1400 :            If `assume_all_coded' is true, the slope threshold is based on the
; 1401 :            assumption that no bytes will be generated for any further samples.
; 1402 :            Otherwise, the assumption is that future samples will have the
; 1403 :            same average compressibility as those already coded.  Note that
; 1404 :            since compressors tend to output a higher proportion of high
; 1405 :            frequency subband samples than low frequency subband samples at
; 1406 :            any point up to the end of the image, the actual compressibility
; 1407 :            of future samples can be expected to be lower on average, making
; 1408 :            our estimate more conservative. */
; 1409 :         int val =
; 1410 :           (assume_all_coded)?remaining_slope_threshold:block_slope_threshold;

	mov	ecx, DWORD PTR [ecx+32816]

; 1411 :         val = (val<<4)-1;
; 1412 :         return (kdu_uint16)((val>0)?val:1);

	mov	eax, 1
	shl	ecx, 4
	dec	ecx
	test	ecx, ecx
	cmovg	eax, ecx

; 1413 :       }

	pop	ebp
	ret	4
?get_conservative_slope_threshold@kd_compressed_stats@@QAEG_N@Z ENDP ; kd_compressed_stats::get_conservative_slope_threshold
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?update_quant_slope_thresholds@kd_compressed_stats@@QAEXXZ
_TEXT	SEGMENT
_cumulative_bytes$ = -16				; size = 8
_max_bytes$3$ = -8					; size = 4
_max_bytes$2$ = -8					; size = 4
_max_bytes$4$ = -4					; size = 4
_max_bytes$1$ = -4					; size = 4
?update_quant_slope_thresholds@kd_compressed_stats@@QAEXXZ PROC ; kd_compressed_stats::update_quant_slope_thresholds, COMDAT
; _this$ = ecx

; 1369 :       { /* This function should be called after `update_stats' to ensure that

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	push	ebx
	mov	ebx, ecx
	push	esi
	push	edi

; 1370 :            the most up-to-date slope threshold is available for return via
; 1371 :            `get_conservative_slope_threshold'.  If desired, multiple calls
; 1372 :            to `update_stats' may precede the call to this function, which
; 1373 :            may improve efficiency.  The reason for computing the slope
; 1374 :            threshold here, rather than in `get_conservative_slope_threshold'
; 1375 :            is that the latter function may be invoked asynchronously by any
; 1376 :            number of threads of execution, whereas the present function is
; 1377 :            always invoked while holding the `KD_THREADLOCK_STATS' mutex
; 1378 :            (in multi-threaded applications) so that other threads cannot
; 1379 :            modify the statistics while this function is in progress. */
; 1380 :         int n;  kdu_long max_bytes, cumulative_bytes;
; 1381 :         // Adjust `block_slope_threshold'
; 1382 :         max_bytes = num_coded_samples + conservative_extra_samples;

	mov	ecx, DWORD PTR [ebx+32]
	add	ecx, DWORD PTR [ebx+24]
	mov	edx, DWORD PTR [ebx+36]
	adc	edx, DWORD PTR [ebx+28]

; 1383 :         max_bytes = 1 + (kdu_long)(max_bytes * target_rate);

	call	__ltod3
	mulsd	xmm0, QWORD PTR [ebx]
	call	__dtol3

; 1384 :         for (cumulative_bytes=0, n=max_quant_slope; n >= min_quant_slope; n--)

	mov	esi, DWORD PTR [ebx+32812]
	add	eax, 1
	mov	edi, DWORD PTR [ebx+32808]
	mov	ecx, edx
	adc	ecx, 0
	mov	DWORD PTR _max_bytes$3$[ebp], eax
	mov	DWORD PTR _max_bytes$1$[ebp], ecx
	xorps	xmm0, xmm0
	mov	ecx, esi
	movlpd	QWORD PTR _cumulative_bytes$[ebp], xmm0
	cmp	ecx, edi
	jl	SHORT $LN13@update_qua

; 1370 :            the most up-to-date slope threshold is available for return via
; 1371 :            `get_conservative_slope_threshold'.  If desired, multiple calls
; 1372 :            to `update_stats' may precede the call to this function, which
; 1373 :            may improve efficiency.  The reason for computing the slope
; 1374 :            threshold here, rather than in `get_conservative_slope_threshold'
; 1375 :            is that the latter function may be invoked asynchronously by any
; 1376 :            number of threads of execution, whereas the present function is
; 1377 :            always invoked while holding the `KD_THREADLOCK_STATS' mutex
; 1378 :            (in multi-threaded applications) so that other threads cannot
; 1379 :            modify the statistics while this function is in progress. */
; 1380 :         int n;  kdu_long max_bytes, cumulative_bytes;
; 1381 :         // Adjust `block_slope_threshold'
; 1382 :         max_bytes = num_coded_samples + conservative_extra_samples;

	mov	edi, DWORD PTR _cumulative_bytes$[ebp+4]
	lea	eax, DWORD PTR [ebx+40]
	mov	edx, DWORD PTR _cumulative_bytes$[ebp]
	lea	eax, DWORD PTR [eax+ecx*8]
	npad	7
$LL4@update_qua:

; 1385 :           if ((cumulative_bytes += quant_slope_rates[n]) >= max_bytes)

	add	edx, DWORD PTR [eax]
	adc	edi, DWORD PTR [eax+4]
	cmp	edi, DWORD PTR _max_bytes$1$[ebp]
	jg	SHORT $LN27@update_qua
	jl	SHORT $LN21@update_qua
	cmp	edx, DWORD PTR _max_bytes$3$[ebp]
	jae	SHORT $LN27@update_qua
$LN21@update_qua:

; 1384 :         for (cumulative_bytes=0, n=max_quant_slope; n >= min_quant_slope; n--)

	dec	ecx
	sub	eax, 8
	cmp	ecx, DWORD PTR [ebx+32808]
	jge	SHORT $LL4@update_qua
$LN27@update_qua:
	mov	edi, DWORD PTR [ebx+32808]
$LN13@update_qua:

; 1388 :         // Adjust `remaining_slope_threshold'
; 1389 :         max_bytes = total_samples;
; 1390 :         max_bytes = 1 + (kdu_long)(max_bytes * target_rate);

	mov	edx, DWORD PTR [ebx+12]
	mov	DWORD PTR [ebx+32816], ecx
	mov	ecx, DWORD PTR [ebx+8]
	call	__ltod3
	mulsd	xmm0, QWORD PTR [ebx]
	call	__dtol3
	add	eax, 1
	mov	ecx, edx
	xorps	xmm0, xmm0
	mov	DWORD PTR _max_bytes$4$[ebp], eax
	adc	ecx, 0

; 1391 :         for (cumulative_bytes=0, n=max_quant_slope; n >= min_quant_slope; n--)

	movlpd	QWORD PTR _cumulative_bytes$[ebp], xmm0
	mov	DWORD PTR _max_bytes$2$[ebp], ecx
	cmp	esi, edi
	jl	SHORT $LN24@update_qua

; 1386 :             break;
; 1387 :         block_slope_threshold = n;

	mov	edx, DWORD PTR _cumulative_bytes$[ebp+4]
	lea	eax, DWORD PTR [ebx+40]
	mov	ecx, DWORD PTR _cumulative_bytes$[ebp]
	lea	eax, DWORD PTR [eax+esi*8]
$LL7@update_qua:

; 1392 :           if ((cumulative_bytes += quant_slope_rates[n]) >= max_bytes)

	add	ecx, DWORD PTR [eax]
	adc	edx, DWORD PTR [eax+4]
	cmp	edx, DWORD PTR _max_bytes$2$[ebp]
	jg	SHORT $LN24@update_qua
	jl	SHORT $LN22@update_qua
	cmp	ecx, DWORD PTR _max_bytes$4$[ebp]
	jae	SHORT $LN24@update_qua
$LN22@update_qua:

; 1391 :         for (cumulative_bytes=0, n=max_quant_slope; n >= min_quant_slope; n--)

	dec	esi
	sub	eax, 8
	cmp	esi, edi
	jge	SHORT $LL7@update_qua
$LN24@update_qua:
	pop	edi

; 1393 :             break;
; 1394 :         remaining_slope_threshold = n;

	mov	DWORD PTR [ebx+32820], esi
	pop	esi
	pop	ebx

; 1395 :       }

	mov	esp, ebp
	pop	ebp
	ret	0
?update_quant_slope_thresholds@kd_compressed_stats@@QAEXXZ ENDP ; kd_compressed_stats::update_quant_slope_thresholds
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?update_stats@kd_compressed_stats@@QAE_NPAUkdu_block@@@Z
_TEXT	SEGMENT
_block$ = 8						; size = 4
?update_stats@kd_compressed_stats@@QAE_NPAUkdu_block@@@Z PROC ; kd_compressed_stats::update_stats, COMDAT
; _this$ = ecx

; 1329 :       { /* Invoked by "kdu_subband::close_block".  If the function returns

	push	ebp
	mov	ebp, esp
	push	ebx

; 1330 :            true, it is recommended that the compressed data be trimmed back
; 1331 :            to a size consistent with the target compressed length at this
; 1332 :            point.  Remember to invoke `update_quant_slope_thresholds' once
; 1333 :            this function returns. */
; 1334 :         num_coded_samples += block->size.x*block->size.y;

	mov	ebx, DWORD PTR _block$[ebp]
	push	esi
	push	edi
	mov	eax, DWORD PTR [ebx+4]
	imul	eax, DWORD PTR [ebx]
	cdq
	add	DWORD PTR [ecx+32], eax
	adc	DWORD PTR [ecx+36], edx

; 1335 :         int quant_slope, length = 0;

	xor	edx, edx

; 1336 :         for (int n=0; n < block->num_passes; n++)

	xor	edi, edi
	cmp	DWORD PTR [ebx+48], edx
	jle	SHORT $LN3@update_sta
	npad	1
$LL4@update_sta:

; 1337 :           {
; 1338 :             length += block->pass_lengths[n];

	mov	eax, DWORD PTR [ebx+52]
	add	edx, DWORD PTR [eax+edi*4]

; 1339 :             if (block->pass_slopes[n] == 0)

	mov	eax, DWORD PTR [ebx+56]
	movzx	eax, WORD PTR [eax+edi*2]
	test	ax, ax
	je	SHORT $LN2@update_sta

; 1340 :               continue;
; 1341 :             quant_slope = block->pass_slopes[n] >> 4;

	mov	esi, eax
	shr	esi, 4

; 1342 :             if (quant_slope < min_quant_slope) min_quant_slope = quant_slope;

	cmp	esi, DWORD PTR [ecx+32808]
	jge	SHORT $LN6@update_sta
	mov	DWORD PTR [ecx+32808], esi
$LN6@update_sta:

; 1343 :             if (quant_slope > max_quant_slope) max_quant_slope = quant_slope;

	cmp	esi, DWORD PTR [ecx+32812]
	jle	SHORT $LN7@update_sta
	mov	DWORD PTR [ecx+32812], esi
$LN7@update_sta:

; 1344 :             quant_slope_rates[quant_slope] += length;

	mov	eax, edx
	cdq
	add	DWORD PTR [ecx+esi*8+40], eax
	adc	DWORD PTR [ecx+esi*8+44], edx

; 1345 :             length = 0;

	xor	edx, edx
$LN2@update_sta:

; 1336 :         for (int n=0; n < block->num_passes; n++)

	inc	edi
	cmp	edi, DWORD PTR [ebx+48]
	jl	SHORT $LL4@update_sta
$LN3@update_sta:

; 1346 :           }
; 1347 :         if (trimming_enabled && (num_coded_samples > next_trim))

	cmp	BYTE PTR [ecx+32824], 0
	je	SHORT $LN8@update_sta
	mov	edi, DWORD PTR [ecx+20]
	mov	esi, DWORD PTR [ecx+16]
	cmp	DWORD PTR [ecx+36], edi
	jl	SHORT $LN8@update_sta
	jg	SHORT $LN14@update_sta
	cmp	DWORD PTR [ecx+32], esi
	jbe	SHORT $LN8@update_sta
$LN14@update_sta:

; 1348 :           { next_trim += (total_samples+7)>>4; return true; }

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [ecx+12]
	add	edx, 7
	adc	eax, 0
	shrd	edx, eax, 4
	sar	eax, 4
	add	edx, esi
	mov	DWORD PTR [ecx+16], edx
	adc	eax, edi
	pop	edi
	pop	esi
	mov	DWORD PTR [ecx+20], eax
	mov	al, 1
	pop	ebx

; 1350 :       }

	pop	ebp
	ret	4
$LN8@update_sta:
	pop	edi
	pop	esi

; 1349 :         return false;

	xor	al, al
	pop	ebx

; 1350 :       }

	pop	ebp
	ret	4
?update_stats@kd_compressed_stats@@QAE_NPAUkdu_block@@@Z ENDP ; kd_compressed_stats::update_stats
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?disable@kd_precinct_pointer_server@@AAEXXZ
_TEXT	SEGMENT
?disable@kd_precinct_pointer_server@@AAEXXZ PROC	; kd_precinct_pointer_server::disable, COMDAT
; _this$ = ecx

; 1230 :       { // Call to discard contents and cease recording new PLT info.

	push	esi
	mov	esi, ecx

; 1231 :         if (buf_server == NULL) return;

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN1@disable

; 1232 :         while ((tail=head) != NULL)

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], eax
	test	eax, eax
	je	SHORT $LN3@disable
$LL2@disable:

; 1233 :           { head = tail->next; buf_server->release(tail); }

	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+4], eax
	call	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ; kd_buf_server::release
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], eax
	test	eax, eax
	jne	SHORT $LL2@disable
$LN3@disable:

; 1234 :         buf_server = NULL;

	mov	DWORD PTR [esi], 0
$LN1@disable:
	pop	esi

; 1235 :       }

	ret	0
?disable@kd_precinct_pointer_server@@AAEXXZ ENDP	; kd_precinct_pointer_server::disable
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?initialize@kd_precinct_pointer_server@@QAEXPAVkd_buf_server@@@Z
_TEXT	SEGMENT
_buf_server$ = 8					; size = 4
?initialize@kd_precinct_pointer_server@@QAEXPAVkd_buf_server@@@Z PROC ; kd_precinct_pointer_server::initialize, COMDAT
; _this$ = ecx

; 1160 :       { assert(this->buf_server == NULL); this->buf_server = buf_server;

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _buf_server$[ebp]
	mov	DWORD PTR [ecx], eax

; 1161 :         head = tail = NULL; head_pos = tail_pos = available_addresses = 0;

	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+20], 0
	mov	DWORD PTR [ecx+16], 0
	mov	DWORD PTR [ecx+12], 0

; 1162 :         next_address = 0; tpart_bytes_left = 0; num_layers = 0;

	mov	DWORD PTR [ecx+24], 0
	mov	DWORD PTR [ecx+28], 0
	mov	DWORD PTR [ecx+32], 0
	mov	DWORD PTR [ecx+40], 0

; 1163 :         something_served = final_tpart_with_unknown_length = false;

	mov	BYTE PTR [ecx+36], 0
	mov	WORD PTR [ecx+44], 0

; 1164 :         next_znum = 0; packets_left_in_precinct=0; }

	mov	DWORD PTR [ecx+56], 0
	pop	ebp
	ret	4
?initialize@kd_precinct_pointer_server@@QAEXPAVkd_buf_server@@@Z ENDP ; kd_precinct_pointer_server::initialize
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?is_active@kd_precinct_pointer_server@@QAE_NXZ
_TEXT	SEGMENT
?is_active@kd_precinct_pointer_server@@QAE_NXZ PROC	; kd_precinct_pointer_server::is_active, COMDAT
; _this$ = ecx

; 1154 :       { return (buf_server != NULL); }

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setne	al
	ret	0
?is_active@kd_precinct_pointer_server@@QAE_NXZ ENDP	; kd_precinct_pointer_server::is_active
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?restart@kd_precinct_pointer_server@@QAEXXZ
_TEXT	SEGMENT
?restart@kd_precinct_pointer_server@@QAEXXZ PROC	; kd_precinct_pointer_server::restart, COMDAT
; _this$ = ecx

; 1152 :       { disable(); } // Called if the code-stream is restarted.

	push	esi
	mov	esi, ecx

; 1153 :     bool is_active()
; 1154 :       { return (buf_server != NULL); }
; 1155 :     void initialize(kd_buf_server *buf_server)
; 1156 :       /* Call this function when constructing the tile to which the
; 1157 :          object is attached, unless the code-stream is being read from
; 1158 :          a non-seekable source, in which case you should leave the object
; 1159 :          uninitialized and none of the other functions will have any effect. */
; 1160 :       { assert(this->buf_server == NULL); this->buf_server = buf_server;
; 1161 :         head = tail = NULL; head_pos = tail_pos = available_addresses = 0;
; 1162 :         next_address = 0; tpart_bytes_left = 0; num_layers = 0;
; 1163 :         something_served = final_tpart_with_unknown_length = false;
; 1164 :         next_znum = 0; packets_left_in_precinct=0; }
; 1165 :     void add_plt_marker(kd_marker &marker, kdu_params *cod_params,
; 1166 :                         kdu_params *poc_params);
; 1167 :       /* Call this function whenever a PLT marker segment is encountered,
; 1168 :          while parsing a tile-part header.  The `cod_params' and `poc_params'
; 1169 :          arguments must point to the relevant tile's COD and POC parameter
; 1170 :          objects.  The function uses these to determine whether or not the
; 1171 :          pointer information can be used.  In particular, it is used only
; 1172 :          if the current progression order sequences all packets of any
; 1173 :          given precinct together and if the POC object indicates that there
; 1174 :          will be no progression order changes.  These conditions are checked
; 1175 :          again after each tile-part header has been loaded (see the
; 1176 :          `start_tpart_body' member function).  The reason for the conditions
; 1177 :          is that at most one seek address can be maintained for any given
; 1178 :          precinct. */
; 1179 :     void start_tpart_body(kdu_long start_address, kdu_uint32 tpart_body_length,
; 1180 :                           kdu_params *cod_params, kdu_params *poc_params,
; 1181 :                           bool packed_headers,
; 1182 :                           bool final_tpart_with_unknown_length);
; 1183 :       /* This function must be called before addresses can be recovered for
; 1184 :          precincts whose packets appear in the current tile-part.  The
; 1185 :          `start_address' and `tpart_body_length' arguments identify the
; 1186 :          absolute seeking address of the first byte in the body of the
; 1187 :          tile-part and the total number of body bytes in the tile-part.
; 1188 :          These will be used to determine which packets belong to the
; 1189 :          tile-part.  If this is the last tile-part of the tile and its
; 1190 :          length is unknown, the `final_tpart_with_unknown_length' argument
; 1191 :          should be true, and `tpart_body_length' is ignored.
; 1192 :             This function may determine that precinct address information
; 1193 :          cannot be served up for the current tile, for one of a number of
; 1194 :          This is generally because the packets of each precinct are found
; 1195 :          not to be contiguous within the tile-part, or because the presence
; 1196 :          of POC information renders this a likely problem.  If the
; 1197 :          number of quality layers is found to have changed from the point
; 1198 :          when packet length information was first converted into precinct
; 1199 :          lengths and addresses, we must also conclude that address information
; 1200 :          is not available.  A further reason for discarding packet length
; 1201 :          information is if packet headers have been packed into marker
; 1202 :          segments, since this requires that the packets be processed in order
; 1203 :          and once one by one.  If any such determination is made before any
; 1204 :          precinct addresses have been served up, the object is simply
; 1205 :          disabled so that calls to `get_precinct_address' will return 0.
; 1206 :          Otherwise, a terminal error is generated.  In this event, the
; 1207 :          code-stream might need to be opened again with seeking disabled
; 1208 :          so that the present object will never be initialized. */
; 1209 :     kdu_long get_precinct_address()
; 1210 :       { return ((buf_server==NULL)?((kdu_long) 0):pop_address()); }
; 1211 :       /* Returns the address of the next precinct (in the sequence determined
; 1212 :          by the current progression order) in the tile.  This address may be
; 1213 :          used to seek to the relevant location when reading the precinct's
; 1214 :          packets.
; 1215 :             The function returns 0 if seeking is not possible, if
; 1216 :          packet length information cannot be found in the code-stream,
; 1217 :          or if packet length information is not usable for one of a number
; 1218 :          of reasons.  As explained above, packet length information is usable
; 1219 :          only if the packets of a precinct all appear consecutively so that
; 1220 :          each precinct is characterized by only one seeking address.
; 1221 :             The function returns -1 if seeking is possible, but the first
; 1222 :          packet of the precinct belongs to a tile-part which has not yet been
; 1223 :          opened.  In this event, the `kd_tile::read_tile_part_header' member
; 1224 :          function will have to be called until the information becomes
; 1225 :          available. */
; 1226 :   private: // Helper functions
; 1227 :     kdu_long pop_address();
; 1228 :       /* Does all the work of `get_precinct_address'. */
; 1229 :     void disable()
; 1230 :       { // Call to discard contents and cease recording new PLT info.
; 1231 :         if (buf_server == NULL) return;

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN3@restart

; 1232 :         while ((tail=head) != NULL)

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], eax
	test	eax, eax
	je	SHORT $LN5@restart
$LL4@restart:

; 1233 :           { head = tail->next; buf_server->release(tail); }

	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+4], eax
	call	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ; kd_buf_server::release
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], eax
	test	eax, eax
	jne	SHORT $LL4@restart
$LN5@restart:

; 1234 :         buf_server = NULL;

	mov	DWORD PTR [esi], 0
$LN3@restart:
	pop	esi

; 1152 :       { disable(); } // Called if the code-stream is restarted.

	ret	0
?restart@kd_precinct_pointer_server@@QAEXXZ ENDP	; kd_precinct_pointer_server::restart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_precinct_pointer_server@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kd_precinct_pointer_server@@QAE@XZ PROC		; kd_precinct_pointer_server::~kd_precinct_pointer_server, COMDAT
; _this$ = ecx

; 1150 :       { disable(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kd_precinct_pointer_server@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	push	esi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	esi, ecx

; 1151 :     void restart()
; 1152 :       { disable(); } // Called if the code-stream is restarted.
; 1153 :     bool is_active()
; 1154 :       { return (buf_server != NULL); }
; 1155 :     void initialize(kd_buf_server *buf_server)
; 1156 :       /* Call this function when constructing the tile to which the
; 1157 :          object is attached, unless the code-stream is being read from
; 1158 :          a non-seekable source, in which case you should leave the object
; 1159 :          uninitialized and none of the other functions will have any effect. */
; 1160 :       { assert(this->buf_server == NULL); this->buf_server = buf_server;
; 1161 :         head = tail = NULL; head_pos = tail_pos = available_addresses = 0;
; 1162 :         next_address = 0; tpart_bytes_left = 0; num_layers = 0;
; 1163 :         something_served = final_tpart_with_unknown_length = false;
; 1164 :         next_znum = 0; packets_left_in_precinct=0; }
; 1165 :     void add_plt_marker(kd_marker &marker, kdu_params *cod_params,
; 1166 :                         kdu_params *poc_params);
; 1167 :       /* Call this function whenever a PLT marker segment is encountered,
; 1168 :          while parsing a tile-part header.  The `cod_params' and `poc_params'
; 1169 :          arguments must point to the relevant tile's COD and POC parameter
; 1170 :          objects.  The function uses these to determine whether or not the
; 1171 :          pointer information can be used.  In particular, it is used only
; 1172 :          if the current progression order sequences all packets of any
; 1173 :          given precinct together and if the POC object indicates that there
; 1174 :          will be no progression order changes.  These conditions are checked
; 1175 :          again after each tile-part header has been loaded (see the
; 1176 :          `start_tpart_body' member function).  The reason for the conditions
; 1177 :          is that at most one seek address can be maintained for any given
; 1178 :          precinct. */
; 1179 :     void start_tpart_body(kdu_long start_address, kdu_uint32 tpart_body_length,
; 1180 :                           kdu_params *cod_params, kdu_params *poc_params,
; 1181 :                           bool packed_headers,
; 1182 :                           bool final_tpart_with_unknown_length);
; 1183 :       /* This function must be called before addresses can be recovered for
; 1184 :          precincts whose packets appear in the current tile-part.  The
; 1185 :          `start_address' and `tpart_body_length' arguments identify the
; 1186 :          absolute seeking address of the first byte in the body of the
; 1187 :          tile-part and the total number of body bytes in the tile-part.
; 1188 :          These will be used to determine which packets belong to the
; 1189 :          tile-part.  If this is the last tile-part of the tile and its
; 1190 :          length is unknown, the `final_tpart_with_unknown_length' argument
; 1191 :          should be true, and `tpart_body_length' is ignored.
; 1192 :             This function may determine that precinct address information
; 1193 :          cannot be served up for the current tile, for one of a number of
; 1194 :          This is generally because the packets of each precinct are found
; 1195 :          not to be contiguous within the tile-part, or because the presence
; 1196 :          of POC information renders this a likely problem.  If the
; 1197 :          number of quality layers is found to have changed from the point
; 1198 :          when packet length information was first converted into precinct
; 1199 :          lengths and addresses, we must also conclude that address information
; 1200 :          is not available.  A further reason for discarding packet length
; 1201 :          information is if packet headers have been packed into marker
; 1202 :          segments, since this requires that the packets be processed in order
; 1203 :          and once one by one.  If any such determination is made before any
; 1204 :          precinct addresses have been served up, the object is simply
; 1205 :          disabled so that calls to `get_precinct_address' will return 0.
; 1206 :          Otherwise, a terminal error is generated.  In this event, the
; 1207 :          code-stream might need to be opened again with seeking disabled
; 1208 :          so that the present object will never be initialized. */
; 1209 :     kdu_long get_precinct_address()
; 1210 :       { return ((buf_server==NULL)?((kdu_long) 0):pop_address()); }
; 1211 :       /* Returns the address of the next precinct (in the sequence determined
; 1212 :          by the current progression order) in the tile.  This address may be
; 1213 :          used to seek to the relevant location when reading the precinct's
; 1214 :          packets.
; 1215 :             The function returns 0 if seeking is not possible, if
; 1216 :          packet length information cannot be found in the code-stream,
; 1217 :          or if packet length information is not usable for one of a number
; 1218 :          of reasons.  As explained above, packet length information is usable
; 1219 :          only if the packets of a precinct all appear consecutively so that
; 1220 :          each precinct is characterized by only one seeking address.
; 1221 :             The function returns -1 if seeking is possible, but the first
; 1222 :          packet of the precinct belongs to a tile-part which has not yet been
; 1223 :          opened.  In this event, the `kd_tile::read_tile_part_header' member
; 1224 :          function will have to be called until the information becomes
; 1225 :          available. */
; 1226 :   private: // Helper functions
; 1227 :     kdu_long pop_address();
; 1228 :       /* Does all the work of `get_precinct_address'. */
; 1229 :     void disable()
; 1230 :       { // Call to discard contents and cease recording new PLT info.
; 1231 :         if (buf_server == NULL) return;

	cmp	DWORD PTR [esi], 0
	je	SHORT $LN3@kd_precinc

; 1232 :         while ((tail=head) != NULL)

	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], eax
	test	eax, eax
	je	SHORT $LN5@kd_precinc
$LL4@kd_precinc:

; 1233 :           { head = tail->next; buf_server->release(tail); }

	mov	eax, DWORD PTR [esi+8]
	push	DWORD PTR [esi+8]
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR [esi+4], eax
	call	?release@kd_buf_server@@QAEXPAUkd_code_buffer@@@Z ; kd_buf_server::release
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+8], eax
	test	eax, eax
	jne	SHORT $LL4@kd_precinc
$LN5@kd_precinc:

; 1234 :         buf_server = NULL;

	mov	DWORD PTR [esi], 0
$LN3@kd_precinc:

; 1150 :       { disable(); }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1kd_precinct_pointer_server@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-8]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kd_precinct_pointer_server@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kd_precinct_pointer_server@@QAE@XZ ENDP		; kd_precinct_pointer_server::~kd_precinct_pointer_server
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_precinct_pointer_server@@QAE@XZ
_TEXT	SEGMENT
??0kd_precinct_pointer_server@@QAE@XZ PROC		; kd_precinct_pointer_server::kd_precinct_pointer_server, COMDAT
; _this$ = ecx

; 1148 :       { buf_server = NULL; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	ret	0
??0kd_precinct_pointer_server@@QAE@XZ ENDP		; kd_precinct_pointer_server::kd_precinct_pointer_server
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?using_tlm_info@kd_tpart_pointer_server@@QAE_NXZ
_TEXT	SEGMENT
?using_tlm_info@kd_tpart_pointer_server@@QAE_NXZ PROC	; kd_tpart_pointer_server::using_tlm_info, COMDAT
; _this$ = ecx

; 1080 :     bool using_tlm_info() { return translated_tlm_markers; }

	mov	al, BYTE PTR [ecx+12]
	ret	0
?using_tlm_info@kd_tpart_pointer_server@@QAE_NXZ ENDP	; kd_tpart_pointer_server::using_tlm_info
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_max_tparts@kd_tlm_generator@@QAEHXZ
_TEXT	SEGMENT
?get_max_tparts@kd_tlm_generator@@QAEHXZ PROC		; kd_tlm_generator::get_max_tparts, COMDAT
; _this$ = ecx

; 1019 :     int get_max_tparts() { return max_tparts; }

	mov	eax, DWORD PTR [ecx+4]
	ret	0
?get_max_tparts@kd_tlm_generator@@QAEHXZ ENDP		; kd_tlm_generator::get_max_tparts
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?exists@kd_tlm_generator@@QAE_NXZ
_TEXT	SEGMENT
?exists@kd_tlm_generator@@QAE_NXZ PROC			; kd_tlm_generator::exists, COMDAT
; _this$ = ecx

; 1010 :     bool exists() { return (num_tiles > 0); }

	xor	eax, eax
	cmp	DWORD PTR [ecx], eax
	setg	al
	ret	0
?exists@kd_tlm_generator@@QAE_NXZ ENDP			; kd_tlm_generator::exists
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_pp_markers@@QAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_pp_markers@@QAEPAXI@Z PROC			; kd_pp_markers::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_pp_markers@@QAE@XZ		; kd_pp_markers::~kd_pp_markers
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	8
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_pp_markers@@QAEPAXI@Z ENDP			; kd_pp_markers::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_pp_markers@@QAE@XZ
_TEXT	SEGMENT
??0kd_pp_markers@@QAE@XZ PROC				; kd_pp_markers::kd_pp_markers, COMDAT
; _this$ = ecx

; 912  :       { list = NULL; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	ret	0
??0kd_pp_markers@@QAE@XZ ENDP				; kd_pp_markers::kd_pp_markers
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?clear@kd_marker@@QAEXXZ
_TEXT	SEGMENT
?clear@kd_marker@@QAEXXZ PROC				; kd_marker::clear, COMDAT
; _this$ = ecx

; 891  :     void clear() { code = 0; length = 0; encountered_skip_code = false; }

	xor	eax, eax
	mov	WORD PTR [ecx+8], ax
	mov	DWORD PTR [ecx+12], eax
	mov	BYTE PTR [ecx+24], al
	ret	0
?clear@kd_marker@@QAEXXZ ENDP				; kd_marker::clear
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_bytes@kd_marker@@QAEPAEXZ
_TEXT	SEGMENT
?get_bytes@kd_marker@@QAEPAEXZ PROC			; kd_marker::get_bytes, COMDAT
; _this$ = ecx

; 888  :     kdu_byte *get_bytes() { return buf; }

	mov	eax, DWORD PTR [ecx+20]
	ret	0
?get_bytes@kd_marker@@QAEPAEXZ ENDP			; kd_marker::get_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_length@kd_marker@@QAEHXZ
_TEXT	SEGMENT
?get_length@kd_marker@@QAEHXZ PROC			; kd_marker::get_length, COMDAT
; _this$ = ecx

; 884  :     int get_length() { return length; }

	mov	eax, DWORD PTR [ecx+12]
	ret	0
?get_length@kd_marker@@QAEHXZ ENDP			; kd_marker::get_length
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_code@kd_marker@@QAEGXZ
_TEXT	SEGMENT
?get_code@kd_marker@@QAEGXZ PROC			; kd_marker::get_code, COMDAT
; _this$ = ecx

; 882  :     kdu_uint16 get_code() { return code; }

	mov	ax, WORD PTR [ecx+8]
	ret	0
?get_code@kd_marker@@QAEGXZ ENDP			; kd_marker::get_code
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?print_current_code@kd_marker@@QAEXAAVkdu_message@@@Z
_TEXT	SEGMENT
_out$ = 8						; size = 4
?print_current_code@kd_marker@@QAEXAAVkdu_message@@@Z PROC ; kd_marker::print_current_code, COMDAT
; _this$ = ecx

; 850  :       { /* Prints a text string identifying the current marker code. */

	push	ebp
	mov	ebp, esp

; 851  :         print_marker_code(this->code,out);

	push	DWORD PTR _out$[ebp]
	movzx	eax, WORD PTR [ecx+8]
	push	eax
	call	?print_marker_code@@YAXGAAVkdu_message@@@Z ; print_marker_code
	add	esp, 8

; 852  :       }

	pop	ebp
	ret	4
?print_current_code@kd_marker@@QAEXAAVkdu_message@@@Z ENDP ; kd_marker::print_current_code
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_Gkd_pph_input@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_pph_input@@UAEPAXI@Z PROC			; kd_pph_input::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	call	??1kd_pph_input@@UAE@XZ			; kd_pph_input::~kd_pph_input
	test	BYTE PTR ___flags$[ebp], 1
	je	SHORT $LN4@scalar
	push	564					; 00000234H
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN4@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_pph_input@@UAEPAXI@Z ENDP			; kd_pph_input::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_pph_input@@QAE@PAVkd_buf_server@@@Z
_TEXT	SEGMENT
_this$ = -4						; size = 4
_server$ = 8						; size = 4
??0kd_pph_input@@QAE@PAVkd_buf_server@@@Z PROC		; kd_pph_input::kd_pph_input, COMDAT
; _this$ = ecx

; 793  :     kd_pph_input(kd_buf_server *server)

	push	ebp
	mov	ebp, esp
	push	ecx

; 484  :       { first_unread = first_unwritten = buffer+KD_IBUF_PUTBACK;

	lea	eax, DWORD PTR [ecx+10]

; 793  :     kd_pph_input(kd_buf_server *server)

	mov	DWORD PTR _this$[ebp], ecx

; 484  :       { first_unread = first_unwritten = buffer+KD_IBUF_PUTBACK;

	mov	DWORD PTR [ecx+528], eax
	mov	DWORD PTR [ecx+524], eax

; 794  :       { buf_server = server; first_buf = read_buf = write_buf = NULL; }

	mov	eax, DWORD PTR _server$[ebp]
	mov	DWORD PTR [ecx+560], eax
	mov	eax, ecx

; 485  :         exhausted = fully_buffered = throw_markers = false; }

	mov	WORD PTR [ecx+533], 0
	mov	BYTE PTR [ecx+532], 0

; 794  :       { buf_server = server; first_buf = read_buf = write_buf = NULL; }

	mov	DWORD PTR [ecx], OFFSET ??_7kd_pph_input@@6B@
	mov	DWORD PTR [ecx+548], 0
	mov	DWORD PTR [ecx+544], 0
	mov	DWORD PTR [ecx+540], 0
	mov	esp, ebp
	pop	ebp
	ret	4
??0kd_pph_input@@QAE@PAVkd_buf_server@@@Z ENDP		; kd_pph_input::kd_pph_input
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?set_suspend@kd_compressed_input@@QAEX_N@Z
_TEXT	SEGMENT
_limit$2$ = 8						; size = 4
_state$ = 8						; size = 1
?set_suspend@kd_compressed_input@@QAEX_N@Z PROC		; kd_compressed_input::set_suspend, COMDAT
; _this$ = ecx

; 711  :       {

	push	ebp
	mov	ebp, esp

; 712  :         if (special_scope) return;

	cmp	BYTE PTR [ecx+592], 0
	jne	$LN8@set_suspen

; 713  :         if ((suspend_ptr == NULL) && state)

	mov	edx, DWORD PTR [ecx+584]
	mov	al, BYTE PTR _state$[ebp]
	push	esi
	test	edx, edx
	jne	SHORT $LN15@set_suspen
	test	al, al
	je	SHORT $LN3@set_suspen

; 714  :           { // Enter suspended mode
; 715  :             suspend_ptr = first_unread;
; 716  :             if (alt_first_unwritten != NULL)

	mov	esi, DWORD PTR [ecx+588]
	mov	eax, DWORD PTR [ecx+524]
	mov	DWORD PTR [ecx+584], eax
	test	esi, esi
	je	$LN11@set_suspen

; 717  :               {
; 718  :                 assert(alt_first_unwritten > first_unwritten);
; 719  :                 last_loaded_bytes += alt_first_unwritten - first_unwritten;

	mov	eax, esi

; 720  :                 first_unwritten = alt_first_unwritten;
; 721  :                 alt_first_unwritten = NULL;

	mov	DWORD PTR [ecx+588], 0
	sub	eax, DWORD PTR [ecx+528]
	cdq
	add	DWORD PTR [ecx+576], eax
	mov	DWORD PTR [ecx+528], esi
	adc	DWORD PTR [ecx+580], edx
	pop	esi

; 739  :                   }
; 740  :               }
; 741  :           }
; 742  :       }

	pop	ebp
	ret	4
$LN3@set_suspen:

; 722  :               }
; 723  :           }
; 724  :         else if ((suspend_ptr != NULL) && !state)

	test	edx, edx
	je	$LN11@set_suspen
$LN15@set_suspen:
	test	al, al
	jne	$LN11@set_suspen

; 725  :           { // Leave suspended mode
; 726  :             suspended_bytes += first_unread-suspend_ptr;  suspend_ptr = NULL;

	mov	esi, DWORD PTR [ecx+524]
	mov	eax, esi
	sub	eax, edx
	mov	DWORD PTR [ecx+584], 0
	cdq
	add	DWORD PTR [ecx+568], eax

; 727  :             kdu_long limit = suspended_bytes + max_bytes_allowed - cur_offset;

	mov	eax, DWORD PTR [ecx+556]
	adc	DWORD PTR [ecx+572], edx
	mov	edx, DWORD PTR [ecx+552]
	sub	edx, DWORD PTR [ecx+544]
	push	ebx
	sbb	eax, DWORD PTR [ecx+548]
	mov	ebx, DWORD PTR [ecx+572]
	push	edi
	mov	edi, DWORD PTR [ecx+568]
	add	edx, edi
	adc	eax, ebx
	mov	DWORD PTR _limit$2$[ebp], eax

; 728  :             if (limit < last_loaded_bytes)

	cmp	eax, DWORD PTR [ecx+580]
	jg	SHORT $LN12@set_suspen
	jl	SHORT $LN10@set_suspen
	cmp	edx, DWORD PTR [ecx+576]
	jae	SHORT $LN12@set_suspen
$LN10@set_suspen:

; 729  :               { // We have already loaded the buffer with too many bytes
; 730  :                 alt_first_unwritten = first_unwritten;

	mov	eax, DWORD PTR [ecx+528]
	mov	DWORD PTR [ecx+588], eax

; 731  :                 first_unwritten -= (last_loaded_bytes - limit);

	sub	eax, DWORD PTR [ecx+576]
	add	eax, edx

; 732  :                 last_loaded_bytes = limit;

	mov	DWORD PTR [ecx+576], edx
	mov	DWORD PTR [ecx+528], eax

; 733  :                 if (first_unwritten < first_unread)

	mov	edx, DWORD PTR [ecx+528]
	mov	eax, DWORD PTR _limit$2$[ebp]
	mov	DWORD PTR [ecx+580], eax
	cmp	edx, esi
	jae	SHORT $LN12@set_suspen

; 734  :                   { // We have already read past the end.
; 735  :                     exhausted = true;
; 736  :                     suspended_bytes -= (first_unread-first_unwritten);

	mov	eax, esi
	mov	BYTE PTR [ecx+533], 1
	sub	eax, edx

; 737  :                     first_unwritten = first_unread;

	mov	DWORD PTR [ecx+528], esi
	cdq
	sub	edi, eax

; 738  :                     alt_first_unwritten = NULL;

	mov	DWORD PTR [ecx+588], 0
	mov	DWORD PTR [ecx+568], edi
	sbb	ebx, edx
	mov	DWORD PTR [ecx+572], ebx
$LN12@set_suspen:
	pop	edi
	pop	ebx
$LN11@set_suspen:
	pop	esi
$LN8@set_suspen:

; 739  :                   }
; 740  :               }
; 741  :           }
; 742  :       }

	pop	ebp
	ret	4
?set_suspend@kd_compressed_input@@QAEX_N@Z ENDP		; kd_compressed_input::set_suspend
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_offset@kd_compressed_input@@QAE_JXZ
_TEXT	SEGMENT
?get_offset@kd_compressed_input@@QAE_JXZ PROC		; kd_compressed_input::get_offset, COMDAT
; _this$ = ecx

; 667  :            base object's `get' function.  If seeking is enabled, the source
; 668  :            may be repositioned to this point by supplying this address as the
; 669  :            `unique_address' argument to `seek'.  Even if seeking is not
; 670  :            enabled, `get_offset' will return the correct address and this may
; 671  :            be used to determine appropriate arguments for the `ignore' member
; 672  :            function declared below.  May not be called if the source is in
; 673  :            anything other than code-stream scope. */
; 674  :         assert(!special_scope);
; 675  :         return cur_offset + last_loaded_bytes - (first_unwritten-first_unread);

	mov	eax, DWORD PTR [ecx+528]
	sub	eax, DWORD PTR [ecx+524]
	push	esi
	mov	esi, DWORD PTR [ecx+580]
	push	edi
	mov	edi, DWORD PTR [ecx+576]
	cdq
	sub	edi, eax
	sbb	esi, edx
	add	edi, DWORD PTR [ecx+544]
	mov	eax, edi
	adc	esi, DWORD PTR [ecx+548]
	pop	edi
	mov	edx, esi
	pop	esi

; 676  :       }

	ret	0
?get_offset@kd_compressed_input@@QAE_JXZ ENDP		; kd_compressed_input::get_offset
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get_capabilities@kd_compressed_input@@QAEHXZ
_TEXT	SEGMENT
?get_capabilities@kd_compressed_input@@QAEHXZ PROC	; kd_compressed_input::get_capabilities, COMDAT
; _this$ = ecx

; 656  :       { return source->get_capabilities(); }

	mov	ecx, DWORD PTR [ecx+540]
	mov	eax, DWORD PTR [ecx]
	jmp	DWORD PTR [eax+8]
?get_capabilities@kd_compressed_input@@QAEHXZ ENDP	; kd_compressed_input::get_capabilities
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??_Gkd_input@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkd_input@@UAEPAXI@Z PROC				; kd_input::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 486  :     virtual ~kd_input() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kd_input@@6B@
	je	SHORT $LN7@scalar
	push	540					; 0000021cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkd_input@@UAEPAXI@Z ENDP				; kd_input::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?pseudo_read@kd_input@@QAEHAAPAEH@Z
_TEXT	SEGMENT
_addr$ = 8						; size = 4
_count$ = 12						; size = 4
?pseudo_read@kd_input@@QAEHAAPAEH@Z PROC		; kd_input::pseudo_read, COMDAT
; _this$ = ecx

; 572  :       { /* This function should be called only for `fully_buffered' sources.

	push	ebp
	mov	ebp, esp

; 573  :            It behaves like `read', except that it does not actually read
; 574  :            any bytes.  Instead, it puts the address of the block of data
; 575  :            that would have been read into the variable referenced by the
; 576  :            `addr' argument. */
; 577  :         assert(fully_buffered);
; 578  :         addr = first_unread;

	mov	eax, DWORD PTR _addr$[ebp]
	mov	edx, ecx
	mov	ecx, DWORD PTR [edx+524]
	mov	DWORD PTR [eax], ecx

; 579  :         if (throw_markers)

	cmp	BYTE PTR [edx+534], 0
	je	SHORT $LN2@pseudo_rea

; 580  :           return read(addr,count); // Slower path, looks for markers

	mov	DWORD PTR _addr$[ebp], ecx
	mov	ecx, edx

; 586  :           }
; 587  :         return count;
; 588  :       }

	pop	ebp

; 580  :           return read(addr,count); // Slower path, looks for markers

	jmp	?read@kd_input@@QAEHPAEH@Z		; kd_input::read
$LN2@pseudo_rea:

; 581  :         first_unread += count;

	mov	eax, DWORD PTR _count$[ebp]
	add	DWORD PTR [edx+524], eax
	push	esi

; 582  :         if (first_unread > first_unwritten)

	mov	esi, DWORD PTR [edx+528]
	cmp	DWORD PTR [edx+524], esi
	jbe	SHORT $LN3@pseudo_rea

; 583  :           {
; 584  :             count -= (int)(first_unread - first_unwritten);

	mov	ecx, esi

; 585  :             first_unread = first_unwritten; exhausted = true;

	mov	BYTE PTR [edx+533], 1
	sub	ecx, DWORD PTR [edx+524]
	add	eax, ecx
	mov	DWORD PTR [edx+524], esi
$LN3@pseudo_rea:
	pop	esi

; 586  :           }
; 587  :         return count;
; 588  :       }

	pop	ebp
	ret	8
?pseudo_read@kd_input@@QAEHAAPAEH@Z ENDP		; kd_input::pseudo_read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?putback@kd_input@@QAEXE@Z
_TEXT	SEGMENT
_byte$ = 8						; size = 1
?putback@kd_input@@QAEXE@Z PROC				; kd_input::putback, COMDAT
; _this$ = ecx

; 545  :       { /* You may put back more than 1 byte, but you may not call this

	push	ebp
	mov	ebp, esp

; 546  :            function if a previous read has ever failed.  It is also illegal
; 547  :            to call this function while marker throwing is enabled. */
; 548  :         assert(!exhausted);
; 549  :         assert(!throw_markers);
; 550  :         first_unread--;

	dec	DWORD PTR [ecx+524]

; 551  :         if (!fully_buffered)

	cmp	BYTE PTR [ecx+532], 0
	mov	edx, DWORD PTR [ecx+524]
	jne	SHORT $LN2@putback

; 552  :           {
; 553  :             assert(first_unread >= buffer);
; 554  :             *first_unread = byte;

	mov	al, BYTE PTR _byte$[ebp]
	mov	BYTE PTR [edx], al
$LN2@putback:

; 555  :           }
; 556  :       }

	pop	ebp
	ret	4
?putback@kd_input@@QAEXE@Z ENDP				; kd_input::putback
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?get@kd_input@@QAE_NAAE@Z
_TEXT	SEGMENT
_byte$ = 8						; size = 4
?get@kd_input@@QAE_NAAE@Z PROC				; kd_input::get, COMDAT
; _this$ = ecx

; 531  :       { /* Access a single byte, returning false if and only if the source is

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 532  :            exhausted, in which case future calls to `failed' return true. */
; 533  :         if (exhausted || ((first_unread==first_unwritten) && !load_buf()))

	cmp	BYTE PTR [esi+533], 0
	jne	SHORT $LN3@get
	mov	eax, DWORD PTR [esi+524]
	cmp	eax, DWORD PTR [esi+528]
	jne	SHORT $LN2@get
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+8]
	call	eax
	test	al, al
	je	SHORT $LN3@get
$LN2@get:

; 535  :         byte = *(first_unread++);

	mov	eax, DWORD PTR [esi+524]
	push	edi
	mov	edi, DWORD PTR _byte$[ebp]
	mov	al, BYTE PTR [eax]
	mov	BYTE PTR [edi], al
	inc	DWORD PTR [esi+524]

; 536  :         if (throw_markers)

	cmp	BYTE PTR [esi+534], 0
	je	SHORT $LN4@get

; 537  :           {
; 538  :             if (have_FF && (byte > 0x8F))

	cmp	BYTE PTR [esi+535], 0
	je	SHORT $LN5@get
	mov	al, BYTE PTR [edi]
	cmp	al, 143					; 0000008fH
	jbe	SHORT $LN5@get

; 539  :               process_unexpected_marker(byte);

	push	eax
	mov	ecx, esi
	call	?process_unexpected_marker@kd_input@@AAEXE@Z ; kd_input::process_unexpected_marker
$LN5@get:

; 540  :             have_FF = (byte==0xFF);

	cmp	BYTE PTR [edi], 255			; 000000ffH
	sete	al
	mov	BYTE PTR [esi+535], al
$LN4@get:

; 541  :           }
; 542  :         return true;

	pop	edi
	mov	al, 1
	pop	esi

; 543  :       }

	pop	ebp
	ret	4
$LN3@get:

; 534  :           return false; // If `load_buf' fails it sets `exhausted' for us.

	xor	al, al
	pop	esi

; 543  :       }

	pop	ebp
	ret	4
?get@kd_input@@QAE_NAAE@Z ENDP				; kd_input::get
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?failed@kd_input@@QAE_NXZ
_TEXT	SEGMENT
?failed@kd_input@@QAE_NXZ PROC				; kd_input::failed, COMDAT
; _this$ = ecx

; 526  :            `ignore' failed to completely fulfill its objective due to
; 527  :            exhaustion of the relevant source. */
; 528  :         return exhausted;

	mov	al, BYTE PTR [ecx+533]

; 529  :       }

	ret	0
?failed@kd_input@@QAE_NXZ ENDP				; kd_input::failed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?disable_marker_throwing@kd_input@@QAE_NXZ
_TEXT	SEGMENT
?disable_marker_throwing@kd_input@@QAE_NXZ PROC		; kd_input::disable_marker_throwing, COMDAT
; _this$ = ecx

; 509  :            last byte which was read was an FF, in which case the function
; 510  :            returns false.  This allows the caller to catch markers which
; 511  :            were partially read.  Any code-stream segment which is not
; 512  :            permitted to contain a marker code in the range FF90 through FFFF
; 513  :            is also not permitted to terminate with an FF. */
; 514  :         if (!throw_markers) return true;

	cmp	BYTE PTR [ecx+534], 0
	jne	SHORT $LN2@disable_ma
	mov	al, 1

; 518  :       }

	ret	0
$LN2@disable_ma:

; 515  :         throw_markers = false; // Must not touch `reject_all' here.
; 516  :         if (exhausted) have_FF = false;

	cmp	BYTE PTR [ecx+533], 0
	mov	BYTE PTR [ecx+534], 0
	je	SHORT $LN3@disable_ma
	mov	BYTE PTR [ecx+535], 0
$LN3@disable_ma:

; 517  :         return !have_FF;

	xor	eax, eax
	cmp	BYTE PTR [ecx+535], al
	sete	al

; 518  :       }

	ret	0
?disable_marker_throwing@kd_input@@QAE_NXZ ENDP		; kd_input::disable_marker_throwing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?enable_marker_throwing@kd_input@@QAEX_N@Z
_TEXT	SEGMENT
_reject_all$ = 8					; size = 1
?enable_marker_throwing@kd_input@@QAEX_N@Z PROC		; kd_input::enable_marker_throwing, COMDAT
; _this$ = ecx

; 489  :       { /* If `reject_all' is false, subsequent reads will throw an exception

	push	ebp
	mov	ebp, esp

; 490  :            if a bona fide SOP or SOT marker is found. In this case, the
; 491  :            function will check to make sure that the length field is correct,
; 492  :            putting the length field and marker code bytes back to the source
; 493  :            before throwing the exception, so that the catch statement can read
; 494  :            them again.
; 495  :               If `reject_all' is true, subsequent reads will throw an
; 496  :            exception if any marker code in the range FF90 to FFFF is found.
; 497  :            Again, the marker code itself is put back onto the stream before
; 498  :            throwing the exception.
; 499  :               Marker throwing is disabled before throwing an exception for
; 500  :            either of the above reasons.
; 501  :               Note that code-stream reading may be slowed down
; 502  :            when this marker throwing is enabled.  For this reason, the
; 503  :            capability is best used only when error resilience or error
; 504  :            detection capabilities are required. */
; 505  :         this->reject_all = reject_all; throw_markers = true; have_FF = false;

	mov	al, BYTE PTR _reject_all$[ebp]
	mov	BYTE PTR [ecx+536], al
	mov	WORD PTR [ecx+534], 1

; 506  :       }

	pop	ebp
	ret	4
?enable_marker_throwing@kd_input@@QAEX_N@Z ENDP		; kd_input::enable_marker_throwing
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??1kd_input@@UAE@XZ
_TEXT	SEGMENT
??1kd_input@@UAE@XZ PROC				; kd_input::~kd_input, COMDAT
; _this$ = ecx

; 486  :     virtual ~kd_input() { return; }

	mov	DWORD PTR [ecx], OFFSET ??_7kd_input@@6B@
	ret	0
??1kd_input@@UAE@XZ ENDP				; kd_input::~kd_input
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ??0kd_input@@QAE@XZ
_TEXT	SEGMENT
??0kd_input@@QAE@XZ PROC				; kd_input::kd_input, COMDAT
; _this$ = ecx

; 484  :       { first_unread = first_unwritten = buffer+KD_IBUF_PUTBACK;

	lea	eax, DWORD PTR [ecx+10]
	mov	DWORD PTR [ecx], OFFSET ??_7kd_input@@6B@
	mov	DWORD PTR [ecx+528], eax
	mov	DWORD PTR [ecx+524], eax

; 485  :         exhausted = fully_buffered = throw_markers = false; }

	mov	eax, ecx
	mov	WORD PTR [ecx+533], 0
	mov	BYTE PTR [ecx+532], 0
	ret	0
??0kd_input@@QAE@XZ ENDP				; kd_input::kd_input
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?set_codestream_buf_server@kd_thread_buf_server@@QAEXPAVkd_buf_server@@@Z
_TEXT	SEGMENT
_lock$1$ = 8						; size = 4
$T1 = 8							; size = 4
_buf_server$ = 8					; size = 4
?set_codestream_buf_server@kd_thread_buf_server@@QAEXPAVkd_buf_server@@@Z PROC ; kd_thread_buf_server::set_codestream_buf_server, COMDAT
; _this$ = ecx

; 4645 : {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx
	push	edi

; 4646 :   if (buf_server != this->ultimate_buf_server)

	mov	edi, DWORD PTR _buf_server$[ebp]
	cmp	edi, DWORD PTR [esi+24]
	je	SHORT $LN18@set_codest

; 4647 :     {
; 4648 :       env->owner->acquire_lock(KD_THREADLOCK_GENERAL);

	mov	eax, DWORD PTR [esi]
	push	ebx
	mov	ebx, DWORD PTR [eax+128]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [ebx+20]
	mov	ecx, DWORD PTR [ebx+28]
	mov	DWORD PTR _lock$1$[ebp], ecx
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN22@set_codest
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN11@set_codest
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	ecx, DWORD PTR _lock$1$[ebp]
$LN11@set_codest:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [ecx+4], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4649 :       if (ultimate_buf_server != NULL)

	mov	ecx, DWORD PTR [esi+24]
	pop	ebx
	test	ecx, ecx
	je	SHORT $LN3@set_codest

; 4650 :         ultimate_buf_server->detach_thread_buf_server(this);

	push	esi
	call	?detach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z ; kd_buf_server::detach_thread_buf_server
$LN3@set_codest:

; 4651 :       if (buf_server != NULL)

	test	edi, edi
	je	SHORT $LN4@set_codest

; 4652 :         buf_server->attach_thread_buf_server(this);

	push	esi
	mov	ecx, edi
	call	?attach_thread_buf_server@kd_buf_server@@QAEXPAVkd_thread_buf_server@@@Z ; kd_buf_server::attach_thread_buf_server
$LN4@set_codest:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+128]
	mov	eax, DWORD PTR [eax+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN18@set_codest
	pop	edi
	pop	esi
	mov	DWORD PTR _buf_server$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4656 : }

	pop	ebp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	jmp	DWORD PTR __imp__ReleaseMutex@4
$LN18@set_codest:
	pop	edi
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4656 : }

	pop	ebp
	ret	4
$LN22@set_codest:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN24@set_codest:
$LN21@set_codest:
	int	3
?set_codestream_buf_server@kd_thread_buf_server@@QAEXPAVkd_buf_server@@@Z ENDP ; kd_thread_buf_server::set_codestream_buf_server
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?cache_threshold_exceeded@kd_buf_server@@QAE_NXZ
_TEXT	SEGMENT
?cache_threshold_exceeded@kd_buf_server@@QAE_NXZ PROC	; kd_buf_server::cache_threshold_exceeded, COMDAT
; _this$ = ecx

; 289  :       { return (cache_threshold_bytes <

	push	esi
	mov	esi, ecx
	push	0
	push	232					; 000000e8H
	push	DWORD PTR [esi+20]
	push	DWORD PTR [esi+16]
	call	__allmul
	add	eax, DWORD PTR [esi+32]
	adc	edx, DWORD PTR [esi+36]
	cmp	DWORD PTR [esi+52], edx
	jg	SHORT $LN3@cache_thre
	jl	SHORT $LN5@cache_thre
	cmp	DWORD PTR [esi+48], eax
	jae	SHORT $LN3@cache_thre
$LN5@cache_thre:
	mov	al, 1
	pop	esi

; 290  :                 (structure_bytes + num_allocated_pages *
; 291  :                  (KD_CODE_BUFFER_LEN*KDU_CODE_BUFFERS_PER_PAGE))); }

	ret	0
$LN3@cache_thre:

; 289  :       { return (cache_threshold_bytes <

	xor	al, al
	pop	esi

; 290  :                 (structure_bytes + num_allocated_pages *
; 291  :                  (KD_CODE_BUFFER_LEN*KDU_CODE_BUFFERS_PER_PAGE))); }

	ret	0
?cache_threshold_exceeded@kd_buf_server@@QAE_NXZ ENDP	; kd_buf_server::cache_threshold_exceeded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
;	COMDAT ?augment_structure_bytes@kd_buf_server@@QAEX_J@Z
_TEXT	SEGMENT
_increment$ = 8						; size = 8
?augment_structure_bytes@kd_buf_server@@QAEX_J@Z PROC	; kd_buf_server::augment_structure_bytes, COMDAT
; _this$ = ecx

; 279  :       { // Use to adjust the number of structural bytes either up or down

	push	ebp
	mov	ebp, esp

; 280  :         structure_bytes += increment; assert(structure_bytes >= 0);

	mov	eax, DWORD PTR _increment$[ebp]
	add	DWORD PTR [ecx+32], eax
	mov	eax, DWORD PTR _increment$[ebp+4]
	adc	DWORD PTR [ecx+36], eax

; 281  :         if (structure_bytes > peak_structure_bytes)

	mov	edx, DWORD PTR [ecx+36]
	mov	eax, DWORD PTR [ecx+32]
	cmp	edx, DWORD PTR [ecx+44]
	jl	SHORT $LN2@augment_st
	jg	SHORT $LN4@augment_st
	cmp	eax, DWORD PTR [ecx+40]
	jbe	SHORT $LN2@augment_st
$LN4@augment_st:

; 282  :           peak_structure_bytes = structure_bytes;

	mov	DWORD PTR [ecx+40], eax
	mov	DWORD PTR [ecx+44], edx
$LN2@augment_st:

; 283  :       }

	pop	ebp
	ret	8
?augment_structure_bytes@kd_buf_server@@QAEX_J@Z ENDP	; kd_buf_server::augment_structure_bytes
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?get_state@kdu_thread_env@@QAEPAVkd_thread_env@@XZ
_TEXT	SEGMENT
?get_state@kdu_thread_env@@QAEPAVkd_thread_env@@XZ PROC	; kdu_thread_env::get_state, COMDAT
; _this$ = ecx

; 6543 :     kd_thread_env *get_state() { return state; }

	mov	eax, DWORD PTR [ecx+40]
	ret	0
?get_state@kdu_thread_env@@QAEPAVkd_thread_env@@XZ ENDP	; kdu_thread_env::get_state
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?close@kdu_precinct@@QAEXXZ
_TEXT	SEGMENT
?close@kdu_precinct@@QAEXXZ PROC			; kdu_precinct::close, COMDAT
; _this$ = ecx

; 6356 : {

	push	esi
	mov	esi, ecx

; 6357 :   state->ref->close();

	mov	ecx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+4]
	call	?close@kd_precinct_ref@@QAEXXZ		; kd_precinct_ref::close

; 6358 :   state = NULL; // A safety measure.

	mov	DWORD PTR [esi], 0
	pop	esi

; 6359 : }

	ret	0
?close@kdu_precinct@@QAEXXZ ENDP			; kdu_precinct::close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?restart@kdu_precinct@@QAEXXZ
_TEXT	SEGMENT
?restart@kdu_precinct@@QAEXXZ PROC			; kdu_precinct::restart, COMDAT
; _this$ = ecx

; 6341 :   if (state->num_outstanding_blocks > 0)

	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax+24], 0
	jg	SHORT $LN1@restart

; 6342 :     return;
; 6343 :   state->flags &= ~(KD_PFLAG_GENERATING | KD_PFLAG_SIGNIFICANT);

	and	DWORD PTR [eax+8], -130			; ffffff7eH

; 6344 :     // state->generating = false;
; 6345 :     // state->is_significant = false;
; 6346 :   state->cumulative_bytes = 0;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [eax+20], 0

; 6347 :   state->next_layer_idx = 0;

	mov	eax, DWORD PTR [ecx]
	mov	DWORD PTR [eax+16], 0
$LN1@restart:

; 6348 : }

	ret	0
?restart@kdu_precinct@@QAEXXZ ENDP			; kdu_precinct::restart
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_packets@kdu_precinct@@QAE_NHHAAH0PAVkdu_output@@@Z
_TEXT	SEGMENT
_cumulative_packets$GSCopy$1$ = -600			; size = 4
_threshold$1$ = -596					; size = 4
_out$GSCopy$1$ = -592					; size = 4
_cumulative_bytes$GSCopy$1$ = -588			; size = 4
_head$2 = -584						; size = 16
_target$1$ = -568					; size = 4
_this$GSCopy$1$ = -564					; size = 4
_layer_bytes$1$ = -560					; size = 4
_layer_idx$1$ = -556					; size = 4
_res$1$ = -552						; size = 4
_b$3$ = -548						; size = 4
_b$2$ = -548						; size = 4
_b$1$ = -548						; size = 4
tv842 = -544						; size = 4
tv840 = -544						; size = 4
tv835 = -544						; size = 4
_dummy_target$ = -540					; size = 524
__$ArrayPad$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_leading_skip_packets$ = 8				; size = 4
_leading_skip_bytes$ = 12				; size = 4
_cumulative_packets$ = 16				; size = 4
_cumulative_bytes$ = 20					; size = 4
_out$ = 24						; size = 4
?get_packets@kdu_precinct@@QAE_NHHAAH0PAVkdu_output@@@Z PROC ; kdu_precinct::get_packets, COMDAT
; _this$ = ecx

; 6259 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get_packets@kdu_precinct@@QAE_NHHAAH0PAVkdu_output@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 588				; 0000024cH
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	ebx
	push	esi
	push	edi
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx
	mov	DWORD PTR _this$GSCopy$1$[ebp], edi
	mov	eax, DWORD PTR _cumulative_bytes$[ebp]
	mov	esi, DWORD PTR _cumulative_packets$[ebp]
	mov	DWORD PTR _cumulative_bytes$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR _out$[ebp]
	mov	DWORD PTR _out$GSCopy$1$[ebp], eax

; 6260 :   // Now for the implementation of this function.
; 6261 :   if (state->num_outstanding_blocks > 0)

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _cumulative_packets$GSCopy$1$[ebp], esi
	cmp	DWORD PTR [eax+24], 0
	jle	SHORT $LN23@get_packet

; 6262 :     return false;

	xor	al, al
	jmp	$LN1@get_packet
$LN23@get_packet:

; 6263 :   if (!(state->flags & KD_PFLAG_GENERATING))

	test	BYTE PTR [eax+8], 1
	jne	SHORT $LN24@get_packet

; 6264 :     {
; 6265 :       state->cumulative_bytes = 0;

	mov	DWORD PTR [eax+20], 0

; 6266 :       state->next_layer_idx = 0;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+16], 0

; 6267 :       state->flags |= KD_PFLAG_GENERATING;

	mov	eax, DWORD PTR [edi]
	or	DWORD PTR [eax+8], 1

; 6268 :       state->flags &= ~KD_PFLAG_SIGNIFICANT;

	mov	eax, DWORD PTR [edi]
	and	DWORD PTR [eax+8], -129			; ffffff7fH
$LN24@get_packet:

; 6269 :         // state->generating = true;
; 6270 :         // state->is_significant = false;
; 6271 :     }
; 6272 :   if (cumulative_packets > state->required_layers)

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+12]
	cmp	DWORD PTR [esi], eax
	jle	SHORT $LN25@get_packet

; 6273 :     cumulative_packets = state->required_layers;

	mov	DWORD PTR [esi], eax
$LN25@get_packet:

; 6275 :   kd_resolution *res = state->resolution;

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 131  :       { next_buf = buffer; end_buf = buffer+KDU_OBUF_SIZE; }

	lea	eax, DWORD PTR _dummy_target$[ebp+4]
	mov	DWORD PTR _dummy_target$[ebp+516], eax
	lea	eax, DWORD PTR _dummy_target$[ebp+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6275 :   kd_resolution *res = state->resolution;

	mov	DWORD PTR _res$1$[ebp], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 131  :       { next_buf = buffer; end_buf = buffer+KDU_OBUF_SIZE; }

	mov	DWORD PTR _dummy_target$[ebp+520], eax
	mov	DWORD PTR _dummy_target$[ebp], OFFSET ??_7kd_dummy_target@@6B@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6276 :   kd_dummy_target dummy_target; // For discarding layers.

	mov	DWORD PTR __$EHRec$[ebp+8], 0
	npad	6
$LL4@get_packet:

; 6277 :   int layer_bytes, block_bytes;
; 6278 :   for (; (state->next_layer_idx < cumulative_packets) ||

	mov	ecx, DWORD PTR [edi]
	mov	edx, DWORD PTR [ecx+16]
	mov	DWORD PTR _layer_idx$1$[ebp], edx
	cmp	edx, DWORD PTR [esi]
	jl	SHORT $LN26@get_packet
	mov	ebx, DWORD PTR _cumulative_bytes$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [ecx+20]
	cmp	eax, DWORD PTR [ebx]
	mov	ebx, DWORD PTR _res$1$[ebp]
	jge	$LN3@get_packet
$LN26@get_packet:

; 6281 :     {
; 6282 :       int b, n, num_blocks, layer_idx = state->next_layer_idx;
; 6283 :       kdu_uint16 threshold = 0xFFFF - 1 - (kdu_uint16) layer_idx;

	mov	eax, 65534				; 0000fffeH
	sub	eax, edx
	movzx	eax, ax
	mov	DWORD PTR _threshold$1$[ebp], eax

; 6284 :       kdu_output *target = out;

	mov	eax, DWORD PTR _out$GSCopy$1$[ebp]
	mov	DWORD PTR _target$1$[ebp], eax

; 6285 :       if ((layer_idx < leading_skip_packets) ||

	cmp	edx, DWORD PTR _leading_skip_packets$[ebp]
	jl	SHORT $LN28@get_packet
	mov	eax, DWORD PTR _leading_skip_bytes$[ebp]
	cmp	DWORD PTR [ecx+20], eax
	jge	SHORT $LN27@get_packet
$LN28@get_packet:

; 6286 :           (state->cumulative_bytes  < leading_skip_bytes))
; 6287 :         target = &dummy_target; // Discard this packet.

	lea	eax, DWORD PTR _dummy_target$[ebp]
	mov	DWORD PTR _target$1$[ebp], eax
$LN27@get_packet:

; 6290 :       for (b=0; b < res->num_subbands; b++)

	xor	esi, esi
	mov	DWORD PTR _layer_bytes$1$[ebp], 0
	cmp	BYTE PTR [ebx+174], 0
	mov	DWORD PTR _b$1$[ebp], esi
	jbe	$LN6@get_packet

; 6288 : 
; 6289 :       layer_bytes = 0;

	xor	ecx, ecx
	mov	DWORD PTR tv842[ebp], ecx
$LL7@get_packet:

; 6291 :         {
; 6292 :           kd_precinct_band *pband = state->subbands + b;

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax+40]
	add	ebx, ecx

; 6293 :           if (layer_idx == 0)

	test	edx, edx
	jne	SHORT $LN29@get_packet

; 6294 :             kd_block::reset_output_tree(pband->blocks,

	push	DWORD PTR [ebx+16]
	push	DWORD PTR [ebx+12]
	push	DWORD PTR [ebx+20]
	call	?reset_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z ; kd_block::reset_output_tree
	mov	edx, DWORD PTR _layer_idx$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR tv842[ebp]
$LN29@get_packet:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	edi, DWORD PTR [ebx+16]
	imul	edi, DWORD PTR [ebx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6297 :           for (n=0; n < num_blocks; n++)

	test	edi, edi
	jle	SHORT $LN5@get_packet

; 6295 :                                         pband->block_indices.size);
; 6296 :           num_blocks = (int) pband->block_indices.area();

	xor	esi, esi
	npad	9
$LL10@get_packet:

; 6298 :             {
; 6299 :               block_bytes = pband->blocks[n].start_packet(layer_idx,threshold);

	push	DWORD PTR _threshold$1$[ebp]
	mov	ecx, DWORD PTR [ebx+20]
	push	edx
	add	ecx, esi
	call	?start_packet@kd_block@@QAEHHG@Z	; kd_block::start_packet

; 6300 :               layer_bytes += block_bytes;

	add	DWORD PTR _layer_bytes$1$[ebp], eax

; 6301 :               if (block_bytes > 0)

	test	eax, eax
	jle	SHORT $LN8@get_packet

; 6302 :                 state->flags |= KD_PFLAG_SIGNIFICANT;

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax]
	or	DWORD PTR [eax+8], 128			; 00000080H
$LN8@get_packet:

; 6297 :           for (n=0; n < num_blocks; n++)

	mov	edx, DWORD PTR _layer_idx$1$[ebp]
	add	esi, 24					; 00000018H
	sub	edi, 1
	jne	SHORT $LL10@get_packet
	mov	ecx, DWORD PTR tv842[ebp]
	mov	esi, DWORD PTR _b$1$[ebp]
$LN5@get_packet:

; 6290 :       for (b=0; b < res->num_subbands; b++)

	mov	eax, DWORD PTR _res$1$[ebp]
	inc	esi
	mov	edx, DWORD PTR _layer_idx$1$[ebp]
	add	ecx, 24					; 00000018H
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR _b$1$[ebp], esi
	movzx	eax, BYTE PTR [eax+174]
	mov	DWORD PTR tv842[ebp], ecx
	cmp	esi, eax
	jl	$LL7@get_packet
$LN6@get_packet:

; 6311 :       for (b=0; b < res->num_subbands; b++)

	mov	eax, DWORD PTR _res$1$[ebp]
	xor	ecx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }

	mov	esi, DWORD PTR _target$1$[ebp]

; 3558 :     void put_bit(int bit)
; 3559 :       { // Output a header bit
; 3560 :         assert(bit == (bit & 1));
; 3561 :         if (bits_left == 0)
; 3562 :           { if (out != NULL) out->put(byte);
; 3563 :             completed_bytes++;
; 3564 :             bits_left = (byte==0xFF)?7:8;
; 3565 :             byte = 0; }
; 3566 :         byte += byte + bit;

	mov	bl, 1

; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }

	mov	DWORD PTR _head$2[ebp+8], 0
	mov	DWORD PTR _head$2[ebp+12], esi

; 3558 :     void put_bit(int bit)
; 3559 :       { // Output a header bit
; 3560 :         assert(bit == (bit & 1));
; 3561 :         if (bits_left == 0)
; 3562 :           { if (out != NULL) out->put(byte);
; 3563 :             completed_bytes++;
; 3564 :             bits_left = (byte==0xFF)?7:8;
; 3565 :             byte = 0; }
; 3566 :         byte += byte + bit;

	mov	BYTE PTR _head$2[ebp], bl

; 3567 :         bits_left--;

	mov	DWORD PTR _head$2[ebp+4], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6311 :       for (b=0; b < res->num_subbands; b++)

	mov	DWORD PTR _b$2$[ebp], ecx
	cmp	BYTE PTR [eax+174], cl
	jbe	$LN107@get_packet
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }

	xor	esi, esi
	mov	DWORD PTR tv840[ebp], esi
	npad	1
$LL13@get_packet:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6313 :           kd_precinct_band *pband = state->subbands + b;

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax+40]
	add	ebx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	edi, DWORD PTR [ebx+16]
	imul	edi, DWORD PTR [ebx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6315 :           for (n=0; n < num_blocks; n++)

	test	edi, edi
	jle	SHORT $LN11@get_packet

; 6313 :           kd_precinct_band *pband = state->subbands + b;

	xor	esi, esi
$LL16@get_packet:

; 6316 :             pband->blocks[n].write_packet_header(head,layer_idx,false);

	mov	ecx, DWORD PTR [ebx+20]
	lea	eax, DWORD PTR _head$2[ebp]
	push	0
	push	edx
	push	eax
	add	ecx, esi
	call	?write_packet_header@kd_block@@QAEXAAVkd_header_out@@H_N@Z ; kd_block::write_packet_header
	mov	edx, DWORD PTR _layer_idx$1$[ebp]
	add	esi, 24					; 00000018H
	sub	edi, 1
	jne	SHORT $LL16@get_packet
	mov	ecx, DWORD PTR _b$2$[ebp]
	mov	esi, DWORD PTR tv840[ebp]
$LN11@get_packet:

; 6311 :       for (b=0; b < res->num_subbands; b++)

	mov	eax, DWORD PTR _res$1$[ebp]
	inc	ecx
	mov	edx, DWORD PTR _layer_idx$1$[ebp]
	add	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR _b$2$[ebp], ecx
	movzx	eax, BYTE PTR [eax+174]
	mov	DWORD PTR tv840[ebp], esi
	cmp	ecx, eax
	jl	SHORT $LL13@get_packet
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3576 :         if (bits_left < 8)

	cmp	DWORD PTR _head$2[ebp+4], 8
	jge	$LN54@get_packet
	mov	esi, DWORD PTR _head$2[ebp+12]
	mov	bl, BYTE PTR _head$2[ebp]
$LN107@get_packet:

; 3577 :           {
; 3578 :             byte <<= bits_left;

	mov	cl, BYTE PTR _head$2[ebp+4]
	shl	bl, cl
	mov	BYTE PTR _head$2[ebp], bl

; 3579 :             if (out != NULL)

	test	esi, esi
	je	SHORT $LN53@get_packet
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN58@get_packet

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN58@get_packet:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
	mov	esi, DWORD PTR _head$2[ebp+12]
	mov	bl, BYTE PTR _head$2[ebp]
$LN53@get_packet:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3581 :             completed_bytes++;

	inc	DWORD PTR _head$2[ebp+8]

; 3582 :             if (byte == 0xFF)

	cmp	bl, 255					; 000000ffH
	jne	SHORT $LN54@get_packet

; 3583 :               { // Need the stuffing byte.
; 3584 :                 if (out != NULL)

	test	esi, esi
	je	SHORT $LN55@get_packet
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN61@get_packet

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN61@get_packet:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 0
	inc	DWORD PTR [esi+516]
$LN55@get_packet:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3586 :                 completed_bytes++;

	inc	DWORD PTR _head$2[ebp+8]
$LN54@get_packet:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6319 :       if (res->tile_comp->tile->use_eph)

	mov	edi, DWORD PTR _res$1$[ebp]
	mov	esi, DWORD PTR _layer_bytes$1$[ebp]
	add	esi, DWORD PTR _head$2[ebp+8]
	mov	DWORD PTR _layer_bytes$1$[ebp], esi
	mov	eax, DWORD PTR [edi+4]
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+225], 0
	je	SHORT $LN31@get_packet
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	ebx, DWORD PTR _target$1$[ebp]
	mov	eax, DWORD PTR [ebx+516]
	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN66@get_packet

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
$LN66@get_packet:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]
	mov	BYTE PTR [eax], 255			; 000000ffH
	inc	DWORD PTR [ebx+516]
	mov	eax, DWORD PTR [ebx+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [ebx+520]
	jne	SHORT $LN69@get_packet

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [ebx]
	mov	ecx, ebx
	call	DWORD PTR [eax+4]
$LN69@get_packet:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [ebx+516]
	mov	BYTE PTR [eax], 146			; 00000092H
	inc	DWORD PTR [ebx+516]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6320 :         layer_bytes += target->put(KDU_EPH);

	add	esi, 2
	mov	DWORD PTR _layer_bytes$1$[ebp], esi
$LN31@get_packet:

; 6321 :       for (b=0; b < res->num_subbands; b++)

	xor	ecx, ecx
	mov	DWORD PTR _b$3$[ebp], ecx
	cmp	BYTE PTR [edi+174], cl
	jbe	SHORT $LN111@get_packet
	xor	edx, edx
	mov	DWORD PTR tv835[ebp], edx
	npad	8
$LL19@get_packet:

; 6322 :         {
; 6323 :           kd_precinct_band *pband = state->subbands + b;

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	ebx, DWORD PTR [eax+40]
	add	ebx, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	edi, DWORD PTR [ebx+16]
	imul	edi, DWORD PTR [ebx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6325 :           for (n=0; n < num_blocks; n++)

	test	edi, edi
	jle	SHORT $LN17@get_packet

; 6322 :         {
; 6323 :           kd_precinct_band *pband = state->subbands + b;

	xor	esi, esi
	npad	6
$LL22@get_packet:

; 6326 :             pband->blocks[n].write_body_bytes(target);

	mov	ecx, DWORD PTR [ebx+20]
	push	DWORD PTR _target$1$[ebp]
	add	ecx, esi
	call	?write_body_bytes@kd_block@@QAEXPAVkdu_output@@@Z ; kd_block::write_body_bytes
	add	esi, 24					; 00000018H
	sub	edi, 1
	jne	SHORT $LL22@get_packet
	mov	ecx, DWORD PTR _b$3$[ebp]
	mov	edx, DWORD PTR tv835[ebp]
$LN17@get_packet:

; 6321 :       for (b=0; b < res->num_subbands; b++)

	mov	ebx, DWORD PTR _res$1$[ebp]
	inc	ecx
	add	edx, 24					; 00000018H
	mov	DWORD PTR _b$3$[ebp], ecx
	mov	DWORD PTR tv835[ebp], edx
	movzx	eax, BYTE PTR [ebx+174]
	cmp	ecx, eax
	jl	SHORT $LL19@get_packet
	mov	esi, DWORD PTR _layer_bytes$1$[ebp]
	jmp	SHORT $LN2@get_packet
$LN111@get_packet:
	mov	ebx, edi
$LN2@get_packet:

; 6279 :          (state->cumulative_bytes < cumulative_bytes);
; 6280 :          state->next_layer_idx++, state->cumulative_bytes += layer_bytes)

	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [edi]
	inc	DWORD PTR [eax+16]
	mov	eax, DWORD PTR [edi]
	add	DWORD PTR [eax+20], esi
	mov	esi, DWORD PTR _cumulative_packets$GSCopy$1$[ebp]
	jmp	$LL4@get_packet
$LN3@get_packet:

; 6327 :         }
; 6328 :     }
; 6329 :   cumulative_bytes = state->cumulative_bytes;

	mov	ecx, DWORD PTR _cumulative_bytes$GSCopy$1$[ebp]
	mov	DWORD PTR [ecx], eax

; 6330 :   cumulative_packets = state->next_layer_idx;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [esi], eax

; 6331 :   return true;

	mov	al, 1
$LN1@get_packet:

; 6332 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	xor	ecx, ebp
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?get_packets@kdu_precinct@@QAE_NHHAAH0PAVkdu_output@@@Z$0:
	lea	ecx, DWORD PTR _dummy_target$[ebp]
	jmp	??1kd_dummy_target@@UAE@XZ
__ehhandler$?get_packets@kdu_precinct@@QAE_NHHAAH0PAVkdu_output@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-604]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?get_packets@kdu_precinct@@QAE_NHHAAH0PAVkdu_output@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?get_packets@kdu_precinct@@QAE_NHHAAH0PAVkdu_output@@@Z ENDP ; kdu_precinct::get_packets
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?size_packets@kdu_precinct@@QAE_NAAH0AA_N@Z
_TEXT	SEGMENT
_head$1 = -44						; size = 16
_threshold$1$ = -28					; size = 4
_b$2$ = -24						; size = 4
_b$1$ = -24						; size = 4
tv684 = -20						; size = 4
tv681 = -20						; size = 4
_layer_bytes$1$ = -16					; size = 4
_res$1$ = -12						; size = 4
_this$1$ = -8						; size = 4
_layer_idx$1$ = -4					; size = 4
_cumulative_packets$ = 8				; size = 4
_cumulative_bytes$ = 12					; size = 4
_is_significant$ = 16					; size = 4
?size_packets@kdu_precinct@@QAE_NAAH0AA_N@Z PROC	; kdu_precinct::size_packets, COMDAT
; _this$ = ecx

; 6178 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 44					; 0000002cH

; 6179 :   is_significant = false;

	mov	eax, DWORD PTR _is_significant$[ebp]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _this$1$[ebp], edi
	mov	BYTE PTR [eax], 0

; 6180 :   if (state->num_outstanding_blocks > 0)

	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax+24], 0
	jle	SHORT $LN20@size_packe

; 6181 :     return false;

	xor	al, al
	pop	edi

; 6241 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN20@size_packe:

; 6182 :   if (state->flags & KD_PFLAG_GENERATING)

	test	BYTE PTR [eax+8], 1
	je	SHORT $LN21@size_packe

; 6183 :     { // Need to go back to the sizing mode.
; 6184 :       state->cumulative_bytes = 0;

	mov	DWORD PTR [eax+20], 0

; 6185 :       state->next_layer_idx = 0;

	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR [eax+16], 0

; 6186 :       state->flags &= ~(KD_PFLAG_GENERATING | KD_PFLAG_SIGNIFICANT);

	mov	eax, DWORD PTR [edi]
	and	DWORD PTR [eax+8], -130			; ffffff7eH
$LN21@size_packe:

; 6187 :          // state->generating = false;
; 6188 :          // state->is_significant = false;
; 6189 :     }
; 6190 :   assert(state->next_layer_idx <= state->required_layers);
; 6191 :   if (cumulative_packets > state->required_layers)

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _cumulative_packets$[ebp]
	mov	eax, DWORD PTR [eax+12]
	cmp	DWORD PTR [ecx], eax
	jle	SHORT $LN22@size_packe

; 6192 :     cumulative_packets = state->required_layers;

	mov	DWORD PTR [ecx], eax
$LN22@size_packe:

; 6193 : 
; 6194 :   kd_resolution *res = state->resolution;

	mov	eax, DWORD PTR [edi]
	push	ebx
	push	esi
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR _res$1$[ebp], ebx
	npad	7
$LL4@size_packe:

; 6195 :   int layer_bytes, block_bytes;
; 6196 :   for (; (state->next_layer_idx < cumulative_packets) ||

	mov	eax, DWORD PTR [edi]
	mov	edx, DWORD PTR [eax+16]
	mov	DWORD PTR _layer_idx$1$[ebp], edx
	cmp	edx, DWORD PTR [ecx]
	jl	SHORT $LN23@size_packe
	mov	esi, DWORD PTR _cumulative_bytes$[ebp]
	mov	eax, DWORD PTR [eax+20]
	cmp	eax, DWORD PTR [esi]
	jge	$LN3@size_packe
$LN23@size_packe:

; 6201 :       kdu_uint16 threshold = 0xFFFF - 1 - (kdu_uint16) layer_idx;

	mov	eax, 65534				; 0000fffeH

; 6202 : 
; 6203 :       layer_bytes = (res->tile_comp->tile->use_eph)?2:0;

	xor	ecx, ecx
	sub	eax, edx
	movzx	eax, ax
	mov	DWORD PTR _threshold$1$[ebp], eax
	mov	eax, DWORD PTR [ebx+4]
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+225], cl
	mov	eax, 2
	cmovne	ecx, eax

; 6204 :       for (b=0; b < res->num_subbands; b++)

	xor	esi, esi
	cmp	BYTE PTR [ebx+174], 0
	mov	DWORD PTR _layer_bytes$1$[ebp], ecx
	mov	DWORD PTR _b$1$[ebp], esi
	jbe	$LN6@size_packe

; 6199 :     {
; 6200 :       int b, n, num_blocks, layer_idx = state->next_layer_idx;

	xor	ecx, ecx
	mov	DWORD PTR tv684[ebp], ecx
$LL7@size_packe:

; 6205 :         {
; 6206 :           kd_precinct_band *pband = state->subbands + b;

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax+40]
	add	ebx, ecx

; 6207 :           if (layer_idx == 0)

	test	edx, edx
	jne	SHORT $LN24@size_packe

; 6208 :             kd_block::reset_output_tree(pband->blocks,

	push	DWORD PTR [ebx+16]
	push	DWORD PTR [ebx+12]
	push	DWORD PTR [ebx+20]
	call	?reset_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z ; kd_block::reset_output_tree
	mov	edx, DWORD PTR _layer_idx$1$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, DWORD PTR tv684[ebp]
$LN24@size_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	edi, DWORD PTR [ebx+16]
	imul	edi, DWORD PTR [ebx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6211 :           for (n=0; n < num_blocks; n++)

	test	edi, edi
	jle	SHORT $LN5@size_packe

; 6209 :                                         pband->block_indices.size);
; 6210 :           num_blocks = (int) pband->block_indices.area();

	xor	esi, esi
$LL10@size_packe:

; 6212 :             {
; 6213 :               block_bytes = pband->blocks[n].start_packet(layer_idx,threshold);

	push	DWORD PTR _threshold$1$[ebp]
	mov	ecx, DWORD PTR [ebx+20]
	push	edx
	add	ecx, esi
	call	?start_packet@kd_block@@QAEHHG@Z	; kd_block::start_packet

; 6214 :               layer_bytes += block_bytes;

	add	DWORD PTR _layer_bytes$1$[ebp], eax

; 6215 :               if (block_bytes > 0)

	test	eax, eax
	jle	SHORT $LN8@size_packe

; 6216 :                 state->flags |= KD_PFLAG_SIGNIFICANT;

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax]
	or	DWORD PTR [eax+8], 128			; 00000080H
$LN8@size_packe:

; 6211 :           for (n=0; n < num_blocks; n++)

	mov	edx, DWORD PTR _layer_idx$1$[ebp]
	add	esi, 24					; 00000018H
	sub	edi, 1
	jne	SHORT $LL10@size_packe
	mov	ecx, DWORD PTR tv684[ebp]
	mov	esi, DWORD PTR _b$1$[ebp]
$LN5@size_packe:

; 6204 :       for (b=0; b < res->num_subbands; b++)

	mov	eax, DWORD PTR _res$1$[ebp]
	inc	esi
	mov	edx, DWORD PTR _layer_idx$1$[ebp]
	add	ecx, 24					; 00000018H
	mov	edi, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _b$1$[ebp], esi
	movzx	eax, BYTE PTR [eax+174]
	mov	DWORD PTR tv684[ebp], ecx
	cmp	esi, eax
	jl	SHORT $LL7@size_packe
$LN6@size_packe:

; 6223 :       for (b=0; b < res->num_subbands; b++)

	mov	eax, DWORD PTR _res$1$[ebp]
	xor	ecx, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }

	xor	esi, esi
	mov	DWORD PTR _head$1[ebp+8], 0

; 3558 :     void put_bit(int bit)
; 3559 :       { // Output a header bit
; 3560 :         assert(bit == (bit & 1));
; 3561 :         if (bits_left == 0)
; 3562 :           { if (out != NULL) out->put(byte);
; 3563 :             completed_bytes++;
; 3564 :             bits_left = (byte==0xFF)?7:8;
; 3565 :             byte = 0; }
; 3566 :         byte += byte + bit;

	mov	bl, 1

; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }

	mov	DWORD PTR _head$1[ebp+12], esi

; 3558 :     void put_bit(int bit)
; 3559 :       { // Output a header bit
; 3560 :         assert(bit == (bit & 1));
; 3561 :         if (bits_left == 0)
; 3562 :           { if (out != NULL) out->put(byte);
; 3563 :             completed_bytes++;
; 3564 :             bits_left = (byte==0xFF)?7:8;
; 3565 :             byte = 0; }
; 3566 :         byte += byte + bit;

	mov	BYTE PTR _head$1[ebp], bl

; 3567 :         bits_left--;

	mov	DWORD PTR _head$1[ebp+4], 7
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6223 :       for (b=0; b < res->num_subbands; b++)

	mov	DWORD PTR _b$2$[ebp], ecx
	cmp	BYTE PTR [eax+174], cl
	jbe	SHORT $LN76@size_packe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3557 :       { byte = 0; bits_left = 8; completed_bytes = 0; this->out = out; }

	mov	DWORD PTR tv681[ebp], esi
$LL13@size_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6225 :           kd_precinct_band *pband = state->subbands + b;

	mov	eax, DWORD PTR [edi]
	mov	ebx, DWORD PTR [eax+40]
	add	ebx, esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	edi, DWORD PTR [ebx+16]
	imul	edi, DWORD PTR [ebx+12]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6227 :           for (n=0; n < num_blocks; n++)

	test	edi, edi
	jle	SHORT $LN11@size_packe

; 6225 :           kd_precinct_band *pband = state->subbands + b;

	xor	esi, esi
$LL16@size_packe:

; 6228 :             pband->blocks[n].write_packet_header(head,layer_idx,true);

	mov	ecx, DWORD PTR [ebx+20]
	lea	eax, DWORD PTR _head$1[ebp]
	push	1
	push	edx
	push	eax
	add	ecx, esi
	call	?write_packet_header@kd_block@@QAEXAAVkd_header_out@@H_N@Z ; kd_block::write_packet_header
	mov	edx, DWORD PTR _layer_idx$1$[ebp]
	add	esi, 24					; 00000018H
	sub	edi, 1
	jne	SHORT $LL16@size_packe
	mov	ecx, DWORD PTR _b$2$[ebp]
	mov	esi, DWORD PTR tv681[ebp]
$LN11@size_packe:

; 6223 :       for (b=0; b < res->num_subbands; b++)

	mov	eax, DWORD PTR _res$1$[ebp]
	inc	ecx
	mov	edx, DWORD PTR _layer_idx$1$[ebp]
	add	esi, 24					; 00000018H
	mov	edi, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR _b$2$[ebp], ecx
	movzx	eax, BYTE PTR [eax+174]
	mov	DWORD PTR tv681[ebp], esi
	cmp	ecx, eax
	jl	SHORT $LL13@size_packe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3576 :         if (bits_left < 8)

	cmp	DWORD PTR _head$1[ebp+4], 8
	jge	SHORT $LN43@size_packe
	mov	esi, DWORD PTR _head$1[ebp+12]
	mov	bl, BYTE PTR _head$1[ebp]
$LN76@size_packe:

; 3577 :           {
; 3578 :             byte <<= bits_left;

	mov	cl, BYTE PTR _head$1[ebp+4]
	shl	bl, cl
	mov	BYTE PTR _head$1[ebp], bl

; 3579 :             if (out != NULL)

	test	esi, esi
	je	SHORT $LN42@size_packe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN47@size_packe

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN47@size_packe:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl
	inc	DWORD PTR [esi+516]
	mov	esi, DWORD PTR _head$1[ebp+12]
	mov	bl, BYTE PTR _head$1[ebp]
$LN42@size_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3581 :             completed_bytes++;

	inc	DWORD PTR _head$1[ebp+8]

; 3582 :             if (byte == 0xFF)

	cmp	bl, 255					; 000000ffH
	jne	SHORT $LN43@size_packe

; 3583 :               { // Need the stuffing byte.
; 3584 :                 if (out != NULL)

	test	esi, esi
	je	SHORT $LN44@size_packe
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN50@size_packe

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN50@size_packe:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], 0
	inc	DWORD PTR [esi+516]
$LN44@size_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3586 :                 completed_bytes++;

	inc	DWORD PTR _head$1[ebp+8]
$LN43@size_packe:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6231 :       for (b=0; b < res->num_subbands; b++)

	mov	eax, DWORD PTR _res$1$[ebp]
	xor	edi, edi
	mov	ebx, DWORD PTR _layer_bytes$1$[ebp]
	add	ebx, DWORD PTR _head$1[ebp+8]
	mov	DWORD PTR _layer_bytes$1$[ebp], ebx
	cmp	BYTE PTR [eax+174], 0
	jbe	SHORT $LN2@size_packe

; 6229 :         }
; 6230 :       layer_bytes += head.finish();

	xor	esi, esi
	mov	ebx, eax
$LL19@size_packe:

; 6232 :         {
; 6233 :           kd_precinct_band *pband = state->subbands + b;

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+40]

; 6234 :           kd_block::save_output_tree(pband->blocks,pband->block_indices.size);

	push	DWORD PTR [eax+esi+16]
	push	DWORD PTR [eax+esi+12]
	push	DWORD PTR [eax+esi+20]
	call	?save_output_tree@kd_block@@SAXPAV1@Ukdu_coords@@@Z ; kd_block::save_output_tree
	movzx	eax, BYTE PTR [ebx+174]
	lea	esi, DWORD PTR [esi+24]
	inc	edi
	add	esp, 12					; 0000000cH
	cmp	edi, eax
	jl	SHORT $LL19@size_packe
	mov	ebx, DWORD PTR _layer_bytes$1$[ebp]
$LN2@size_packe:

; 6197 :          (state->cumulative_bytes < cumulative_bytes);
; 6198 :          state->next_layer_idx++, state->cumulative_bytes += layer_bytes)

	mov	edi, DWORD PTR _this$1$[ebp]
	mov	ecx, DWORD PTR _cumulative_packets$[ebp]
	mov	eax, DWORD PTR [edi]
	inc	DWORD PTR [eax+16]
	mov	eax, DWORD PTR [edi]
	add	DWORD PTR [eax+20], ebx
	mov	ebx, DWORD PTR _res$1$[ebp]
	jmp	$LL4@size_packe
$LN3@size_packe:

; 6235 :         }
; 6236 :     }
; 6237 :   cumulative_bytes = state->cumulative_bytes;

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax+20]
	mov	DWORD PTR [esi], eax

; 6238 :   cumulative_packets = state->next_layer_idx;

	mov	eax, DWORD PTR [edi]
	pop	esi
	pop	ebx
	mov	eax, DWORD PTR [eax+16]
	mov	DWORD PTR [ecx], eax

; 6239 :   is_significant = ((state->flags & KD_PFLAG_SIGNIFICANT) != 0);

	mov	eax, DWORD PTR [edi]
	mov	ecx, DWORD PTR _is_significant$[ebp]
	pop	edi
	mov	eax, DWORD PTR [eax+8]
	shr	eax, 7
	and	al, 1
	mov	BYTE PTR [ecx], al

; 6240 :   return true;

	mov	al, 1

; 6241 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?size_packets@kdu_precinct@@QAE_NAAH0AA_N@Z ENDP	; kdu_precinct::size_packets
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?close_block@kdu_precinct@@QAEXPAUkdu_block@@PAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_cs$1$ = -4						; size = 4
_result$ = 8						; size = 4
_env$ = 12						; size = 4
?close_block@kdu_precinct@@QAEXPAUkdu_block@@PAVkdu_thread_env@@@Z PROC ; kdu_precinct::close_block, COMDAT
; _this$ = ecx

; 6148 : { // Note that this function can only be called with codestreams created

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx

; 6149 :   // for interchange.
; 6150 :   kd_codestream *cs = state->resolution->codestream;
; 6151 :   kd_block *block = result->block;
; 6152 :   assert((result->precinct == state) && (block != NULL) && block->empty());
; 6153 :   assert(((env == NULL) && (result == cs->block)) ||
; 6154 :          ((env != NULL) && (result == &(env->get_state()->block))));
; 6155 :   result->precinct = NULL;
; 6156 : 
; 6157 :   if (env != NULL)

	mov	ebx, DWORD PTR _env$[ebp]
	push	esi
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax]
	mov	ecx, DWORD PTR [eax]
	mov	eax, DWORD PTR _result$[ebp]
	mov	DWORD PTR _cs$1$[ebp], ecx
	mov	edx, DWORD PTR [eax+156]
	mov	DWORD PTR [eax+152], 0
	test	ebx, ebx
	je	SHORT $LN2@close_bloc
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 6543 :     kd_thread_env *get_state() { return state; }

	mov	ebx, DWORD PTR [ebx+40]
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6161 :         env_state->get_block_state(cs,state,block);

	push	edx
	push	DWORD PTR [esi]
	push	ecx
	mov	ecx, ebx
	call	?get_block_state@kd_thread_env@@QAEPAUkd_thread_block_state@@PAUkd_codestream@@PAUkd_precinct@@PAVkd_block@@@Z ; kd_thread_env::get_block_state
	mov	edi, eax

; 6162 :       env_state->buf_server.set_codestream_buf_server(cs->buf_server);

	lea	esi, DWORD PTR [ebx+33132]
	mov	eax, DWORD PTR _cs$1$[ebp]
	mov	ecx, esi
	push	DWORD PTR [eax+24]
	call	?set_codestream_buf_server@kd_thread_buf_server@@QAEXPAVkd_buf_server@@@Z ; kd_thread_buf_server::set_codestream_buf_server

; 6163 :       block_state->block.store_data(result,&(env_state->buf_server));

	push	esi
	push	DWORD PTR _result$[ebp]
	mov	ecx, edi
	call	?store_data@kd_block@@QAEXPAUkdu_block@@PAVkd_thread_buf_server@@@Z ; kd_block::store_data

; 6164 :       env_state->flush(true); // Hard flush for interchange codestreams

	push	1
	mov	ecx, ebx
	call	?flush@kd_thread_env@@QAEX_N@Z		; kd_thread_env::flush
	pop	edi
	pop	esi
	pop	ebx

; 6169 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@close_bloc:

; 6165 :       return;
; 6166 :     }
; 6167 :   block->store_data(result,cs->buf_server);

	push	DWORD PTR [ecx+24]
	mov	ecx, edx
	push	eax
	call	?store_data@kd_block@@QAEXPAUkdu_block@@PAVkd_buf_server@@@Z ; kd_block::store_data

; 6168 :   state->num_outstanding_blocks--;

	mov	eax, DWORD PTR [esi]
	pop	esi
	pop	ebx
	dec	DWORD PTR [eax+24]

; 6169 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?close_block@kdu_precinct@@QAEXPAUkdu_block@@PAVkdu_thread_env@@@Z ENDP ; kdu_precinct::close_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?open_block@kdu_precinct@@QAEPAUkdu_block@@HUkdu_coords@@PAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_e$2 = -56						; size = 20
$T3 = -52						; size = 16
_band_dims$ = -36					; size = 16
tv391 = -20						; size = 4
_this$1$ = -20						; size = 4
_res$1$ = -16						; size = 4
__$EHRec$ = -12						; size = 12
_subband$1$ = 8						; size = 4
_band_idx$ = 8						; size = 4
_transp$1$ = 11						; size = 1
_block_idx$ = 12					; size = 8
_env$ = 20						; size = 4
?open_block@kdu_precinct@@QAEPAUkdu_block@@HUkdu_coords@@PAVkdu_thread_env@@@Z PROC ; kdu_precinct::open_block, COMDAT
; _this$ = ecx

; 6089 : { // Note that this function can only be called with codestreams created

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?open_block@kdu_precinct@@QAEPAUkdu_block@@HUkdu_coords@@PAVkdu_thread_env@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 44					; 0000002cH
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, ecx
	mov	DWORD PTR _this$1$[ebp], eax

; 6090 :   // for interchange.
; 6091 :   kd_resolution *res = state->resolution;

	mov	eax, DWORD PTR [eax]

; 6092 :   kd_codestream *codestream = res->codestream;
; 6093 :   if (res->res_level > 0)
; 6094 :     band_idx--;

	mov	edi, DWORD PTR _band_idx$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _res$1$[ebp], eax
	cmp	BYTE PTR [eax+12], 0
	mov	ebx, DWORD PTR [eax]
	jbe	SHORT $LN2@open_block
	dec	edi
$LN2@open_block:

; 6095 :   assert((band_idx >= 0) && (band_idx < res->num_subbands));
; 6096 :   if (codestream->transpose)

	mov	cl, BYTE PTR [ebx+329]
	mov	BYTE PTR _transp$1$[ebp], cl
	test	cl, cl
	je	SHORT $LN3@open_block

; 6097 :     band_idx = res->subbands[band_idx].transpose_sequence_idx;

	mov	eax, DWORD PTR [eax+184]
	imul	ecx, edi, 132
	movzx	edi, BYTE PTR [eax+ecx+48]
	mov	cl, BYTE PTR _transp$1$[ebp]
$LN3@open_block:

; 6098 :   block_idx.from_apparent(codestream->transpose,

	mov	al, BYTE PTR [ebx+331]
	mov	dl, BYTE PTR [ebx+330]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	mov	esi, DWORD PTR _block_idx$[ebp+4]
	test	al, al
	je	SHORT $LN12@open_block
	neg	esi
	mov	DWORD PTR _block_idx$[ebp+4], esi
$LN12@open_block:

; 267  :         y=(vflip)?(-y):y;

	test	dl, dl
	mov	edx, DWORD PTR _block_idx$[ebp]
	je	SHORT $LN14@open_block
	neg	edx
	mov	DWORD PTR _block_idx$[ebp], edx
$LN14@open_block:

; 268  :         if (transp) transpose();

	test	cl, cl
	je	SHORT $LN10@open_block

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, edx
	mov	edx, esi
	mov	esi, eax
	mov	DWORD PTR _block_idx$[ebp], edx
	mov	DWORD PTR _block_idx$[ebp+4], esi
$LN10@open_block:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6102 :   kd_subband *subband = res->subbands + band_idx;

	mov	eax, DWORD PTR _res$1$[ebp]
	imul	ecx, edi, 132
	add	ecx, DWORD PTR [eax+184]
	mov	DWORD PTR _subband$1$[ebp], ecx

; 6103 :   kdu_dims band_dims = subband->block_partition;

	movups	xmm1, XMMWORD PTR [ecx+68]

; 6104 :   band_dims.pos.x += block_idx.x*band_dims.size.x;

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	movups	XMMWORD PTR _band_dims$[ebp], xmm1
	movd	ecx, xmm0
	psrldq	xmm1, 4
	movd	eax, xmm1
	imul	ecx, esi
	add	eax, ecx

; 6105 :   band_dims.pos.y += block_idx.y*band_dims.size.y;
; 6106 :   band_dims &= subband->dims;

	lea	ecx, DWORD PTR _band_dims$[ebp]
	mov	DWORD PTR _band_dims$[ebp+4], eax
	mov	eax, DWORD PTR _band_dims$[ebp+8]
	imul	eax, edx
	add	DWORD PTR _band_dims$[ebp], eax
	mov	eax, DWORD PTR _subband$1$[ebp]
	add	eax, 8
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=

; 6107 :   assert(band_dims.area() > 0);
; 6108 : 
; 6109 :   kd_precinct_band *pband = state->subbands + band_idx;

	mov	eax, DWORD PTR _this$1$[ebp]
	lea	ecx, DWORD PTR [edi+edi*2]
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR tv391[ebp], eax
	mov	eax, DWORD PTR [eax+40]
	lea	edx, DWORD PTR [eax+ecx*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	mov	eax, DWORD PTR [edx+8]
	sub	DWORD PTR _block_idx$[ebp+4], eax
	mov	eax, DWORD PTR [edx+4]
	sub	DWORD PTR _block_idx$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6115 :   if (env == NULL)

	mov	eax, DWORD PTR _env$[ebp]
	test	eax, eax
	jne	SHORT $LN4@open_block

; 6116 :     result = codestream->block;

	mov	esi, DWORD PTR [ebx+28]

; 6117 :   else

	jmp	SHORT $LN5@open_block
$LN4@open_block:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 6543 :     kd_thread_env *get_state() { return state; }

	mov	esi, DWORD PTR [eax+40]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6118 :     result = &(env->get_state()->block);

	add	esi, 136				; 00000088H
$LN5@open_block:

; 6119 :   assert(result->precinct == NULL);
; 6120 :   result->precinct = state;

	mov	eax, DWORD PTR tv391[ebp]
	mov	DWORD PTR [esi+152], eax

; 6121 :   result->block = pband->blocks +

	mov	eax, DWORD PTR [edx+16]
	imul	eax, DWORD PTR _block_idx$[ebp]
	add	eax, DWORD PTR _block_idx$[ebp+4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edx+20]
	lea	edx, DWORD PTR [eax+ecx*8]

; 6122 :     block_idx.x + block_idx.y*pband->block_indices.size.x;
; 6123 : 
; 6124 :   // Set up the common fields (common to input and output codestream objects).
; 6125 : 
; 6126 :   result->size = band_dims.size;
; 6127 :   result->region.pos = kdu_coords(0,0);

	mov	DWORD PTR [esi+8], 0
	mov	eax, DWORD PTR _band_dims$[ebp+12]
	mov	ecx, DWORD PTR _band_dims$[ebp+8]
	mov	DWORD PTR [esi+4], eax

; 6128 :   result->region.size = band_dims.size;

	mov	DWORD PTR [esi+20], eax

; 6129 :   result->modes = res->tile_comp->modes;

	mov	eax, DWORD PTR _res$1$[ebp]
	mov	DWORD PTR [esi], ecx
	mov	DWORD PTR [esi+16], ecx

; 6130 :   result->orientation = subband->orientation;

	mov	ecx, DWORD PTR _subband$1$[ebp]
	mov	DWORD PTR [esi+156], edx
	mov	DWORD PTR [esi+12], 0
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+140]
	mov	DWORD PTR [esi+28], eax
	movzx	eax, BYTE PTR [ecx+46]
	mov	DWORD PTR [esi+32], eax

; 6131 :   result->K_max_prime = subband->K_max_prime;

	movzx	eax, BYTE PTR [ecx+51]
	mov	DWORD PTR [esi+40], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3801 :         return first_buf == NULL;

	cmp	DWORD PTR [edx], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6133 :   if (!result->block->empty())

	je	SHORT $LN28@open_block

; 6134 :     { KDU_ERROR_DEV(e,38); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	edx, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0ED@CJMFIANH@Attempting?5to?5open?5the?5same?5code@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6134 :     { KDU_ERROR_DEV(e,38); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [edx+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6137 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN28@open_block:

; 6138 : 
; 6139 :   return result;

	mov	eax, esi

; 6140 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open_block@kdu_precinct@@QAEPAUkdu_block@@HUkdu_coords@@PAVkdu_thread_env@@@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?open_block@kdu_precinct@@QAEPAUkdu_block@@HUkdu_coords@@PAVkdu_thread_env@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-60]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?open_block@kdu_precinct@@QAEPAUkdu_block@@HUkdu_coords@@PAVkdu_thread_env@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?open_block@kdu_precinct@@QAEPAUkdu_block@@HUkdu_coords@@PAVkdu_thread_env@@@Z ENDP ; kdu_precinct::open_block
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_valid_blocks@kdu_precinct@@QAE_NHAAUkdu_dims@@@Z
_TEXT	SEGMENT
_band_idx$ = 8						; size = 4
_indices$ = 12						; size = 4
?get_valid_blocks@kdu_precinct@@QAE_NHAAUkdu_dims@@@Z PROC ; kdu_precinct::get_valid_blocks, COMDAT
; _this$ = ecx

; 6065 : {

	push	ebp
	mov	ebp, esp
	push	esi
	push	edi

; 6066 :   kd_resolution *res = state->resolution;

	mov	edi, DWORD PTR [ecx]

; 6067 :   kd_codestream *codestream = res->codestream;
; 6068 :   if (res->res_level > 0)
; 6069 :     band_idx--;

	mov	ecx, DWORD PTR _band_idx$[ebp]
	mov	edx, DWORD PTR [edi]
	cmp	BYTE PTR [edx+12], 0
	mov	esi, DWORD PTR [edx]
	jbe	SHORT $LN2@get_valid_
	dec	ecx
$LN2@get_valid_:

; 6070 :   if ((band_idx < 0) || (band_idx >= res->num_subbands))

	test	ecx, ecx
	js	$LN4@get_valid_
	movzx	eax, BYTE PTR [edx+174]
	cmp	ecx, eax
	jge	$LN4@get_valid_

; 6072 :   if (codestream->transpose)

	cmp	BYTE PTR [esi+329], 0
	je	SHORT $LN5@get_valid_

; 6073 :     band_idx = res->subbands[band_idx].transpose_sequence_idx;

	mov	eax, DWORD PTR [edx+184]
	imul	ecx, ecx, 132
	movzx	ecx, BYTE PTR [eax+ecx+48]
$LN5@get_valid_:

; 6074 :   indices = state->subbands[band_idx].block_indices;

	mov	eax, DWORD PTR [edi+40]
	lea	ecx, DWORD PTR [ecx+ecx*2]
	mov	edx, DWORD PTR _indices$[ebp]
	push	ebx
	movups	xmm0, XMMWORD PTR [eax+ecx*8+4]
	movups	XMMWORD PTR [edx], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	cmp	BYTE PTR [esi+329], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6075 :   indices.to_apparent(codestream->transpose,

	mov	bl, BYTE PTR [esi+331]
	mov	bh, BYTE PTR [esi+330]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	je	SHORT $LN9@get_valid_

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
$LN9@get_valid_:

; 426  :       if (hflip) pos.x = -(pos.x+size.x-1);

	mov	ecx, 1
	test	bl, bl
	je	SHORT $LN10@get_valid_
	mov	eax, ecx
	sub	eax, DWORD PTR [edx+12]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx+4], eax
$LN10@get_valid_:

; 427  :       if (vflip) pos.y = -(pos.y+size.y-1);

	test	bh, bh
	pop	ebx
	je	SHORT $LN11@get_valid_
	sub	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [edx]
	mov	DWORD PTR [edx], ecx
$LN11@get_valid_:

; 221  :       /* [SYNOPSIS] Swaps the vertical and horizontal coordinates. */
; 222  :     kdu_coords operator+(const kdu_coords &rhs)
; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }
; 224  :     kdu_coords plus(const kdu_coords &rhs)
; 225  :       { /* [SYNOPSIS] Same as `operator+', but more suitable for
; 226  :                       some language bindings. */
; 227  :            return (*this)+rhs;
; 228  :       }
; 229  :     kdu_coords operator-(const kdu_coords &rhs)
; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }
; 231  :     kdu_coords minus(const kdu_coords &rhs)
; 232  :       { /* [SYNOPSIS] Same as `operator-', but more suitable for
; 233  :                       some language bindings. */
; 234  :            return (*this)-rhs;
; 235  :       }
; 236  :     kdu_coords operator+=(const kdu_coords &rhs)
; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }
; 238  :     kdu_coords add(const kdu_coords &rhs)
; 239  :       { /* [SYNOPSIS] Same as `operator+=', but more suitable for some
; 240  :                       language bindings. */
; 241  :         x+=rhs.x; y+=rhs.y; return *this;
; 242  :       }
; 243  :     kdu_coords operator-=(const kdu_coords &rhs)
; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }
; 245  :     kdu_coords subtract(const kdu_coords &rhs)
; 246  :       { /* [SYNOPSIS] Same as `operator-=', but more suitable for some
; 247  :                       language bindings. */
; 248  :         x-=rhs.x; y-=rhs.y; return *this;
; 249  :       }
; 250  :     bool operator==(const kdu_coords &rhs)
; 251  :       { return (x==rhs.x) && (y==rhs.y); }
; 252  :     bool equals(const kdu_coords &rhs)
; 253  :       { /* [SYNOPSIS] Same as `operator==', but more suitable for
; 254  :                       some language bindings. */
; 255  :            return (*this)==rhs;
; 256  :       }
; 257  :     bool operator!=(const kdu_coords &rhs)
; 258  :       { return (x!=rhs.x) || (y!=rhs.y); }
; 259  :     void from_apparent(bool transp, bool vflip, bool hflip)
; 260  :       { /* [SYNOPSIS]
; 261  :              Converts a point from the apparent coordinate system established
; 262  :              by `kdu_codestream::change_appearance' to the real coordinates.
; 263  :              The `transp', `vflip' and `hflip' parameters are identical to
; 264  :              those supplied to `kdu_codestream::change_appearance'.
; 265  :         */
; 266  :         x=(hflip)?(-x):x;
; 267  :         y=(vflip)?(-y):y;
; 268  :         if (transp) transpose();
; 269  :       }
; 270  :     void to_apparent(bool transp, bool vflip, bool hflip)
; 271  :       { /* [SYNOPSIS]
; 272  :              Does the reverse of `from_apparent', assuming the same values
; 273  :              for `transp', `vflip' and `hflip' are supplied.
; 274  :         */
; 275  :         if (transp) transpose();
; 276  :         x = (hflip)?(-x):x;
; 277  :         y = (vflip)?(-y):y;
; 278  :       }
; 279  :   };
; 280  : 
; 281  : /*****************************************************************************/
; 282  : /*                                kdu_dims                                   */
; 283  : /*****************************************************************************/
; 284  : 
; 285  : struct kdu_dims {
; 286  :   /* [BIND: copy]
; 287  :      [SYNOPSIS]
; 288  :        Generic structure for holding location and size information for various
; 289  :        partitions on the canvas.  The `size' coordinates identify the
; 290  :        dimensions of the specific tile, tile-component, precinct, code-block,
; 291  :        etc., while the `pos' coordinates identify the absolute location of
; 292  :        its upper left hand corner.
; 293  :        [//]
; 294  :        When used to describe partitions, the dimensions of the partition
; 295  :        element are maintained by `size', while `pos' holds the anchor
; 296  :        point for the partition.  The anchor point is the absolute coordinates
; 297  :        of the upper left hand corner of a reference partition element. */
; 298  :   public: // Data
; 299  :     kdu_coords pos;
; 300  :       /* [SYNOPSIS] Upper left hand corner. */
; 301  :     kdu_coords size;
; 302  :       /* [SYNOPSIS] Dimensions of rectangle or partition element. */
; 303  :   public: // Convenience functions
; 304  :     kdu_dims() {};
; 305  :     void assign(const kdu_dims &src) { *this = src; }
; 306  :       /* [SYNOPSIS] Copies the contents of `src' to the present object.
; 307  :          This function is useful only when using a language binding
; 308  :          which does not support data member access or direct copying
; 309  :          of contents. */
; 310  :     kdu_coords *access_pos() { return &pos; }
; 311  :       /* [SYNOPSIS] Returns a pointer (reference) to the public
; 312  :          `pos' member.  This is useful when working with a language
; 313  :          binding which does not support data member access.  When
; 314  :          used with the Java language binding, for example, interacting
; 315  :          with the returned object, is equivalent to interacting with
; 316  :          the `pos' member of the present object directly. */
; 317  :     kdu_coords *access_size() { return &size; }
; 318  :       /* [SYNOPSIS] Returns a pointer (reference) to the public
; 319  :          `size' member.  This is useful when working with a language
; 320  :          binding which does not support data member access.  When
; 321  :          used with the Java language binding, for example, interacting
; 322  :          with the returned object, is equivalent to interacting with
; 323  :          the `size' member of the present object directly. */
; 324  :     kdu_long area()
; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }
; 326  :       /* [SYNOPSIS]
; 327  :          Returns the product of the horizontal and vertical dimensions. */
; 328  :     void transpose()
; 329  :       { size.transpose(); pos.transpose(); }
; 330  :       /* [SYNOPSIS]
; 331  :          Swap the roles played by horizontal and vertical coordinates. */
; 332  :     kdu_dims operator&(kdu_dims &rhs) // Intersects region with RHS.
; 333  :       { kdu_dims result = *this; result &= rhs; return result; }
; 334  :       /* [SYNOPSIS]
; 335  :            Returns the intersection of the region represented by `rhs' with
; 336  :            that represented by the current object.
; 337  :       */
; 338  :     kdu_dims intersection(kdu_dims &rhs)
; 339  :       { /* [SYNOPSIS] Same as `operator&', but more appropriate for
; 340  :                       some language bindings. */
; 341  :         return (*this) & rhs;
; 342  :       }
; 343  :     kdu_dims operator&=(kdu_dims &rhs) // Returns intersection of operands
; 344  :       {
; 345  :       /* [SYNOPSIS]
; 346  :            Intersects the region represented by `rhs' with that  represented
; 347  :            by the current object.
; 348  :       */
; 349  :         kdu_coords lim = pos+size;
; 350  :         kdu_coords rhs_lim = rhs.pos + rhs.size;
; 351  :         if (lim.x > rhs_lim.x) lim.x = rhs_lim.x;
; 352  :         if (lim.y > rhs_lim.y) lim.y  = rhs_lim.y;
; 353  :         if (pos.x < rhs.pos.x) pos.x = rhs.pos.x;
; 354  :         if (pos.y < rhs.pos.y) pos.y = rhs.pos.y;
; 355  :         size = lim-pos;
; 356  :         if (size.x < 0) size.x = 0;
; 357  :         if (size.y < 0) size.y = 0;
; 358  :         return *this;
; 359  :       }
; 360  : 
; 361  :     bool intersects(kdu_dims &rhs)
; 362  :       {
; 363  :       /* [SYNOPSIS]
; 364  :            Checks whether or not the region represented by `rhs' has
; 365  :            a non-empty intersection with that represented by the current
; 366  :            object.
; 367  :          [RETURNS]
; 368  :            True if the intersection is non-empty.
; 369  :       */
; 370  :         if ((pos.x+size.x) <= rhs.pos.x) return false;
; 371  :         if ((pos.y+size.y) <= rhs.pos.y) return false;
; 372  :         if (pos.x >= (rhs.pos.x+rhs.size.x)) return false;
; 373  :         if (pos.y >= (rhs.pos.y+rhs.size.y)) return false;
; 374  :         if ((size.x <= 0) || (size.y <= 0) ||
; 375  :             (rhs.size.x <= 0) || (rhs.size.y <= 0))
; 376  :           return false;
; 377  :         return true;
; 378  :       }
; 379  :     bool operator!()
; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	cmp	DWORD PTR [edx+12], 0
	jle	SHORT $LN4@get_valid_
	cmp	DWORD PTR [edx+8], 0
	jle	SHORT $LN4@get_valid_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 6079 :   return true;

	pop	edi
	mov	al, 1
	pop	esi

; 6080 : }

	pop	ebp
	ret	8
$LN4@get_valid_:
	pop	edi

; 6071 :     return false;

	xor	al, al
	pop	esi

; 6080 : }

	pop	ebp
	ret	8
?get_valid_blocks@kdu_precinct@@QAE_NHAAUkdu_dims@@@Z ENDP ; kdu_precinct::get_valid_blocks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_unique_id@kdu_precinct@@QAE_JXZ
_TEXT	SEGMENT
?get_unique_id@kdu_precinct@@QAE_JXZ PROC		; kdu_precinct::get_unique_id, COMDAT
; _this$ = ecx

; 6044 :   kdu_long result = -(1+state->unique_address);

	mov	ecx, DWORD PTR [ecx]
	or	edx, -1
	mov	eax, edx
	sub	eax, DWORD PTR [ecx+32]
	sbb	edx, DWORD PTR [ecx+36]

; 6045 :   assert(result >= 0);
; 6046 :   return result;
; 6047 : }

	ret	0
?get_unique_id@kdu_precinct@@QAE_JXZ ENDP		; kdu_precinct::get_unique_id
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?check_loaded@kdu_precinct@@QAE_NXZ
_TEXT	SEGMENT
?check_loaded@kdu_precinct@@QAE_NXZ PROC		; kdu_precinct::check_loaded, COMDAT
; _this$ = ecx

; 6056 :   return (state->num_outstanding_blocks == 0);

	mov	ecx, DWORD PTR [ecx]
	xor	eax, eax
	cmp	DWORD PTR [ecx+24], eax
	sete	al

; 6057 : }

	ret	0
?check_loaded@kdu_precinct@@QAE_NXZ ENDP		; kdu_precinct::check_loaded
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_precinct@@QAE@PAUkd_precinct@@@Z
_TEXT	SEGMENT
_state$ = 8						; size = 4
??0kdu_precinct@@QAE@PAUkd_precinct@@@Z PROC		; kdu_precinct::kdu_precinct, COMDAT
; _this$ = ecx

; 5571 :     kdu_precinct(kd_precinct *state) { this->state = state; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0kdu_precinct@@QAE@PAUkd_precinct@@@Z ENDP		; kdu_precinct::kdu_precinct
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_conservative_slope_threshold@kdu_subband@@QAEGXZ
_TEXT	SEGMENT
?get_conservative_slope_threshold@kdu_subband@@QAEGXZ PROC ; kdu_subband::get_conservative_slope_threshold, COMDAT
; _this$ = ecx

; 5197 :   kd_codestream *codestream = state->resolution->codestream;

	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	eax, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax]

; 5198 :   kdu_uint16 result = 1;

	mov	eax, 1

; 5199 :   if (codestream->stats != NULL)

	mov	edx, DWORD PTR [esi+32]
	test	edx, edx
	je	SHORT $LN2@get_conser
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 1410 :           (assume_all_coded)?remaining_slope_threshold:block_slope_threshold;

	mov	edx, DWORD PTR [edx+32816]

; 1411 :         val = (val<<4)-1;
; 1412 :         return (kdu_uint16)((val>0)?val:1);

	mov	ecx, eax
	shl	edx, 4
	dec	edx
	movzx	eax, dx
	test	edx, edx
	cmovg	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5200 :     result = codestream->stats->get_conservative_slope_threshold();

	movzx	eax, cx
$LN2@get_conser:

; 5201 :   if (codestream->min_slope_threshold > result)

	movzx	ecx, WORD PTR [esi+384]
	pop	esi
	cmp	cx, ax
	jbe	SHORT $LN3@get_conser

; 5202 :     result = codestream->min_slope_threshold;

	mov	eax, ecx
$LN3@get_conser:

; 5203 :   return result;
; 5204 : }

	ret	0
?get_conservative_slope_threshold@kdu_subband@@QAEGXZ ENDP ; kdu_subband::get_conservative_slope_threshold
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?close_block@kdu_subband@@QAEXPAUkdu_block@@PAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_block$1$ = -4						; size = 4
_result$ = 8						; size = 4
_trim_storage$1$ = 11					; size = 1
_block_state$1$ = 12					; size = 4
_env$ = 12						; size = 4
?close_block@kdu_subband@@QAEXPAUkdu_block@@PAVkdu_thread_env@@@Z PROC ; kdu_subband::close_block, COMDAT
; _this$ = ecx

; 5134 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 5135 :   kd_precinct *precinct = result->precinct;
; 5136 :   kd_block *block = result->block;
; 5137 :   kd_codestream *cs = state->resolution->codestream;

	mov	eax, DWORD PTR [ecx]
	push	ebx
	mov	ebx, DWORD PTR _result$[ebp]
	push	esi
	mov	eax, DWORD PTR [eax+4]
	push	edi
	mov	esi, DWORD PTR [ebx+152]
	mov	edx, DWORD PTR [ebx+156]
	mov	edi, DWORD PTR [eax]

; 5138 :   assert(precinct != NULL);
; 5139 :   assert(((env == NULL) && (result == cs->block)) ||
; 5140 :          ((env != NULL) && (result == &(env->get_state()->block))));
; 5141 :   result->precinct = NULL;
; 5142 : 
; 5143 :   if (env != NULL)

	mov	eax, DWORD PTR _env$[ebp]
	mov	DWORD PTR _block$1$[ebp], edx
	mov	DWORD PTR [ebx+152], 0
	test	eax, eax
	je	$LN2@close_bloc
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 6543 :     kd_thread_env *get_state() { return state; }

	mov	ebx, DWORD PTR [eax+40]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5147 :         env_state->get_block_state(cs,precinct,block);

	mov	ecx, ebx
	push	edx
	push	esi
	push	edi
	call	?get_block_state@kd_thread_env@@QAEPAUkd_thread_block_state@@PAUkd_codestream@@PAUkd_precinct@@PAVkd_block@@@Z ; kd_thread_env::get_block_state

; 5148 :       if (cs->in == NULL)

	cmp	DWORD PTR [edi+4], 0
	mov	DWORD PTR _block_state$1$[ebp], eax
	jne	SHORT $LN5@close_bloc

; 5149 :         { // Update stats and store data, all temporarily
; 5150 :           env_state->buf_server.set_codestream_buf_server(cs->buf_server);

	push	DWORD PTR [edi+24]
	lea	esi, DWORD PTR [ebx+33132]
	mov	ecx, esi
	call	?set_codestream_buf_server@kd_thread_buf_server@@QAEXPAVkd_buf_server@@@Z ; kd_thread_buf_server::set_codestream_buf_server

; 5151 :           block_state->block.store_data(result,&(env_state->buf_server));

	mov	ecx, DWORD PTR _block_state$1$[ebp]
	push	esi
	mov	esi, DWORD PTR _result$[ebp]
	push	esi
	call	?store_data@kd_block@@QAEXPAUkdu_block@@PAVkd_thread_buf_server@@@Z ; kd_block::store_data

; 5152 :           if (cs->stats != NULL)

	cmp	DWORD PTR [edi+32], 0
	je	SHORT $LN4@close_bloc
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4584 :         if ((stats_codestream != cs) && (stats_codestream != NULL))

	mov	eax, DWORD PTR [ebx+33128]
	cmp	eax, edi
	je	SHORT $LN17@close_bloc
	test	eax, eax
	je	SHORT $LN17@close_bloc

; 4585 :           {
; 4586 :             reconcile_stats();

	mov	ecx, ebx
	call	?reconcile_stats@kd_thread_env@@QAEXXZ	; kd_thread_env::reconcile_stats

; 4587 :             stats_codestream = cs;

	mov	DWORD PTR [ebx+33128], edi
$LN17@close_bloc:

; 4588 :           }
; 4589 :         stats.update_stats(blk);

	push	esi
	lea	ecx, DWORD PTR [ebx+296]
	call	?update_stats@kd_compressed_stats@@QAE_NPAUkdu_block@@@Z ; kd_compressed_stats::update_stats
$LN4@close_bloc:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5154 :           if (cs->out == NULL)

	cmp	DWORD PTR [edi+8], 0
	jne	SHORT $LN5@close_bloc

; 5155 :             env_state->flush(true); // Hard flush for interchange codestreams

	push	1
	mov	ecx, ebx
	call	?flush@kd_thread_env@@QAEX_N@Z		; kd_thread_env::flush
$LN5@close_bloc:

; 5156 :         }
; 5157 :       if (env_state->num_outstanding_blocks >=

	cmp	DWORD PTR [ebx+33168], 6
	jl	$LN12@close_bloc

; 5158 :           (KD_THREAD_MAX_OUTSTANDING_BLOCKS-2))
; 5159 :         env_state->flush(false); // Soft flush for non-interchange codestreams

	push	0
	mov	ecx, ebx
	call	?flush@kd_thread_env@@QAEX_N@Z		; kd_thread_env::flush
	pop	edi
	pop	esi
	pop	ebx

; 5188 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@close_bloc:

; 5160 :       return;
; 5161 :     }
; 5162 : 
; 5163 :   assert(precinct->num_outstanding_blocks > 0);
; 5164 :   if (cs->in != NULL)

	cmp	DWORD PTR [edi+4], 0
	je	SHORT $LN7@close_bloc

; 5165 :     { // Release as many resources as we can here.
; 5166 :       if (!cs->persistent)

	cmp	BYTE PTR [edi+337], 0
	jne	SHORT $LN8@close_bloc

; 5167 :         block->cleanup(cs->buf_server);

	push	DWORD PTR [edi+24]
	mov	ecx, edx
	call	?cleanup@kd_block@@QAEXPAVkd_buf_server@@@Z ; kd_block::cleanup
$LN8@close_bloc:

; 5168 :       precinct->num_outstanding_blocks--;

	add	DWORD PTR [esi+24], -1

; 5169 :       if (precinct->num_outstanding_blocks == 0)

	jne	SHORT $LN12@close_bloc

; 5170 :         precinct->release(); // Does nothing unless resources no longer needed

	mov	ecx, esi
	call	?release@kd_precinct@@QAEXXZ		; kd_precinct::release
	pop	edi
	pop	esi
	pop	ebx

; 5188 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN7@close_bloc:

; 5171 :       return;
; 5172 :     }
; 5173 : 
; 5174 :   // If we get here, we have an output block.
; 5175 :   bool trim_storage = false;
; 5176 :   if (cs->stats != NULL)

	mov	ecx, DWORD PTR [edi+32]
	mov	BYTE PTR _trim_storage$1$[ebp], 0
	test	ecx, ecx
	je	SHORT $LN10@close_bloc

; 5177 :     {
; 5178 :       trim_storage = cs->stats->update_stats(result);

	push	ebx
	call	?update_stats@kd_compressed_stats@@QAE_NPAUkdu_block@@@Z ; kd_compressed_stats::update_stats

; 5179 :       cs->stats->update_quant_slope_thresholds();

	mov	ecx, DWORD PTR [edi+32]
	mov	BYTE PTR _trim_storage$1$[ebp], al
	call	?update_quant_slope_thresholds@kd_compressed_stats@@QAEXXZ ; kd_compressed_stats::update_quant_slope_thresholds
	mov	edx, DWORD PTR _block$1$[ebp]
$LN10@close_bloc:

; 5180 :     }
; 5181 :   assert(block->empty());
; 5182 :   block->store_data(result,cs->buf_server);

	push	DWORD PTR [edi+24]
	mov	ecx, edx
	push	ebx
	call	?store_data@kd_block@@QAEXPAUkdu_block@@PAVkd_buf_server@@@Z ; kd_block::store_data

; 5183 :   precinct->num_outstanding_blocks--;

	dec	DWORD PTR [esi+24]

; 5184 :   if (trim_storage && !cs->header_generated)

	cmp	BYTE PTR _trim_storage$1$[ebp], 0
	je	SHORT $LN11@close_bloc
	cmp	BYTE PTR [edi+343], 0
	jne	SHORT $LN11@close_bloc

; 5185 :     cs->trim_compressed_data();

	mov	ecx, edi
	call	?trim_compressed_data@kd_codestream@@QAEXXZ ; kd_codestream::trim_compressed_data
$LN11@close_bloc:

; 5186 :   if (precinct->num_outstanding_blocks == 0)

	cmp	DWORD PTR [esi+24], 0
	jne	SHORT $LN12@close_bloc

; 5187 :     precinct->resolution->rescomp->add_ready_precinct(precinct);

	mov	ecx, DWORD PTR [esi]
	push	esi
	mov	ecx, DWORD PTR [ecx+8]
	call	?add_ready_precinct@kd_global_rescomp@@QAEXPAUkd_precinct@@@Z ; kd_global_rescomp::add_ready_precinct
$LN12@close_bloc:
	pop	edi
	pop	esi
	pop	ebx

; 5188 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?close_block@kdu_subband@@QAEXPAUkdu_block@@PAVkdu_thread_env@@@Z ENDP ; kdu_subband::close_block
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
$T2 = -164						; size = 16
$T3 = -148						; size = 16
$T4 = -132						; size = 16
_e$5 = -116						; size = 20
_e$6 = -96						; size = 20
_seq_res$7 = -76					; size = 4
$T8 = -72						; size = 4
tv969 = -68						; size = 4
$T9 = -64						; size = 4
_band_dims$ = -60					; size = 16
_seq_idx$10 = -44					; size = 8
_precinct_idx$ = -44					; size = 8
_lock$1$ = -36						; size = 4
_precinct_idx$2$ = -36					; size = 4
_lock$1$ = -32						; size = 4
tv846 = -32						; size = 4
_this$1$ = -28						; size = 4
_res$1$ = -24						; size = 4
_codestream$1$ = -20					; size = 4
_have_lock$1$ = -13					; size = 1
__$EHRec$ = -12						; size = 12
_block_idx$ = 8						; size = 8
_return_tpart$ = 16					; size = 4
_disc_passes$1$ = 20					; size = 4
_env$ = 20						; size = 4
?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z PROC ; kdu_subband::open_block, COMDAT
; _this$ = ecx

; 4978 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 152				; 00000098H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, ecx
	mov	DWORD PTR _this$1$[ebp], eax

; 4979 :   kd_resolution *res = state->resolution;

	mov	edi, DWORD PTR [eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	mov	esi, DWORD PTR _block_idx$[ebp+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4979 :   kd_resolution *res = state->resolution;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _res$1$[ebp], eax

; 4980 :   kd_codestream *codestream = res->codestream;

	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR _codestream$1$[ebp], ebx

; 4981 :   block_idx.from_apparent(codestream->transpose,

	mov	al, BYTE PTR [ebx+331]
	mov	dl, BYTE PTR [ebx+330]
	mov	cl, BYTE PTR [ebx+329]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	test	al, al
	je	SHORT $LN28@open_block
	neg	esi
	mov	DWORD PTR _block_idx$[ebp+4], esi
$LN28@open_block:

; 267  :         y=(vflip)?(-y):y;

	test	dl, dl
	mov	edx, DWORD PTR _block_idx$[ebp]
	je	SHORT $LN30@open_block
	neg	edx
	mov	DWORD PTR _block_idx$[ebp], edx
$LN30@open_block:

; 268  :         if (transp) transpose();

	test	cl, cl
	je	SHORT $LN26@open_block

; 210  :     kdu_coords(int x, int y) {this->x=x; this->y=y; }
; 211  :     void assign(const kdu_coords &src) { *this = src; }
; 212  :       /* [SYNOPSIS] Copies the contents of `src' to the present object.
; 213  :          This function is useful only when using a language binding
; 214  :          which does not support data member access or direct copying
; 215  :          of contents. */
; 216  :     int get_x() { return x; }
; 217  :     int get_y() { return y; }
; 218  :     void set_x(int x) { this->x = x; }
; 219  :     void set_y(int y) { this->y = y; }
; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, edx
	mov	edx, esi
	mov	esi, eax
	mov	DWORD PTR _block_idx$[ebp], edx
	mov	DWORD PTR _block_idx$[ebp+4], esi
$LN26@open_block:

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	sub	esi, DWORD PTR [edi+104]
	mov	DWORD PTR _block_idx$[ebp+4], esi
	sub	edx, DWORD PTR [edi+100]
	mov	DWORD PTR _block_idx$[ebp], edx

; 221  :       /* [SYNOPSIS] Swaps the vertical and horizontal coordinates. */
; 222  :     kdu_coords operator+(const kdu_coords &rhs)
; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }
; 224  :     kdu_coords plus(const kdu_coords &rhs)
; 225  :       { /* [SYNOPSIS] Same as `operator+', but more suitable for
; 226  :                       some language bindings. */
; 227  :            return (*this)+rhs;
; 228  :       }
; 229  :     kdu_coords operator-(const kdu_coords &rhs)
; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }
; 231  :     kdu_coords minus(const kdu_coords &rhs)
; 232  :       { /* [SYNOPSIS] Same as `operator-', but more suitable for
; 233  :                       some language bindings. */
; 234  :            return (*this)-rhs;
; 235  :       }
; 236  :     kdu_coords operator+=(const kdu_coords &rhs)
; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	add	esi, DWORD PTR [edi+104]
	mov	DWORD PTR _block_idx$[ebp+4], esi
	add	edx, DWORD PTR [edi+100]
	mov	DWORD PTR _block_idx$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4992 :   precinct_idx.x >>= state->log2_blocks_per_precinct.x;

	mov	ecx, DWORD PTR [edi+128]
	mov	DWORD PTR _precinct_idx$[ebp+4], esi
	sar	esi, cl

; 4993 :   precinct_idx.y >>= state->log2_blocks_per_precinct.y;

	mov	ecx, DWORD PTR [edi+124]
	sar	edx, cl

; 4996 :   kd_tile *tile = res->tile_comp->tile;

	mov	ecx, DWORD PTR _res$1$[ebp]
	mov	eax, DWORD PTR [ecx+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	sub	edx, DWORD PTR [ecx+136]
	sub	esi, DWORD PTR [ecx+140]
	mov	DWORD PTR _precinct_idx$2$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4996 :   kd_tile *tile = res->tile_comp->tile;

	mov	ebx, DWORD PTR [eax+4]

; 5000 :     precinct_idx.x + precinct_idx.y*res->precinct_indices.size.x;

	mov	eax, DWORD PTR [ecx+148]
	imul	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4745 :   volatile kdu_long *state_ref = &state;

	mov	edx, DWORD PTR [ecx+180]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5000 :     precinct_idx.x + precinct_idx.y*res->precinct_indices.size.x;

	add	eax, esi

; 5002 :   kd_precinct *precinct = res->precinct_refs[precinct_num].active_deref();

	shl	eax, 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4745 :   volatile kdu_long *state_ref = &state;

	add	edx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5002 :   kd_precinct *precinct = res->precinct_refs[precinct_num].active_deref();

	mov	DWORD PTR tv969[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4746 :   register kdu_long state_val = *state_ref;

	mov	edi, DWORD PTR [edx]

; 4747 :   if ((state_val & 1) || (state_val == 0)) return NULL;

	mov	eax, edi
	mov	ecx, DWORD PTR [edx+4]
	and	eax, 1
	or	eax, 0
	jne	SHORT $LN42@open_block
	mov	eax, edi
	or	eax, ecx
	je	SHORT $LN42@open_block

; 4749 :   if (result->flags & (KD_PFLAG_INACTIVE|KD_PFLAG_RELEASED)) return NULL;

	test	BYTE PTR [edi+8], 48			; 00000030H
	je	SHORT $LN43@open_block
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5003 :   bool have_lock = false;

	xor	cl, cl
	mov	BYTE PTR _have_lock$1$[ebp], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4749 :   if (result->flags & (KD_PFLAG_INACTIVE|KD_PFLAG_RELEASED)) return NULL;

	jmp	SHORT $LN109@open_block
$LN43@open_block:

; 4750 :   return (*state_ref == _addr_to_kdu_long(result))?result:NULL;

	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv846[ebp], eax
	mov	eax, edi
	cdq
	cmp	ecx, eax
	jne	SHORT $LN42@open_block
	cmp	DWORD PTR tv846[ebp], edx
	je	SHORT $LN40@open_block
$LN42@open_block:

; 4747 :   if ((state_val & 1) || (state_val == 0)) return NULL;

	xor	edi, edi
$LN40@open_block:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5003 :   bool have_lock = false;

	xor	cl, cl
	mov	BYTE PTR _have_lock$1$[ebp], cl

; 5004 :   if (precinct == NULL)

	test	edi, edi
	jne	$LN6@open_block
$LN109@open_block:

; 5005 :     { // Need to lock general mutex and open the precinct.
; 5006 :       if (env != NULL)

	mov	edi, DWORD PTR _env$[ebp]
	test	edi, edi
	je	SHORT $LN49@open_block
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [edi+20]
	mov	ecx, DWORD PTR [edi+28]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5008 :           have_lock = true;

	mov	BYTE PTR _have_lock$1$[ebp], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1024 :       { kd_thread_lock *lock = locks + lock_id;

	mov	DWORD PTR _lock$1$[ebp], ecx

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	cmp	BYTE PTR [eax], 0
	je	SHORT $LN48@open_block
	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T9[ebp], eax
	lea	eax, DWORD PTR $T9[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN124@open_block:
$LN48@open_block:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN52@open_block
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	ecx, DWORD PTR _lock$1$[ebp]
$LN52@open_block:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [ecx+4], edi
$LN49@open_block:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5011 :       precinct = res->precinct_refs[precinct_num].open(res,precinct_idx,true);

	mov	edx, DWORD PTR _res$1$[ebp]
	mov	edx, DWORD PTR [edx+180]
	add	edx, DWORD PTR tv969[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4722 :   if (state == 3)

	mov	ecx, DWORD PTR [edx]
	mov	edi, DWORD PTR [edx+4]
	cmp	ecx, 3
	jne	SHORT $LN56@open_block
	test	edi, edi
	je	SHORT $LN110@open_block
$LN56@open_block:

; 4723 :     return NULL; // Precinct is not currently loaded
; 4724 :   if ((state == 0) || (state & 1))

	mov	eax, ecx
	or	eax, edi
	je	SHORT $LN58@open_block
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN58@open_block

; 4726 :   kd_precinct *result = (kd_precinct *) _kdu_long_to_addr(state);

	mov	edi, DWORD PTR [edx]

; 4727 :   if (result->flags & KD_PFLAG_INACTIVE)

	mov	eax, DWORD PTR [edi+8]
	test	al, 32					; 00000020H
	je	SHORT $LN59@open_block

; 4728 :     { // Must be on the inactive list
; 4729 :       result->size_class->withdraw_from_inactive_list(result);

	mov	ecx, DWORD PTR [edi+52]
	push	edi
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list

; 4730 :       result->activate();

	mov	ecx, edi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate
	jmp	SHORT $LN55@open_block
$LN59@open_block:

; 4731 :     }
; 4732 :   else if (need_activate && (result->flags & KD_PFLAG_RELEASED))

	test	al, 16					; 00000010H
	je	SHORT $LN55@open_block

; 4733 :     result->activate();

	mov	ecx, edi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate

; 4734 :   return result;

	jmp	SHORT $LN55@open_block
$LN58@open_block:

; 4725 :     return instantiate_precinct(res,pos_idx);

	push	esi
	push	DWORD PTR _precinct_idx$2$[ebp]
	mov	ecx, edx
	push	DWORD PTR _res$1$[ebp]
	call	?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z ; kd_precinct_ref::instantiate_precinct
	mov	edi, eax
$LN55@open_block:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5012 :       if (precinct == NULL)

	test	edi, edi
	jne	SHORT $LN119@open_block
$LN110@open_block:

; 5013 :         { KDU_ERROR_DEV(e,23); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$6[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$6[ebp]
	lea	ecx, DWORD PTR _e$6[ebp]
	push	OFFSET ??_C@_0NN@MFAEJGKE@You?5are?5permitted?5to?5open?5each?5c@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5013 :         { KDU_ERROR_DEV(e,23); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5018 :         }

	lea	ecx, DWORD PTR _e$6[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN119@open_block:
	mov	cl, BYTE PTR _have_lock$1$[ebp]
$LN6@open_block:

; 5019 :     }
; 5020 : 
; 5021 :   // Load the precinct if necessary.
; 5022 :   if ((codestream->in != NULL) &&

	mov	esi, DWORD PTR _codestream$1$[ebp]
	cmp	DWORD PTR [esi+4], 0
	je	$LN7@open_block
	mov	eax, DWORD PTR [edi+20]
	cmp	eax, DWORD PTR [edi+12]
	jge	$LN7@open_block

; 5023 :       (precinct->num_packets_read < precinct->required_layers))
; 5024 :     {
; 5025 :       if ((env != NULL) && !have_lock)

	mov	eax, DWORD PTR _env$[ebp]
	test	eax, eax
	je	SHORT $LN67@open_block
	test	cl, cl
	jne	SHORT $LN67@open_block
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax+28]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5027 :           have_lock = true;

	mov	BYTE PTR _have_lock$1$[ebp], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1024 :       { kd_thread_lock *lock = locks + lock_id;

	mov	DWORD PTR _lock$1$[ebp], edx

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN66@open_block
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T8[ebp], eax
	lea	eax, DWORD PTR $T8[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN125@open_block:
$LN66@open_block:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $LN70@open_block
	push	-1
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	eax, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR _lock$1$[ebp]
$LN70@open_block:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edx+4], eax
$LN67@open_block:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5030 :       if (!codestream->cached)

	cmp	BYTE PTR [esi+338], 0
	jne	$LN13@open_block
$LN123@open_block:

; 5031 :         {
; 5032 :           while ((!tile->exhausted) &&

	cmp	BYTE PTR [ebx+268], 0
	jne	$LN112@open_block
	mov	eax, DWORD PTR [edi+16]
	cmp	eax, DWORD PTR [edi+12]
	jge	$LN112@open_block

; 5033 :                  (precinct->next_layer_idx < precinct->required_layers))
; 5034 :             {
; 5035 :               if ((tile != codestream->active_tile) &&

	cmp	ebx, DWORD PTR [esi+364]
	je	SHORT $LN10@open_block
	mov	ecx, ebx
	call	?read_tile_part_header@kd_tile@@QAE_NXZ	; kd_tile::read_tile_part_header
	test	al, al
	je	$LN106@open_block
$LN10@open_block:

; 5045 :                 tile->sequencer->next_in_sequence(seq_res,seq_idx);

	mov	ecx, DWORD PTR [ebx+52]
	lea	eax, DWORD PTR _seq_idx$10[ebp]
	push	eax
	lea	eax, DWORD PTR _seq_res$7[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _seq_idx$10[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5045 :                 tile->sequencer->next_in_sequence(seq_res,seq_idx);

	push	eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _seq_idx$10[ebp+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5045 :                 tile->sequencer->next_in_sequence(seq_res,seq_idx);

	call	?next_in_sequence@kd_packet_sequencer@@QAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_sequence
	mov	edx, eax

; 5046 :               if ((seq_ref == NULL) ||

	test	edx, edx
	je	SHORT $LN12@open_block
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4661 :   register kdu_long state_val = state;

	mov	ecx, DWORD PTR [edx]

; 4662 :   return ((state_val != 0) &&

	mov	eax, ecx
	mov	esi, DWORD PTR [edx+4]
	or	eax, esi
	je	SHORT $LN77@open_block
	mov	eax, ecx
	and	eax, 1
	or	eax, 0
	jne	SHORT $LN11@open_block
	test	BYTE PTR [ecx+8], 4
	jne	SHORT $LN11@open_block
$LN77@open_block:

; 4722 :   if (state == 3)

	cmp	ecx, 3
	jne	SHORT $LN80@open_block
	test	esi, esi
	je	SHORT $LN79@open_block
$LN80@open_block:

; 4723 :     return NULL; // Precinct is not currently loaded
; 4724 :   if ((state == 0) || (state & 1))

	mov	eax, ecx
	or	eax, esi
	je	SHORT $LN82@open_block
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN82@open_block

; 4726 :   kd_precinct *result = (kd_precinct *) _kdu_long_to_addr(state);

	mov	esi, DWORD PTR [edx]

; 4727 :   if (result->flags & KD_PFLAG_INACTIVE)

	test	BYTE PTR [esi+8], 32			; 00000020H
	je	SHORT $LN79@open_block

; 4728 :     { // Must be on the inactive list
; 4729 :       result->size_class->withdraw_from_inactive_list(result);

	mov	ecx, DWORD PTR [esi+52]
	push	esi
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list

; 4730 :       result->activate();

	mov	ecx, esi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate

; 4734 :   return result;

	jmp	SHORT $LN79@open_block
$LN82@open_block:

; 4725 :     return instantiate_precinct(res,pos_idx);

	push	DWORD PTR _seq_idx$10[ebp+4]
	mov	ecx, edx
	push	DWORD PTR _seq_idx$10[ebp]
	push	DWORD PTR _seq_res$7[ebp]
	call	?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z ; kd_precinct_ref::instantiate_precinct
	mov	esi, eax
$LN79@open_block:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5046 :               if ((seq_ref == NULL) ||

	mov	ecx, esi
	call	?desequence_packet@kd_precinct@@QAE_NXZ	; kd_precinct::desequence_packet
	test	al, al
	jne	SHORT $LN11@open_block
$LN12@open_block:

; 5047 :                   !(seq_ref->is_desequenced() ||
; 5048 :                     seq_ref->open(seq_res,seq_idx,false)->desequence_packet()))
; 5049 :                 tile->read_tile_part_header();

	mov	ecx, ebx
	call	?read_tile_part_header@kd_tile@@QAE_NXZ	; kd_tile::read_tile_part_header
$LN11@open_block:

; 5031 :         {
; 5032 :           while ((!tile->exhausted) &&

	mov	esi, DWORD PTR _codestream$1$[ebp]
	jmp	$LN123@open_block
$LN106@open_block:

; 5036 :                   !tile->read_tile_part_header())
; 5037 :                 {
; 5038 :                   assert(!tile->closed); // Otherwise, we could delete ourself.
; 5039 :                   tile->finished_reading();

	mov	ecx, ebx
	call	?finished_reading@kd_tile@@QAE_NXZ	; kd_tile::finished_reading
$LN112@open_block:

; 5050 :             }
; 5051 :           if ((precinct->num_packets_read == 0) &&
; 5052 :               (codestream->active_tile != NULL) &&

	cmp	DWORD PTR [edi+20], 0
	jne	SHORT $LN13@open_block
	mov	eax, DWORD PTR [esi+364]
	test	eax, eax
	je	SHORT $LN13@open_block
	cmp	BYTE PTR [eax+231], 0
	jne	SHORT $LN13@open_block

; 5053 :               !codestream->active_tile->is_addressable)
; 5054 :             { // Strange situation in which `precinct' has a seek address, but
; 5055 :               // the `active_tile' does not have seek addresses; must fully
; 5056 :               // desequence it before doing any seeking.
; 5057 :               kd_tile *active=codestream->active_tile;  assert(active != tile);
; 5058 :               desequence_packets_until_tile_inactive(active,codestream);

	push	esi
	push	eax
	call	?desequence_packets_until_tile_inactive@@YAXPAUkd_tile@@PAUkd_codestream@@@Z ; desequence_packets_until_tile_inactive
	add	esp, 8
$LN13@open_block:

; 5059 :             }
; 5060 :         }
; 5061 :       precinct->load_required_packets(); // In case they are not already in.

	mov	ecx, edi
	call	?load_required_packets@kd_precinct@@QAEXXZ ; kd_precinct::load_required_packets
$LN7@open_block:

; 5064 :   if (have_lock)

	cmp	BYTE PTR _have_lock$1$[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	ebx, DWORD PTR _env$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5064 :   if (have_lock)

	je	SHORT $LN91@open_block
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [ebx+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN91@open_block
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN91@open_block:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5068 :   kdu_dims band_dims = state->block_partition;

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	edx, DWORD PTR [eax]
	movups	xmm1, XMMWORD PTR [edx+68]

; 5069 :   band_dims.pos.x += block_idx.x*band_dims.size.x;

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	movups	XMMWORD PTR _band_dims$[ebp], xmm1
	movd	ecx, xmm0
	psrldq	xmm1, 4
	movd	eax, xmm1
	imul	ecx, DWORD PTR _block_idx$[ebp+4]
	add	eax, ecx

; 5070 :   band_dims.pos.y += block_idx.y*band_dims.size.y;
; 5071 :   band_dims &= state->dims;

	lea	ecx, DWORD PTR _band_dims$[ebp]
	mov	DWORD PTR _band_dims$[ebp+4], eax
	mov	eax, DWORD PTR _band_dims$[ebp+8]
	imul	eax, DWORD PTR _block_idx$[ebp]
	add	DWORD PTR _band_dims$[ebp], eax
	lea	eax, DWORD PTR [edx+8]
	push	eax
	lea	eax, DWORD PTR $T3[ebp]
	push	eax
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=

; 5072 :   assert(band_dims.area() > 0);
; 5073 : 
; 5074 :   kd_precinct_band *pband = precinct->subbands + state->sequence_idx;

	mov	ecx, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [eax+47]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edi+40]
	lea	edx, DWORD PTR [eax+ecx*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	mov	eax, DWORD PTR [edx+8]
	sub	DWORD PTR _block_idx$[ebp+4], eax
	mov	eax, DWORD PTR [edx+4]
	sub	DWORD PTR _block_idx$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5081 :   if (env == NULL)

	test	ebx, ebx
	jne	SHORT $LN15@open_block

; 5082 :     result = codestream->block;

	mov	esi, DWORD PTR [esi+28]

; 5083 :   else

	jmp	SHORT $LN16@open_block
$LN15@open_block:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 6543 :     kd_thread_env *get_state() { return state; }

	mov	esi, DWORD PTR [ebx+40]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5084 :     result = &(env->get_state()->block);

	add	esi, 136				; 00000088H
$LN16@open_block:

; 5093 :   result->region = band_dims & state->region;

	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR [esi+152], edi
	mov	eax, DWORD PTR [edx+16]
	imul	eax, DWORD PTR _block_idx$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 333  :       { kdu_dims result = *this; result &= rhs; return result; }

	movups	xmm0, XMMWORD PTR _band_dims$[ebp]
	movups	XMMWORD PTR $T4[ebp], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5088 :   result->block = pband->blocks +

	add	eax, DWORD PTR _block_idx$[ebp+4]
	lea	ecx, DWORD PTR [eax+eax*2]
	mov	eax, DWORD PTR [edx+20]
	lea	eax, DWORD PTR [eax+ecx*8]
	mov	DWORD PTR [esi+156], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 333  :       { kdu_dims result = *this; result &= rhs; return result; }

	lea	ecx, DWORD PTR $T4[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5092 :   result->size = band_dims.size;

	mov	eax, DWORD PTR _band_dims$[ebp+8]
	mov	DWORD PTR [esi], eax
	mov	eax, DWORD PTR _band_dims$[ebp+12]
	mov	DWORD PTR [esi+4], eax

; 5093 :   result->region = band_dims & state->region;

	mov	eax, DWORD PTR [ebx]
	add	eax, 24					; 00000018H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 333  :       { kdu_dims result = *this; result &= rhs; return result; }

	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5093 :   result->region = band_dims & state->region;

	movups	xmm0, XMMWORD PTR $T4[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	movups	xmm1, XMMWORD PTR _band_dims$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5093 :   result->region = band_dims & state->region;

	movups	XMMWORD PTR [esi+8], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	movaps	xmm0, xmm1
	psrldq	xmm0, 4
	movd	eax, xmm0
	sub	DWORD PTR [esi+12], eax
	movd	eax, xmm1
	sub	DWORD PTR [esi+8], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5095 :   result->modes = state->resolution->tile_comp->modes;

	mov	eax, DWORD PTR [ebx]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+140]
	mov	DWORD PTR [esi+28], eax

; 5096 :   result->orientation = state->orientation;

	mov	eax, DWORD PTR [ebx]
	movzx	eax, BYTE PTR [eax+46]
	mov	DWORD PTR [esi+32], eax

; 5097 :   result->K_max_prime = state->K_max_prime;

	mov	eax, DWORD PTR [ebx]

; 5098 :   result->vflip = codestream->vflip;

	mov	ebx, DWORD PTR _codestream$1$[ebp]
	movzx	eax, BYTE PTR [eax+51]
	mov	DWORD PTR [esi+40], eax
	mov	al, BYTE PTR [ebx+330]
	mov	BYTE PTR [esi+25], al

; 5099 :   result->hflip = codestream->hflip;

	mov	al, BYTE PTR [ebx+331]
	mov	BYTE PTR [esi+26], al

; 5100 :   result->transpose = codestream->transpose;

	mov	al, BYTE PTR [ebx+329]
	mov	BYTE PTR [esi+24], al

; 5101 :   result->resilient = codestream->resilient;

	mov	al, BYTE PTR [ebx+332]
	mov	BYTE PTR [esi+36], al

; 5102 :   result->fussy = codestream->fussy;

	mov	al, BYTE PTR [ebx+334]
	mov	BYTE PTR [esi+37], al

; 5103 : 
; 5104 :   // Retrieve compressed data, if necessary.
; 5105 :   if (codestream->in != NULL)

	cmp	DWORD PTR [ebx+4], 0
	je	SHORT $LN17@open_block

; 5106 :     {
; 5107 :       int trunc=codestream->block_truncation_factor;

	mov	ecx, DWORD PTR [ebx+344]

; 5108 :       int disc_passes = trunc>>8;

	mov	eax, ecx
	sar	eax, 8
	mov	DWORD PTR _disc_passes$1$[ebp], eax

; 5109 :       if ((trunc > 0) &&

	test	ecx, ecx
	jle	SHORT $LN117@open_block
	mov	eax, DWORD PTR _res$1$[ebp]
	movzx	edx, BYTE PTR [eax+13]
	movzx	ecx, BYTE PTR [eax+12]
	mov	eax, DWORD PTR [ebx+344]
	add	ecx, edx
	movzx	eax, al
	imul	ecx, eax
	shl	edx, 8
	cmp	ecx, edx

; 5110 :           (((trunc & 255)*(res->dwt_level+res->res_level)) >
; 5111 :            (((int) res->dwt_level)<<8)))
; 5112 :         disc_passes ++;

	mov	ecx, DWORD PTR _disc_passes$1$[ebp]
	jle	SHORT $LN19@open_block
	inc	ecx
	jmp	SHORT $LN19@open_block
$LN117@open_block:
	mov	ecx, eax
$LN19@open_block:

; 5113 :       result->block->retrieve_data(result,precinct->required_layers,

	movzx	eax, BYTE PTR [ebx+339]
	push	eax
	push	ecx
	push	DWORD PTR [edi+12]
	mov	ecx, DWORD PTR [esi+156]
	push	esi
	call	?retrieve_data@kd_block@@QAEXPAUkdu_block@@HH_N@Z ; kd_block::retrieve_data

; 5116 :   else if (!result->block->empty())

	jmp	SHORT $LN20@open_block
$LN17@open_block:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3801 :         return first_buf == NULL;

	mov	eax, DWORD PTR [esi+156]
	cmp	DWORD PTR [eax], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5116 :   else if (!result->block->empty())

	je	SHORT $LN20@open_block

; 5117 :     { KDU_ERROR_DEV(e,24); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$5[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$5[ebp]
	lea	ecx, DWORD PTR _e$5[ebp]
	push	OFFSET ??_C@_0ED@CJMFIANH@Attempting?5to?5open?5the?5same?5code@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5117 :     { KDU_ERROR_DEV(e,24); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 5120 :     }

	lea	ecx, DWORD PTR _e$5[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN20@open_block:

; 5121 : 
; 5122 :   if (return_tpart != NULL)

	mov	eax, DWORD PTR _return_tpart$[ebp]
	test	eax, eax
	je	SHORT $LN21@open_block

; 5123 :     *return_tpart = precinct->resolution->tile_comp->tile->next_tpart-1;

	mov	ecx, DWORD PTR [edi]
	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+4]
	mov	ecx, DWORD PTR [ecx+244]
	dec	ecx
	mov	DWORD PTR [eax], ecx
$LN21@open_block:

; 5124 : 
; 5125 :   return result;

	mov	eax, esi

; 5126 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN121@open_block:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z$0:
	lea	ecx, DWORD PTR _e$6[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z$1:
	lea	ecx, DWORD PTR _e$5[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-168]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?open_block@kdu_subband@@QAEPAUkdu_block@@Ukdu_coords@@PAHPAVkdu_thread_env@@@Z ENDP ; kdu_subband::open_block
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_block_size@kdu_subband@@QAEXAAUkdu_coords@@0@Z
_TEXT	SEGMENT
$T1 = -40						; size = 16
_first_dims$ = -24					; size = 16
_indices$ = -24						; size = 16
_this$1$ = -8						; size = 4
_cs$1$ = -4						; size = 4
_nominal_size$ = 8					; size = 4
_first_size$ = 12					; size = 4
?get_block_size@kdu_subband@@QAEXAAUkdu_coords@@0@Z PROC ; kdu_subband::get_block_size, COMDAT
; _this$ = ecx

; 4948 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H

; 4949 :   kdu_dims indices;
; 4950 :   kdu_coords first_idx;
; 4951 :   kdu_dims first_dims;
; 4952 :   kd_codestream *cs = state->resolution->codestream;

	mov	edx, DWORD PTR [ecx]
	xorps	xmm0, xmm0
	push	ebx

; 4953 :   
; 4954 :   nominal_size = state->block_partition.size;

	mov	ebx, DWORD PTR _nominal_size$[ebp]
	push	esi
	mov	eax, DWORD PTR [edx+4]
	push	edi
	mov	DWORD PTR _this$1$[ebp], ecx
	movups	XMMWORD PTR _indices$[ebp], xmm0
	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _cs$1$[ebp], eax
	mov	eax, DWORD PTR [edx+76]
	mov	DWORD PTR [ebx], eax
	mov	eax, DWORD PTR [edx+80]
	mov	DWORD PTR [ebx+4], eax

; 4955 :   get_valid_blocks(indices);

	lea	eax, DWORD PTR _indices$[ebp]
	push	eax
	call	?get_valid_blocks@kdu_subband@@QAEXAAUkdu_dims@@@Z ; kdu_subband::get_valid_blocks

; 4957 :   first_idx.from_apparent(cs->transpose,cs->vflip,cs->hflip);

	mov	ecx, DWORD PTR _cs$1$[ebp]
	mov	esi, DWORD PTR _indices$[ebp]
	mov	edi, DWORD PTR _indices$[ebp+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	cmp	BYTE PTR [ecx+331], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4957 :   first_idx.from_apparent(cs->transpose,cs->vflip,cs->hflip);

	mov	al, BYTE PTR [ecx+330]
	mov	dl, BYTE PTR [ecx+329]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	je	SHORT $LN21@get_block_
	neg	edi
$LN21@get_block_:

; 267  :         y=(vflip)?(-y):y;

	test	al, al
	je	SHORT $LN23@get_block_
	neg	esi
$LN23@get_block_:

; 268  :         if (transp) transpose();

	test	dl, dl
	je	SHORT $LN19@get_block_

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, esi
	mov	esi, edi
	mov	edi, eax
$LN19@get_block_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4958 :   first_dims = state->block_partition;

	mov	edx, DWORD PTR _this$1$[ebp]
	mov	edx, DWORD PTR [edx]
	movups	xmm1, XMMWORD PTR [edx+68]

; 4959 :   first_dims.pos.x += first_idx.x*first_dims.size.x;

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	movups	XMMWORD PTR _first_dims$[ebp], xmm1
	movd	ecx, xmm0
	psrldq	xmm1, 4
	movd	eax, xmm1
	imul	ecx, edi
	add	eax, ecx

; 4960 :   first_dims.pos.y += first_idx.y*first_dims.size.y;
; 4961 :   first_dims &= state->region;

	lea	ecx, DWORD PTR _first_dims$[ebp]
	mov	DWORD PTR _first_dims$[ebp+4], eax
	mov	eax, DWORD PTR _first_dims$[ebp+8]
	imul	eax, esi
	add	DWORD PTR _first_dims$[ebp], eax
	lea	eax, DWORD PTR [edx+24]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=

; 4962 :   assert((!first_dims) || (first_dims.area() > 0));
; 4963 :   first_size = first_dims.size;

	mov	edx, DWORD PTR _first_size$[ebp]
	mov	eax, DWORD PTR _first_dims$[ebp+8]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR _first_dims$[ebp+12]
	mov	DWORD PTR [edx+4], eax

; 4964 :   if (cs->transpose)

	mov	eax, DWORD PTR _cs$1$[ebp]
	cmp	BYTE PTR [eax+329], 0
	je	SHORT $LN2@get_block_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ebx+4]
	mov	DWORD PTR [ebx], eax
	mov	DWORD PTR [ebx+4], ecx
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
$LN2@get_block_:
	pop	edi
	pop	esi
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4969 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?get_block_size@kdu_subband@@QAEXAAUkdu_coords@@0@Z ENDP ; kdu_subband::get_block_size
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_valid_blocks@kdu_subband@@QAEXAAUkdu_dims@@@Z
_TEXT	SEGMENT
_indices$ = 8						; size = 4
?get_valid_blocks@kdu_subband@@QAEXAAUkdu_dims@@@Z PROC	; kdu_subband::get_valid_blocks, COMDAT
; _this$ = ecx

; 4936 : {

	push	ebp
	mov	ebp, esp

; 4937 :   kd_codestream *cs = state->resolution->codestream;

	mov	ecx, DWORD PTR [ecx]

; 4938 :   indices = state->region_indices;

	mov	edx, DWORD PTR _indices$[ebp]
	push	ebx
	mov	eax, DWORD PTR [ecx+4]
	movups	xmm0, XMMWORD PTR [ecx+100]
	mov	eax, DWORD PTR [eax]
	movups	XMMWORD PTR [edx], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	cmp	BYTE PTR [eax+329], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4939 :   indices.to_apparent(cs->transpose,cs->vflip,cs->hflip);

	mov	bl, BYTE PTR [eax+331]
	mov	bh, BYTE PTR [eax+330]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	je	SHORT $LN4@get_valid_

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
$LN4@get_valid_:

; 426  :       if (hflip) pos.x = -(pos.x+size.x-1);

	mov	ecx, 1
	test	bl, bl
	je	SHORT $LN5@get_valid_
	mov	eax, ecx
	sub	eax, DWORD PTR [edx+12]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx+4], eax
$LN5@get_valid_:

; 427  :       if (vflip) pos.y = -(pos.y+size.y-1);

	test	bh, bh
	pop	ebx
	je	SHORT $LN6@get_valid_
	sub	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [edx]
	mov	DWORD PTR [edx], ecx
$LN6@get_valid_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4940 : }

	pop	ebp
	ret	4
?get_valid_blocks@kdu_subband@@QAEXAAUkdu_dims@@@Z ENDP	; kdu_subband::get_valid_blocks
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_dims@kdu_subband@@QAEXAAUkdu_dims@@@Z
_TEXT	SEGMENT
_cs$1$ = -16						; size = 4
_this$1$ = -12						; size = 4
_offset$1$ = -8						; size = 4
_vflip$1$ = -2						; size = 1
tv391 = -2						; size = 1
tv389 = -1						; size = 1
_hflip$1$ = -1						; size = 1
_result$ = 8						; size = 4
?get_dims@kdu_subband@@QAEXAAUkdu_dims@@@Z PROC		; kdu_subband::get_dims, COMDAT
; _this$ = ecx

; 4908 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, ecx
	mov	DWORD PTR _this$1$[ebp], eax
	push	ebx

; 4909 :   kd_codestream *cs = state->resolution->codestream;

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]

; 4910 :   result = state->region;

	movups	xmm0, XMMWORD PTR [edx+24]
	mov	edx, DWORD PTR _result$[ebp]
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR _cs$1$[ebp], ebx
	movups	XMMWORD PTR [edx], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	cmp	BYTE PTR [ebx+329], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4911 :   result.to_apparent(cs->transpose,cs->vflip,cs->hflip);

	mov	al, BYTE PTR [ebx+331]
	mov	cl, BYTE PTR [ebx+330]
	mov	BYTE PTR _hflip$1$[ebp], al
	mov	BYTE PTR _vflip$1$[ebp], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	je	SHORT $LN11@get_dims

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx], eax
	mov	al, BYTE PTR _hflip$1$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	cl, BYTE PTR _vflip$1$[ebp]
$LN11@get_dims:

; 426  :       if (hflip) pos.x = -(pos.x+size.x-1);

	test	al, al
	je	SHORT $LN12@get_dims
	mov	eax, 1
	sub	eax, DWORD PTR [edx+12]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx+4], eax
$LN12@get_dims:

; 427  :       if (vflip) pos.y = -(pos.y+size.y-1);

	test	cl, cl
	je	SHORT $LN13@get_dims
	mov	eax, 1
	sub	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR [edx], eax
$LN13@get_dims:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4912 :   if (!(cs->vflip || cs->hflip))

	mov	al, BYTE PTR [ebx+330]
	mov	BYTE PTR tv391[ebp], al
	test	al, al
	jne	SHORT $LN5@get_dims
	cmp	BYTE PTR [ebx+331], al
	je	SHORT $LN1@get_dims
$LN5@get_dims:

; 4917 :   for (scan=state; scan!=&(scan->resolution->node); scan=scan->parent)

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	esi
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	xor	esi, esi
	xor	edi, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4917 :   for (scan=state; scan!=&(scan->resolution->node); scan=scan->parent)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, 16					; 00000010H
	cmp	ecx, eax
	je	SHORT $LN3@get_dims

; 4920 :       if (cs->transpose)

	mov	al, BYTE PTR [ebx+329]
	xor	edx, edx
	mov	BYTE PTR tv389[ebp], al
	npad	2
$LL4@get_dims:

; 4918 :     {
; 4919 :       branch_idx.x = scan->branch_x;  branch_idx.y = scan->branch_y;

	movzx	edi, BYTE PTR [ecx+40]
	movzx	ebx, BYTE PTR [ecx+41]

; 4920 :       if (cs->transpose)

	test	al, al
	je	SHORT $LN6@get_dims
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, ebx
	mov	ebx, edi
	mov	edi, eax
$LN6@get_dims:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4922 :       if ((branch_idx.x == 1) && cs->hflip)

	cmp	edi, 1
	jne	SHORT $LN33@get_dims
	mov	eax, DWORD PTR _cs$1$[ebp]
	cmp	BYTE PTR [eax+331], 0
	mov	eax, edi
	cmovne	edx, eax
	jmp	SHORT $LN7@get_dims
$LN33@get_dims:
	mov	eax, 1
$LN7@get_dims:

; 4923 :         { assert(!offset.x); offset.x = 1; }
; 4924 :       if ((branch_idx.y == 1) && cs->vflip)

	cmp	ebx, 1
	jne	SHORT $LN2@get_dims
	cmp	BYTE PTR tv391[ebp], 0
	cmovne	esi, eax
$LN2@get_dims:

; 4917 :   for (scan=state; scan!=&(scan->resolution->node); scan=scan->parent)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, 16					; 00000010H
	cmp	ecx, eax
	mov	al, BYTE PTR tv389[ebp]
	jne	SHORT $LL4@get_dims
	mov	DWORD PTR _offset$1$[ebp], edx
	mov	edx, DWORD PTR _result$[ebp]
	mov	edi, DWORD PTR _offset$1$[ebp]
$LN3@get_dims:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	sub	DWORD PTR [edx+4], edi
	sub	DWORD PTR [edx], esi
	pop	edi
	pop	esi
$LN1@get_dims:
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4928 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?get_dims@kdu_subband@@QAEXAAUkdu_dims@@@Z ENDP		; kdu_subband::get_dims
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_roi_weight@kdu_subband@@QAE_NAAM@Z
_TEXT	SEGMENT
_energy_weight$ = 8					; size = 4
?get_roi_weight@kdu_subband@@QAE_NAAM@Z PROC		; kdu_subband::get_roi_weight, COMDAT
; _this$ = ecx

; 4882 : {

	push	ebp
	mov	ebp, esp

; 4883 :   if (state->roi_weight < 0.0F)

	mov	eax, DWORD PTR [ecx]
	xorps	xmm0, xmm0
	movss	xmm1, DWORD PTR [eax+64]
	comiss	xmm0, xmm1
	jbe	SHORT $LN2@get_roi_we

; 4884 :     return false;

	xor	al, al

; 4887 : }

	pop	ebp
	ret	4
$LN2@get_roi_we:

; 4885 :   energy_weight = state->roi_weight * state->roi_weight;

	mov	eax, DWORD PTR _energy_weight$[ebp]
	mulss	xmm1, xmm1
	movss	DWORD PTR [eax], xmm1

; 4886 :   return true;

	mov	al, 1

; 4887 : }

	pop	ebp
	ret	4
?get_roi_weight@kdu_subband@@QAE_NAAM@Z ENDP		; kdu_subband::get_roi_weight
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_msb_wmse@kdu_subband@@QAEMXZ
_TEXT	SEGMENT
tv283 = -4						; size = 4
?get_msb_wmse@kdu_subband@@QAEMXZ PROC			; kdu_subband::get_msb_wmse, COMDAT
; _this$ = ecx

; 4858 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi

; 4859 :   kd_resolution *res = state->resolution;

	mov	esi, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [esi+4]

; 4860 :   if (res->codestream->in != NULL)

	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+4], 0
	je	SHORT $LN5@get_msb_wm

; 4861 :     return 1.0F;

	fld1
	pop	esi
	pop	ebx

; 4874 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN5@get_msb_wm:
	movss	xmm0, DWORD PTR [esi+52]
	push	edi

; 4862 :   double result = state->delta;
; 4863 :   int i;
; 4864 :   for (i=state->K_max_prime; i > 30; i-=30)

	movzx	edi, BYTE PTR [esi+51]
	cvtps2pd xmm0, xmm0
	cmp	edi, 30					; 0000001eH
	jle	SHORT $LN3@get_msb_wm
	movsd	xmm1, QWORD PTR __real@41d0000000000000
	lea	ecx, DWORD PTR [edi-31]
	mov	eax, -2004318071			; 88888889H
	mul	ecx
	shr	edx, 4
	inc	edx
	mov	eax, edx
	shl	eax, 4
	sub	eax, edx
	neg	eax
	lea	edi, DWORD PTR [edi+eax*2]
	npad	1
$LL4@get_msb_wm:

; 4865 :     result *= (double)(1<<30);

	mulsd	xmm0, xmm1
	sub	edx, 1
	jne	SHORT $LL4@get_msb_wm
$LN3@get_msb_wm:

; 4866 :   result *= (double)(1<<(i-1));

	lea	ecx, DWORD PTR [edi-1]
	mov	eax, 1
	shl	eax, cl
	pop	edi
	movd	xmm2, eax

; 4867 :   result *= result;
; 4868 :   result *= state->G_b;
; 4869 :   if (res->tile_comp->G_tc > 0.0F)

	mov	eax, DWORD PTR [ebx+4]
	cvtdq2pd xmm2, xmm2
	mulsd	xmm2, xmm0
	movss	xmm0, DWORD PTR [esi+56]
	cvtps2pd xmm0, xmm0
	mulsd	xmm2, xmm2
	mulsd	xmm2, xmm0
	movss	xmm0, DWORD PTR [eax+120]
	comiss	xmm0, DWORD PTR __real@00000000
	jbe	SHORT $LN6@get_msb_wm

; 4870 :     result *= res->tile_comp->G_tc; // Should always be the case

	cvtps2pd xmm0, xmm0
	mulsd	xmm2, xmm0
$LN6@get_msb_wm:

; 4871 :   result *= state->W_b;

	movss	xmm0, DWORD PTR [esi+60]
	cvtps2pd xmm1, xmm0
	pop	esi
	pop	ebx

; 4872 :   result *= state->W_b; // Squares the W_b weight.

	cvtps2pd xmm0, xmm0
	mulsd	xmm1, xmm2
	mulsd	xmm1, xmm0

; 4873 :   return (float) result;

	cvtpd2ps xmm0, xmm1
	movss	DWORD PTR tv283[ebp], xmm0
	fld	DWORD PTR tv283[ebp]

; 4874 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?get_msb_wmse@kdu_subband@@QAEMXZ ENDP			; kdu_subband::get_msb_wmse
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_delta@kdu_subband@@QAEMXZ
_TEXT	SEGMENT
tv76 = -4						; size = 4
?get_delta@kdu_subband@@QAEMXZ PROC			; kdu_subband::get_delta, COMDAT
; _this$ = ecx

; 4848 : {

	push	ebp
	mov	ebp, esp
	push	ecx

; 4849 :   return (state->resolution->tile_comp->reversible)?0.0F:state->delta;

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [eax+4]
	cmp	BYTE PTR [eax+64], 0
	je	SHORT $LN3@get_delta
	mov	DWORD PTR tv76[ebp], 0
	fld	DWORD PTR tv76[ebp]

; 4850 : }

	mov	esp, ebp
	pop	ebp
	ret	0
$LN3@get_delta:

; 4849 :   return (state->resolution->tile_comp->reversible)?0.0F:state->delta;

	movss	xmm0, DWORD PTR [ecx+52]
	movss	DWORD PTR tv76[ebp], xmm0
	fld	DWORD PTR tv76[ebp]

; 4850 : }

	mov	esp, ebp
	pop	ebp
	ret	0
?get_delta@kdu_subband@@QAEMXZ ENDP			; kdu_subband::get_delta
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_reversible@kdu_subband@@QAE_NXZ
_TEXT	SEGMENT
?get_reversible@kdu_subband@@QAE_NXZ PROC		; kdu_subband::get_reversible, COMDAT
; _this$ = ecx

; 4839 :   return state->resolution->tile_comp->reversible;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+4]
	mov	al, BYTE PTR [eax+64]

; 4840 : }

	ret	0
?get_reversible@kdu_subband@@QAE_NXZ ENDP		; kdu_subband::get_reversible
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_K_max_prime@kdu_subband@@QAEHXZ
_TEXT	SEGMENT
?get_K_max_prime@kdu_subband@@QAEHXZ PROC		; kdu_subband::get_K_max_prime, COMDAT
; _this$ = ecx

; 4829 :   return state->K_max_prime;

	mov	eax, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [eax+51]

; 4830 : }

	ret	0
?get_K_max_prime@kdu_subband@@QAEHXZ ENDP		; kdu_subband::get_K_max_prime
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_K_max@kdu_subband@@QAEHXZ
_TEXT	SEGMENT
?get_K_max@kdu_subband@@QAEHXZ PROC			; kdu_subband::get_K_max, COMDAT
; _this$ = ecx

; 4819 :   return state->K_max;

	mov	eax, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [eax+50]

; 4820 : }

	ret	0
?get_K_max@kdu_subband@@QAEHXZ ENDP			; kdu_subband::get_K_max
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?access_resolution@kdu_subband@@QAE?AVkdu_resolution@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?access_resolution@kdu_subband@@QAE?AVkdu_resolution@@XZ PROC ; kdu_subband::access_resolution, COMDAT
; _this$ = ecx

; 4808 : {

	push	ebp
	mov	ebp, esp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4668 :     kdu_resolution(kd_resolution *state) { this->state = state; }

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4810 : }

	pop	ebp
	ret	4
?access_resolution@kdu_subband@@QAE?AVkdu_resolution@@XZ ENDP ; kdu_subband::access_resolution
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_band_idx@kdu_subband@@QAEHXZ
_TEXT	SEGMENT
?get_band_idx@kdu_subband@@QAEHXZ PROC			; kdu_subband::get_band_idx, COMDAT
; _this$ = ecx

; 4796 :   int band_idx = state->sequence_idx;

	mov	ecx, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [ecx+47]

; 4797 :   if (state->resolution->res_level > 0)

	mov	ecx, DWORD PTR [ecx+4]
	cmp	BYTE PTR [ecx+12], 0
	jbe	SHORT $LN2@get_band_i

; 4798 :     band_idx++;

	inc	eax
$LN2@get_band_i:

; 4799 :   return band_idx;
; 4800 : }

	ret	0
?get_band_idx@kdu_subband@@QAEHXZ ENDP			; kdu_subband::get_band_idx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_subband@@QAE@PAUkd_subband@@@Z
_TEXT	SEGMENT
_state$ = 8						; size = 4
??0kdu_subband@@QAE@PAUkd_subband@@@Z PROC		; kdu_subband::kdu_subband, COMDAT
; _this$ = ecx

; 5280 :     kdu_subband(kd_subband *state) { this->state = state; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0kdu_subband@@QAE@PAUkd_subband@@@Z ENDP		; kdu_subband::kdu_subband
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_bibo_gains@kdu_node@@QAEPBMAAH_N@Z
_TEXT	SEGMENT
_num_steps$ = 8						; size = 4
_vertical$ = 12						; size = 1
?get_bibo_gains@kdu_node@@QAEPBMAAH_N@Z PROC		; kdu_node::get_bibo_gains, COMDAT
; _this$ = ecx

; 4756 : {

	push	ebp
	mov	ebp, esp
	push	esi

; 4757 :   if (state->resolution->codestream->transpose)

	mov	esi, DWORD PTR [ecx]
	mov	eax, DWORD PTR [esi+4]
	mov	eax, DWORD PTR [eax]
	cmp	BYTE PTR [eax+329], 0
	je	SHORT $LN10@get_bibo_g

; 4758 :     vertical = !vertical;

	cmp	BYTE PTR _vertical$[ebp], 0
	sete	dl
	jmp	SHORT $LN2@get_bibo_g
$LN10@get_bibo_g:
	mov	dl, BYTE PTR _vertical$[ebp]
$LN2@get_bibo_g:

; 4759 :   if (state->is_leaf)

	cmp	BYTE PTR [esi+42], 0
	je	SHORT $LN3@get_bibo_g

; 4760 :     {
; 4761 :       num_steps = 0;

	mov	eax, DWORD PTR _num_steps$[ebp]
	mov	DWORD PTR [eax], 0

; 4762 :       kd_node *parent = state->parent;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]

; 4763 :       if (vertical)

	test	dl, dl
	je	SHORT $LN5@get_bibo_g

; 4764 :         return parent->bibo_gains + (parent->num_vert_steps & 254);

	movzx	ecx, BYTE PTR [eax+93]
	mov	eax, DWORD PTR [eax+100]
	and	ecx, 254				; 000000feH
	pop	esi
	lea	eax, DWORD PTR [eax+ecx*4]

; 4780 :         }
; 4781 :     }
; 4782 : }

	pop	ebp
	ret	8
$LN5@get_bibo_g:

; 4765 :       else
; 4766 :         return parent->bibo_gains + (parent->num_hor_steps & 254);

	movzx	ecx, BYTE PTR [eax+92]
	mov	eax, DWORD PTR [eax+100]
	and	ecx, 254				; 000000feH
	pop	esi
	lea	eax, DWORD PTR [eax+ecx*4]

; 4780 :         }
; 4781 :     }
; 4782 : }

	pop	ebp
	ret	8
$LN3@get_bibo_g:

; 4767 :     }
; 4768 :   else
; 4769 :     {
; 4770 :       kd_node *node = (kd_node *) state;
; 4771 :       if (vertical)

	test	dl, dl
	je	SHORT $LN7@get_bibo_g

; 4772 :         {
; 4773 :           num_steps = node->num_vert_steps;

	mov	eax, DWORD PTR _num_steps$[ebp]
	movzx	ecx, BYTE PTR [esi+93]
	mov	DWORD PTR [eax], ecx

; 4774 :           return node->bibo_gains + (node->num_hor_steps+1);

	movzx	ecx, BYTE PTR [esi+92]
	mov	eax, DWORD PTR [esi+100]
	pop	esi
	lea	eax, DWORD PTR [eax+ecx*4]
	add	eax, 4

; 4780 :         }
; 4781 :     }
; 4782 : }

	pop	ebp
	ret	8
$LN7@get_bibo_g:

; 4775 :         }
; 4776 :       else
; 4777 :         {
; 4778 :           num_steps = node->num_hor_steps;

	mov	ecx, DWORD PTR _num_steps$[ebp]
	movzx	edx, BYTE PTR [esi+92]
	mov	DWORD PTR [ecx], edx

; 4779 :           return node->bibo_gains;

	mov	eax, DWORD PTR [esi+100]
	pop	esi

; 4780 :         }
; 4781 :     }
; 4782 : }

	pop	ebp
	ret	8
?get_bibo_gains@kdu_node@@QAEPBMAAH_N@Z ENDP		; kdu_node::get_bibo_gains
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_kernel_coefficients@kdu_node@@QAEPBM_N@Z
_TEXT	SEGMENT
_vertical$ = 8						; size = 1
?get_kernel_coefficients@kdu_node@@QAEPBM_N@Z PROC	; kdu_node::get_kernel_coefficients, COMDAT
; _this$ = ecx

; 4744 : {

	push	ebp
	mov	ebp, esp

; 4745 :   kd_tile_comp *tc = state->resolution->tile_comp;
; 4746 :   bool flip = (vertical)?(tc->codestream->vflip):(tc->codestream->hflip);

	cmp	BYTE PTR _vertical$[ebp], 0
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [ecx]
	je	SHORT $LN3@get_kernel
	mov	al, BYTE PTR [eax+330]
	jmp	SHORT $LN4@get_kernel
$LN3@get_kernel:
	mov	al, BYTE PTR [eax+331]
$LN4@get_kernel:

; 4747 :   return (flip)?(tc->kernel_coefficients_flipped):(tc->kernel_coefficients);

	test	al, al
	je	SHORT $LN5@get_kernel
	mov	eax, DWORD PTR [ecx+92]

; 4748 : }

	pop	ebp
	ret	4
$LN5@get_kernel:

; 4747 :   return (flip)?(tc->kernel_coefficients_flipped):(tc->kernel_coefficients);

	mov	eax, DWORD PTR [ecx+88]

; 4748 : }

	pop	ebp
	ret	4
?get_kernel_coefficients@kdu_node@@QAEPBM_N@Z ENDP	; kdu_node::get_kernel_coefficients
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_kernel_info@kdu_node@@QAEPBUkdu_kernel_step_info@@AAHAAM1AA_N20000_N@Z
_TEXT	SEGMENT
_num_steps$ = 8						; size = 4
_low_scale$ = 12					; size = 4
_high_scale$ = 16					; size = 4
_symmetric$ = 20					; size = 4
_symmetric_extension$ = 24				; size = 4
_low_support_min$ = 28					; size = 4
_low_support_max$ = 32					; size = 4
_high_support_min$ = 36					; size = 4
_high_support_max$ = 40					; size = 4
_vertical$ = 44						; size = 1
?get_kernel_info@kdu_node@@QAEPBUkdu_kernel_step_info@@AAHAAM1AA_N20000_N@Z PROC ; kdu_node::get_kernel_info, COMDAT
; _this$ = ecx

; 4712 : {

	push	ebp
	mov	ebp, esp

; 4713 :   kd_tile_comp *tc = state->resolution->tile_comp;
; 4714 :   bool flip = (vertical)?(tc->codestream->vflip):(tc->codestream->hflip);

	cmp	BYTE PTR _vertical$[ebp], 0
	mov	eax, DWORD PTR [ecx]
	push	esi
	mov	eax, DWORD PTR [eax+4]
	mov	esi, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [esi]
	je	SHORT $LN5@get_kernel
	mov	dl, BYTE PTR [eax+330]
	jmp	SHORT $LN6@get_kernel
$LN5@get_kernel:
	mov	dl, BYTE PTR [eax+331]
$LN6@get_kernel:

; 4715 :   num_steps = tc->kernel_num_steps;

	mov	ecx, DWORD PTR [esi+76]
	mov	eax, DWORD PTR _num_steps$[ebp]
	mov	DWORD PTR [eax], ecx

; 4716 :   low_scale = tc->kernel_low_scale;

	mov	eax, DWORD PTR _low_scale$[ebp]
	mov	ecx, DWORD PTR [esi+96]
	mov	DWORD PTR [eax], ecx

; 4717 :   high_scale = tc->kernel_high_scale;

	mov	eax, DWORD PTR _high_scale$[ebp]
	mov	ecx, DWORD PTR [esi+100]
	mov	DWORD PTR [eax], ecx

; 4718 :   symmetric = tc->kernel_symmetric;

	mov	eax, DWORD PTR _symmetric$[ebp]
	movzx	ecx, BYTE PTR [esi+72]
	mov	BYTE PTR [eax], cl

; 4719 :   symmetric_extension = tc->kernel_symmetric_extension;

	mov	eax, DWORD PTR _symmetric_extension$[ebp]
	movzx	ecx, BYTE PTR [esi+73]
	mov	BYTE PTR [eax], cl

; 4720 :   if (flip)
; 4721 :     {
; 4722 :       low_support_min = -tc->low_support_max;

	mov	eax, DWORD PTR _low_support_min$[ebp]
	test	dl, dl
	je	SHORT $LN2@get_kernel
	mov	ecx, DWORD PTR [esi+108]
	neg	ecx
	mov	DWORD PTR [eax], ecx

; 4723 :       low_support_max = -tc->low_support_min;

	mov	edx, DWORD PTR [esi+104]
	mov	ecx, DWORD PTR _low_support_max$[ebp]
	neg	edx
	mov	DWORD PTR [ecx], edx

; 4724 :       high_support_min = -tc->high_support_max;

	mov	edx, DWORD PTR [esi+116]
	mov	ecx, DWORD PTR _high_support_min$[ebp]
	neg	edx
	mov	DWORD PTR [ecx], edx

; 4725 :       high_support_max = -tc->high_support_min;

	mov	edx, DWORD PTR [esi+112]
	mov	ecx, DWORD PTR _high_support_max$[ebp]
	neg	edx
	mov	DWORD PTR [ecx], edx

; 4726 :       return tc->kernel_step_info_flipped;

	mov	eax, DWORD PTR [esi+84]
	pop	esi

; 4735 :     }
; 4736 : }

	pop	ebp
	ret	40					; 00000028H
$LN2@get_kernel:

; 4727 :     }
; 4728 :   else
; 4729 :     {
; 4730 :       low_support_min = tc->low_support_min;

	mov	ecx, DWORD PTR [esi+104]
	mov	DWORD PTR [eax], ecx

; 4731 :       low_support_max = tc->low_support_max;

	mov	eax, DWORD PTR _low_support_max$[ebp]
	mov	ecx, DWORD PTR [esi+108]
	mov	DWORD PTR [eax], ecx

; 4732 :       high_support_min = tc->high_support_min;

	mov	eax, DWORD PTR _high_support_min$[ebp]
	mov	ecx, DWORD PTR [esi+112]
	mov	DWORD PTR [eax], ecx

; 4733 :       high_support_max = tc->high_support_max;

	mov	eax, DWORD PTR _high_support_max$[ebp]
	mov	ecx, DWORD PTR [esi+116]
	mov	DWORD PTR [eax], ecx

; 4734 :       return tc->kernel_step_info;

	mov	eax, DWORD PTR [esi+80]
	pop	esi

; 4735 :     }
; 4736 : }

	pop	ebp
	ret	40					; 00000028H
?get_kernel_info@kdu_node@@QAEPBUkdu_kernel_step_info@@AAHAAM1AA_N20000_N@Z ENDP ; kdu_node::get_kernel_info
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_kernel_id@kdu_node@@QAEHXZ
_TEXT	SEGMENT
?get_kernel_id@kdu_node@@QAEHXZ PROC			; kdu_node::get_kernel_id, COMDAT
; _this$ = ecx

; 4698 :   return state->resolution->tile_comp->kernel_id;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+4]
	mov	eax, DWORD PTR [eax+68]

; 4699 : }

	ret	0
?get_kernel_id@kdu_node@@QAEHXZ ENDP			; kdu_node::get_kernel_id
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_dims@kdu_node@@QAEXAAUkdu_dims@@@Z
_TEXT	SEGMENT
_cs$1$ = -16						; size = 4
_this$1$ = -12						; size = 4
_offset$1$ = -8						; size = 4
_vflip$1$ = -2						; size = 1
tv359 = -2						; size = 1
tv357 = -1						; size = 1
_hflip$1$ = -1						; size = 1
_result$ = 8						; size = 4
?get_dims@kdu_node@@QAEXAAUkdu_dims@@@Z PROC		; kdu_node::get_dims, COMDAT
; _this$ = ecx

; 4669 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 16					; 00000010H
	mov	eax, ecx
	mov	DWORD PTR _this$1$[ebp], eax
	push	ebx

; 4670 :   kd_codestream *cs = state->resolution->codestream;

	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx+4]

; 4671 :   result = state->region;

	movups	xmm0, XMMWORD PTR [edx+24]
	mov	edx, DWORD PTR _result$[ebp]
	mov	ebx, DWORD PTR [eax]
	mov	DWORD PTR _cs$1$[ebp], ebx
	movups	XMMWORD PTR [edx], xmm0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	cmp	BYTE PTR [ebx+329], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4672 :   result.to_apparent(cs->transpose,cs->vflip,cs->hflip);

	mov	al, BYTE PTR [ebx+331]
	mov	cl, BYTE PTR [ebx+330]
	mov	BYTE PTR _hflip$1$[ebp], al
	mov	BYTE PTR _vflip$1$[ebp], cl
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	je	SHORT $LN11@get_dims

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx], eax
	mov	al, BYTE PTR _hflip$1$[ebp]
	mov	DWORD PTR [edx+4], ecx
	mov	cl, BYTE PTR _vflip$1$[ebp]
$LN11@get_dims:

; 426  :       if (hflip) pos.x = -(pos.x+size.x-1);

	test	al, al
	je	SHORT $LN12@get_dims
	mov	eax, 1
	sub	eax, DWORD PTR [edx+12]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx+4], eax
$LN12@get_dims:

; 427  :       if (vflip) pos.y = -(pos.y+size.y-1);

	test	cl, cl
	je	SHORT $LN13@get_dims
	mov	eax, 1
	sub	eax, DWORD PTR [edx+8]
	sub	eax, DWORD PTR [edx]
	mov	DWORD PTR [edx], eax
$LN13@get_dims:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4673 :   if (!(cs->vflip || cs->hflip))

	mov	al, BYTE PTR [ebx+330]
	mov	BYTE PTR tv359[ebp], al
	test	al, al
	jne	SHORT $LN5@get_dims
	cmp	BYTE PTR [ebx+331], al
	je	SHORT $LN1@get_dims
$LN5@get_dims:

; 4678 :   for (scan=state; scan != &(scan->resolution->node); scan=scan->parent)

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	esi
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	xor	esi, esi
	xor	edi, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4678 :   for (scan=state; scan != &(scan->resolution->node); scan=scan->parent)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, 16					; 00000010H
	cmp	ecx, eax
	je	SHORT $LN3@get_dims

; 4681 :       if (cs->transpose)

	mov	al, BYTE PTR [ebx+329]
	xor	edx, edx
	mov	BYTE PTR tv357[ebp], al
	npad	2
$LL4@get_dims:

; 4679 :     {
; 4680 :       branch_idx.x = scan->branch_x;  branch_idx.y = scan->branch_y;

	movzx	edi, BYTE PTR [ecx+40]
	movzx	ebx, BYTE PTR [ecx+41]

; 4681 :       if (cs->transpose)

	test	al, al
	je	SHORT $LN6@get_dims
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, ebx
	mov	ebx, edi
	mov	edi, eax
$LN6@get_dims:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4683 :       if ((branch_idx.x == 1) && cs->hflip)

	cmp	edi, 1
	jne	SHORT $LN33@get_dims
	mov	eax, DWORD PTR _cs$1$[ebp]
	cmp	BYTE PTR [eax+331], 0
	mov	eax, edi
	cmovne	edx, eax
	jmp	SHORT $LN7@get_dims
$LN33@get_dims:
	mov	eax, 1
$LN7@get_dims:

; 4684 :         { assert(!offset.x); offset.x = 1; }
; 4685 :       if ((branch_idx.y == 1) && cs->vflip)

	cmp	ebx, 1
	jne	SHORT $LN2@get_dims
	cmp	BYTE PTR tv359[ebp], 0
	cmovne	esi, eax
$LN2@get_dims:

; 4678 :   for (scan=state; scan != &(scan->resolution->node); scan=scan->parent)

	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	add	eax, 16					; 00000010H
	cmp	ecx, eax
	mov	al, BYTE PTR tv357[ebp]
	jne	SHORT $LL4@get_dims
	mov	DWORD PTR _offset$1$[ebp], edx
	mov	edx, DWORD PTR _result$[ebp]
	mov	edi, DWORD PTR _offset$1$[ebp]
$LN3@get_dims:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	sub	DWORD PTR [edx+4], edi
	sub	DWORD PTR [edx], esi
	pop	edi
	pop	esi
$LN1@get_dims:
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4689 : }

	mov	esp, ebp
	pop	ebp
	ret	4
?get_dims@kdu_node@@QAEXAAUkdu_dims@@@Z ENDP		; kdu_node::get_dims
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?access_resolution@kdu_node@@QAE?AVkdu_resolution@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?access_resolution@kdu_node@@QAE?AVkdu_resolution@@XZ PROC ; kdu_node::access_resolution, COMDAT
; _this$ = ecx

; 4647 : {

	push	ebp
	mov	ebp, esp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4668 :     kdu_resolution(kd_resolution *state) { this->state = state; }

	mov	eax, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [eax+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4649 : }

	pop	ebp
	ret	4
?access_resolution@kdu_node@@QAE?AVkdu_resolution@@XZ ENDP ; kdu_node::access_resolution
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?access_subband@kdu_node@@QAE?AVkdu_subband@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?access_subband@kdu_node@@QAE?AVkdu_subband@@XZ PROC	; kdu_node::access_subband, COMDAT
; _this$ = ecx

; 4637 : {

	push	ebp
	mov	ebp, esp

; 4638 :   return kdu_subband((state->is_leaf)?((kd_subband *) state):NULL);

	mov	eax, DWORD PTR [ecx]
	xor	ecx, ecx
	cmp	BYTE PTR [eax+42], cl
	cmovne	ecx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 5280 :     kdu_subband(kd_subband *state) { this->state = state; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4639 : }

	pop	ebp
	ret	4
?access_subband@kdu_node@@QAE?AVkdu_subband@@XZ ENDP	; kdu_node::access_subband
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_num_descendants@kdu_node@@QAEHAAH@Z
_TEXT	SEGMENT
_num_leaf_descendants$ = 8				; size = 4
?get_num_descendants@kdu_node@@QAEHAAH@Z PROC		; kdu_node::get_num_descendants, COMDAT
; _this$ = ecx

; 4616 : {

	push	ebp
	mov	ebp, esp

; 4617 :   if (state->is_leaf)

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+42], 0
	je	SHORT $LN2@get_num_de

; 4618 :     return (num_leaf_descendants = 0);

	mov	eax, DWORD PTR _num_leaf_descendants$[ebp]
	mov	DWORD PTR [eax], 0
	xor	eax, eax

; 4629 : }

	pop	ebp
	ret	4
$LN2@get_num_de:

; 4619 :   kd_node *node = (kd_node *) state;
; 4620 :   if (node->resolution->res_level == 0)

	mov	eax, DWORD PTR [edx+4]
	cmp	BYTE PTR [eax+12], 0

; 4621 :     { // Special case: the lowest resolution level formally can be used to
; 4622 :       // access one child node, which is the LL subband, so we should return
; 4623 :       // 1 here, even though we cannot access this node via calls to
; 4624 :       // `access_child', starting from higher up in the subband hierarchy.
; 4625 :       return (num_leaf_descendants = 1);

	mov	eax, DWORD PTR _num_leaf_descendants$[ebp]
	jne	SHORT $LN3@get_num_de
	mov	DWORD PTR [eax], 1
	mov	eax, 1

; 4629 : }

	pop	ebp
	ret	4
$LN3@get_num_de:

; 4626 :     }
; 4627 :   num_leaf_descendants = node->num_descendant_leaves;

	movzx	ecx, WORD PTR [edx+96]
	mov	DWORD PTR [eax], ecx

; 4628 :   return node->num_descendant_nodes;

	movzx	eax, WORD PTR [edx+94]

; 4629 : }

	pop	ebp
	ret	4
?get_num_descendants@kdu_node@@QAEHAAH@Z ENDP		; kdu_node::get_num_descendants
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?access_child@kdu_node@@QAE?AV1@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_child_idx$ = 12					; size = 4
?access_child@kdu_node@@QAE?AV1@H@Z PROC		; kdu_node::access_child, COMDAT
; _this$ = ecx

; 4592 : {

	push	ebp
	mov	ebp, esp

; 4593 :   assert((child_idx >= 0) && (child_idx <= 3));
; 4594 :   if (state->is_leaf)

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+42], 0
	je	SHORT $LN2@access_chi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4982 :     kdu_node(kd_leaf_node *state) { this->state = state; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4608 : }

	pop	ebp
	ret	8
$LN2@access_chi:

; 4595 :     return kdu_node(NULL);
; 4596 : 
; 4597 :   if (state->resolution->codestream->transpose)

	mov	eax, DWORD PTR [edx+4]

; 4598 :     child_idx = ((child_idx & 1) << 1) + ((child_idx >> 1) & 1);

	mov	ecx, DWORD PTR _child_idx$[ebp]
	mov	eax, DWORD PTR [eax]
	cmp	BYTE PTR [eax+329], 0
	je	SHORT $LN3@access_chi
	mov	eax, ecx
	sar	eax, 1
	and	eax, 1
	and	ecx, 1
	lea	ecx, DWORD PTR [eax+ecx*2]
$LN3@access_chi:

; 4599 :   kd_leaf_node *result = ((kd_node *) state)->children[child_idx];

	mov	ecx, DWORD PTR [edx+ecx*4+76]

; 4600 :   if ((result != NULL) && (result->resolution->res_level == 0))

	test	ecx, ecx
	je	SHORT $LN4@access_chi
	mov	eax, DWORD PTR [ecx+4]
	cmp	BYTE PTR [eax+12], 0
	jne	SHORT $LN4@access_chi

; 4601 :     { // Special case in which the LL child node should actually be the LL
; 4602 :       // subband, rather than the next lower resolution primary node
; 4603 :       assert((child_idx==LL_BAND) && (result==&(result->resolution->node)));
; 4604 :       result = ((kd_node *) result)->children[LL_BAND];

	mov	ecx, DWORD PTR [ecx+76]
$LN4@access_chi:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4982 :     kdu_node(kd_leaf_node *state) { this->state = state; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4608 : }

	pop	ebp
	ret	8
?access_child@kdu_node@@QAE?AV1@H@Z ENDP		; kdu_node::access_child
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_node@@QAE@PAUkd_leaf_node@@@Z
_TEXT	SEGMENT
_state$ = 8						; size = 4
??0kdu_node@@QAE@PAUkd_leaf_node@@@Z PROC		; kdu_node::kdu_node, COMDAT
; _this$ = ecx

; 4982 :     kdu_node(kd_leaf_node *state) { this->state = state; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0kdu_node@@QAE@PAUkd_leaf_node@@@Z ENDP		; kdu_node::kdu_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?propagate_roi@kdu_resolution@@QAE_NXZ
_TEXT	SEGMENT
?propagate_roi@kdu_resolution@@QAE_NXZ PROC		; kdu_resolution::propagate_roi, COMDAT
; _this$ = ecx

; 4488 :   return state->propagate_roi;

	mov	eax, DWORD PTR [ecx]
	mov	al, BYTE PTR [eax+172]

; 4489 : }

	ret	0
?propagate_roi@kdu_resolution@@QAE_NXZ ENDP		; kdu_resolution::propagate_roi
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_reversible@kdu_resolution@@QAE_NXZ
_TEXT	SEGMENT
?get_reversible@kdu_resolution@@QAE_NXZ PROC		; kdu_resolution::get_reversible, COMDAT
; _this$ = ecx

; 4478 :   return state->tile_comp->reversible;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]
	mov	al, BYTE PTR [eax+64]

; 4479 : }

	ret	0
?get_reversible@kdu_resolution@@QAE_NXZ ENDP		; kdu_resolution::get_reversible
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?access_subband@kdu_resolution@@QAE?AVkdu_subband@@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_band_idx$ = 12						; size = 4
?access_subband@kdu_resolution@@QAE?AVkdu_subband@@H@Z PROC ; kdu_resolution::access_subband, COMDAT
; _this$ = ecx

; 4519 : {

	push	ebp
	mov	ebp, esp

; 4520 :   if (state->res_level > 0)

	mov	edx, DWORD PTR [ecx]

; 4521 :     band_idx--;

	mov	eax, DWORD PTR _band_idx$[ebp]
	cmp	BYTE PTR [edx+12], 0
	jbe	SHORT $LN2@access_sub
	dec	eax
$LN2@access_sub:

; 4522 :   assert((band_idx >= 0) && (band_idx < state->num_subbands));
; 4523 :   kd_subband *band = state->subbands + band_idx;

	imul	ecx, eax, 132

; 4524 :   if (state->codestream->transpose)

	mov	eax, DWORD PTR [edx]
	add	ecx, DWORD PTR [edx+184]
	cmp	BYTE PTR [eax+329], 0
	je	SHORT $LN7@access_sub

; 4525 :     band = state->subbands + band->transpose_sequence_idx;

	movzx	eax, BYTE PTR [ecx+48]
	imul	ecx, eax, 132
	add	ecx, DWORD PTR [edx+184]
$LN7@access_sub:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 5280 :     kdu_subband(kd_subband *state) { this->state = state; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4527 : }

	pop	ebp
	ret	8
?access_subband@kdu_resolution@@QAE?AVkdu_subband@@H@Z ENDP ; kdu_resolution::access_subband
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_valid_band_indices@kdu_resolution@@QAEHAAH@Z
_TEXT	SEGMENT
_min_idx$ = 8						; size = 4
?get_valid_band_indices@kdu_resolution@@QAEHAAH@Z PROC	; kdu_resolution::get_valid_band_indices, COMDAT
; _this$ = ecx

; 4508 : {

	push	ebp
	mov	ebp, esp

; 4509 :   min_idx = (state->res_level==0)?0:1;

	mov	eax, DWORD PTR [ecx]
	xor	edx, edx
	cmp	BYTE PTR [eax+12], dl
	mov	eax, DWORD PTR _min_idx$[ebp]
	setne	dl
	mov	DWORD PTR [eax], edx

; 4510 :   return state->num_subbands;

	mov	eax, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [eax+174]

; 4511 : }

	pop	ebp
	ret	4
?get_valid_band_indices@kdu_resolution@@QAEHAAH@Z ENDP	; kdu_resolution::get_valid_band_indices
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?access_node@kdu_resolution@@QAE?AVkdu_node@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?access_node@kdu_resolution@@QAE?AVkdu_node@@XZ PROC	; kdu_resolution::access_node, COMDAT
; _this$ = ecx

; 4497 : {

	push	ebp
	mov	ebp, esp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4982 :     kdu_node(kd_leaf_node *state) { this->state = state; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4499 :   return kdu_node(&state->node);

	mov	ecx, DWORD PTR [ecx]
	add	ecx, 16					; 00000010H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4982 :     kdu_node(kd_leaf_node *state) { this->state = state; }

	mov	DWORD PTR [eax], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4500 : }

	pop	ebp
	ret	4
?access_node@kdu_resolution@@QAE?AVkdu_node@@XZ ENDP	; kdu_resolution::access_node
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_precinct_samples@kdu_resolution@@QAE_JUkdu_coords@@@Z
_TEXT	SEGMENT
$T1 = -40						; size = 16
_precinct_region$ = -24					; size = 16
_area$1$ = -8						; size = 4
_this$1$ = -4						; size = 4
_idx$ = 8						; size = 8
?get_precinct_samples@kdu_resolution@@QAE_JUkdu_coords@@@Z PROC ; kdu_resolution::get_precinct_samples, COMDAT
; _this$ = ecx

; 4444 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	mov	eax, ecx
	push	ebx
	push	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	mov	esi, DWORD PTR _idx$[ebp+4]
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4445 :   idx.from_apparent(state->codestream->transpose,

	mov	edi, DWORD PTR [eax]
	mov	DWORD PTR _this$1$[ebp], eax
	mov	eax, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	cmp	BYTE PTR [eax+331], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4445 :   idx.from_apparent(state->codestream->transpose,

	mov	dl, BYTE PTR [eax+330]
	mov	cl, BYTE PTR [eax+329]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	je	SHORT $LN8@get_precin
	neg	esi
	mov	DWORD PTR _idx$[ebp+4], esi
$LN8@get_precin:

; 267  :         y=(vflip)?(-y):y;

	test	dl, dl
	mov	edx, DWORD PTR _idx$[ebp]
	je	SHORT $LN10@get_precin
	neg	edx
	mov	DWORD PTR _idx$[ebp], edx
$LN10@get_precin:

; 268  :         if (transp) transpose();

	test	cl, cl
	je	SHORT $LN6@get_precin

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, edx
	mov	edx, esi
	mov	esi, eax
	mov	DWORD PTR _idx$[ebp], edx
	mov	DWORD PTR _idx$[ebp+4], esi
$LN6@get_precin:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4448 :   kdu_dims precinct_region = state->precinct_partition;

	movups	xmm1, XMMWORD PTR [edi+120]

; 4449 :   precinct_region.pos.x += idx.x * precinct_region.size.x;

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	movups	XMMWORD PTR _precinct_region$[ebp], xmm1
	movd	ecx, xmm0
	psrldq	xmm1, 4
	movd	eax, xmm1
	imul	ecx, esi
	add	eax, ecx

; 4450 :   precinct_region.pos.y += idx.y * precinct_region.size.y;
; 4451 :   precinct_region &= state->node.dims;

	lea	ecx, DWORD PTR _precinct_region$[ebp]
	mov	DWORD PTR _precinct_region$[ebp+4], eax
	mov	eax, DWORD PTR _precinct_region$[ebp+8]
	imul	eax, edx
	add	DWORD PTR _precinct_region$[ebp], eax
	lea	eax, DWORD PTR [edi+24]
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	ecx, DWORD PTR _precinct_region$[ebp+12]
	mov	eax, ecx
	mov	esi, DWORD PTR _precinct_region$[ebp+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4453 :   kdu_coords low_min = precinct_region.pos;

	mov	edi, DWORD PTR _precinct_region$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	imul	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4452 :   kdu_long area = precinct_region.area();

	mov	ebx, eax
	mov	DWORD PTR _area$1$[ebp], edx

; 4453 :   kdu_coords low_min = precinct_region.pos;

	mov	edx, DWORD PTR _precinct_region$[ebp+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	lea	eax, DWORD PTR [edi+esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4455 :   if (state->node.children[HL_BAND] != NULL)

	mov	esi, DWORD PTR _this$1$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	ecx, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4455 :   if (state->node.children[HL_BAND] != NULL)

	mov	esi, DWORD PTR [esi]
	cmp	DWORD PTR [esi+96], 0
	je	SHORT $LN2@get_precin

; 4456 :     { // Primary node is split horizontally
; 4457 :       low_min.x = (low_min.x+1) >> 1;

	inc	edx

; 4458 :       low_lim.x = (low_lim.x+1) >> 1;

	inc	ecx
	sar	edx, 1
	sar	ecx, 1
$LN2@get_precin:

; 4459 :     }
; 4460 :   if (state->node.children[LH_BAND] != NULL)

	cmp	DWORD PTR [esi+100], 0
	je	SHORT $LN3@get_precin

; 4461 :     { // Primary node is split vertically
; 4462 :       low_lim.y = (low_lim.y+1) >> 1;

	inc	eax

; 4463 :       low_min.y = (low_min.y+1) >> 1;

	inc	edi
	sar	eax, 1
	sar	edi, 1
$LN3@get_precin:

; 4464 :     }
; 4465 : 
; 4466 :   area -= (low_lim.y-low_min.y) * (low_lim.x-low_min.x);

	sub	eax, edi
	sub	ecx, edx
	imul	eax, ecx
	mov	ecx, DWORD PTR _area$1$[ebp]
	pop	edi
	pop	esi
	cdq
	sub	ebx, eax

; 4467 :   assert(area >= 0);
; 4468 :   return area;

	mov	eax, ebx
	sbb	ecx, edx
	mov	edx, ecx
	pop	ebx

; 4469 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?get_precinct_samples@kdu_resolution@@QAE_JUkdu_coords@@@Z ENDP ; kdu_resolution::get_precinct_samples
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_precinct_packets@kdu_resolution@@QAEHUkdu_coords@@PAVkdu_thread_env@@_N@Z
_TEXT	SEGMENT
_e$2 = -64						; size = 20
_seq_idx$3 = -44					; size = 8
_seq_res$4 = -36					; size = 4
tv569 = -32						; size = 4
_this$1$ = -28						; size = 4
$T5 = -24						; size = 4
tv535 = -20						; size = 4
_codestream$1$ = -16					; size = 4
__$EHRec$ = -12						; size = 12
_idx$ = 8						; size = 8
_env$ = 16						; size = 4
_lock$1$ = 20						; size = 4
_parse_if_necessary$ = 20				; size = 1
?get_precinct_packets@kdu_resolution@@QAEHUkdu_coords@@PAVkdu_thread_env@@_N@Z PROC ; kdu_resolution::get_precinct_packets, COMDAT
; _this$ = ecx

; 4365 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?get_precinct_packets@kdu_resolution@@QAEHUkdu_coords@@PAVkdu_thread_env@@_N@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 52					; 00000034H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	eax, ecx
	mov	DWORD PTR _this$1$[ebp], eax

; 4366 :   kd_tile *tile = state->tile_comp->tile;

	mov	esi, DWORD PTR [eax]

; 4367 :   kd_codestream *codestream = state->codestream;

	mov	ebx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR _codestream$1$[ebp], ebx

; 4368 :   if (codestream->out != NULL)

	cmp	DWORD PTR [ebx+8], 0
	mov	edi, DWORD PTR [eax+4]
	je	SHORT $LN4@get_precin

; 4369 :     return state->tile_comp->tile->num_layers;

	mov	eax, DWORD PTR [edi+132]

; 4436 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN4@get_precin:

; 4370 : 
; 4371 :   idx.from_apparent(state->codestream->transpose,

	mov	al, BYTE PTR [ebx+331]
	mov	cl, BYTE PTR [ebx+330]
	mov	ah, BYTE PTR [ebx+329]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	mov	edx, DWORD PTR _idx$[ebp+4]
	test	al, al
	je	SHORT $LN24@get_precin
	neg	edx
	mov	DWORD PTR _idx$[ebp+4], edx
$LN24@get_precin:

; 267  :         y=(vflip)?(-y):y;

	test	cl, cl
	mov	ecx, DWORD PTR _idx$[ebp]
	je	SHORT $LN26@get_precin
	neg	ecx
	mov	DWORD PTR _idx$[ebp], ecx
$LN26@get_precin:

; 268  :         if (transp) transpose();

	test	ah, ah
	je	SHORT $LN22@get_precin

; 210  :     kdu_coords(int x, int y) {this->x=x; this->y=y; }
; 211  :     void assign(const kdu_coords &src) { *this = src; }
; 212  :       /* [SYNOPSIS] Copies the contents of `src' to the present object.
; 213  :          This function is useful only when using a language binding
; 214  :          which does not support data member access or direct copying
; 215  :          of contents. */
; 216  :     int get_x() { return x; }
; 217  :     int get_y() { return y; }
; 218  :     void set_x(int x) { this->x = x; }
; 219  :     void set_y(int y) { this->y = y; }
; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, ecx
	mov	ecx, edx
	mov	edx, eax
	mov	DWORD PTR _idx$[ebp], ecx
	mov	DWORD PTR _idx$[ebp+4], edx
$LN22@get_precin:

; 238  :     kdu_coords add(const kdu_coords &rhs)
; 239  :       { /* [SYNOPSIS] Same as `operator+=', but more suitable for some
; 240  :                       language bindings. */
; 241  :         x+=rhs.x; y+=rhs.y; return *this;
; 242  :       }
; 243  :     kdu_coords operator-=(const kdu_coords &rhs)
; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	sub	edx, DWORD PTR [esi+156]
	mov	DWORD PTR _idx$[ebp+4], edx
	sub	ecx, DWORD PTR [esi+152]
	mov	DWORD PTR _idx$[ebp], ecx

; 221  :       /* [SYNOPSIS] Swaps the vertical and horizontal coordinates. */
; 222  :     kdu_coords operator+(const kdu_coords &rhs)
; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }
; 224  :     kdu_coords plus(const kdu_coords &rhs)
; 225  :       { /* [SYNOPSIS] Same as `operator+', but more suitable for
; 226  :                       some language bindings. */
; 227  :            return (*this)+rhs;
; 228  :       }
; 229  :     kdu_coords operator-(const kdu_coords &rhs)
; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }
; 231  :     kdu_coords minus(const kdu_coords &rhs)
; 232  :       { /* [SYNOPSIS] Same as `operator-', but more suitable for
; 233  :                       some language bindings. */
; 234  :            return (*this)-rhs;
; 235  :       }
; 236  :     kdu_coords operator+=(const kdu_coords &rhs)
; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	add	edx, DWORD PTR [esi+156]
	mov	DWORD PTR _idx$[ebp+4], edx
	add	ecx, DWORD PTR [esi+152]
	mov	DWORD PTR _idx$[ebp], ecx

; 238  :     kdu_coords add(const kdu_coords &rhs)
; 239  :       { /* [SYNOPSIS] Same as `operator+=', but more suitable for some
; 240  :                       language bindings. */
; 241  :         x+=rhs.x; y+=rhs.y; return *this;
; 242  :       }
; 243  :     kdu_coords operator-=(const kdu_coords &rhs)
; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	sub	edx, DWORD PTR [esi+140]
	mov	DWORD PTR _idx$[ebp+4], edx
	sub	ecx, DWORD PTR [esi+136]
	mov	DWORD PTR _idx$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4379 :   int p = idx.y*state->precinct_indices.size.x + idx.x;

	mov	eax, DWORD PTR [esi+148]
	imul	eax, ecx
	add	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4745 :   volatile kdu_long *state_ref = &state;

	mov	edx, DWORD PTR [esi+180]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4380 :   kd_precinct *precinct = state->precinct_refs[p].active_deref();

	shl	eax, 3
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4745 :   volatile kdu_long *state_ref = &state;

	add	edx, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4380 :   kd_precinct *precinct = state->precinct_refs[p].active_deref();

	mov	DWORD PTR tv569[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4746 :   register kdu_long state_val = *state_ref;

	mov	esi, DWORD PTR [edx]

; 4747 :   if ((state_val & 1) || (state_val == 0)) return NULL;

	mov	eax, esi
	mov	ecx, DWORD PTR [edx+4]
	and	eax, 1
	or	eax, 0
	jne	SHORT $LN38@get_precin
	mov	eax, esi
	or	eax, ecx
	je	SHORT $LN38@get_precin

; 4748 :   kd_precinct *result = (kd_precinct *) _kdu_long_to_addr(state_val);
; 4749 :   if (result->flags & (KD_PFLAG_INACTIVE|KD_PFLAG_RELEASED)) return NULL;

	test	BYTE PTR [esi+8], 48			; 00000030H
	jne	SHORT $LN38@get_precin

; 4750 :   return (*state_ref == _addr_to_kdu_long(result))?result:NULL;

	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR tv535[ebp], eax
	mov	eax, esi
	cdq
	cmp	ecx, eax
	jne	SHORT $LN38@get_precin
	cmp	DWORD PTR tv535[ebp], edx
	je	SHORT $LN36@get_precin
$LN38@get_precin:

; 4747 :   if ((state_val & 1) || (state_val == 0)) return NULL;

	xor	esi, esi
$LN36@get_precin:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4381 :   if (parse_if_necessary && (codestream->in != NULL) &&

	cmp	BYTE PTR _parse_if_necessary$[ebp], 0
	je	$LN16@get_precin
	cmp	DWORD PTR [ebx+4], 0
	je	$LN16@get_precin
	test	esi, esi
	je	SHORT $LN6@get_precin
	mov	eax, DWORD PTR [esi+16]
	cmp	eax, DWORD PTR [esi+12]
	jge	$LN16@get_precin
$LN6@get_precin:

; 4382 :       ((precinct == NULL) ||
; 4383 :        (precinct->next_layer_idx < precinct->required_layers)))
; 4384 :     {
; 4385 :       if (env != NULL)

	mov	eax, DWORD PTR _env$[ebp]
	test	eax, eax
	je	SHORT $LN45@get_precin
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	ecx, DWORD PTR [eax+20]
	mov	edx, DWORD PTR [eax+28]
	mov	DWORD PTR _lock$1$[ebp], edx
	cmp	BYTE PTR [ecx], 0
	je	SHORT $LN44@get_precin
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR $T5[ebp], eax
	lea	eax, DWORD PTR $T5[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN73@get_precin:
$LN44@get_precin:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	je	SHORT $LN48@get_precin
	push	-1
	push	ecx
	call	DWORD PTR __imp__WaitForSingleObject@8
	mov	eax, DWORD PTR _env$[ebp]
	mov	edx, DWORD PTR _lock$1$[ebp]
$LN48@get_precin:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edx+4], eax
$LN45@get_precin:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4387 :       if (precinct == NULL)

	test	esi, esi
	jne	SHORT $LN9@get_precin

; 4388 :         precinct = state->precinct_refs[p].open(state,idx,true);

	mov	ecx, DWORD PTR _this$1$[ebp]
	push	1
	push	DWORD PTR _idx$[ebp+4]
	mov	ecx, DWORD PTR [ecx]
	push	DWORD PTR _idx$[ebp]
	push	ecx
	mov	ecx, DWORD PTR [ecx+180]
	add	ecx, DWORD PTR tv569[ebp]
	call	?open@kd_precinct_ref@@QAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@_N@Z ; kd_precinct_ref::open
	mov	esi, eax

; 4389 :       if (precinct == NULL)

	test	esi, esi
	jne	SHORT $LN9@get_precin

; 4390 :         {
; 4391 :           if (env != NULL)

	mov	ecx, DWORD PTR _env$[ebp]
	test	ecx, ecx
	je	SHORT $LN10@get_precin

; 4392 :             env->release_lock(KD_THREADLOCK_GENERAL); // Not strictly required

	push	eax
	call	?release_lock@kdu_thread_entity@@QAEXH@Z ; kdu_thread_entity::release_lock
$LN10@get_precin:

; 4393 :           KDU_ERROR_DEV(e,22); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0MG@MIKKMPNN@The?5precinct?5you?5are?5trying?5to?5a@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4393 :           KDU_ERROR_DEV(e,22); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4398 :         }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN9@get_precin:

; 4399 :       if (!codestream->cached)

	cmp	BYTE PTR [ebx+338], 0
	jne	$LN15@get_precin
$LN72@get_precin:

; 4400 :         {
; 4401 :           while ((!tile->exhausted) &&

	cmp	BYTE PTR [edi+268], 0
	jne	$LN65@get_precin
	mov	eax, DWORD PTR [esi+16]
	cmp	eax, DWORD PTR [esi+12]
	jge	$LN65@get_precin

; 4402 :                  (precinct->next_layer_idx < precinct->required_layers))
; 4403 :             {
; 4404 :               if ((tile != codestream->active_tile) &&

	cmp	edi, DWORD PTR [ebx+364]
	je	SHORT $LN12@get_precin
	mov	ecx, edi
	call	?read_tile_part_header@kd_tile@@QAE_NXZ	; kd_tile::read_tile_part_header
	test	al, al
	je	SHORT $LN61@get_precin
$LN12@get_precin:

; 4414 :                 tile->sequencer->next_in_sequence(seq_res,seq_idx);

	mov	ecx, DWORD PTR [edi+52]
	lea	eax, DWORD PTR _seq_idx$3[ebp]
	push	eax
	lea	eax, DWORD PTR _seq_res$4[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _seq_idx$3[ebp], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4414 :                 tile->sequencer->next_in_sequence(seq_res,seq_idx);

	push	eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _seq_idx$3[ebp+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4414 :                 tile->sequencer->next_in_sequence(seq_res,seq_idx);

	call	?next_in_sequence@kd_packet_sequencer@@QAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_sequence
	mov	edx, eax

; 4415 :               if ((seq_ref == NULL) ||

	test	edx, edx
	je	SHORT $LN14@get_precin
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4661 :   register kdu_long state_val = state;

	mov	ebx, DWORD PTR [edx]

; 4662 :   return ((state_val != 0) &&

	mov	ecx, ebx
	or	ecx, DWORD PTR [edx+4]
	je	SHORT $LN58@get_precin
	mov	eax, ebx
	and	eax, 1
	or	eax, 0
	jne	SHORT $LN13@get_precin
	test	BYTE PTR [ebx+8], 4
	jne	SHORT $LN13@get_precin
$LN58@get_precin:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4415 :               if ((seq_ref == NULL) ||

	push	0
	push	DWORD PTR _seq_idx$3[ebp+4]
	mov	ecx, edx
	push	DWORD PTR _seq_idx$3[ebp]
	push	DWORD PTR _seq_res$4[ebp]
	call	?open@kd_precinct_ref@@QAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@_N@Z ; kd_precinct_ref::open
	mov	ecx, eax
	call	?desequence_packet@kd_precinct@@QAE_NXZ	; kd_precinct::desequence_packet
	test	al, al
	jne	SHORT $LN13@get_precin
$LN14@get_precin:

; 4416 :                   !(seq_ref->is_desequenced() ||
; 4417 :                     seq_ref->open(seq_res,seq_idx,false)->desequence_packet()))
; 4418 :                 tile->read_tile_part_header();

	mov	ecx, edi
	call	?read_tile_part_header@kd_tile@@QAE_NXZ	; kd_tile::read_tile_part_header
$LN13@get_precin:

; 4400 :         {
; 4401 :           while ((!tile->exhausted) &&

	mov	ebx, DWORD PTR _codestream$1$[ebp]
	jmp	$LN72@get_precin
$LN61@get_precin:

; 4405 :                   !tile->read_tile_part_header())
; 4406 :                 {
; 4407 :                   assert(!tile->closed); // Otherwise, we could delete ourself.
; 4408 :                   tile->finished_reading();

	mov	ecx, edi
	call	?finished_reading@kd_tile@@QAE_NXZ	; kd_tile::finished_reading
$LN65@get_precin:

; 4419 :             }
; 4420 :           if ((precinct->num_packets_read == 0) &&
; 4421 :               (codestream->active_tile != NULL) &&

	cmp	DWORD PTR [esi+20], 0
	jne	SHORT $LN15@get_precin
	mov	eax, DWORD PTR [ebx+364]
	test	eax, eax
	je	SHORT $LN15@get_precin
	cmp	BYTE PTR [eax+231], 0
	jne	SHORT $LN15@get_precin

; 4422 :               !codestream->active_tile->is_addressable)
; 4423 :             { // Strange situation in which `precinct' has a seek address, but
; 4424 :               // the `active_tile' does not have seek addresses; must fully
; 4425 :               // desequence it before doing any seeking.
; 4426 :               kd_tile *active=codestream->active_tile;  assert(active != tile);
; 4427 :               desequence_packets_until_tile_inactive(active,codestream);

	push	ebx
	push	eax
	call	?desequence_packets_until_tile_inactive@@YAXPAUkd_tile@@PAUkd_codestream@@@Z ; desequence_packets_until_tile_inactive
	add	esp, 8
$LN15@get_precin:

; 4428 :             }
; 4429 :         }
; 4430 :       precinct->load_required_packets(); // In case they are not already in.

	mov	ecx, esi
	call	?load_required_packets@kd_precinct@@QAEXXZ ; kd_precinct::load_required_packets

; 4431 :       if (env != NULL)

	mov	eax, DWORD PTR _env$[ebp]
	test	eax, eax
	je	SHORT $LN16@get_precin

; 4432 :         env->release_lock(KD_THREADLOCK_GENERAL);

	push	0
	mov	ecx, eax
	call	?release_lock@kdu_thread_entity@@QAEXH@Z ; kdu_thread_entity::release_lock
$LN16@get_precin:

; 4433 :     }
; 4434 : 
; 4435 :   return (precinct==NULL)?0:(precinct->num_packets_read);

	test	esi, esi
	jne	SHORT $LN18@get_precin
	xor	eax, eax

; 4436 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN18@get_precin:

; 4433 :     }
; 4434 : 
; 4435 :   return (precinct==NULL)?0:(precinct->num_packets_read);

	mov	eax, DWORD PTR [esi+20]

; 4436 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN70@get_precin:
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?get_precinct_packets@kdu_resolution@@QAEHUkdu_coords@@PAVkdu_thread_env@@_N@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?get_precinct_packets@kdu_resolution@@QAEHUkdu_coords@@PAVkdu_thread_env@@_N@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-68]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?get_precinct_packets@kdu_resolution@@QAEHUkdu_coords@@PAVkdu_thread_env@@_N@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?get_precinct_packets@kdu_resolution@@QAEHUkdu_coords@@PAVkdu_thread_env@@_N@Z ENDP ; kdu_resolution::get_precinct_packets
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_precinct_relevance@kdu_resolution@@QAENUkdu_coords@@@Z
_TEXT	SEGMENT
$T1 = -32						; size = 16
$T2 = -32						; size = 16
_precinct_region$ = -16					; size = 16
tv203 = 8						; size = 8
tv165 = 8						; size = 8
_idx$ = 8						; size = 8
?get_precinct_relevance@kdu_resolution@@QAENUkdu_coords@@@Z PROC ; kdu_resolution::get_precinct_relevance, COMDAT
; _this$ = ecx

; 4342 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 32					; 00000020H
	push	ebx
	mov	ebx, ecx
	push	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	mov	esi, DWORD PTR _idx$[ebp+4]
	push	edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4343 :   idx.from_apparent(state->codestream->transpose,

	mov	edi, DWORD PTR [ebx]
	mov	eax, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	cmp	BYTE PTR [eax+331], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4343 :   idx.from_apparent(state->codestream->transpose,

	mov	dl, BYTE PTR [eax+330]
	mov	cl, BYTE PTR [eax+329]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	je	SHORT $LN7@get_precin
	neg	esi
	mov	DWORD PTR _idx$[ebp+4], esi
$LN7@get_precin:

; 267  :         y=(vflip)?(-y):y;

	test	dl, dl
	mov	edx, DWORD PTR _idx$[ebp]
	je	SHORT $LN9@get_precin
	neg	edx
	mov	DWORD PTR _idx$[ebp], edx
$LN9@get_precin:

; 268  :         if (transp) transpose();

	test	cl, cl
	je	SHORT $LN5@get_precin

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, edx
	mov	edx, esi
	mov	esi, eax
	mov	DWORD PTR _idx$[ebp], edx
	mov	DWORD PTR _idx$[ebp+4], esi
$LN5@get_precin:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4346 :   kdu_dims precinct_region = state->precinct_partition;

	movups	xmm1, XMMWORD PTR [edi+120]

; 4347 :   precinct_region.pos.x += idx.x * precinct_region.size.x;

	movaps	xmm0, xmm1
	psrldq	xmm0, 12				; 0000000cH
	movups	XMMWORD PTR _precinct_region$[ebp], xmm1
	movd	ecx, xmm0
	psrldq	xmm1, 4
	movd	eax, xmm1
	imul	ecx, esi
	add	eax, ecx

; 4348 :   precinct_region.pos.y += idx.y * precinct_region.size.y;
; 4349 :   precinct_region &= state->node.dims;

	lea	ecx, DWORD PTR _precinct_region$[ebp]
	mov	DWORD PTR _precinct_region$[ebp+4], eax
	mov	eax, DWORD PTR _precinct_region$[ebp+8]
	imul	eax, edx
	add	DWORD PTR _precinct_region$[ebp], eax
	lea	eax, DWORD PTR [edi+24]
	push	eax
	lea	eax, DWORD PTR $T2[ebp]
	push	eax
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR _precinct_region$[ebp+12]
	imul	DWORD PTR _precinct_region$[ebp+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4350 :   kdu_long area = precinct_region.area();

	mov	edi, edx
	mov	esi, eax

; 4351 :   if (area <= 0)

	test	edi, edi
	jg	SHORT $LN2@get_precin
	jl	SHORT $LN17@get_precin
	test	esi, esi
	jne	SHORT $LN2@get_precin
$LN17@get_precin:

; 4352 :     return 0.0;

	fldz
	pop	edi
	pop	esi
	pop	ebx

; 4356 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN2@get_precin:

; 4353 :   precinct_region &= state->node.region_cover;

	mov	eax, DWORD PTR [ebx]
	lea	ecx, DWORD PTR _precinct_region$[ebp]
	add	eax, 60					; 0000003cH
	push	eax
	lea	eax, DWORD PTR $T1[ebp]
	push	eax
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR _precinct_region$[ebp+12]
	imul	DWORD PTR _precinct_region$[ebp+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4354 :   double ratio = ((double) precinct_region.area()) / ((double) area);

	mov	ecx, eax
	call	__ltod3
	mov	edx, edi
	movsd	QWORD PTR tv165[ebp], xmm0
	mov	ecx, esi
	call	__ltod3
	movsd	xmm1, QWORD PTR tv165[ebp]
	divsd	xmm1, xmm0
	pop	edi
	pop	esi
	pop	ebx

; 4355 :   return ratio;

	movsd	QWORD PTR tv203[ebp], xmm1
	fld	QWORD PTR tv203[ebp]

; 4356 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?get_precinct_relevance@kdu_resolution@@QAENUkdu_coords@@@Z ENDP ; kdu_resolution::get_precinct_relevance
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_precinct_id@kdu_resolution@@QAE_JUkdu_coords@@@Z
_TEXT	SEGMENT
_tc$1$ = -12						; size = 4
_tile$1$ = -8						; size = 4
_id$2$ = -4						; size = 4
_idx$ = 8						; size = 8
?get_precinct_id@kdu_resolution@@QAE_JUkdu_coords@@@Z PROC ; kdu_resolution::get_precinct_id, COMDAT
; _this$ = ecx

; 4318 : {

	push	ebp
	mov	ebp, esp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	mov	edx, DWORD PTR _idx$[ebp+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4318 : {

	sub	esp, 12					; 0000000cH
	push	ebx
	push	esi
	push	edi

; 4319 :   idx.from_apparent(state->codestream->transpose,

	mov	edi, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	cmp	BYTE PTR [eax+331], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4319 :   idx.from_apparent(state->codestream->transpose,

	mov	cl, BYTE PTR [eax+330]
	mov	bl, BYTE PTR [eax+329]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	je	SHORT $LN9@get_precin
	neg	edx
	mov	DWORD PTR _idx$[ebp+4], edx
$LN9@get_precin:

; 267  :         y=(vflip)?(-y):y;

	test	cl, cl
	mov	ecx, DWORD PTR _idx$[ebp]
	je	SHORT $LN11@get_precin
	neg	ecx
	mov	DWORD PTR _idx$[ebp], ecx
$LN11@get_precin:

; 268  :         if (transp) transpose();

	test	bl, bl
	je	SHORT $LN7@get_precin

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, ecx
	mov	ecx, edx
	mov	edx, eax
	mov	DWORD PTR _idx$[ebp], ecx
	mov	DWORD PTR _idx$[ebp+4], edx
$LN7@get_precin:

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	sub	edx, DWORD PTR [edi+140]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4328 :   for (kd_resolution *rp=state-state->res_level; rp != state; rp++)

	mov	esi, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	mov	DWORD PTR _idx$[ebp+4], edx
	sub	ecx, DWORD PTR [edi+136]
	mov	DWORD PTR _idx$[ebp], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4325 :   kd_tile_comp *tc = state->tile_comp;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR _tc$1$[ebp], eax

; 4326 :   kd_tile *tile = tc->tile;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR _tile$1$[ebp], eax

; 4327 :   kdu_long id = idx.y*state->precinct_indices.size.x + idx.x;

	mov	eax, DWORD PTR [edi+148]
	imul	eax, ecx
	add	eax, edx
	cdq
	mov	ebx, eax
	mov	ecx, edx

; 4328 :   for (kd_resolution *rp=state-state->res_level; rp != state; rp++)

	movzx	eax, BYTE PTR [edi+12]
	imul	eax, eax, 604
	mov	DWORD PTR _id$2$[ebp], ecx
	sub	esi, eax
	cmp	esi, edi
	je	SHORT $LN3@get_precin

; 4320 :                     state->codestream->vflip,
; 4321 :                     state->codestream->hflip);
; 4322 :   idx -= state->precinct_indices.pos;

	lea	ecx, DWORD PTR [esi+144]
	npad	1
$LL4@get_precin:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [ecx+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4328 :   for (kd_resolution *rp=state-state->res_level; rp != state; rp++)

	lea	ecx, DWORD PTR [ecx+604]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	imul	DWORD PTR [ecx-604]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4329 :     id += rp->precinct_indices.area();

	add	ebx, eax
	adc	DWORD PTR _id$2$[ebp], edx
	add	esi, 604				; 0000025cH
	cmp	esi, edi
	jne	SHORT $LL4@get_precin
	mov	ecx, DWORD PTR _id$2$[ebp]
$LN3@get_precin:

; 4330 :   id = id*tile->num_components + tc->cnum;
; 4331 :   id = id*tile->codestream->tile_span.x*tile->codestream->tile_span.y;

	mov	eax, DWORD PTR _tile$1$[ebp]
	push	ecx
	push	ebx
	mov	edi, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+128]
	cdq
	push	edx
	push	eax
	call	__allmul
	mov	esi, eax
	mov	ecx, edx
	mov	eax, DWORD PTR _tc$1$[ebp]
	mov	eax, DWORD PTR [eax+12]
	cdq
	add	esi, eax
	mov	eax, DWORD PTR [edi+168]
	adc	ecx, edx
	cdq
	push	edx
	push	eax
	push	ecx
	push	esi
	call	__allmul
	mov	esi, eax
	mov	ecx, edx
	mov	eax, DWORD PTR [edi+164]
	cdq
	push	edx
	push	eax
	push	ecx
	push	esi
	call	__allmul
	mov	ecx, eax
	mov	esi, edx

; 4332 :   id += tile->t_num;

	mov	eax, DWORD PTR _tile$1$[ebp]
	pop	edi
	mov	eax, DWORD PTR [eax+4]
	cdq
	add	eax, ecx
	adc	edx, esi
	pop	esi
	pop	ebx

; 4333 :   return id;
; 4334 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?get_precinct_id@kdu_resolution@@QAE_JUkdu_coords@@@Z ENDP ; kdu_resolution::get_precinct_id
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?open_precinct@kdu_resolution@@QAE?AVkdu_precinct@@Ukdu_coords@@@Z
_TEXT	SEGMENT
_e$2 = -32						; size = 20
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_idx$ = 12						; size = 8
?open_precinct@kdu_resolution@@QAE?AVkdu_precinct@@Ukdu_coords@@@Z PROC ; kdu_resolution::open_precinct, COMDAT
; _this$ = ecx

; 4290 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?open_precinct@kdu_resolution@@QAE?AVkdu_precinct@@Ukdu_coords@@@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 20					; 00000014H
	push	ebx
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 4291 :   if ((state->codestream->in != NULL) ||

	mov	eax, DWORD PTR [edi]
	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN3@open_preci
	cmp	DWORD PTR [eax+8], 0
	je	SHORT $LN2@open_preci
$LN3@open_preci:

; 4293 :     { KDU_ERROR_DEV(e,21); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0LI@BAKNOCIL@Calls?5to?5?$GAkdu_resolution?3?3open_p@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4293 :     { KDU_ERROR_DEV(e,21); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4298 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@open_preci:

; 4299 :   idx.from_apparent(state->codestream->transpose,

	mov	edi, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	mov	esi, DWORD PTR _idx$[ebp+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4299 :   idx.from_apparent(state->codestream->transpose,

	mov	eax, DWORD PTR [edi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	cmp	BYTE PTR [eax+331], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4299 :   idx.from_apparent(state->codestream->transpose,

	mov	cl, BYTE PTR [eax+330]
	mov	bl, BYTE PTR [eax+329]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 266  :         x=(hflip)?(-x):x;

	je	SHORT $LN11@open_preci
	neg	esi
	mov	DWORD PTR _idx$[ebp+4], esi
$LN11@open_preci:

; 267  :         y=(vflip)?(-y):y;

	mov	edx, DWORD PTR _idx$[ebp]
	test	cl, cl
	je	SHORT $LN13@open_preci
	neg	edx
	mov	DWORD PTR _idx$[ebp], edx
$LN13@open_preci:

; 268  :         if (transp) transpose();

	test	bl, bl
	je	SHORT $LN9@open_preci

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, edx
	mov	edx, esi
	mov	esi, eax
	mov	DWORD PTR _idx$[ebp], edx
	mov	DWORD PTR _idx$[ebp+4], esi
$LN9@open_preci:

; 238  :     kdu_coords add(const kdu_coords &rhs)
; 239  :       { /* [SYNOPSIS] Same as `operator+=', but more suitable for some
; 240  :                       language bindings. */
; 241  :         x+=rhs.x; y+=rhs.y; return *this;
; 242  :       }
; 243  :     kdu_coords operator-=(const kdu_coords &rhs)
; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	sub	esi, DWORD PTR [edi+156]
	mov	DWORD PTR _idx$[ebp+4], esi
	sub	edx, DWORD PTR [edi+152]
	mov	DWORD PTR _idx$[ebp], edx

; 221  :       /* [SYNOPSIS] Swaps the vertical and horizontal coordinates. */
; 222  :     kdu_coords operator+(const kdu_coords &rhs)
; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }
; 224  :     kdu_coords plus(const kdu_coords &rhs)
; 225  :       { /* [SYNOPSIS] Same as `operator+', but more suitable for
; 226  :                       some language bindings. */
; 227  :            return (*this)+rhs;
; 228  :       }
; 229  :     kdu_coords operator-(const kdu_coords &rhs)
; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }
; 231  :     kdu_coords minus(const kdu_coords &rhs)
; 232  :       { /* [SYNOPSIS] Same as `operator-', but more suitable for
; 233  :                       some language bindings. */
; 234  :            return (*this)-rhs;
; 235  :       }
; 236  :     kdu_coords operator+=(const kdu_coords &rhs)
; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	add	esi, DWORD PTR [edi+156]
	mov	DWORD PTR _idx$[ebp+4], esi
	add	edx, DWORD PTR [edi+152]
	mov	DWORD PTR _idx$[ebp], edx

; 238  :     kdu_coords add(const kdu_coords &rhs)
; 239  :       { /* [SYNOPSIS] Same as `operator+=', but more suitable for some
; 240  :                       language bindings. */
; 241  :         x+=rhs.x; y+=rhs.y; return *this;
; 242  :       }
; 243  :     kdu_coords operator-=(const kdu_coords &rhs)
; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	sub	esi, DWORD PTR [edi+140]
	mov	DWORD PTR _idx$[ebp+4], esi
	sub	edx, DWORD PTR [edi+136]
	mov	DWORD PTR _idx$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4308 :   kd_precinct *precinct = state->precinct_refs[p].open(state,idx,true);

	mov	ecx, DWORD PTR [edi+148]
	mov	eax, DWORD PTR [edi+180]
	imul	ecx, edx
	add	ecx, esi
	lea	ebx, DWORD PTR [eax+ecx*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4722 :   if (state == 3)

	mov	ecx, DWORD PTR [ebx]
	cmp	ecx, 3
	jne	SHORT $LN24@open_preci
	cmp	DWORD PTR [ebx+4], 0
	jne	SHORT $LN24@open_preci
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 5571 :     kdu_precinct(kd_precinct *state) { this->state = state; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4310 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN24@open_preci:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4724 :   if ((state == 0) || (state & 1))

	mov	eax, ecx
	or	eax, DWORD PTR [ebx+4]
	je	SHORT $LN26@open_preci
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN26@open_preci

; 4726 :   kd_precinct *result = (kd_precinct *) _kdu_long_to_addr(state);

	mov	esi, DWORD PTR [ebx]

; 4727 :   if (result->flags & KD_PFLAG_INACTIVE)

	mov	eax, DWORD PTR [esi+8]
	test	al, 32					; 00000020H
	je	SHORT $LN27@open_preci

; 4728 :     { // Must be on the inactive list
; 4729 :       result->size_class->withdraw_from_inactive_list(result);

	mov	ecx, DWORD PTR [esi+52]
	push	esi
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list

; 4733 :     result->activate();

	mov	ecx, esi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 5571 :     kdu_precinct(kd_precinct *state) { this->state = state; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4310 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN27@open_preci:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4732 :   else if (need_activate && (result->flags & KD_PFLAG_RELEASED))

	test	al, 16					; 00000010H
	je	SHORT $LN29@open_preci

; 4733 :     result->activate();

	mov	ecx, esi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate
$LN29@open_preci:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 5571 :     kdu_precinct(kd_precinct *state) { this->state = state; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4310 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN26@open_preci:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4725 :     return instantiate_precinct(res,pos_idx);

	push	esi
	push	edx
	push	edi
	mov	ecx, ebx
	call	?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z ; kd_precinct_ref::instantiate_precinct
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 5571 :     kdu_precinct(kd_precinct *state) { this->state = state; }

	mov	ecx, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [ecx], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4309 :   return kdu_precinct(precinct);

	mov	eax, ecx

; 4310 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?open_precinct@kdu_resolution@@QAE?AVkdu_precinct@@Ukdu_coords@@@Z$0:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?open_precinct@kdu_resolution@@QAE?AVkdu_precinct@@Ukdu_coords@@@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-36]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?open_precinct@kdu_resolution@@QAE?AVkdu_precinct@@Ukdu_coords@@@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?open_precinct@kdu_resolution@@QAE?AVkdu_precinct@@Ukdu_coords@@@Z ENDP ; kdu_resolution::open_precinct
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_valid_precincts@kdu_resolution@@QAEXAAUkdu_dims@@@Z
_TEXT	SEGMENT
_indices$ = 8						; size = 4
?get_valid_precincts@kdu_resolution@@QAEXAAUkdu_dims@@@Z PROC ; kdu_resolution::get_valid_precincts, COMDAT
; _this$ = ecx

; 4277 : {

	push	ebp
	mov	ebp, esp

; 4278 :   indices = state->region_indices;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _indices$[ebp]
	push	ebx
	movups	xmm0, XMMWORD PTR [eax+152]
	movups	XMMWORD PTR [edx], xmm0

; 4279 :   indices.to_apparent(state->codestream->transpose,

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	cmp	BYTE PTR [eax+329], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4279 :   indices.to_apparent(state->codestream->transpose,

	mov	bl, BYTE PTR [eax+331]
	mov	bh, BYTE PTR [eax+330]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	je	SHORT $LN4@get_valid_

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
$LN4@get_valid_:

; 426  :       if (hflip) pos.x = -(pos.x+size.x-1);

	mov	ecx, 1
	test	bl, bl
	je	SHORT $LN5@get_valid_
	mov	eax, ecx
	sub	eax, DWORD PTR [edx+12]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx+4], eax
$LN5@get_valid_:

; 427  :       if (vflip) pos.y = -(pos.y+size.y-1);

	test	bh, bh
	pop	ebx
	je	SHORT $LN6@get_valid_
	sub	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [edx]
	mov	DWORD PTR [edx], ecx
$LN6@get_valid_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4282 : }

	pop	ebp
	ret	4
?get_valid_precincts@kdu_resolution@@QAEXAAUkdu_dims@@@Z ENDP ; kdu_resolution::get_valid_precincts
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_dims@kdu_resolution@@QAEXAAUkdu_dims@@@Z
_TEXT	SEGMENT
_result$ = 8						; size = 4
?get_dims@kdu_resolution@@QAEXAAUkdu_dims@@@Z PROC	; kdu_resolution::get_dims, COMDAT
; _this$ = ecx

; 4263 : {

	push	ebp
	mov	ebp, esp

; 4264 :   assert(state != NULL);
; 4265 :   result = state->node.region;

	mov	eax, DWORD PTR [ecx]
	mov	edx, DWORD PTR _result$[ebp]
	push	ebx
	movups	xmm0, XMMWORD PTR [eax+40]
	movups	XMMWORD PTR [edx], xmm0

; 4266 :   result.to_apparent(state->codestream->transpose,

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	cmp	BYTE PTR [eax+329], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4266 :   result.to_apparent(state->codestream->transpose,

	mov	bl, BYTE PTR [eax+331]
	mov	bh, BYTE PTR [eax+330]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 425  :       if (transp) transpose();

	je	SHORT $LN4@get_dims

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	ecx, DWORD PTR [edx+8]
	mov	eax, DWORD PTR [edx+12]
	mov	DWORD PTR [edx+8], eax
	mov	DWORD PTR [edx+12], ecx
	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
$LN4@get_dims:

; 426  :       if (hflip) pos.x = -(pos.x+size.x-1);

	mov	ecx, 1
	test	bl, bl
	je	SHORT $LN5@get_dims
	mov	eax, ecx
	sub	eax, DWORD PTR [edx+12]
	sub	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx+4], eax
$LN5@get_dims:

; 427  :       if (vflip) pos.y = -(pos.y+size.y-1);

	test	bh, bh
	pop	ebx
	je	SHORT $LN6@get_dims
	sub	ecx, DWORD PTR [edx+8]
	sub	ecx, DWORD PTR [edx]
	mov	DWORD PTR [edx], ecx
$LN6@get_dims:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4269 : }

	pop	ebp
	ret	4
?get_dims@kdu_resolution@@QAEXAAUkdu_dims@@@Z ENDP	; kdu_resolution::get_dims
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_comp_idx@kdu_resolution@@QAEHXZ
_TEXT	SEGMENT
?get_comp_idx@kdu_resolution@@QAEHXZ PROC		; kdu_resolution::get_comp_idx, COMDAT
; _this$ = ecx

; 4254 : 	return state->rescomp->comp_idx;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+8]
	mov	eax, DWORD PTR [eax+8]

; 4255 : }

	ret	0
?get_comp_idx@kdu_resolution@@QAEHXZ ENDP		; kdu_resolution::get_comp_idx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_dwt_level@kdu_resolution@@QAEHXZ
_TEXT	SEGMENT
?get_dwt_level@kdu_resolution@@QAEHXZ PROC		; kdu_resolution::get_dwt_level, COMDAT
; _this$ = ecx

; 4246 :   return state->dwt_level;

	mov	eax, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [eax+13]

; 4247 : }

	ret	0
?get_dwt_level@kdu_resolution@@QAEHXZ ENDP		; kdu_resolution::get_dwt_level
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?which@kdu_resolution@@QAEHXZ
_TEXT	SEGMENT
?which@kdu_resolution@@QAEHXZ PROC			; kdu_resolution::which, COMDAT
; _this$ = ecx

; 4235 :   assert(state != NULL);
; 4236 :   return state->res_level;

	mov	eax, DWORD PTR [ecx]
	movzx	eax, BYTE PTR [eax+12]

; 4237 : }

	ret	0
?which@kdu_resolution@@QAEHXZ ENDP			; kdu_resolution::which
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?access_next@kdu_resolution@@QAE?AV1@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?access_next@kdu_resolution@@QAE?AV1@XZ PROC		; kdu_resolution::access_next, COMDAT
; _this$ = ecx

; 4223 : {

	push	ebp
	mov	ebp, esp

; 4225 :   return kdu_resolution((state->res_level==0)?NULL:(state-1));

	mov	ecx, DWORD PTR [ecx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4668 :     kdu_resolution(kd_resolution *state) { this->state = state; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4225 :   return kdu_resolution((state->res_level==0)?NULL:(state-1));

	cmp	BYTE PTR [ecx+12], 0
	jne	SHORT $LN3@access_nex
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4668 :     kdu_resolution(kd_resolution *state) { this->state = state; }

	mov	DWORD PTR [eax], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4226 : }

	pop	ebp
	ret	4
$LN3@access_nex:

; 4225 :   return kdu_resolution((state->res_level==0)?NULL:(state-1));

	add	ecx, -604				; fffffda4H
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4668 :     kdu_resolution(kd_resolution *state) { this->state = state; }

	mov	DWORD PTR [eax], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 4226 : }

	pop	ebp
	ret	4
?access_next@kdu_resolution@@QAE?AV1@XZ ENDP		; kdu_resolution::access_next
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_resolution@@QAE@PAUkd_resolution@@@Z
_TEXT	SEGMENT
_state$ = 8						; size = 4
??0kdu_resolution@@QAE@PAUkd_resolution@@@Z PROC	; kdu_resolution::kdu_resolution, COMDAT
; _this$ = ecx

; 4668 :     kdu_resolution(kd_resolution *state) { this->state = state; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0kdu_resolution@@QAE@PAUkd_resolution@@@Z ENDP	; kdu_resolution::kdu_resolution
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@XZ PROC ; kdu_tile_comp::access_resolution, COMDAT
; _this$ = ecx

; 3989 : {

	push	ebp
	mov	ebp, esp

; 3990 :   return access_resolution(state->apparent_dwt_levels);

	mov	eax, DWORD PTR [ecx]
	push	DWORD PTR [eax+60]
	push	DWORD PTR ___$ReturnUdt$[ebp]
	call	?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@H@Z ; kdu_tile_comp::access_resolution
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]

; 3991 : }

	pop	ebp
	ret	4
?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@XZ ENDP ; kdu_tile_comp::access_resolution
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@H@Z
_TEXT	SEGMENT
_e$2 = -52						; size = 20
_e$3 = -32						; size = 20
__$EHRec$ = -12						; size = 12
___$ReturnUdt$ = 8					; size = 4
_res_level$ = 12					; size = 4
?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@H@Z PROC ; kdu_tile_comp::access_resolution, COMDAT
; _this$ = ecx

; 3961 : {

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@H@Z
	mov	eax, DWORD PTR fs:0
	push	eax
	sub	esp, 40					; 00000028H
	push	esi
	push	edi
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	mov	edi, ecx

; 3962 :   if ((res_level < 0) || (res_level > state->apparent_dwt_levels))

	mov	esi, DWORD PTR _res_level$[ebp]
	test	esi, esi
	js	SHORT $LN3@access_res
	mov	eax, DWORD PTR [edi]
	cmp	esi, DWORD PTR [eax+60]
	jle	SHORT $LN2@access_res
$LN3@access_res:

; 3963 :     { KDU_ERROR_DEV(e,19); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$3[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$3[ebp]
	lea	ecx, DWORD PTR _e$3[ebp]
	push	OFFSET ??_C@_0NP@CFEPKMLA@Attempting?5to?5access?5a?5non?9exist@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3963 :     { KDU_ERROR_DEV(e,19); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3968 :     }

	lea	ecx, DWORD PTR _e$3[ebp]
	mov	DWORD PTR __$EHRec$[ebp+8], -1
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN2@access_res:

; 3969 :   kd_resolution *result = state->resolutions + res_level;

	mov	eax, DWORD PTR [edi]
	imul	esi, esi, 604
	add	esi, DWORD PTR [eax+144]

; 3970 :   if ((!result->can_flip) &&

	cmp	BYTE PTR [esi+173], 0
	jne	SHORT $LN15@access_res
	mov	eax, DWORD PTR [eax]
	cmp	BYTE PTR [eax+330], 0
	jne	SHORT $LN5@access_res
	cmp	BYTE PTR [eax+331], 0
	je	SHORT $LN15@access_res
$LN5@access_res:

; 3972 :     { KDU_ERROR_DEV(e,0x17050500); e <<

	push	OFFSET ??_C@_0BE@KMIJLGEL@Kakadu?5Core?5Error?3?6?$AA@
	lea	ecx, DWORD PTR _e$2[ebp]
	call	??0kdu_error@@QAE@PBD@Z			; kdu_error::kdu_error
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	mov	eax, DWORD PTR _e$2[ebp]
	lea	ecx, DWORD PTR _e$2[ebp]
	push	OFFSET ??_C@_0BCL@NDBOHLBO@Attempting?5to?5access?5a?5resolutio@
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3972 :     { KDU_ERROR_DEV(e,0x17050500); e <<

	mov	DWORD PTR __$EHRec$[ebp+8], 1
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h

; 257  :       { put_text(string); return *this; }

	call	DWORD PTR [eax+8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3979 :     }

	lea	ecx, DWORD PTR _e$2[ebp]
	call	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
$LN15@access_res:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4668 :     kdu_resolution(kd_resolution *state) { this->state = state; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	DWORD PTR [eax], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3981 : }

	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	pop	edi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__unwindfunclet$?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@H@Z$0:
	lea	ecx, DWORD PTR _e$3[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__unwindfunclet$?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@H@Z$1:
	lea	ecx, DWORD PTR _e$2[ebp]
	jmp	??1kdu_error@@UAE@XZ			; kdu_error::~kdu_error
__ehhandler$?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@H@Z:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-52]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@H@Z
	jmp	___CxxFrameHandler3
text$x	ENDS
?access_resolution@kdu_tile_comp@@QAE?AVkdu_resolution@@H@Z ENDP ; kdu_tile_comp::access_resolution
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_num_resolutions@kdu_tile_comp@@QAEHXZ
_TEXT	SEGMENT
?get_num_resolutions@kdu_tile_comp@@QAEHXZ PROC		; kdu_tile_comp::get_num_resolutions, COMDAT
; _this$ = ecx

; 3950 :   if (state->apparent_dwt_levels < 0)

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+60]
	test	eax, eax
	jns	SHORT $LN2@get_num_re

; 3951 :     return 0;

	xor	eax, eax

; 3953 : }

	ret	0
$LN2@get_num_re:

; 3952 :   return state->apparent_dwt_levels+1;

	inc	eax

; 3953 : }

	ret	0
?get_num_resolutions@kdu_tile_comp@@QAEHXZ ENDP		; kdu_tile_comp::get_num_resolutions
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_signed@kdu_tile_comp@@QAE_NXZ
_TEXT	SEGMENT
?get_signed@kdu_tile_comp@@QAE_NXZ PROC			; kdu_tile_comp::get_signed, COMDAT
; _this$ = ecx

; 3940 :   return state->comp_info->is_signed;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+8]
	mov	al, BYTE PTR [eax+20]

; 3941 : }

	ret	0
?get_signed@kdu_tile_comp@@QAE_NXZ ENDP			; kdu_tile_comp::get_signed
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_bit_depth@kdu_tile_comp@@QAEH_N@Z
_TEXT	SEGMENT
_internal$ = 8						; size = 1
?get_bit_depth@kdu_tile_comp@@QAEH_N@Z PROC		; kdu_tile_comp::get_bit_depth, COMDAT
; _this$ = ecx

; 3926 : {

	push	ebp
	mov	ebp, esp

; 3927 :   int bit_depth = state->comp_info->precision;
; 3928 :   if (internal)

	cmp	BYTE PTR _internal$[ebp], 0
	mov	ecx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [eax+16]
	je	SHORT $LN2@get_bit_de

; 3929 :     bit_depth += state->recommended_extra_bits;

	add	eax, DWORD PTR [ecx+128]
$LN2@get_bit_de:

; 3930 :   return bit_depth;
; 3931 : }

	pop	ebp
	ret	4
?get_bit_depth@kdu_tile_comp@@QAEH_N@Z ENDP		; kdu_tile_comp::get_bit_depth
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_subsampling@kdu_tile_comp@@QAEXAAUkdu_coords@@@Z
_TEXT	SEGMENT
tv188 = 8						; size = 4
_sub_sampling$ = 8					; size = 4
?get_subsampling@kdu_tile_comp@@QAEXAAUkdu_coords@@@Z PROC ; kdu_tile_comp::get_subsampling, COMDAT
; _this$ = ecx

; 3911 : {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx
	push	edi

; 3912 :   sub_sampling = state->sub_sampling;

	mov	edi, DWORD PTR _sub_sampling$[ebp]
	mov	edx, DWORD PTR [esi]
	mov	eax, DWORD PTR [edx+16]
	mov	DWORD PTR [edi], eax
	mov	eax, DWORD PTR [edx+20]
	mov	DWORD PTR [edi+4], eax

; 3913 :   int shift = state->dwt_levels - state->apparent_dwt_levels;

	mov	eax, DWORD PTR [esi]

; 3914 :   sub_sampling.x <<= state->comp_info->hor_depth[shift];

	mov	ebx, DWORD PTR [edi+4]
	mov	edx, DWORD PTR [eax+56]
	sub	edx, DWORD PTR [eax+60]
	mov	eax, DWORD PTR [eax+8]
	movzx	ecx, BYTE PTR [eax+edx+21]
	shl	ebx, cl
	mov	DWORD PTR [edi+4], ebx

; 3915 :   sub_sampling.y <<= state->comp_info->vert_depth[shift];

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+8]
	movzx	ecx, BYTE PTR [eax+edx+54]
	mov	edx, DWORD PTR [edi]
	shl	edx, cl
	mov	DWORD PTR [edi], edx

; 3916 :   if (state->codestream->transpose)

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax]
	cmp	BYTE PTR [eax+329], 0
	je	SHORT $LN2@get_subsam
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	DWORD PTR [edi], ebx
	mov	DWORD PTR [edi+4], edx
$LN2@get_subsam:
	pop	edi
	pop	esi
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3918 : }

	pop	ebp
	ret	4
?get_subsampling@kdu_tile_comp@@QAEXAAUkdu_coords@@@Z ENDP ; kdu_tile_comp::get_subsampling
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_reversible@kdu_tile_comp@@QAE_NXZ
_TEXT	SEGMENT
?get_reversible@kdu_tile_comp@@QAE_NXZ PROC		; kdu_tile_comp::get_reversible, COMDAT
; _this$ = ecx

; 3902 :   return state->reversible;

	mov	eax, DWORD PTR [ecx]
	mov	al, BYTE PTR [eax+64]

; 3903 : }

	ret	0
?get_reversible@kdu_tile_comp@@QAE_NXZ ENDP		; kdu_tile_comp::get_reversible
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_tile_comp@@QAE@PAUkd_tile_comp@@@Z
_TEXT	SEGMENT
_state$ = 8						; size = 4
??0kdu_tile_comp@@QAE@PAUkd_tile_comp@@@Z PROC		; kdu_tile_comp::kdu_tile_comp, COMDAT
; _this$ = ecx

; 4518 :     kdu_tile_comp(kd_tile_comp *state) { this->state = state; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _state$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	4
??0kdu_tile_comp@@QAE@PAUkd_tile_comp@@@Z ENDP		; kdu_tile_comp::kdu_tile_comp
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?find_component_gain_info@kdu_tile@@QAEMH_N@Z
_TEXT	SEGMENT
_comp_idx$ = 8						; size = 4
_restrict_to_interest$ = 12				; size = 1
?find_component_gain_info@kdu_tile@@QAEMH_N@Z PROC	; kdu_tile::find_component_gain_info, COMDAT
; _this$ = ecx

; 3785 : {

	push	ebp
	mov	ebp, esp

; 3786 :   if ((comp_idx < 0) || (comp_idx >= state->num_components))

	mov	edx, DWORD PTR _comp_idx$[ebp]
	push	esi
	mov	esi, ecx
	test	edx, edx
	js	$LN3@find_compo
	mov	ecx, DWORD PTR [esi]
	cmp	edx, DWORD PTR [ecx+128]
	jge	$LN3@find_compo

; 3788 :   if (state->codestream->component_access_mode != KDU_WANT_OUTPUT_COMPONENTS)

	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax+128], 0
	je	SHORT $LN4@find_compo

; 3789 :     return 1.0F;

	fld1
	pop	esi

; 3805 :     }
; 3806 : }

	pop	ebp
	ret	8
$LN4@find_compo:

; 3790 :   if (restrict_to_interest)
; 3791 :     {
; 3792 :       if (state->comps[comp_idx].G_tc_restricted < 0.0F)

	mov	eax, DWORD PTR [ecx+208]
	xorps	xmm0, xmm0
	push	edi
	imul	edi, edx, 188
	cmp	BYTE PTR _restrict_to_interest$[ebp], 0
	je	SHORT $LN5@find_compo
	comiss	xmm0, DWORD PTR [eax+edi+124]
	jbe	SHORT $LN7@find_compo

; 3793 :         state->comps[comp_idx].G_tc_restricted =

	push	1
	push	edx
	call	?find_multicomponent_energy_gain@kd_tile@@AAEMH_N@Z ; kd_tile::find_multicomponent_energy_gain
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+208]
	fstp	DWORD PTR [eax+edi+124]
$LN7@find_compo:

; 3794 :           state->find_multicomponent_energy_gain(comp_idx,true);
; 3795 :       assert(state->comps[comp_idx].G_tc_restricted > 0.0F);
; 3796 :       return state->comps[comp_idx].G_tc_restricted;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+208]
	fld	DWORD PTR [eax+edi+124]
	pop	edi
	pop	esi

; 3805 :     }
; 3806 : }

	pop	ebp
	ret	8
$LN5@find_compo:

; 3797 :     }
; 3798 :   else
; 3799 :     {
; 3800 :       if (state->comps[comp_idx].G_tc < 0.0F)

	comiss	xmm0, DWORD PTR [eax+edi+120]
	jbe	SHORT $LN8@find_compo

; 3801 :         state->comps[comp_idx].G_tc =

	push	0
	push	edx
	call	?find_multicomponent_energy_gain@kd_tile@@AAEMH_N@Z ; kd_tile::find_multicomponent_energy_gain
	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+208]
	fstp	DWORD PTR [eax+edi+120]
$LN8@find_compo:

; 3802 :           state->find_multicomponent_energy_gain(comp_idx,false);
; 3803 :       assert(state->comps[comp_idx].G_tc > 0.0F);
; 3804 :       return state->comps[comp_idx].G_tc;

	mov	eax, DWORD PTR [esi]
	mov	eax, DWORD PTR [eax+208]
	fld	DWORD PTR [eax+edi+120]
	pop	edi
	pop	esi

; 3805 :     }
; 3806 : }

	pop	ebp
	ret	8
$LN3@find_compo:

; 3787 :     return 0.0F;

	fldz
	pop	esi

; 3805 :     }
; 3806 : }

	pop	ebp
	ret	8
?find_component_gain_info@kdu_tile@@QAEMH_N@Z ENDP	; kdu_tile::find_component_gain_info
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?access_component@kdu_tile@@QAE?AVkdu_tile_comp@@H@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_comp_idx$ = 12						; size = 4
?access_component@kdu_tile@@QAE?AVkdu_tile_comp@@H@Z PROC ; kdu_tile::access_component, COMDAT
; _this$ = ecx

; 3767 : {

	push	ebp
	mov	ebp, esp

; 3768 :   if ((comp_idx < 0) ||

	mov	eax, DWORD PTR _comp_idx$[ebp]
	push	esi
	test	eax, eax
	js	SHORT $LN3@access_com
	mov	esi, DWORD PTR [ecx]
	mov	edx, DWORD PTR [esi]
	cmp	eax, DWORD PTR [edx+116]
	jge	SHORT $LN3@access_com

; 3769 :       (comp_idx >= state->codestream->num_apparent_components))
; 3770 :     return kdu_tile_comp(NULL); // Return an empty interface.
; 3771 :   int true_idx = (int)(state->codestream->comp_info[comp_idx].from_apparent -

	mov	edx, DWORD PTR [edx+256]
	lea	eax, DWORD PTR [eax+eax*2]
	shl	eax, 5
	mov	ecx, DWORD PTR [eax+edx+92]
	mov	eax, 715827883				; 2aaaaaabH
	sub	ecx, edx
	imul	ecx
	sar	edx, 4
	mov	eax, edx
	shr	eax, 31					; 0000001fH
	add	eax, edx

; 3774 :   if (!state->comps[true_idx].enabled)

	imul	ecx, eax, 188
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4518 :     kdu_tile_comp(kd_tile_comp *state) { this->state = state; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3774 :   if (!state->comps[true_idx].enabled)

	add	ecx, DWORD PTR [esi+208]
	cmp	BYTE PTR [ecx+152], 0
	je	SHORT $LN12@access_com
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4518 :     kdu_tile_comp(kd_tile_comp *state) { this->state = state; }

	mov	DWORD PTR [eax], ecx
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3777 : }

	pop	ebp
	ret	8
$LN3@access_com:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 4518 :     kdu_tile_comp(kd_tile_comp *state) { this->state = state; }

	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
$LN12@access_com:
	mov	DWORD PTR [eax], 0
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3777 : }

	pop	ebp
	ret	8
?access_component@kdu_tile@@QAE?AVkdu_tile_comp@@H@Z ENDP ; kdu_tile::access_component
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_parsed_packet_stats@kdu_tile@@QAE_JHHHPA_J0@Z
_TEXT	SEGMENT
_max_packets$ = -36					; size = 8
_comp$1$ = -32						; size = 4
tv448 = -28						; size = 4
_tile_layers$1$ = -24					; size = 4
_this$1$ = -20						; size = 4
_lim_comp_idx$1$ = -16					; size = 4
tv444 = -12						; size = 4
_lim_res_idx$1$ = -8					; size = 4
tv445 = -4						; size = 4
_max_packets$1$ = 8					; size = 4
_component_idx$ = 8					; size = 4
_discard_levels$ = 12					; size = 4
_max_packets$2$ = 16					; size = 4
_num_layers$ = 16					; size = 4
_layer_bytes$ = 20					; size = 4
_layer_packets$ = 24					; size = 4
?get_parsed_packet_stats@kdu_tile@@QAE_JHHHPA_J0@Z PROC	; kdu_tile::get_parsed_packet_stats, COMDAT
; _this$ = ecx

; 3728 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	mov	eax, ecx
	push	esi
	mov	DWORD PTR _this$1$[ebp], eax

; 3729 :   if ((state == NULL) || (state->codestream->in == NULL) || (num_layers < 1))

	mov	edx, DWORD PTR [eax]
	test	edx, edx
	je	$LN15@get_parsed
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+4], 0
	je	$LN15@get_parsed
	mov	esi, DWORD PTR _num_layers$[ebp]
	cmp	esi, 1
	jl	$LN15@get_parsed

; 3731 : 
; 3732 :   if (discard_levels < 0)

	mov	eax, DWORD PTR _discard_levels$[ebp]
	xor	ecx, ecx
	test	eax, eax
	cmovs	eax, ecx
	mov	DWORD PTR _discard_levels$[ebp], eax

; 3733 :     discard_levels = 0;
; 3734 :   int c=component_idx, lim_comp_idx=component_idx+1;

	mov	eax, DWORD PTR _component_idx$[ebp]
	lea	ecx, DWORD PTR [eax+1]

; 3735 :   if (component_idx < 0)

	test	eax, eax
	jns	SHORT $LN17@get_parsed

; 3736 :     { c = 0;  lim_comp_idx = state->num_components; }

	mov	ecx, DWORD PTR [edx+128]
	xor	eax, eax
$LN17@get_parsed:

; 3738 :   int tile_layers = state->num_layers;

	mov	edx, DWORD PTR [edx+132]
	xorps	xmm0, xmm0

; 3739 :   int xfer_layers = (tile_layers < num_layers)?tile_layers:num_layers;

	cmp	edx, esi
	movlpd	QWORD PTR _max_packets$[ebp], xmm0
	mov	DWORD PTR _tile_layers$1$[ebp], edx
	cmovl	esi, edx
	mov	edx, DWORD PTR _max_packets$[ebp+4]

; 3740 :   for (; c < lim_comp_idx; c++)

	cmp	eax, ecx
	jge	$LN40@get_parsed

; 3737 :   kdu_long max_packets = 0;

	push	ebx
	mov	ebx, DWORD PTR _layer_packets$[ebp]
	push	edi
	imul	edi, eax, 188
	sub	ecx, eax
	mov	eax, DWORD PTR _max_packets$[ebp]
	mov	DWORD PTR _lim_comp_idx$1$[ebp], ecx
	mov	DWORD PTR _max_packets$2$[ebp], edx
	mov	DWORD PTR _max_packets$1$[ebp], eax
	mov	DWORD PTR tv444[ebp], edi
	npad	6
$LL4@get_parsed:

; 3741 :     {
; 3742 :       kd_tile_comp *comp = state->comps + c;

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	edx, DWORD PTR [eax+208]
	add	edx, edi
	mov	DWORD PTR _comp$1$[ebp], edx

; 3743 :       if (comp->layer_stats == NULL)

	mov	edi, DWORD PTR [edx+148]
	test	edi, edi
	je	$LN2@get_parsed

; 3744 :         continue;
; 3745 :       int n, r, lim_res_idx = comp->dwt_levels+1-discard_levels;

	mov	eax, DWORD PTR [edx+56]
	sub	eax, DWORD PTR _discard_levels$[ebp]
	inc	eax
	mov	DWORD PTR _lim_res_idx$1$[ebp], eax

; 3746 :       kdu_long *stats = comp->layer_stats;
; 3747 :       for (r=0; r < lim_res_idx; r++, stats += (tile_layers<<1))

	test	eax, eax
	jle	$LN2@get_parsed

; 3744 :         continue;
; 3745 :       int n, r, lim_res_idx = comp->dwt_levels+1-discard_levels;

	mov	eax, DWORD PTR _tile_layers$1$[ebp]
	shl	eax, 4
	xor	ecx, ecx
	mov	DWORD PTR tv448[ebp], eax
	mov	DWORD PTR tv445[ebp], ecx
	npad	2
$LL7@get_parsed:

; 3749 :           max_packets += comp->resolutions[r].precinct_indices.area();

	add	ecx, DWORD PTR [edx+144]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [ecx+148]
	imul	DWORD PTR [ecx+144]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3749 :           max_packets += comp->resolutions[r].precinct_indices.area();

	add	DWORD PTR _max_packets$1$[ebp], eax
	adc	DWORD PTR _max_packets$2$[ebp], edx

; 3750 :           if (layer_bytes != NULL)

	cmp	DWORD PTR _layer_bytes$[ebp], 0
	je	SHORT $LN9@get_parsed

; 3751 :             for (n=0; n < xfer_layers; n++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN9@get_parsed

; 3746 :       kdu_long *stats = comp->layer_stats;
; 3747 :       for (r=0; r < lim_res_idx; r++, stats += (tile_layers<<1))

	mov	ebx, DWORD PTR _layer_bytes$[ebp]
	lea	ecx, DWORD PTR [edi+8]
	npad	6
$LL10@get_parsed:

; 3752 :               layer_bytes[n] += stats[2*n+1];

	mov	eax, DWORD PTR [ecx]
	lea	ecx, DWORD PTR [ecx+16]
	add	DWORD PTR [ebx+edx*8], eax
	mov	eax, DWORD PTR [ecx-12]
	adc	DWORD PTR [ebx+edx*8+4], eax
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL10@get_parsed
	mov	ebx, DWORD PTR _layer_packets$[ebp]
$LN9@get_parsed:

; 3753 :           if (layer_packets != NULL)

	test	ebx, ebx
	je	SHORT $LN5@get_parsed

; 3754 :             for (n=0; n < xfer_layers; n++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN5@get_parsed
	mov	eax, edi
$LL13@get_parsed:

; 3755 :               layer_packets[n] += stats[2*n];

	mov	ecx, DWORD PTR [eax]
	lea	eax, DWORD PTR [eax+16]
	add	DWORD PTR [ebx+edx*8], ecx
	mov	ecx, DWORD PTR [eax-12]
	adc	DWORD PTR [ebx+edx*8+4], ecx
	inc	edx
	cmp	edx, esi
	jl	SHORT $LL13@get_parsed
$LN5@get_parsed:

; 3746 :       kdu_long *stats = comp->layer_stats;
; 3747 :       for (r=0; r < lim_res_idx; r++, stats += (tile_layers<<1))

	mov	ecx, DWORD PTR tv445[ebp]
	add	edi, DWORD PTR tv448[ebp]
	add	ecx, 604				; 0000025cH
	sub	DWORD PTR _lim_res_idx$1$[ebp], 1
	mov	edx, DWORD PTR _comp$1$[ebp]
	mov	DWORD PTR tv445[ebp], ecx
	jne	SHORT $LL7@get_parsed
	mov	ecx, DWORD PTR _lim_comp_idx$1$[ebp]
$LN2@get_parsed:

; 3740 :   for (; c < lim_comp_idx; c++)

	mov	edi, DWORD PTR tv444[ebp]
	add	edi, 188				; 000000bcH
	sub	ecx, 1
	mov	DWORD PTR tv444[ebp], edi
	mov	DWORD PTR _lim_comp_idx$1$[ebp], ecx
	jne	$LL4@get_parsed
	mov	edx, DWORD PTR _max_packets$2$[ebp]
	mov	eax, DWORD PTR _max_packets$1$[ebp]
	pop	edi
	pop	ebx
	pop	esi

; 3756 :         }
; 3757 :     }
; 3758 :   return max_packets;
; 3759 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN40@get_parsed:

; 3740 :   for (; c < lim_comp_idx; c++)

	mov	eax, DWORD PTR _max_packets$[ebp]
	pop	esi

; 3756 :         }
; 3757 :     }
; 3758 :   return max_packets;
; 3759 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
$LN15@get_parsed:

; 3730 :     return 0;

	xor	eax, eax
	xor	edx, edx
	pop	esi

; 3756 :         }
; 3757 :     }
; 3758 :   return max_packets;
; 3759 : }

	mov	esp, ebp
	pop	ebp
	ret	20					; 00000014H
?get_parsed_packet_stats@kdu_tile@@QAE_JHHHPA_J0@Z ENDP	; kdu_tile::get_parsed_packet_stats
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?parse_all_relevant_packets@kdu_tile@@QAE_N_NPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
tv1342 = -60						; size = 4
_res$1$ = -60						; size = 4
_seq_res$1 = -60					; size = 4
$T2 = -56						; size = 4
_idx_offset$1$ = -56					; size = 4
_comp$1$ = -56						; size = 4
_comp$1$ = -52						; size = 4
_lim$2$ = -52						; size = 4
_seq_idx$3 = -48					; size = 8
_min$2$ = -44						; size = 4
_lim$1$ = -40						; size = 4
tv1295 = -36						; size = 4
tv1290 = -36						; size = 4
_min$1$ = -32						; size = 4
_c$2$ = -32						; size = 4
tv1344 = -28						; size = 4
_res$1$ = -28						; size = 4
_stats$1$ = -28						; size = 4
tv1307 = -24						; size = 4
_pos_idx$2$ = -24					; size = 4
_r$1$ = -24						; size = 4
_idx_offset$2$ = -20					; size = 4
tv1346 = -20						; size = 4
tv1299 = -20						; size = 4
_idx$1$ = -16						; size = 4
_idx$1$ = -16						; size = 4
_c$1$ = -16						; size = 4
_codestream$1$ = -12					; size = 4
tv1319 = -8						; size = 4
tv1296 = -8						; size = 4
_r$2$ = -8						; size = 4
tv1291 = -4						; size = 4
_this$1$ = -4						; size = 4
tv1345 = 8						; size = 4
_idx$2$ = 8						; size = 4
_idx$1$ = 8						; size = 4
$T4 = 8							; size = 4
_start_from_scratch_if_possible$ = 8			; size = 1
_env$ = 12						; size = 4
?parse_all_relevant_packets@kdu_tile@@QAE_N_NPAVkdu_thread_env@@@Z PROC ; kdu_tile::parse_all_relevant_packets, COMDAT
; _this$ = ecx

; 3583 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 60					; 0000003cH
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx

; 3584 :   if ((state == NULL) || !state->is_open)

	mov	eax, DWORD PTR [ebx]
	test	eax, eax
	je	SHORT $LN44@parse_all_
	cmp	BYTE PTR [eax+229], 0
	je	SHORT $LN44@parse_all_

; 3585 :     return false;
; 3586 :   kd_codestream *codestream = state->codestream;

	mov	eax, DWORD PTR [eax]
	mov	DWORD PTR _codestream$1$[ebp], eax

; 3587 :   if (codestream->in == NULL)

	cmp	DWORD PTR [eax+4], 0
	jne	SHORT $LN45@parse_all_
$LN44@parse_all_:

; 3588 :     return false;

	xor	al, al
	pop	ebx

; 3718 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN45@parse_all_:
	push	esi
	push	edi

; 3589 :   
; 3590 :   int r, c;
; 3591 :   if (env != NULL)

	mov	edi, DWORD PTR _env$[ebp]
	test	edi, edi
	je	SHORT $LN70@parse_all_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [edi+20]
	mov	esi, DWORD PTR [edi+28]
	cmp	BYTE PTR [eax], 0
	jne	$LN229@parse_all_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN73@parse_all_
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN73@parse_all_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [esi+4], edi
$LN70@parse_all_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3594 :   if (start_from_scratch_if_possible)

	cmp	BYTE PTR _start_from_scratch_if_possible$[ebp], 0
	je	$LN15@parse_all_

; 3595 :     { // We may need to unload a lot of stuff.  Need to check.
; 3596 :       bool need_unload = false;
; 3597 :       bool addressable = true;
; 3598 :       for (c=0; c < state->num_components; c++)

	mov	eax, DWORD PTR _this$1$[ebp]
	xor	bl, bl
	mov	bh, 1
	mov	ecx, DWORD PTR [eax]
	mov	DWORD PTR tv1342[ebp], ecx
	mov	eax, DWORD PTR [ecx+128]
	mov	DWORD PTR $T2[ebp], eax
	test	eax, eax
	jle	$LN222@parse_all_

; 3599 :         {
; 3600 :           kd_tile_comp *comp = state->comps + c;

	mov	ecx, DWORD PTR [ecx+208]
	mov	edx, eax
	add	ecx, 60					; 0000003cH
	mov	DWORD PTR tv1344[ebp], eax
	mov	DWORD PTR tv1307[ebp], ecx
$LL4@parse_all_:

; 3601 :           if (!comp->enabled)

	cmp	BYTE PTR [ecx+92], 0
	je	$LN2@parse_all_

; 3602 :             continue;
; 3603 :           for (r=0; r <= comp->apparent_dwt_levels; r++)

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	js	$LN2@parse_all_

; 3604 :             {
; 3605 :               kd_resolution *res = comp->resolutions + r;

	mov	edi, DWORD PTR [ecx+84]
	xor	edx, edx
	inc	eax
	mov	DWORD PTR tv1345[ebp], edi
	mov	DWORD PTR tv1319[ebp], edx
	mov	DWORD PTR tv1346[ebp], eax
	npad	12
$LL7@parse_all_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	eax, DWORD PTR [edi+edx+152]
	sub	eax, DWORD PTR [edi+edx+136]
	mov	ecx, DWORD PTR [edi+edx+156]
	sub	ecx, DWORD PTR [edi+edx+140]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3606 :               kd_precinct_ref *ref = res->precinct_refs;

	mov	esi, DWORD PTR [edi+edx+180]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	edx, DWORD PTR [edi+edx+160]
	add	edx, eax

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	DWORD PTR _min$2$[ebp], eax

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	DWORD PTR _lim$2$[ebp], edx
	mov	edx, DWORD PTR tv1319[ebp]

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	DWORD PTR _min$1$[ebp], ecx

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	eax, DWORD PTR [edi+edx+164]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3610 :               for (idx.y=0; idx.y < res->precinct_indices.size.y; idx.y++)

	xor	edi, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	eax, ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3610 :               for (idx.y=0; idx.y < res->precinct_indices.size.y; idx.y++)

	mov	DWORD PTR _idx$1$[ebp], edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	DWORD PTR _lim$1$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3610 :               for (idx.y=0; idx.y < res->precinct_indices.size.y; idx.y++)

	mov	eax, DWORD PTR tv1345[ebp]
	cmp	DWORD PTR [eax+edx+144], edi
	jle	$LN5@parse_all_
	mov	eax, DWORD PTR [eax+edx+148]
	mov	ecx, DWORD PTR tv1345[ebp]
$LL10@parse_all_:

; 3611 :                 for (idx.x=0; idx.x < res->precinct_indices.size.x;

	xor	edx, edx
	test	eax, eax
	jle	$LN8@parse_all_
	npad	3
$LL13@parse_all_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3071 :       { return ((state & 3) == 3) && (state != 3); }

	mov	ecx, DWORD PTR [esi]
	mov	eax, ecx
	and	eax, 3
	mov	DWORD PTR tv1295[ebp], 0
	cmp	eax, 3
	jne	SHORT $LN49@parse_all_
	cmp	DWORD PTR tv1295[ebp], 0
	jne	SHORT $LN49@parse_all_
	cmp	ecx, eax
	jne	SHORT $LN217@parse_all_
	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN49@parse_all_
$LN217@parse_all_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3615 :                       need_unload = true;

	mov	bl, 1

; 3616 :                     else

	jmp	SHORT $LN11@parse_all_
$LN49@parse_all_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }

	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN11@parse_all_
	mov	ecx, DWORD PTR [esi]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3619 :                         if (precinct == NULL)

	test	ecx, ecx
	je	SHORT $LN11@parse_all_

; 3620 :                           continue;
; 3621 :                         if (((precinct->flags & KD_PFLAG_PARSED) ||
; 3622 :                              (precinct->num_packets_read > 0)) &&

	mov	eax, DWORD PTR [ecx+8]
	test	eax, 256				; 00000100H
	jne	SHORT $LN53@parse_all_
	cmp	DWORD PTR [ecx+20], 0
	jle	SHORT $LN52@parse_all_
$LN53@parse_all_:
	cmp	edx, DWORD PTR _min$1$[ebp]
	jl	SHORT $LN54@parse_all_
	cmp	edx, DWORD PTR _lim$1$[ebp]
	jge	SHORT $LN54@parse_all_
	cmp	edi, DWORD PTR _min$2$[ebp]
	jl	SHORT $LN54@parse_all_
	cmp	edi, DWORD PTR _lim$2$[ebp]
	jl	SHORT $LN52@parse_all_
$LN54@parse_all_:

; 3623 :                             ((idx.x < min.x) || (idx.x >= lim.x) ||
; 3624 :                              (idx.y < min.y) || (idx.y >= lim.y)))
; 3625 :                           need_unload = true;

	mov	bl, 1
$LN52@parse_all_:

; 3626 :                         if (!(precinct->flags & KD_PFLAG_ADDRESSABLE))

	and	al, 8
	neg	al
	sbb	al, al
	and	al, bh
	mov	bh, al
$LN11@parse_all_:

; 3612 :                      idx.x++, ref++)

	mov	edi, DWORD PTR tv1345[ebp]
	inc	edx
	mov	ecx, DWORD PTR tv1319[ebp]
	add	esi, 8
	mov	eax, DWORD PTR [edi+ecx+148]
	mov	edi, DWORD PTR _idx$1$[ebp]
	cmp	edx, eax
	jl	SHORT $LL13@parse_all_
	mov	ecx, DWORD PTR tv1345[ebp]
$LN8@parse_all_:

; 3610 :               for (idx.y=0; idx.y < res->precinct_indices.size.y; idx.y++)

	mov	edx, DWORD PTR tv1319[ebp]
	inc	edi
	mov	DWORD PTR _idx$1$[ebp], edi
	cmp	edi, DWORD PTR [ecx+edx+144]
	jl	$LL10@parse_all_
$LN5@parse_all_:

; 3602 :             continue;
; 3603 :           for (r=0; r <= comp->apparent_dwt_levels; r++)

	mov	edi, DWORD PTR tv1345[ebp]
	add	edx, 604				; 0000025cH
	sub	DWORD PTR tv1346[ebp], 1
	mov	DWORD PTR tv1319[ebp], edx
	jne	$LL7@parse_all_
	mov	ecx, DWORD PTR tv1307[ebp]
	mov	edx, DWORD PTR tv1344[ebp]
$LN2@parse_all_:

; 3595 :     { // We may need to unload a lot of stuff.  Need to check.
; 3596 :       bool need_unload = false;
; 3597 :       bool addressable = true;
; 3598 :       for (c=0; c < state->num_components; c++)

	add	ecx, 188				; 000000bcH
	sub	edx, 1
	mov	DWORD PTR tv1307[ebp], ecx
	mov	DWORD PTR tv1344[ebp], edx
	jne	$LL4@parse_all_

; 3627 :                           addressable = false;
; 3628 :                       }
; 3629 :                   }
; 3630 :             }
; 3631 :         }
; 3632 :       
; 3633 :       if (need_unload)

	test	bl, bl
	je	$LN222@parse_all_

; 3634 :         {
; 3635 :           if (!addressable)

	test	bh, bh
	jne	SHORT $LN57@parse_all_

; 3636 :             return false;

	pop	edi
	pop	esi
	xor	al, al
	pop	ebx

; 3718 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN57@parse_all_:

; 3637 :           for (c=0; c < state->num_components; c++)

	xor	eax, eax
	mov	DWORD PTR _c$1$[ebp], eax
	cmp	DWORD PTR $T2[ebp], eax
	jle	$LN222@parse_all_
	mov	ecx, DWORD PTR tv1342[ebp]
	xor	ebx, ebx
	mov	esi, DWORD PTR _this$1$[ebp]
	mov	DWORD PTR tv1296[ebp], ebx
$LL16@parse_all_:

; 3638 :             {
; 3639 :               kd_tile_comp *comp = state->comps + c;

	mov	edx, DWORD PTR [ecx+208]
	add	edx, ebx
	mov	DWORD PTR _comp$1$[ebp], edx

; 3640 :               if (!comp->enabled)

	cmp	BYTE PTR [edx+152], 0
	je	$LN14@parse_all_

; 3643 :               for (r=0; r <= comp->apparent_dwt_levels; r++)

	cmp	DWORD PTR [edx+60], 0
	mov	ecx, DWORD PTR [edx+148]
	mov	DWORD PTR _stats$1$[ebp], ecx
	mov	DWORD PTR _r$1$[ebp], 0
	jl	$LN14@parse_all_

; 3641 :                 continue;
; 3642 :               kdu_long *stats = comp->layer_stats;

	xor	esi, esi
	mov	DWORD PTR tv1299[ebp], esi
	npad	4
$LL19@parse_all_:

; 3644 :                 {
; 3645 :                   for (int n=state->num_layers; n > 0; n--, stats+=2)

	mov	eax, DWORD PTR _this$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+132]
	test	eax, eax
	jle	SHORT $LN21@parse_all_
	npad	1
$LL22@parse_all_:

; 3646 :                     stats[0] = stats[1] = 0;

	mov	DWORD PTR [ecx+8], 0
	dec	eax
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+4], 0
	add	ecx, 16					; 00000010H
	test	eax, eax
	jg	SHORT $LL22@parse_all_
	mov	DWORD PTR _stats$1$[ebp], ecx
$LN21@parse_all_:

; 3647 :                   kd_resolution *res = comp->resolutions + r;

	mov	eax, DWORD PTR [edx+144]

; 3648 :                   kd_precinct_ref *ref = res->precinct_refs;
; 3649 :                   kdu_coords idx;
; 3650 :                   for (idx.y=0; idx.y < res->precinct_indices.size.y; idx.y++)

	xor	edx, edx
	add	eax, esi
	mov	DWORD PTR _idx$1$[ebp], edx
	mov	DWORD PTR _res$1$[ebp], eax
	mov	ebx, DWORD PTR [eax+180]
	cmp	DWORD PTR [eax+144], edx
	jle	SHORT $LN17@parse_all_
$LL25@parse_all_:

; 3651 :                     for (idx.x=0; idx.x<res->precinct_indices.size.x; idx.x++)

	xor	edi, edi
	cmp	DWORD PTR [eax+148], edi
	jle	SHORT $LN23@parse_all_
	npad	2
$LL28@parse_all_:

; 3652 :                       (ref++)->close_and_reset();

	mov	esi, ebx
	add	ebx, 8
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4684 :   if (state & 1)

	mov	ecx, DWORD PTR [esi]
	mov	eax, ecx
	mov	edx, DWORD PTR [esi+4]
	and	eax, 1
	or	eax, 0
	je	SHORT $LN101@parse_all_

; 4685 :     {
; 4686 :       if (state != 3)

	cmp	ecx, 3
	jne	SHORT $LN218@parse_all_
	test	edx, edx
	je	SHORT $LN26@parse_all_
$LN218@parse_all_:

; 4687 :         state &= ~((kdu_long) 2);

	and	ecx, -3					; fffffffdH
	mov	DWORD PTR [esi+4], edx
	mov	DWORD PTR [esi], ecx

; 4688 :     }

	jmp	SHORT $LN26@parse_all_
$LN101@parse_all_:

; 4689 :   else if (state != 0)

	or	ecx, edx
	je	SHORT $LN26@parse_all_

; 4690 :     {
; 4691 :       kd_precinct *prec = (kd_precinct *) _kdu_long_to_addr(state);

	mov	eax, DWORD PTR [esi]

; 4692 :       if ((prec->flags & KD_PFLAG_PARSED)||(prec->num_packets_read > 0))

	test	DWORD PTR [eax+8], 256			; 00000100H
	jne	SHORT $LN106@parse_all_
	cmp	DWORD PTR [eax+20], 0
	jle	SHORT $LN26@parse_all_
$LN106@parse_all_:

; 4693 :         {
; 4694 :           close();

	mov	ecx, esi
	call	?close@kd_precinct_ref@@QAEXXZ		; kd_precinct_ref::close

; 4695 :           state &= ~((kdu_long) 2);

	mov	eax, DWORD PTR [esi+4]
	and	DWORD PTR [esi], -3			; fffffffdH
	mov	DWORD PTR [esi+4], eax
$LN26@parse_all_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3651 :                     for (idx.x=0; idx.x<res->precinct_indices.size.x; idx.x++)

	mov	eax, DWORD PTR _res$1$[ebp]
	inc	edi
	cmp	edi, DWORD PTR [eax+148]
	jl	SHORT $LL28@parse_all_
	mov	edx, DWORD PTR _idx$1$[ebp]
$LN23@parse_all_:

; 3648 :                   kd_precinct_ref *ref = res->precinct_refs;
; 3649 :                   kdu_coords idx;
; 3650 :                   for (idx.y=0; idx.y < res->precinct_indices.size.y; idx.y++)

	inc	edx
	mov	DWORD PTR _idx$1$[ebp], edx
	cmp	edx, DWORD PTR [eax+144]
	jl	SHORT $LL25@parse_all_
	mov	ecx, DWORD PTR _stats$1$[ebp]
	mov	esi, DWORD PTR tv1299[ebp]
$LN17@parse_all_:

; 3643 :               for (r=0; r <= comp->apparent_dwt_levels; r++)

	mov	ebx, DWORD PTR _r$1$[ebp]
	add	esi, 604				; 0000025cH
	mov	edx, DWORD PTR _comp$1$[ebp]
	inc	ebx
	mov	DWORD PTR _r$1$[ebp], ebx
	mov	DWORD PTR tv1299[ebp], esi
	cmp	ebx, DWORD PTR [edx+60]
	jle	$LL19@parse_all_
	mov	eax, DWORD PTR _c$1$[ebp]
	mov	ebx, DWORD PTR tv1296[ebp]
	mov	esi, DWORD PTR _this$1$[ebp]
$LN14@parse_all_:

; 3637 :           for (c=0; c < state->num_components; c++)

	mov	ecx, DWORD PTR [esi]
	inc	eax
	add	ebx, 188				; 000000bcH
	mov	DWORD PTR _c$1$[ebp], eax
	mov	DWORD PTR tv1296[ebp], ebx
	cmp	eax, DWORD PTR [ecx+128]
	jl	$LL16@parse_all_
$LN222@parse_all_:
	mov	ebx, DWORD PTR _this$1$[ebp]
$LN15@parse_all_:

; 3653 :                 }
; 3654 :             }
; 3655 :         }
; 3656 :     }
; 3657 :   
; 3658 :   for (c=0; c < state->num_components; c++)

	mov	eax, DWORD PTR [ebx]
	xor	edx, edx
	mov	DWORD PTR _c$2$[ebp], edx
	cmp	DWORD PTR [eax+128], edx
	jle	$LN30@parse_all_
	xor	esi, esi
	mov	DWORD PTR tv1290[ebp], esi
	npad	8
$LL31@parse_all_:

; 3659 :     {
; 3660 :       kd_tile_comp *comp = state->comps + c;

	mov	ecx, DWORD PTR [eax+208]
	add	ecx, esi
	mov	DWORD PTR _comp$1$[ebp], ecx

; 3661 :       if (!comp->enabled)

	cmp	BYTE PTR [ecx+152], 0
	je	$LN29@parse_all_

; 3662 :         continue;
; 3663 :       for (r=0; r <= comp->apparent_dwt_levels; r++)

	xor	eax, eax
	mov	DWORD PTR _r$2$[ebp], eax
	cmp	DWORD PTR [ecx+60], eax
	jl	$LN29@parse_all_
	xor	esi, esi
	mov	DWORD PTR tv1291[ebp], esi
	npad	5
$LL34@parse_all_:

; 3664 :         {
; 3665 :           kd_resolution *res = comp->resolutions + r;

	mov	edx, DWORD PTR [ecx+144]

; 3669 :           for (idx.y=0; idx.y < res->region_indices.size.y; idx.y++)

	xor	ecx, ecx
	add	edx, esi
	mov	DWORD PTR _idx$1$[ebp], ecx
	mov	DWORD PTR _res$1$[ebp], edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	edi, DWORD PTR [edx+156]
	mov	esi, DWORD PTR [edx+152]
	sub	edi, DWORD PTR [edx+140]
	sub	esi, DWORD PTR [edx+136]
	mov	DWORD PTR _idx_offset$2$[ebp], edi
	mov	DWORD PTR _idx_offset$1$[ebp], esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3669 :           for (idx.y=0; idx.y < res->region_indices.size.y; idx.y++)

	cmp	DWORD PTR [edx+160], ecx
	jle	$LN32@parse_all_
	npad	6
$LL37@parse_all_:

; 3670 :             for (idx.x=0; idx.x < res->region_indices.size.x; idx.x++)

	xor	eax, eax
	mov	DWORD PTR _idx$2$[ebp], eax
	cmp	DWORD PTR [edx+164], eax
	jle	$LN35@parse_all_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	esi, ecx
	mov	DWORD PTR _pos_idx$2$[ebp], esi
	npad	10
$LL40@parse_all_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3674 :                 kd_precinct_ref *ref = res->precinct_refs+p_num;

	mov	ecx, DWORD PTR [edx+148]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	add	edi, eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3674 :                 kd_precinct_ref *ref = res->precinct_refs+p_num;

	mov	eax, DWORD PTR [edx+180]
	imul	ecx, esi
	add	ecx, edi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4722 :   if (state == 3)

	mov	esi, DWORD PTR [eax+ecx*8+4]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3674 :                 kd_precinct_ref *ref = res->precinct_refs+p_num;

	lea	edx, DWORD PTR [eax+ecx*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4722 :   if (state == 3)

	mov	ecx, DWORD PTR [edx]
	cmp	ecx, 3
	jne	SHORT $LN119@parse_all_
	test	esi, esi
	jne	SHORT $LN119@parse_all_

; 4723 :     return NULL; // Precinct is not currently loaded

	xor	edi, edi
	jmp	SHORT $LN118@parse_all_
$LN119@parse_all_:

; 4724 :   if ((state == 0) || (state & 1))

	mov	eax, ecx
	or	eax, esi
	je	SHORT $LN121@parse_all_
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN121@parse_all_

; 4726 :   kd_precinct *result = (kd_precinct *) _kdu_long_to_addr(state);

	mov	edi, DWORD PTR [edx]

; 4727 :   if (result->flags & KD_PFLAG_INACTIVE)

	mov	eax, DWORD PTR [edi+8]
	test	al, 32					; 00000020H
	je	SHORT $LN122@parse_all_

; 4728 :     { // Must be on the inactive list
; 4729 :       result->size_class->withdraw_from_inactive_list(result);

	mov	ecx, DWORD PTR [edi+52]
	push	edi
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list

; 4730 :       result->activate();

	mov	ecx, edi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate
	jmp	SHORT $LN118@parse_all_
$LN122@parse_all_:

; 4731 :     }
; 4732 :   else if (need_activate && (result->flags & KD_PFLAG_RELEASED))

	test	al, 16					; 00000010H
	je	SHORT $LN118@parse_all_

; 4733 :     result->activate();

	mov	ecx, edi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate

; 4734 :   return result;

	jmp	SHORT $LN118@parse_all_
$LN121@parse_all_:

; 4725 :     return instantiate_precinct(res,pos_idx);

	push	edi
	push	DWORD PTR _pos_idx$2$[ebp]
	mov	ecx, edx
	push	DWORD PTR _res$1$[ebp]
	call	?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z ; kd_precinct_ref::instantiate_precinct
	mov	edi, eax
$LN118@parse_all_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3676 :                 if (precinct->num_packets_read >= precinct->required_layers)

	mov	ecx, DWORD PTR [edi+20]
	cmp	ecx, DWORD PTR [edi+12]
	jge	$LN38@parse_all_

; 3677 :                   continue;
; 3678 :                 if (!codestream->cached)

	mov	edx, DWORD PTR _codestream$1$[ebp]
	cmp	BYTE PTR [edx+338], 0
	jne	$LN65@parse_all_
$LN228@parse_all_:

; 3679 :                   {
; 3680 :                     while ((!state->exhausted) &&

	mov	ecx, DWORD PTR [ebx]
	cmp	BYTE PTR [ecx+268], 0
	jne	$LN216@parse_all_
	mov	eax, DWORD PTR [edi+16]
	cmp	eax, DWORD PTR [edi+12]
	jge	$LN216@parse_all_

; 3681 :                            (precinct->next_layer_idx <
; 3682 :                             precinct->required_layers))
; 3683 :                       {
; 3684 :                         if ((state != codestream->active_tile) &&

	cmp	ecx, DWORD PTR [edx+364]
	je	SHORT $LN62@parse_all_
	call	?read_tile_part_header@kd_tile@@QAE_NXZ	; kd_tile::read_tile_part_header
	test	al, al
	je	$LN169@parse_all_
$LN62@parse_all_:

; 3693 :                         state->sequencer->next_in_sequence(seq_res,seq_idx);

	mov	ecx, DWORD PTR [ebx]
	lea	eax, DWORD PTR _seq_idx$3[ebp]
	push	eax
	lea	eax, DWORD PTR _seq_res$1[ebp]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR _seq_idx$3[ebp], 0
	mov	DWORD PTR _seq_idx$3[ebp+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3693 :                         state->sequencer->next_in_sequence(seq_res,seq_idx);

	mov	ecx, DWORD PTR [ecx+52]
	push	eax
	call	?next_in_sequence@kd_packet_sequencer@@QAEPAVkd_precinct_ref@@AAPAUkd_resolution@@AAUkdu_coords@@@Z ; kd_packet_sequencer::next_in_sequence
	mov	edx, eax

; 3694 :                         if ((seq_ref == NULL) ||

	test	edx, edx
	je	SHORT $LN64@parse_all_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4661 :   register kdu_long state_val = state;

	mov	ecx, DWORD PTR [edx]

; 4662 :   return ((state_val != 0) &&

	mov	eax, ecx
	mov	esi, DWORD PTR [edx+4]
	or	eax, esi
	je	SHORT $LN131@parse_all_
	mov	eax, ecx
	and	eax, 1
	or	eax, 0
	jne	SHORT $LN63@parse_all_
	test	BYTE PTR [ecx+8], 4
	jne	SHORT $LN63@parse_all_
$LN131@parse_all_:

; 4722 :   if (state == 3)

	cmp	ecx, 3
	jne	SHORT $LN134@parse_all_
	test	esi, esi
	je	SHORT $LN133@parse_all_
$LN134@parse_all_:

; 4724 :   if ((state == 0) || (state & 1))

	mov	eax, ecx
	or	eax, esi
	je	SHORT $LN136@parse_all_
	and	ecx, 1
	or	ecx, 0
	jne	SHORT $LN136@parse_all_

; 4726 :   kd_precinct *result = (kd_precinct *) _kdu_long_to_addr(state);

	mov	esi, DWORD PTR [edx]

; 4727 :   if (result->flags & KD_PFLAG_INACTIVE)

	test	BYTE PTR [esi+8], 32			; 00000020H
	je	SHORT $LN133@parse_all_

; 4728 :     { // Must be on the inactive list
; 4729 :       result->size_class->withdraw_from_inactive_list(result);

	mov	ecx, DWORD PTR [esi+52]
	push	esi
	call	?withdraw_from_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::withdraw_from_inactive_list

; 4730 :       result->activate();

	mov	ecx, esi
	call	?activate@kd_precinct@@QAEXXZ		; kd_precinct::activate

; 4734 :   return result;

	jmp	SHORT $LN133@parse_all_
$LN136@parse_all_:

; 4725 :     return instantiate_precinct(res,pos_idx);

	push	DWORD PTR _seq_idx$3[ebp+4]
	mov	ecx, edx
	push	DWORD PTR _seq_idx$3[ebp]
	push	DWORD PTR _seq_res$1[ebp]
	call	?instantiate_precinct@kd_precinct_ref@@AAEPAUkd_precinct@@PAUkd_resolution@@Ukdu_coords@@@Z ; kd_precinct_ref::instantiate_precinct
	mov	esi, eax
$LN133@parse_all_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3694 :                         if ((seq_ref == NULL) ||

	mov	ecx, esi
	call	?desequence_packet@kd_precinct@@QAE_NXZ	; kd_precinct::desequence_packet
	test	al, al
	jne	SHORT $LN63@parse_all_
$LN64@parse_all_:

; 3695 :                             !(seq_ref->is_desequenced() ||
; 3696 :                               seq_ref->open(seq_res,seq_idx,
; 3697 :                                             false)->desequence_packet()))
; 3698 :                           state->read_tile_part_header();

	mov	ecx, DWORD PTR [ebx]
	call	?read_tile_part_header@kd_tile@@QAE_NXZ	; kd_tile::read_tile_part_header
$LN63@parse_all_:

; 3679 :                   {
; 3680 :                     while ((!state->exhausted) &&

	mov	edx, DWORD PTR _codestream$1$[ebp]
	jmp	$LN228@parse_all_
$LN169@parse_all_:

; 3685 :                             !state->read_tile_part_header())
; 3686 :                           { // Can't read any more from tile.
; 3687 :                             state->finished_reading();

	mov	ecx, DWORD PTR [ebx]
	call	?finished_reading@kd_tile@@QAE_NXZ	; kd_tile::finished_reading
	mov	edx, DWORD PTR _codestream$1$[ebp]
$LN216@parse_all_:

; 3699 :                       }
; 3700 :                     if ((precinct->num_packets_read == 0) &&
; 3701 :                         (codestream->active_tile != NULL) &&

	cmp	DWORD PTR [edi+20], 0
	jne	SHORT $LN65@parse_all_
	mov	eax, DWORD PTR [edx+364]
	test	eax, eax
	je	SHORT $LN65@parse_all_
	cmp	BYTE PTR [eax+231], 0
	jne	SHORT $LN65@parse_all_

; 3702 :                         !codestream->active_tile->is_addressable)
; 3703 :                       { // Strange situation (see corresponding code in
; 3704 :                         // `kdu_subband::open_block').
; 3705 :                         kd_tile *active=codestream->active_tile;
; 3706 :                         assert(active != state);
; 3707 :                         desequence_packets_until_tile_inactive(active,

	push	edx
	push	eax
	call	?desequence_packets_until_tile_inactive@@YAXPAUkd_tile@@PAUkd_codestream@@@Z ; desequence_packets_until_tile_inactive
	add	esp, 8
$LN65@parse_all_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4228 :             (unique_address == 0) || (num_packets_read != 0))

	test	BYTE PTR [edi+8], 8
	je	SHORT $LN38@parse_all_
	mov	edx, DWORD PTR [edi+32]
	mov	eax, edx
	mov	ecx, DWORD PTR [edi+36]
	or	eax, ecx
	je	SHORT $LN38@parse_all_
	cmp	DWORD PTR [edi+20], 0
	jne	SHORT $LN38@parse_all_

; 4229 :           return;
; 4230 :         assert((flags & KD_PFLAG_DESEQUENCED) &&
; 4231 :                (next_layer_idx >= required_layers));
; 4232 :         resolution->codestream->in->seek(unique_address);

	mov	eax, DWORD PTR [edi]
	push	ecx
	push	edx
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx+4]
	call	?seek@kd_compressed_input@@QAEX_J@Z	; kd_compressed_input::seek

; 4233 :         while (num_packets_read < required_layers)

	mov	eax, DWORD PTR [edi+20]
	cmp	eax, DWORD PTR [edi+12]
	jge	SHORT $LN38@parse_all_
$LL142@parse_all_:

; 4234 :           if (!read_packet())

	mov	ecx, edi
	call	?read_packet@kd_precinct@@AAE_NXZ	; kd_precinct::read_packet
	test	al, al
	je	SHORT $LN38@parse_all_

; 4233 :         while (num_packets_read < required_layers)

	mov	eax, DWORD PTR [edi+20]
	cmp	eax, DWORD PTR [edi+12]
	jl	SHORT $LL142@parse_all_
$LN38@parse_all_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3670 :             for (idx.x=0; idx.x < res->region_indices.size.x; idx.x++)

	mov	eax, DWORD PTR _idx$2$[ebp]
	mov	edx, DWORD PTR _res$1$[ebp]
	inc	eax
	mov	esi, DWORD PTR _pos_idx$2$[ebp]
	mov	edi, DWORD PTR _idx_offset$2$[ebp]
	mov	DWORD PTR _idx$2$[ebp], eax
	cmp	eax, DWORD PTR [edx+164]
	jl	$LL40@parse_all_
	mov	ecx, DWORD PTR _idx$1$[ebp]
	mov	esi, DWORD PTR _idx_offset$1$[ebp]
$LN35@parse_all_:

; 3669 :           for (idx.y=0; idx.y < res->region_indices.size.y; idx.y++)

	inc	ecx
	mov	DWORD PTR _idx$1$[ebp], ecx
	cmp	ecx, DWORD PTR [edx+160]
	jl	$LL37@parse_all_
	mov	eax, DWORD PTR _r$2$[ebp]
$LN32@parse_all_:

; 3662 :         continue;
; 3663 :       for (r=0; r <= comp->apparent_dwt_levels; r++)

	mov	ecx, DWORD PTR _comp$1$[ebp]
	inc	eax
	mov	esi, DWORD PTR tv1291[ebp]
	add	esi, 604				; 0000025cH
	mov	DWORD PTR _r$2$[ebp], eax
	mov	DWORD PTR tv1291[ebp], esi
	cmp	eax, DWORD PTR [ecx+60]
	jle	$LL34@parse_all_
	mov	edx, DWORD PTR _c$2$[ebp]
	mov	esi, DWORD PTR tv1290[ebp]
$LN29@parse_all_:

; 3653 :                 }
; 3654 :             }
; 3655 :         }
; 3656 :     }
; 3657 :   
; 3658 :   for (c=0; c < state->num_components; c++)

	mov	eax, DWORD PTR [ebx]
	inc	edx
	add	esi, 188				; 000000bcH
	mov	DWORD PTR _c$2$[ebp], edx
	mov	DWORD PTR tv1290[ebp], esi
	cmp	edx, DWORD PTR [eax+128]
	jl	$LL31@parse_all_
$LN30@parse_all_:

; 3708 :                                                                codestream);
; 3709 :                       }
; 3710 :                   }
; 3711 :                 precinct->load_required_packets();
; 3712 :               }
; 3713 :         }
; 3714 :     }
; 3715 :   if (env != NULL)

	mov	eax, DWORD PTR _env$[ebp]
	test	eax, eax
	je	SHORT $LN152@parse_all_
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [eax+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN152@parse_all_
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN152@parse_all_:
	pop	edi
	pop	esi
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 3717 :   return true;

	mov	al, 1
	pop	ebx

; 3718 : }

	mov	esp, ebp
	pop	ebp
	ret	8
$LN229@parse_all_:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T4[ebp], eax
	lea	eax, DWORD PTR $T4[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN231@parse_all_:
$LN226@parse_all_:
	int	3
?parse_all_relevant_packets@kdu_tile@@QAE_N_NPAVkdu_thread_env@@@Z ENDP ; kdu_tile::parse_all_relevant_packets
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_num_layers@kdu_tile@@QAEHXZ
_TEXT	SEGMENT
?get_num_layers@kdu_tile@@QAEHXZ PROC			; kdu_tile::get_num_layers, COMDAT
; _this$ = ecx

; 3573 :   return state->num_apparent_layers;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+136]

; 3574 : }

	ret	0
?get_num_layers@kdu_tile@@QAEHXZ ENDP			; kdu_tile::get_num_layers
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_num_components@kdu_tile@@QAEHXZ
_TEXT	SEGMENT
?get_num_components@kdu_tile@@QAEHXZ PROC		; kdu_tile::get_num_components, COMDAT
; _this$ = ecx

; 3563 :   return state->codestream->num_apparent_components;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+116]

; 3564 : }

	ret	0
?get_num_components@kdu_tile@@QAEHXZ ENDP		; kdu_tile::get_num_components
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_mct_dwt_info@kdu_tile@@QAEPBUkdu_kernel_step_info@@HHAA_NAAH11100AAPBMPAH3@Z
_TEXT	SEGMENT
_stage_idx$ = 8						; size = 4
_block_idx$ = 12					; size = 4
_is_reversible$ = 16					; size = 4
_num_levels$ = 20					; size = 4
_canvas_min$ = 24					; size = 4
_canvas_lim$ = 28					; size = 4
_num_steps$ = 32					; size = 4
_symmetric$ = 36					; size = 4
_symmetric_extension$ = 40				; size = 4
_coefficients$ = 44					; size = 4
_active_inputs$ = 48					; size = 4
_active_outputs$ = 52					; size = 4
?get_mct_dwt_info@kdu_tile@@QAEPBUkdu_kernel_step_info@@HHAA_NAAH11100AAPBMPAH3@Z PROC ; kdu_tile::get_mct_dwt_info, COMDAT
; _this$ = ecx

; 3498 : {

	push	ebp
	mov	ebp, esp
	push	edi

; 3499 :   if (state->codestream->component_access_mode != KDU_WANT_OUTPUT_COMPONENTS)

	mov	edi, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax+128], 0
	je	SHORT $LN14@get_mct_dw
$LN44@get_mct_dw:

; 3500 :     return NULL;

	xor	eax, eax
	pop	edi

; 3554 : }

	pop	ebp
	ret	48					; 00000030H
$LN14@get_mct_dw:

; 3501 :   kd_mct_stage *stage = state->mct_head;
; 3502 :   for (; (stage_idx > 0) && (stage != NULL); stage_idx--)

	mov	eax, DWORD PTR _stage_idx$[ebp]
	mov	edi, DWORD PTR [edi+200]
	test	eax, eax
	jle	SHORT $LN3@get_mct_dw
$LL4@get_mct_dw:
	test	edi, edi
	je	SHORT $LN44@get_mct_dw

; 3503 :     stage = stage->next_stage;

	mov	edi, DWORD PTR [edi+36]
	dec	eax
	test	eax, eax
	jg	SHORT $LL4@get_mct_dw
$LN3@get_mct_dw:

; 3504 :   if (stage == NULL)

	test	edi, edi
	je	SHORT $LN44@get_mct_dw

; 3505 :     return NULL;
; 3506 :   if (stage->num_blocks <= block_idx)

	mov	ecx, DWORD PTR _block_idx$[ebp]
	push	esi
	mov	esi, DWORD PTR [edi+24]
	cmp	esi, ecx
	jle	$LN21@get_mct_dw

; 3507 :     return NULL;
; 3508 : 
; 3509 :   int b;
; 3510 :   kd_mct_block *block = stage->blocks;

	mov	eax, DWORD PTR [edi+28]

; 3511 :   for (b=0; b < stage->num_blocks; b++, block++)

	xor	edx, edx
	test	esi, esi
	jle	SHORT $LN45@get_mct_dw
	npad	3
$LL7@get_mct_dw:

; 3512 :     if (block->num_apparent_outputs > 0)

	cmp	DWORD PTR [eax+24], 0
	jle	SHORT $LN5@get_mct_dw

; 3513 :       {
; 3514 :         if (block_idx == 0)

	test	ecx, ecx
	je	SHORT $LN45@get_mct_dw

; 3515 :           break;
; 3516 :         block_idx--;

	dec	ecx
$LN5@get_mct_dw:

; 3511 :   for (b=0; b < stage->num_blocks; b++, block++)

	inc	edx
	add	eax, 108				; 0000006cH
	cmp	edx, esi
	jl	SHORT $LL7@get_mct_dw
$LN45@get_mct_dw:

; 3517 :       }
; 3518 :   if (b == stage->num_blocks)

	cmp	edx, esi
	je	$LN21@get_mct_dw

; 3519 :     return NULL;
; 3520 : 
; 3521 :   if ((block->dwt_step_info == NULL) || (block->dwt_num_levels < 1) ||

	cmp	DWORD PTR [eax+72], 0
	je	$LN21@get_mct_dw
	cmp	DWORD PTR [eax+60], 1
	jl	$LN21@get_mct_dw
	cmp	BYTE PTR [eax+37], 0
	jne	$LN21@get_mct_dw

; 3524 :   is_reversible = block->is_reversible;

	movzx	edx, BYTE PTR [eax+36]
	mov	ecx, DWORD PTR _is_reversible$[ebp]
	push	ebx

; 3525 :   num_levels = block->dwt_num_levels;
; 3526 :   canvas_min = block->dwt_canvas_origin;
; 3527 :   canvas_lim = canvas_min + block->num_inputs;
; 3528 :   num_steps = block->dwt_num_steps;
; 3529 :   symmetric = block->dwt_symmetric;
; 3530 :   symmetric_extension = block->dwt_symmetric_extension;
; 3531 :   coefficients = block->dwt_coefficients;
; 3532 : 
; 3533 :   int m, n;
; 3534 :   if (active_inputs != NULL)

	mov	ebx, DWORD PTR _active_inputs$[ebp]
	mov	BYTE PTR [ecx], dl
	mov	edx, DWORD PTR [eax+60]
	mov	ecx, DWORD PTR _num_levels$[ebp]
	mov	DWORD PTR [ecx], edx
	mov	esi, DWORD PTR [eax+64]
	mov	ecx, DWORD PTR _canvas_min$[ebp]
	mov	DWORD PTR [ecx], esi
	mov	edx, DWORD PTR [eax+4]
	mov	ecx, DWORD PTR _canvas_lim$[ebp]
	add	edx, esi
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR _num_steps$[ebp]
	mov	edx, DWORD PTR [eax+56]
	mov	DWORD PTR [ecx], edx
	mov	ecx, DWORD PTR _symmetric$[ebp]
	movzx	edx, BYTE PTR [eax+68]
	mov	BYTE PTR [ecx], dl
	mov	ecx, DWORD PTR _symmetric_extension$[ebp]
	movzx	edx, BYTE PTR [eax+69]
	mov	BYTE PTR [ecx], dl
	mov	ecx, DWORD PTR _coefficients$[ebp]
	mov	edx, DWORD PTR [eax+76]
	mov	DWORD PTR [ecx], edx
	test	ebx, ebx
	je	SHORT $LN46@get_mct_dw

; 3535 :     {
; 3536 :       for (n=m=0; (n<block->num_inputs) && (m<block->num_required_inputs); n++)

	xor	edx, edx
	xor	esi, esi
	cmp	DWORD PTR [eax+4], edx
	jle	SHORT $LN46@get_mct_dw
	npad	1
$LL10@get_mct_dw:
	cmp	esi, DWORD PTR [eax+8]
	jge	SHORT $LN46@get_mct_dw

; 3537 :         if (block->inputs_required[n])

	mov	ecx, DWORD PTR [eax+16]
	cmp	BYTE PTR [edx+ecx], 0
	je	SHORT $LN8@get_mct_dw

; 3538 :           active_inputs[m++] = n;

	mov	DWORD PTR [ebx+esi*4], edx
	inc	esi
$LN8@get_mct_dw:

; 3535 :     {
; 3536 :       for (n=m=0; (n<block->num_inputs) && (m<block->num_required_inputs); n++)

	inc	edx
	cmp	edx, DWORD PTR [eax+4]
	jl	SHORT $LL10@get_mct_dw
$LN46@get_mct_dw:

; 3539 :       assert(m == block->num_required_inputs);
; 3540 :     }
; 3541 :   if (active_outputs != NULL)

	cmp	DWORD PTR _active_outputs$[ebp], 0
	je	SHORT $LN47@get_mct_dw

; 3542 :     {
; 3543 :       for (n=m=0; (n<block->num_outputs)&&(m<block->num_apparent_outputs); n++)

	xor	ebx, ebx
	xor	esi, esi
	cmp	DWORD PTR [eax+20], ebx
	jle	SHORT $LN47@get_mct_dw
$LL13@get_mct_dw:
	cmp	ebx, DWORD PTR [eax+24]
	jge	SHORT $LN47@get_mct_dw

; 3544 :         {
; 3545 :           kd_output_comp_info *oci =
; 3546 :             stage->output_comp_info + block->output_indices[n];

	mov	ecx, DWORD PTR [eax+28]
	mov	ecx, DWORD PTR [ecx+esi*4]
	lea	edx, DWORD PTR [ecx+ecx*4]

; 3547 :           if (oci->is_of_interest)

	mov	ecx, DWORD PTR [edi+20]
	cmp	BYTE PTR [ecx+edx*8+32], 0
	je	SHORT $LN11@get_mct_dw

; 3548 :             active_outputs[m++] = n;

	mov	ecx, DWORD PTR _active_outputs$[ebp]
	mov	DWORD PTR [ecx+ebx*4], esi
	inc	ebx
$LN11@get_mct_dw:

; 3542 :     {
; 3543 :       for (n=m=0; (n<block->num_outputs)&&(m<block->num_apparent_outputs); n++)

	inc	esi
	cmp	esi, DWORD PTR [eax+20]
	jl	SHORT $LL13@get_mct_dw
$LN47@get_mct_dw:

; 3549 :         }
; 3550 :       assert(m == block->num_apparent_outputs);
; 3551 :     }
; 3552 : 
; 3553 :   return block->dwt_step_info;

	mov	eax, DWORD PTR [eax+72]
	pop	ebx
	pop	esi
	pop	edi

; 3554 : }

	pop	ebp
	ret	48					; 00000030H
$LN21@get_mct_dw:
	pop	esi

; 3522 :       block->is_null_transform)
; 3523 :     return NULL;

	xor	eax, eax
	pop	edi

; 3554 : }

	pop	ebp
	ret	48					; 00000030H
?get_mct_dwt_info@kdu_tile@@QAEPBUkdu_kernel_step_info@@HHAA_NAAH11100AAPBMPAH3@Z ENDP ; kdu_tile::get_mct_dwt_info
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_mct_dependency_info@kdu_tile@@QAE_NHHAA_NPAM1PAH22@Z
_TEXT	SEGMENT
tv590 = -12						; size = 8
tv578 = -12						; size = 8
_stage$1$ = -4						; size = 4
_stage_idx$ = 8						; size = 4
_block_idx$ = 12					; size = 4
_is_reversible$ = 16					; size = 4
_num_coeffs$1$ = 20					; size = 4
_coeff$1 = 20						; size = 4
_irrev_coefficients$ = 20				; size = 4
_irrev_offsets$ = 24					; size = 4
_num_coeffs$1$ = 28					; size = 4
_off$2 = 28						; size = 4
_coeff$3 = 28						; size = 4
_off$4 = 28						; size = 4
_rev_coefficients$ = 28					; size = 4
_rev_offsets$ = 32					; size = 4
_active_outputs$ = 36					; size = 4
?get_mct_dependency_info@kdu_tile@@QAE_NHHAA_NPAM1PAH22@Z PROC ; kdu_tile::get_mct_dependency_info, COMDAT
; _this$ = ecx

; 3398 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 12					; 0000000cH
	push	edi

; 3399 :   if (state->codestream->component_access_mode != KDU_WANT_OUTPUT_COMPONENTS)

	mov	edi, DWORD PTR [ecx]
	mov	eax, DWORD PTR [edi]
	cmp	DWORD PTR [eax+128], 0
	je	SHORT $LN23@get_mct_de
$LN69@get_mct_de:

; 3400 :     return false;

	xor	al, al
	pop	edi

; 3484 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN23@get_mct_de:

; 3401 :   kd_mct_stage *stage = state->mct_head;
; 3402 :   for (; (stage_idx > 0) && (stage != NULL); stage_idx--)

	mov	eax, DWORD PTR _stage_idx$[ebp]
	mov	edi, DWORD PTR [edi+200]
	mov	DWORD PTR _stage$1$[ebp], edi
	test	eax, eax
	jle	SHORT $LN3@get_mct_de
	npad	3
$LL4@get_mct_de:
	test	edi, edi
	je	SHORT $LN69@get_mct_de

; 3403 :     stage = stage->next_stage;

	mov	edi, DWORD PTR [edi+36]
	dec	eax
	mov	DWORD PTR _stage$1$[ebp], edi
	test	eax, eax
	jg	SHORT $LL4@get_mct_de
$LN3@get_mct_de:

; 3404 :   if (stage == NULL)

	test	edi, edi
	je	SHORT $LN69@get_mct_de

; 3405 :     return false;
; 3406 :   if (stage->num_blocks <= block_idx)

	mov	edx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR _block_idx$[ebp]
	cmp	edx, eax
	jle	SHORT $LN69@get_mct_de

; 3407 :     return false;
; 3408 : 
; 3409 :   int b;
; 3410 :   kd_mct_block *block = stage->blocks;
; 3411 :   for (b=0; b < stage->num_blocks; b++, block++)

	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR [edi+28]
	test	edx, edx
	jle	SHORT $LN70@get_mct_de
$LL7@get_mct_de:

; 3412 :     if (block->num_apparent_outputs > 0)

	cmp	DWORD PTR [esi+24], 0
	jle	SHORT $LN5@get_mct_de

; 3413 :       {
; 3414 :         if (block_idx == 0)

	test	eax, eax
	je	SHORT $LN70@get_mct_de

; 3415 :           break;
; 3416 :         block_idx--;

	dec	eax
$LN5@get_mct_de:

; 3407 :     return false;
; 3408 : 
; 3409 :   int b;
; 3410 :   kd_mct_block *block = stage->blocks;
; 3411 :   for (b=0; b < stage->num_blocks; b++, block++)

	inc	ecx
	add	esi, 108				; 0000006cH
	cmp	ecx, edx
	jl	SHORT $LL7@get_mct_de
$LN70@get_mct_de:

; 3417 :       }
; 3418 :   if (b == stage->num_blocks)

	cmp	ecx, edx
	je	$LN30@get_mct_de

; 3419 :     return false;
; 3420 : 
; 3421 :   if ((block->triang_params == NULL) || block->is_null_transform)

	cmp	DWORD PTR [esi+52], 0
	je	$LN30@get_mct_de
	cmp	BYTE PTR [esi+37], 0
	jne	$LN30@get_mct_de

; 3423 : 
; 3424 :   int n, m;
; 3425 :   is_reversible = block->is_reversible;

	mov	eax, DWORD PTR _is_reversible$[ebp]
	mov	cl, BYTE PTR [esi+36]
	push	ebx
	mov	BYTE PTR [eax], cl

; 3426 :   if (block->is_reversible)

	cmp	BYTE PTR [esi+36], 0
	je	$LN31@get_mct_de

; 3427 :     {
; 3428 :       assert((irrev_coefficients == NULL) && (irrev_offsets == NULL));
; 3429 :       if (rev_coefficients != NULL)

	cmp	DWORD PTR _rev_coefficients$[ebp], 0
	je	SHORT $LN9@get_mct_de

; 3430 :         {
; 3431 :           int num_coeffs =
; 3432 :             (block->num_required_inputs*(block->num_required_inputs+1))/2 - 1;

	mov	ecx, DWORD PTR [esi+8]

; 3433 :           for (n=0; n < num_coeffs; n++)

	xor	ebx, ebx
	lea	eax, DWORD PTR [ecx+1]
	imul	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	dec	eax
	mov	DWORD PTR _num_coeffs$1$[ebp], eax
	test	eax, eax
	jle	SHORT $LN9@get_mct_de
	mov	edi, eax
	npad	7
$LL10@get_mct_de:

; 3434 :             {
; 3435 :               float coeff=0.0F;
; 3436 :               block->triang_params->get(Mtriang_coeffs,n,0,coeff);

	mov	ecx, DWORD PTR [esi+52]
	lea	eax, DWORD PTR _coeff$1[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@
	mov	DWORD PTR _coeff$1[ebp], 0
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	movss	xmm0, DWORD PTR _coeff$1[ebp]

; 3437 :               rev_coefficients[n] = (int) floor(coeff + 0.5);

	sub	esp, 8
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv590[ebp], xmm0
	fld	QWORD PTR tv590[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	ecx, DWORD PTR _rev_coefficients$[ebp]
	mov	DWORD PTR [ecx+ebx*4], eax
	inc	ebx
	cmp	ebx, edi
	jl	SHORT $LL10@get_mct_de
	mov	edi, DWORD PTR _stage$1$[ebp]
$LN9@get_mct_de:

; 3438 :             }
; 3439 :         }
; 3440 :       if (rev_offsets != NULL)

	cmp	DWORD PTR _rev_offsets$[ebp], 0
	je	$LN18@get_mct_de

; 3441 :         for (n=0; n < block->num_required_inputs; n++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+8], ebx
	jle	$LN18@get_mct_de
	mov	edi, DWORD PTR _rev_offsets$[ebp]
$LL13@get_mct_de:

; 3442 :           {
; 3443 :             float off=0.0F;
; 3444 :             block->offset_params->get(Mvector_coeffs,n,0,off);

	mov	ecx, DWORD PTR [esi+40]
	lea	eax, DWORD PTR _off$4[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0P@DIALIICI@Mvector_coeffs?$AA@
	mov	DWORD PTR _off$4[ebp], 0
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	movss	xmm0, DWORD PTR _off$4[ebp]

; 3445 :             rev_offsets[n] = (int) floor(off + 0.5);

	sub	esp, 8
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv578[ebp], xmm0
	fld	QWORD PTR tv578[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	DWORD PTR [edi+ebx*4], eax
	inc	ebx
	cmp	ebx, DWORD PTR [esi+8]
	jl	SHORT $LL13@get_mct_de

; 3446 :           }
; 3447 :     }
; 3448 :   else

	jmp	$LN73@get_mct_de
$LN31@get_mct_de:

; 3449 :     {
; 3450 :       assert((rev_coefficients == NULL) && (rev_offsets == NULL));
; 3451 :       if (irrev_coefficients != NULL)

	cmp	DWORD PTR _irrev_coefficients$[ebp], 0
	je	SHORT $LN15@get_mct_de

; 3452 :         {
; 3453 :           int num_coeffs =
; 3454 :             (block->num_required_inputs*(block->num_required_inputs-1))/2;

	mov	ecx, DWORD PTR [esi+8]

; 3455 :           for (n=0; n < num_coeffs; n++)

	xor	ebx, ebx
	lea	eax, DWORD PTR [ecx-1]
	imul	eax, ecx
	cdq
	sub	eax, edx
	sar	eax, 1
	mov	DWORD PTR _num_coeffs$1$[ebp], eax
	test	eax, eax
	jle	SHORT $LN15@get_mct_de
	mov	edi, eax
	npad	5
$LL16@get_mct_de:

; 3456 :             {
; 3457 :               float coeff=0.0F;
; 3458 :               block->triang_params->get(Mtriang_coeffs,n,0,coeff);

	mov	ecx, DWORD PTR [esi+52]
	lea	eax, DWORD PTR _coeff$3[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0P@CMBCAAOP@Mtriang_coeffs?$AA@
	mov	DWORD PTR _coeff$3[ebp], 0
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get

; 3459 :               irrev_coefficients[n] = coeff;

	mov	eax, DWORD PTR _irrev_coefficients$[ebp]
	movss	xmm0, DWORD PTR _coeff$3[ebp]
	movss	DWORD PTR [eax+ebx*4], xmm0
	inc	ebx
	cmp	ebx, edi
	jl	SHORT $LL16@get_mct_de
	mov	edi, DWORD PTR _stage$1$[ebp]
$LN15@get_mct_de:

; 3460 :             }
; 3461 :         }
; 3462 :       if (irrev_offsets != NULL)

	cmp	DWORD PTR _irrev_offsets$[ebp], 0
	je	SHORT $LN18@get_mct_de

; 3463 :         for (n=0; n < block->num_required_inputs; n++)

	xor	ebx, ebx
	cmp	DWORD PTR [esi+8], ebx
	jle	SHORT $LN18@get_mct_de
	mov	edi, DWORD PTR _irrev_offsets$[ebp]
$LL19@get_mct_de:

; 3464 :           {
; 3465 :             float off=0.0F;
; 3466 :             block->offset_params->get(Mvector_coeffs,n,0,off);

	mov	ecx, DWORD PTR [esi+40]
	lea	eax, DWORD PTR _off$2[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0P@DIALIICI@Mvector_coeffs?$AA@
	mov	DWORD PTR _off$2[ebp], 0
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get

; 3467 :             irrev_offsets[n] = off;

	movss	xmm0, DWORD PTR _off$2[ebp]
	movss	DWORD PTR [edi+ebx*4], xmm0
	inc	ebx
	cmp	ebx, DWORD PTR [esi+8]
	jl	SHORT $LL19@get_mct_de
$LN73@get_mct_de:
	mov	edi, DWORD PTR _stage$1$[ebp]
$LN18@get_mct_de:

; 3468 :           }
; 3469 :     }
; 3470 : 
; 3471 :   if (active_outputs != NULL)

	cmp	DWORD PTR _active_outputs$[ebp], 0
	je	SHORT $LN71@get_mct_de

; 3472 :     {
; 3473 :       for (n=m=0; (n<block->num_outputs)&&(m<block->num_apparent_outputs); n++)

	xor	edx, edx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+20], edx
	jle	SHORT $LN71@get_mct_de
	npad	7
$LL22@get_mct_de:
	cmp	ebx, DWORD PTR [esi+24]
	jge	SHORT $LN71@get_mct_de

; 3474 :         {
; 3475 :           kd_output_comp_info *oci =
; 3476 :             stage->output_comp_info + block->output_indices[n];

	mov	eax, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [eax+edx*4]
	lea	ecx, DWORD PTR [eax+eax*4]

; 3477 :           if (oci->is_of_interest)

	mov	eax, DWORD PTR [edi+20]
	cmp	BYTE PTR [eax+ecx*8+32], 0
	je	SHORT $LN20@get_mct_de

; 3478 :             active_outputs[m++] = n;

	mov	eax, DWORD PTR _active_outputs$[ebp]
	mov	DWORD PTR [eax+ebx*4], edx
	inc	ebx
$LN20@get_mct_de:

; 3472 :     {
; 3473 :       for (n=m=0; (n<block->num_outputs)&&(m<block->num_apparent_outputs); n++)

	inc	edx
	cmp	edx, DWORD PTR [esi+20]
	jl	SHORT $LL22@get_mct_de
$LN71@get_mct_de:
	pop	ebx
	pop	esi

; 3479 :         }
; 3480 :       assert(m == block->num_apparent_outputs);
; 3481 :     }
; 3482 : 
; 3483 :   return true;

	mov	al, 1
	pop	edi

; 3484 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
$LN30@get_mct_de:
	pop	esi

; 3422 :     return false;

	xor	al, al
	pop	edi

; 3484 : }

	mov	esp, ebp
	pop	ebp
	ret	32					; 00000020H
?get_mct_dependency_info@kdu_tile@@QAE_NHHAA_NPAM1PAH22@Z ENDP ; kdu_tile::get_mct_dependency_info
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_mct_rxform_info@kdu_tile@@QAE_NHHPAH0@Z
_TEXT	SEGMENT
tv667 = -36						; size = 8
tv642 = -28						; size = 4
tv629 = -28						; size = 4
tv649 = -24						; size = 4
tv648 = -24						; size = 4
tv655 = -20						; size = 4
tv631 = -20						; size = 4
tv646 = -16						; size = 4
tv632 = -16						; size = 4
tv679 = -12						; size = 8
_m$1$ = -8						; size = 4
_coeff$1 = -8						; size = 4
_stage$1$ = -4						; size = 4
tv645 = 8						; size = 4
_coeff$2 = 8						; size = 4
_stage_idx$ = 8						; size = 4
_N$1$ = 12						; size = 4
_block_idx$ = 12					; size = 4
_coefficients$ = 16					; size = 4
_active_outputs$ = 20					; size = 4
?get_mct_rxform_info@kdu_tile@@QAE_NHHPAH0@Z PROC	; kdu_tile::get_mct_rxform_info, COMDAT
; _this$ = ecx

; 3318 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 36					; 00000024H
	push	ebx

; 3319 :   if (state->codestream->component_access_mode != KDU_WANT_OUTPUT_COMPONENTS)

	mov	ebx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ebx]
	cmp	DWORD PTR [eax+128], 0
	je	SHORT $LN23@get_mct_rx
$LN67@get_mct_rx:

; 3320 :     return false;

	xor	al, al
	pop	ebx

; 3384 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN23@get_mct_rx:

; 3321 :   kd_mct_stage *stage = state->mct_head;
; 3322 :   for (; (stage_idx > 0) && (stage != NULL); stage_idx--)

	mov	eax, DWORD PTR _stage_idx$[ebp]
	mov	ebx, DWORD PTR [ebx+200]
	mov	DWORD PTR _stage$1$[ebp], ebx
	test	eax, eax
	jle	SHORT $LN3@get_mct_rx
	npad	3
$LL4@get_mct_rx:
	test	ebx, ebx
	je	SHORT $LN67@get_mct_rx

; 3323 :     stage = stage->next_stage;

	mov	ebx, DWORD PTR [ebx+36]
	dec	eax
	mov	DWORD PTR _stage$1$[ebp], ebx
	test	eax, eax
	jg	SHORT $LL4@get_mct_rx
$LN3@get_mct_rx:

; 3324 :   if (stage == NULL)

	test	ebx, ebx
	je	SHORT $LN67@get_mct_rx

; 3325 :     return false;
; 3326 :   if (stage->num_blocks <= block_idx)

	mov	edx, DWORD PTR [ebx+24]
	mov	eax, DWORD PTR _block_idx$[ebp]
	cmp	edx, eax
	jle	SHORT $LN67@get_mct_rx

; 3327 :     return false;
; 3328 : 
; 3329 :   int b;
; 3330 :   kd_mct_block *block = stage->blocks;
; 3331 :   for (b=0; b < stage->num_blocks; b++, block++)

	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR [ebx+28]
	test	edx, edx
	jle	SHORT $LN68@get_mct_rx
$LL7@get_mct_rx:

; 3332 :     if (block->num_apparent_outputs > 0)

	cmp	DWORD PTR [esi+24], 0
	jle	SHORT $LN5@get_mct_rx

; 3333 :       {
; 3334 :         if (block_idx == 0)

	test	eax, eax
	je	SHORT $LN68@get_mct_rx

; 3335 :           break;
; 3336 :         block_idx--;

	dec	eax
$LN5@get_mct_rx:

; 3327 :     return false;
; 3328 : 
; 3329 :   int b;
; 3330 :   kd_mct_block *block = stage->blocks;
; 3331 :   for (b=0; b < stage->num_blocks; b++, block++)

	inc	ecx
	add	esi, 108				; 0000006cH
	cmp	ecx, edx
	jl	SHORT $LL7@get_mct_rx
$LN68@get_mct_rx:

; 3337 :       }
; 3338 :   if (b == stage->num_blocks)

	cmp	ecx, edx
	je	$LN30@get_mct_rx

; 3339 :     return false;
; 3340 : 
; 3341 :   if (((block->matrix_params == NULL) && (block->old_mat_params == NULL)) ||
; 3342 :       block->is_null_transform || !block->is_reversible)

	cmp	DWORD PTR [esi+44], 0
	jne	SHORT $LN31@get_mct_rx
	cmp	DWORD PTR [esi+48], 0
	je	$LN30@get_mct_rx
$LN31@get_mct_rx:
	cmp	BYTE PTR [esi+37], 0
	jne	$LN30@get_mct_rx
	cmp	BYTE PTR [esi+36], 0
	je	$LN30@get_mct_rx

; 3344 :   assert(block->num_required_inputs == block->num_inputs);
; 3345 : 
; 3346 :   int n, m;
; 3347 :   if (coefficients != NULL)

	push	edi
	mov	edi, DWORD PTR _coefficients$[ebp]
	test	edi, edi
	je	$LN15@get_mct_rx

; 3348 :     {
; 3349 :       int N = block->num_required_inputs;
; 3350 :       if (block->old_mat_params != NULL)

	cmp	DWORD PTR [esi+48], 0
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR _N$1$[ebp], eax
	je	$LN33@get_mct_rx

; 3351 :         {
; 3352 :           for (m=0; m < N; m++)

	test	eax, eax
	jle	$LN15@get_mct_rx
	lea	edx, DWORD PTR [eax+1]
	mov	DWORD PTR tv655[ebp], eax
	mov	DWORD PTR tv649[ebp], edx
	xor	ecx, ecx
	lea	edx, DWORD PTR [eax*4+4]
	mov	DWORD PTR tv645[ebp], ecx
	mov	DWORD PTR tv642[ebp], edx
$LL10@get_mct_rx:

; 3353 :             for (n=0; n <= N; n++)

	mov	DWORD PTR tv646[ebp], edi
	xor	ebx, ebx
	mov	edi, DWORD PTR _N$1$[ebp]
	npad	6
$LL13@get_mct_rx:

; 3354 :               {
; 3355 :                 float coeff = 0.0F;
; 3356 :                 block->old_mat_params->get(Mmatrix_coeffs,m*(N+1)+n,0,coeff);

	push	1
	push	1
	push	1
	lea	eax, DWORD PTR _coeff$1[ebp]
	mov	DWORD PTR _coeff$1[ebp], 0
	push	eax
	push	0
	lea	eax, DWORD PTR [ecx+ebx]
	mov	ecx, DWORD PTR [esi+48]
	push	eax
	push	OFFSET ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	movss	xmm0, DWORD PTR _coeff$1[ebp]

; 3357 :                 coefficients[m*(N+1)+n] = (int) floor(coeff + 0.5);

	sub	esp, 8
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv679[ebp], xmm0
	fld	QWORD PTR tv679[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	ecx, DWORD PTR tv646[ebp]
	inc	ebx
	mov	DWORD PTR [ecx], eax
	add	ecx, 4
	mov	DWORD PTR tv646[ebp], ecx
	mov	ecx, DWORD PTR tv645[ebp]
	cmp	ebx, edi
	jle	SHORT $LL13@get_mct_rx

; 3351 :         {
; 3352 :           for (m=0; m < N; m++)

	mov	edi, DWORD PTR _coefficients$[ebp]
	add	ecx, DWORD PTR tv649[ebp]
	add	edi, DWORD PTR tv642[ebp]
	sub	DWORD PTR tv655[ebp], 1
	mov	DWORD PTR tv645[ebp], ecx
	mov	DWORD PTR _coefficients$[ebp], edi
	jne	$LL10@get_mct_rx

; 3358 :               }
; 3359 :         }
; 3360 :       else

	jmp	$LN71@get_mct_rx
$LN33@get_mct_rx:

; 3361 :         {
; 3362 :           for (m=0; m < N; m++)

	xor	ecx, ecx
	mov	DWORD PTR _m$1$[ebp], ecx
	test	eax, eax
	jle	$LN15@get_mct_rx
	inc	eax
	mov	DWORD PTR tv648[ebp], eax
	lea	edx, DWORD PTR [eax*4]
	mov	DWORD PTR tv629[ebp], edx
	npad	5
$LL16@get_mct_rx:

; 3363 :             for (n=0; n <= N; n++)

	mov	DWORD PTR tv631[ebp], edi
	mov	ebx, ecx
	mov	edi, DWORD PTR _N$1$[ebp]
	mov	DWORD PTR tv632[ebp], eax
	npad	5
$LL19@get_mct_rx:

; 3364 :               {
; 3365 :                 float coeff = 0.0F;
; 3366 :                 block->matrix_params->get(Mmatrix_coeffs,n*N+m,0,coeff);

	mov	ecx, DWORD PTR [esi+44]
	lea	eax, DWORD PTR _coeff$2[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
	mov	DWORD PTR _coeff$2[ebp], 0
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get
	movss	xmm0, DWORD PTR _coeff$2[ebp]

; 3367 :                 coefficients[m*(N+1)+n] = (int) floor(coeff + 0.5);

	sub	esp, 8
	cvtps2pd xmm0, xmm0
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv667[ebp], xmm0
	fld	QWORD PTR tv667[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	ecx, DWORD PTR tv631[ebp]
	add	ebx, edi
	mov	DWORD PTR [ecx], eax
	add	ecx, 4
	sub	DWORD PTR tv632[ebp], 1
	mov	DWORD PTR tv631[ebp], ecx
	jne	SHORT $LL19@get_mct_rx

; 3361 :         {
; 3362 :           for (m=0; m < N; m++)

	mov	ecx, DWORD PTR _m$1$[ebp]
	mov	edi, DWORD PTR _coefficients$[ebp]
	inc	ecx
	add	edi, DWORD PTR tv629[ebp]
	mov	eax, DWORD PTR tv648[ebp]
	mov	DWORD PTR _m$1$[ebp], ecx
	mov	DWORD PTR _coefficients$[ebp], edi
	cmp	ecx, DWORD PTR _N$1$[ebp]
	jl	$LL16@get_mct_rx
$LN71@get_mct_rx:
	mov	ebx, DWORD PTR _stage$1$[ebp]
$LN15@get_mct_rx:

; 3368 :               }
; 3369 :         }
; 3370 :     }
; 3371 :   if (active_outputs != NULL)

	cmp	DWORD PTR _active_outputs$[ebp], 0
	je	SHORT $LN69@get_mct_rx

; 3372 :     {
; 3373 :       for (n=m=0; (n<block->num_outputs)&&(m<block->num_apparent_outputs); n++)

	xor	edx, edx
	xor	edi, edi
	cmp	DWORD PTR [esi+20], edx
	jle	SHORT $LN69@get_mct_rx
	npad	3
$LL22@get_mct_rx:
	cmp	edi, DWORD PTR [esi+24]
	jge	SHORT $LN69@get_mct_rx

; 3374 :         {
; 3375 :           kd_output_comp_info *oci =
; 3376 :             stage->output_comp_info + block->output_indices[n];

	mov	eax, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [eax+edx*4]
	lea	ecx, DWORD PTR [eax+eax*4]

; 3377 :           if (oci->is_of_interest)

	mov	eax, DWORD PTR [ebx+20]
	cmp	BYTE PTR [eax+ecx*8+32], 0
	je	SHORT $LN20@get_mct_rx

; 3378 :             active_outputs[m++] = n;

	mov	eax, DWORD PTR _active_outputs$[ebp]
	mov	DWORD PTR [eax+edi*4], edx
	inc	edi
$LN20@get_mct_rx:

; 3372 :     {
; 3373 :       for (n=m=0; (n<block->num_outputs)&&(m<block->num_apparent_outputs); n++)

	inc	edx
	cmp	edx, DWORD PTR [esi+20]
	jl	SHORT $LL22@get_mct_rx
$LN69@get_mct_rx:
	pop	edi
	pop	esi

; 3379 :         }
; 3380 :       assert(m == block->num_apparent_outputs);
; 3381 :     }
; 3382 : 
; 3383 :   return true;

	mov	al, 1
	pop	ebx

; 3384 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
$LN30@get_mct_rx:
	pop	esi

; 3343 :     return false;

	xor	al, al
	pop	ebx

; 3384 : }

	mov	esp, ebp
	pop	ebp
	ret	16					; 00000010H
?get_mct_rxform_info@kdu_tile@@QAE_NHHPAH0@Z ENDP	; kdu_tile::get_mct_rxform_info
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_mct_matrix_info@kdu_tile@@QAE_NHHPAM@Z
_TEXT	SEGMENT
_m$1$ = -8						; size = 4
_stage$1$ = -4						; size = 4
_coeff$1 = 8						; size = 4
_stage_idx$ = 8						; size = 4
_c_out$1$ = 12						; size = 4
_block_idx$ = 12					; size = 4
_coefficients$ = 16					; size = 4
?get_mct_matrix_info@kdu_tile@@QAE_NHHPAM@Z PROC	; kdu_tile::get_mct_matrix_info, COMDAT
; _this$ = ecx

; 3258 : {

	push	ebp
	mov	ebp, esp

; 3259 :   if (state->codestream->component_access_mode != KDU_WANT_OUTPUT_COMPONENTS)

	mov	edx, DWORD PTR [ecx]
	sub	esp, 8
	mov	eax, DWORD PTR [edx]
	cmp	DWORD PTR [eax+128], 0
	je	SHORT $LN14@get_mct_ma
$LN43@get_mct_ma:

; 3260 :     return false;

	xor	al, al

; 3309 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN14@get_mct_ma:

; 3261 :   kd_mct_stage *stage = state->mct_head;
; 3262 :   for (; (stage_idx > 0) && (stage != NULL); stage_idx--)

	mov	eax, DWORD PTR _stage_idx$[ebp]
	mov	edx, DWORD PTR [edx+200]
	mov	DWORD PTR _stage$1$[ebp], edx
	test	eax, eax
	jle	SHORT $LN3@get_mct_ma
	npad	5
$LL4@get_mct_ma:
	test	edx, edx
	je	SHORT $LN43@get_mct_ma

; 3263 :     stage = stage->next_stage;

	mov	edx, DWORD PTR [edx+36]
	dec	eax
	mov	DWORD PTR _stage$1$[ebp], edx
	test	eax, eax
	jg	SHORT $LL4@get_mct_ma
$LN3@get_mct_ma:

; 3264 :   if (stage == NULL)

	test	edx, edx
	je	SHORT $LN43@get_mct_ma

; 3265 :     return false;
; 3266 :   if (stage->num_blocks <= block_idx)

	mov	eax, DWORD PTR _block_idx$[ebp]
	push	edi
	mov	edi, DWORD PTR [edx+24]
	cmp	edi, eax
	jg	SHORT $LN16@get_mct_ma

; 3267 :     return false;

	xor	al, al
	pop	edi

; 3309 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN16@get_mct_ma:

; 3268 : 
; 3269 :   int b;
; 3270 :   kd_mct_block *block = stage->blocks;
; 3271 :   for (b=0; b < stage->num_blocks; b++, block++)

	xor	ecx, ecx
	push	esi
	mov	esi, DWORD PTR [edx+28]
	test	edi, edi
	jle	SHORT $LN44@get_mct_ma
$LL7@get_mct_ma:

; 3272 :     if (block->num_apparent_outputs > 0)

	cmp	DWORD PTR [esi+24], 0
	jle	SHORT $LN5@get_mct_ma

; 3273 :       {
; 3274 :         if (block_idx == 0)

	test	eax, eax
	je	SHORT $LN44@get_mct_ma

; 3275 :           break;
; 3276 :         block_idx--;

	dec	eax
$LN5@get_mct_ma:

; 3268 : 
; 3269 :   int b;
; 3270 :   kd_mct_block *block = stage->blocks;
; 3271 :   for (b=0; b < stage->num_blocks; b++, block++)

	inc	ecx
	add	esi, 108				; 0000006cH
	cmp	ecx, edi
	jl	SHORT $LL7@get_mct_ma
$LN44@get_mct_ma:

; 3277 :       }
; 3278 :   if (b == stage->num_blocks)

	cmp	ecx, edi
	je	$LN21@get_mct_ma

; 3279 :     return false;
; 3280 : 
; 3281 :   if ((block->matrix_params == NULL) ||
; 3282 :       block->is_null_transform || block->is_reversible)

	cmp	DWORD PTR [esi+44], 0
	je	$LN21@get_mct_ma
	cmp	BYTE PTR [esi+37], 0
	jne	$LN21@get_mct_ma
	cmp	BYTE PTR [esi+36], 0
	jne	$LN21@get_mct_ma

; 3284 : 
; 3285 :   if (coefficients != NULL)

	cmp	DWORD PTR _coefficients$[ebp], 0
	je	$LN9@get_mct_ma

; 3286 :     {
; 3287 :       int m, n, c_in=0, c_out=0;
; 3288 :       for (m=0; m < block->num_outputs; m++)

	xor	ecx, ecx
	push	ebx
	xor	ebx, ebx
	mov	DWORD PTR _m$1$[ebp], ecx
	mov	DWORD PTR _c_out$1$[ebp], ebx
	cmp	DWORD PTR [esi+20], ecx
	jle	SHORT $LN47@get_mct_ma
$LL10@get_mct_ma:

; 3289 :         {
; 3290 :           kd_output_comp_info *oci =
; 3291 :             stage->output_comp_info + block->output_indices[m];

	mov	eax, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [eax+ecx*4]
	lea	ecx, DWORD PTR [eax+eax*4]

; 3292 :           if (!oci->is_of_interest)

	mov	eax, DWORD PTR [edx+20]
	cmp	BYTE PTR [eax+ecx*8+32], 0
	jne	SHORT $LN23@get_mct_ma

; 3293 :             { // Skip this row
; 3294 :               c_in += block->num_inputs;

	add	ebx, DWORD PTR [esi+4]

; 3295 :               continue;

	jmp	SHORT $LN8@get_mct_ma
$LN23@get_mct_ma:

; 3296 :             }
; 3297 :           for (n=0; n < block->num_inputs; n++, c_in++)

	xor	edi, edi
	cmp	DWORD PTR [esi+4], edi
	jle	SHORT $LN8@get_mct_ma
$LL13@get_mct_ma:

; 3298 :             {
; 3299 :               if (!block->inputs_required[n])

	mov	eax, DWORD PTR [esi+16]
	cmp	BYTE PTR [edi+eax], 0
	je	SHORT $LN11@get_mct_ma

; 3300 :                 continue; // Skip this column
; 3301 :               float coeff=0.0F;
; 3302 :               block->matrix_params->get(Mmatrix_coeffs,c_in,0,coeff);

	mov	ecx, DWORD PTR [esi+44]
	lea	eax, DWORD PTR _coeff$1[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0P@NJDNNBNG@Mmatrix_coeffs?$AA@
	mov	DWORD PTR _coeff$1[ebp], 0
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get

; 3303 :               coefficients[c_out++] = coeff;

	mov	eax, DWORD PTR _c_out$1$[ebp]
	mov	ecx, DWORD PTR _coefficients$[ebp]
	movss	xmm0, DWORD PTR _coeff$1[ebp]
	movss	DWORD PTR [ecx+eax*4], xmm0
	inc	eax
	mov	DWORD PTR _c_out$1$[ebp], eax
$LN11@get_mct_ma:

; 3296 :             }
; 3297 :           for (n=0; n < block->num_inputs; n++, c_in++)

	inc	edi
	inc	ebx
	cmp	edi, DWORD PTR [esi+4]
	jl	SHORT $LL13@get_mct_ma
	mov	edx, DWORD PTR _stage$1$[ebp]
$LN8@get_mct_ma:

; 3286 :     {
; 3287 :       int m, n, c_in=0, c_out=0;
; 3288 :       for (m=0; m < block->num_outputs; m++)

	mov	ecx, DWORD PTR _m$1$[ebp]
	inc	ecx
	mov	DWORD PTR _m$1$[ebp], ecx
	cmp	ecx, DWORD PTR [esi+20]
	jl	SHORT $LL10@get_mct_ma
$LN47@get_mct_ma:
	pop	ebx
$LN9@get_mct_ma:
	pop	esi

; 3304 :             }
; 3305 :         }
; 3306 :       assert(c_out==(block->num_apparent_outputs*block->num_required_inputs));
; 3307 :     }
; 3308 :   return true;

	mov	al, 1
	pop	edi

; 3309 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
$LN21@get_mct_ma:
	pop	esi

; 3283 :     return false;

	xor	al, al
	pop	edi

; 3309 : }

	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
?get_mct_matrix_info@kdu_tile@@QAE_NHHPAM@Z ENDP	; kdu_tile::get_mct_matrix_info
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_mct_block_info@kdu_tile@@QAE_NHHAAH000PAH1PAM11@Z
_TEXT	SEGMENT
_ycc_perm$1$ = -68					; size = 4
tv1754 = -64						; size = 8
_ycc_perm$3$ = -60					; size = 4
tv1689 = -60						; size = 4
_m$6$ = -56						; size = 4
_ycc_perm$2$ = -56					; size = 4
_num_block_inputs$GSCopy$1$ = -52			; size = 4
tv1693 = -52						; size = 4
_block_output_indices$GSCopy$1$ = -48			; size = 4
tv1641 = -44						; size = 4
_block_input_indices$GSCopy$1$ = -40			; size = 4
_irrev_block_offsets$GSCopy$1$ = -36			; size = 4
_cs$1$ = -32						; size = 4
_rev_block_offsets$GSCopy$1$ = -28			; size = 4
_stage_input_indices$GSCopy$1$ = -24			; size = 4
_m$4$ = -24						; size = 4
_num_stage_inputs$GSCopy$1$ = -20			; size = 4
_span_stage_inputs$1$ = -20				; size = 4
_n$12$ = -20						; size = 4
tv1702 = -20						; size = 4
_this$GSCopy$1$ = -16					; size = 4
_num_block_outputs$GSCopy$1$ = -12			; size = 4
tv1697 = -12						; size = 4
_coeff$1 = -12						; size = 4
_num_stage_outputs$GSCopy$1$ = -8			; size = 4
tv1703 = -8						; size = 4
_want_codestream$1$ = -1				; size = 1
_stage_idx$ = 8						; size = 4
_block_idx$ = 12					; size = 4
_num_stage_inputs$ = 16					; size = 4
_num_stage_outputs$ = 20				; size = 4
_num_block_inputs$ = 24					; size = 4
_num_block_outputs$ = 28				; size = 4
_block_input_indices$ = 32				; size = 4
_block_output_indices$ = 36				; size = 4
_irrev_block_offsets$ = 40				; size = 4
_rev_block_offsets$ = 44				; size = 4
_stage_input_indices$ = 48				; size = 4
?get_mct_block_info@kdu_tile@@QAE_NHHAAH000PAH1PAM11@Z PROC ; kdu_tile::get_mct_block_info, COMDAT
; _this$ = ecx

; 2997 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 68					; 00000044H
	mov	eax, DWORD PTR _num_block_outputs$[ebp]
	mov	edx, DWORD PTR _num_block_inputs$[ebp]
	push	ebx
	mov	ebx, DWORD PTR _num_stage_inputs$[ebp]
	push	esi
	mov	esi, DWORD PTR _block_output_indices$[ebp]
	mov	DWORD PTR _num_block_outputs$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR _block_input_indices$[ebp]
	push	edi
	mov	edi, ecx
	mov	DWORD PTR _block_input_indices$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR _irrev_block_offsets$[ebp]
	mov	ecx, DWORD PTR _num_stage_outputs$[ebp]
	mov	DWORD PTR _irrev_block_offsets$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR _rev_block_offsets$[ebp]
	mov	DWORD PTR _this$GSCopy$1$[ebp], edi

; 2998 :   int n, m, k;
; 2999 : 
; 3000 :   kd_codestream *cs = state->codestream;

	mov	edi, DWORD PTR [edi]
	mov	DWORD PTR _rev_block_offsets$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR _stage_input_indices$[ebp]
	mov	DWORD PTR _stage_input_indices$GSCopy$1$[ebp], eax
	mov	eax, DWORD PTR [edi]
	mov	DWORD PTR _num_stage_inputs$GSCopy$1$[ebp], ebx
	mov	DWORD PTR _num_stage_outputs$GSCopy$1$[ebp], ecx
	mov	DWORD PTR _num_block_inputs$GSCopy$1$[ebp], edx

; 3001 :   bool want_codestream =
; 3002 :     (cs->component_access_mode==KDU_WANT_CODESTREAM_COMPONENTS);

	cmp	DWORD PTR [eax+128], 1
	mov	DWORD PTR _block_output_indices$GSCopy$1$[ebp], esi
	sete	BYTE PTR _want_codestream$1$[ebp]
	mov	DWORD PTR _cs$1$[ebp], eax

; 3003 :   if (want_codestream || (state->mct_head == NULL))

	cmp	BYTE PTR _want_codestream$1$[ebp], 0
	jne	$LN51@get_mct_bl
	mov	edi, DWORD PTR [edi+200]
	test	edi, edi
	je	$LN51@get_mct_bl

; 3150 :     }
; 3151 : 
; 3152 :   // If we get here, we have a `kd_mct_stage' list from which to derive the
; 3153 :   // requested information.
; 3154 :   kd_mct_stage *stage = state->mct_head;
; 3155 :   for (; (stage_idx > 0) && (stage != NULL); stage_idx--)

	mov	eax, DWORD PTR _stage_idx$[ebp]
	test	eax, eax
	jle	SHORT $LN27@get_mct_bl
$LL28@get_mct_bl:
	test	edi, edi
	je	$LN53@get_mct_bl

; 3156 :     stage = stage->next_stage;

	mov	edi, DWORD PTR [edi+36]
	dec	eax
	test	eax, eax
	jg	SHORT $LL28@get_mct_bl
$LN27@get_mct_bl:

; 3157 :   if (stage == NULL)

	test	edi, edi
	je	$LN53@get_mct_bl

; 3158 :     return false;
; 3159 :   num_stage_inputs = stage->num_required_inputs;

	mov	eax, DWORD PTR [edi+4]
	mov	DWORD PTR [ebx], eax

; 3160 :   num_stage_outputs = stage->num_apparent_outputs;
; 3161 :   if (stage_input_indices != NULL)

	mov	ebx, DWORD PTR _stage_input_indices$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [edi+16]
	mov	DWORD PTR [ecx], eax
	test	ebx, ebx
	je	SHORT $LN193@get_mct_bl

; 3162 :     {
; 3163 :       assert(stage_idx == 0);
; 3164 :       for (n=m=0; (n<stage->num_inputs) && (m<stage->num_required_inputs); n++)

	xor	ecx, ecx
	xor	edx, edx
	cmp	DWORD PTR [edi], ecx
	jle	SHORT $LN193@get_mct_bl
$LL31@get_mct_bl:
	cmp	edx, DWORD PTR [edi+4]
	jge	SHORT $LN193@get_mct_bl

; 3165 :         if (stage->input_required_indices[n] >= 0)

	mov	eax, DWORD PTR [edi+8]
	cmp	DWORD PTR [eax+ecx*4], 0
	jl	SHORT $LN29@get_mct_bl

; 3166 :           {
; 3167 :             assert(stage->input_required_indices[n] == m);
; 3168 :             stage_input_indices[m++] = n;

	mov	DWORD PTR [ebx+edx*4], ecx
	inc	edx
$LN29@get_mct_bl:

; 3162 :     {
; 3163 :       assert(stage_idx == 0);
; 3164 :       for (n=m=0; (n<stage->num_inputs) && (m<stage->num_required_inputs); n++)

	inc	ecx
	cmp	ecx, DWORD PTR [edi]
	jl	SHORT $LL31@get_mct_bl
$LN193@get_mct_bl:

; 3169 :           }
; 3170 :       assert(m == stage->num_required_inputs);
; 3171 :     }
; 3172 :   if (stage->num_blocks <= block_idx)

	mov	edx, DWORD PTR [edi+24]
	mov	eax, DWORD PTR _block_idx$[ebp]
	cmp	edx, eax
	jle	$LN53@get_mct_bl

; 3173 :     return false;
; 3174 : 
; 3175 :   int b;
; 3176 :   kd_mct_block *block = stage->blocks;

	mov	esi, DWORD PTR [edi+28]

; 3177 :   for (b=0; b < stage->num_blocks; b++, block++)

	xor	ecx, ecx
	test	edx, edx
	jle	SHORT $LN194@get_mct_bl
$LL34@get_mct_bl:

; 3178 :     if (block->num_apparent_outputs > 0)

	cmp	DWORD PTR [esi+24], 0
	jle	SHORT $LN32@get_mct_bl

; 3179 :       {
; 3180 :         if (block_idx == 0)

	test	eax, eax
	je	SHORT $LN194@get_mct_bl

; 3181 :           break;
; 3182 :         block_idx--;

	dec	eax
$LN32@get_mct_bl:

; 3177 :   for (b=0; b < stage->num_blocks; b++, block++)

	inc	ecx
	add	esi, 108				; 0000006cH
	cmp	ecx, edx
	jl	SHORT $LL34@get_mct_bl
$LN194@get_mct_bl:

; 3183 :       }
; 3184 :   if (b == stage->num_blocks)

	cmp	ecx, edx
	je	$LN53@get_mct_bl

; 3185 :     return false;
; 3186 :   num_block_inputs = block->num_required_inputs;
; 3187 :   num_block_outputs = block->num_apparent_outputs;
; 3188 :   if (block_input_indices != NULL)

	cmp	DWORD PTR _block_input_indices$GSCopy$1$[ebp], 0
	mov	ecx, DWORD PTR _num_block_inputs$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [esi+8]
	mov	DWORD PTR [ecx], eax
	mov	ecx, DWORD PTR _num_block_outputs$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [esi+24]
	mov	DWORD PTR [ecx], eax
	je	SHORT $LN195@get_mct_bl

; 3189 :     {
; 3190 :       for (n=m=0; (n<block->num_inputs) && (m<block->num_required_inputs); n++)

	xor	edx, edx
	xor	ebx, ebx
	cmp	DWORD PTR [esi+4], edx
	jle	SHORT $LN195@get_mct_bl
	npad	2
$LL37@get_mct_bl:
	cmp	ebx, DWORD PTR [esi+8]
	jge	SHORT $LN195@get_mct_bl

; 3191 :         if (block->inputs_required[n])

	mov	eax, DWORD PTR [esi+16]
	cmp	BYTE PTR [edx+eax], 0
	je	SHORT $LN35@get_mct_bl

; 3192 :           {
; 3193 :             int idx = block->input_indices[n];
; 3194 :             assert(stage->input_required_indices[idx] >= 0);
; 3195 :             block_input_indices[m++] = stage->input_required_indices[idx];

	mov	eax, DWORD PTR [esi+12]
	mov	ecx, DWORD PTR [eax+edx*4]
	mov	eax, DWORD PTR [edi+8]
	mov	eax, DWORD PTR [eax+ecx*4]
	mov	ecx, DWORD PTR _block_input_indices$GSCopy$1$[ebp]
	mov	DWORD PTR [ecx+ebx*4], eax
	inc	ebx
$LN35@get_mct_bl:

; 3189 :     {
; 3190 :       for (n=m=0; (n<block->num_inputs) && (m<block->num_required_inputs); n++)

	inc	edx
	cmp	edx, DWORD PTR [esi+4]
	jl	SHORT $LL37@get_mct_bl
$LN195@get_mct_bl:

; 3196 :             /*
; 3197 :             if (stage_idx == 0)
; 3198 :               idx = cs->comp_info[idx].apparent_idx;
; 3199 :             else
; 3200 :               idx = stage->prev_stage->output_comp_info[idx].apparent_idx;
; 3201 :             block_input_indices[m++] = idx;
; 3202 :             */
; 3203 :           }
; 3204 :       assert(m == block->num_required_inputs);
; 3205 :     }
; 3206 :   if (block_output_indices != NULL)

	cmp	DWORD PTR _block_output_indices$GSCopy$1$[ebp], 0
	je	SHORT $LN196@get_mct_bl

; 3207 :     {
; 3208 :       for (n=m=0; (n<block->num_outputs)&&(m<block->num_apparent_outputs); n++)

	xor	ecx, ecx
	xor	edx, edx
	cmp	DWORD PTR [esi+20], ecx
	jle	SHORT $LN196@get_mct_bl
$LL40@get_mct_bl:
	cmp	edx, DWORD PTR [esi+24]
	jge	SHORT $LN196@get_mct_bl

; 3209 :         {
; 3210 :           kd_output_comp_info *oci =
; 3211 :             stage->output_comp_info + block->output_indices[n];

	mov	eax, DWORD PTR [esi+28]
	mov	ebx, DWORD PTR [edi+20]
	mov	eax, DWORD PTR [eax+ecx*4]
	lea	eax, DWORD PTR [eax+eax*4]

; 3212 :           if (oci->is_of_interest)

	cmp	BYTE PTR [ebx+eax*8+32], 0
	je	SHORT $LN38@get_mct_bl

; 3213 :             block_output_indices[m++] = oci->apparent_idx;

	mov	eax, DWORD PTR [ebx+eax*8+12]
	mov	ebx, DWORD PTR _block_output_indices$GSCopy$1$[ebp]
	mov	DWORD PTR [ebx+edx*4], eax
	inc	edx
$LN38@get_mct_bl:

; 3207 :     {
; 3208 :       for (n=m=0; (n<block->num_outputs)&&(m<block->num_apparent_outputs); n++)

	inc	ecx
	cmp	ecx, DWORD PTR [esi+20]
	jl	SHORT $LL40@get_mct_bl
$LN196@get_mct_bl:

; 3214 :         }
; 3215 :       assert(m == block->num_apparent_outputs);
; 3216 :     }
; 3217 : 
; 3218 :   if ((block->offset_params == NULL) || (block->triang_params != NULL))

	cmp	DWORD PTR [esi+40], 0
	je	$LN103@get_mct_bl
	cmp	DWORD PTR [esi+52], 0
	jne	$LN103@get_mct_bl

; 3228 :     }
; 3229 :   else if ((irrev_block_offsets != NULL) || (rev_block_offsets != NULL))

	mov	ecx, DWORD PTR _irrev_block_offsets$GSCopy$1$[ebp]
	mov	edx, DWORD PTR _rev_block_offsets$GSCopy$1$[ebp]
	test	ecx, ecx
	jne	SHORT $LN107@get_mct_bl
	test	edx, edx
	je	$LN24@get_mct_bl
$LN107@get_mct_bl:

; 3230 :     {
; 3231 :       for (n=m=0; (n<block->num_outputs)&&(m<block->num_apparent_outputs); n++)

	xor	eax, eax
	xor	ebx, ebx
	mov	DWORD PTR _m$4$[ebp], eax
	cmp	DWORD PTR [esi+20], eax
	jle	$LN24@get_mct_bl
	sub	ecx, edx
	mov	DWORD PTR tv1703[ebp], edx
	mov	DWORD PTR tv1702[ebp], ecx
	npad	3
$LL49@get_mct_bl:
	cmp	eax, DWORD PTR [esi+24]
	jge	$LN24@get_mct_bl

; 3232 :         {
; 3233 :           kd_output_comp_info *oci =
; 3234 :             stage->output_comp_info + block->output_indices[n];

	mov	eax, DWORD PTR [esi+28]
	mov	eax, DWORD PTR [eax+ebx*4]
	lea	ecx, DWORD PTR [eax+eax*4]

; 3235 :           if (oci->is_of_interest)

	mov	eax, DWORD PTR [edi+20]
	cmp	BYTE PTR [eax+ecx*8+32], 0
	je	$LN198@get_mct_bl

; 3236 :             {
; 3237 :               float coeff=0.0F;
; 3238 :               block->offset_params->get(Mvector_coeffs,n,0,coeff);

	mov	ecx, DWORD PTR [esi+40]
	lea	eax, DWORD PTR _coeff$1[ebp]
	push	1
	push	1
	push	1
	push	eax
	push	0
	push	ebx
	push	OFFSET ??_C@_0P@DIALIICI@Mvector_coeffs?$AA@
	mov	DWORD PTR _coeff$1[ebp], 0
	call	?get@kdu_params@@QAE_NPBDHHAAM_N22@Z	; kdu_params::get

; 3239 :               if (irrev_block_offsets != NULL)

	cmp	DWORD PTR _irrev_block_offsets$GSCopy$1$[ebp], 0
	movss	xmm0, DWORD PTR _coeff$1[ebp]

; 3240 :                 irrev_block_offsets[m] = coeff;

	mov	ecx, DWORD PTR tv1703[ebp]
	je	SHORT $LN109@get_mct_bl
	mov	eax, DWORD PTR tv1702[ebp]
	movss	DWORD PTR [eax+ecx], xmm0
$LN109@get_mct_bl:

; 3241 :               if (rev_block_offsets != NULL)

	cmp	DWORD PTR _rev_block_offsets$GSCopy$1$[ebp], 0
	je	SHORT $LN110@get_mct_bl

; 3242 :                 rev_block_offsets[m] = (int) floor(coeff + 0.5);

	cvtps2pd xmm0, xmm0
	sub	esp, 8
	addsd	xmm0, QWORD PTR __real@3fe0000000000000
	movsd	QWORD PTR tv1754[ebp], xmm0
	fld	QWORD PTR tv1754[ebp]
	fstp	QWORD PTR [esp]
	call	_floor
	add	esp, 8
	call	__ftol2_sse
	mov	ecx, DWORD PTR tv1703[ebp]
	mov	DWORD PTR [ecx], eax
$LN110@get_mct_bl:

; 3243 :               m++;

	mov	eax, DWORD PTR _m$4$[ebp]
	inc	eax
	add	ecx, 4
	mov	DWORD PTR _m$4$[ebp], eax
	mov	DWORD PTR tv1703[ebp], ecx
	jmp	SHORT $LN47@get_mct_bl
$LN198@get_mct_bl:
	mov	eax, DWORD PTR _m$4$[ebp]
$LN47@get_mct_bl:

; 3230 :     {
; 3231 :       for (n=m=0; (n<block->num_outputs)&&(m<block->num_apparent_outputs); n++)

	inc	ebx
	cmp	ebx, DWORD PTR [esi+20]
	jl	$LL49@get_mct_bl

; 3144 :             }
; 3145 :           assert(non_ycc_idx == num_stage_inputs);
; 3146 :           assert(k == num_block_inputs);
; 3147 :         }
; 3148 : 
; 3149 :       return true;

	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx

; 3249 : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
$LN103@get_mct_bl:

; 3219 :     { // Note that dependency transforms always report having 0 offsets here,
; 3220 :       // since their offsets have a different interpretation and should be
; 3221 :       // returned via the `get_mct_dependency_info' function.
; 3222 :       if (irrev_block_offsets != NULL)

	mov	ecx, DWORD PTR _irrev_block_offsets$GSCopy$1$[ebp]
	test	ecx, ecx
	je	SHORT $LN42@get_mct_bl

; 3223 :         for (n=0; n < block->num_apparent_outputs; n++)

	xor	eax, eax
	cmp	DWORD PTR [esi+24], eax
	jle	SHORT $LN42@get_mct_bl
	npad	3
$LL43@get_mct_bl:

; 3224 :           irrev_block_offsets[n] = 0.0F;

	mov	DWORD PTR [ecx+eax*4], 0
	inc	eax
	cmp	eax, DWORD PTR [esi+24]
	jl	SHORT $LL43@get_mct_bl
$LN42@get_mct_bl:

; 3225 :       if (rev_block_offsets != NULL)

	mov	ecx, DWORD PTR _rev_block_offsets$GSCopy$1$[ebp]
	test	ecx, ecx
	je	$LN24@get_mct_bl

; 3226 :         for (n=0; n < block->num_apparent_outputs; n++)

	xor	eax, eax
	cmp	DWORD PTR [esi+24], eax
	jle	$LN24@get_mct_bl
$LL46@get_mct_bl:

; 3227 :           rev_block_offsets[n] = 0;

	mov	DWORD PTR [ecx+eax*4], 0
	inc	eax
	cmp	eax, DWORD PTR [esi+24]
	jl	SHORT $LL46@get_mct_bl

; 3244 :             }
; 3245 :         }
; 3246 :       assert(m == block->num_apparent_outputs);
; 3247 :     }
; 3248 :   return true;

	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx

; 3249 : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
$LN51@get_mct_bl:

; 3004 :     { // Report the existence of one dummy transform stage
; 3005 :       if ((stage_idx != 0) || (block_idx != 0))

	cmp	DWORD PTR _stage_idx$[ebp], 0
	jne	$LN53@get_mct_bl
	cmp	DWORD PTR _block_idx$[ebp], 0
	jne	$LN53@get_mct_bl

; 3007 :       if (want_codestream)

	cmp	BYTE PTR _want_codestream$1$[ebp], 0
	je	SHORT $LN54@get_mct_bl

; 3008 :         num_stage_outputs = cs->num_apparent_components;

	mov	eax, DWORD PTR [eax+116]

; 3009 :       else

	jmp	SHORT $LN205@get_mct_bl
$LN54@get_mct_bl:

; 3010 :         num_stage_outputs = cs->num_apparent_output_components;

	mov	eax, DWORD PTR [eax+124]
$LN205@get_mct_bl:
	mov	DWORD PTR [ecx], eax

; 3011 :       num_stage_inputs = num_block_inputs =

	mov	edi, eax
	mov	ecx, DWORD PTR _num_block_outputs$GSCopy$1$[ebp]
	mov	DWORD PTR [ecx], edi

; 3012 :         num_block_outputs = num_stage_outputs;
; 3013 : 
; 3014 :       bool need_ycc = get_ycc();

	mov	ecx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	DWORD PTR [edx], edi
	mov	DWORD PTR [ebx], edi
	call	?get_ycc@kdu_tile@@QAE_NXZ		; kdu_tile::get_ycc

; 3015 :                // If this is true and `want_codestream', all of the YCC
; 3016 :                // components are necessarily of interest.
; 3017 :       if (need_ycc && !want_codestream)

	mov	cl, BYTE PTR _want_codestream$1$[ebp]
	mov	DWORD PTR tv1641[ebp], eax
	test	al, al
	je	SHORT $LN58@get_mct_bl
	test	cl, cl
	jne	SHORT $LN58@get_mct_bl

; 3018 :         {
; 3019 :           for (n=0; n < 3; n++)

	mov	edx, DWORD PTR _cs$1$[ebp]
	xor	esi, esi
	mov	ebx, DWORD PTR _this$GSCopy$1$[ebp]
	mov	edx, DWORD PTR [edx+260]
	add	edx, 12					; 0000000cH
$LL4@get_mct_bl:

; 3020 :             if (((k=cs->output_comp_info[n].apparent_idx) >= 0) &&

	mov	ecx, DWORD PTR [edx]
	test	ecx, ecx
	js	SHORT $LN2@get_mct_bl
	mov	eax, DWORD PTR [ebx]
	imul	ecx, ecx, 188
	mov	eax, DWORD PTR [eax+208]
	cmp	BYTE PTR [eax+ecx+153], 0
	jne	SHORT $LN131@get_mct_bl
$LN2@get_mct_bl:

; 3018 :         {
; 3019 :           for (n=0; n < 3; n++)

	inc	esi
	add	edx, 40					; 00000028H
	cmp	esi, 3
	jl	SHORT $LL4@get_mct_bl
$LN131@get_mct_bl:

; 3021 :                 state->comps[k].is_of_interest)
; 3022 :               break;
; 3023 :           if (n == 3)

	mov	eax, DWORD PTR tv1641[ebp]
	xor	ecx, ecx
	mov	ebx, DWORD PTR _num_stage_inputs$GSCopy$1$[ebp]
	cmp	esi, 3
	mov	esi, DWORD PTR _block_output_indices$GSCopy$1$[ebp]
	movzx	eax, al
	cmove	eax, ecx
	mov	cl, BYTE PTR _want_codestream$1$[ebp]
	mov	DWORD PTR tv1641[ebp], eax
$LN58@get_mct_bl:

; 3024 :             need_ycc = false; // None of the first 3 codestream components are
; 3025 :                               // of interest
; 3026 :         }
; 3027 :       int ycc_perm[3] = {-1,-1,-1};

	mov	DWORD PTR _ycc_perm$1$[ebp], -1
	mov	DWORD PTR _ycc_perm$2$[ebp], -1
	mov	DWORD PTR _ycc_perm$3$[ebp], -1

; 3028 :       if (need_ycc)

	test	al, al
	je	$LN173@get_mct_bl

; 3029 :         { // Find the apparent indices of the components which are involved in
; 3030 :           // the YCC transform.
; 3031 :           for (n=0; n < 3; n++)
; 3032 :             {
; 3033 :               ycc_perm[n] = state->codestream->comp_info[n].apparent_idx;

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	edx, DWORD PTR [eax]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+256]
	mov	eax, DWORD PTR [eax+88]
	mov	DWORD PTR _ycc_perm$1$[ebp], eax

; 3034 :               assert(ycc_perm[n] >= 0);
; 3035 :               if ((!want_codestream) &&

	test	cl, cl
	jne	SHORT $LN5@get_mct_bl
	mov	eax, DWORD PTR _cs$1$[ebp]
	mov	eax, DWORD PTR [eax+260]
	mov	eax, DWORD PTR [eax+12]
	test	eax, eax
	js	SHORT $LN61@get_mct_bl
	imul	ecx, eax, 188
	mov	eax, DWORD PTR [edx+208]
	cmp	BYTE PTR [eax+ecx+153], 0
	jne	SHORT $LN5@get_mct_bl
$LN61@get_mct_bl:

; 3036 :                   (((k=cs->output_comp_info[n].apparent_idx) < 0) ||
; 3037 :                    !state->comps[k].is_of_interest))
; 3038 :                 num_stage_inputs++; // Need more codestream components than

	lea	eax, DWORD PTR [edi+1]
	mov	DWORD PTR [ebx], eax
$LN5@get_mct_bl:

; 3029 :         { // Find the apparent indices of the components which are involved in
; 3030 :           // the YCC transform.
; 3031 :           for (n=0; n < 3; n++)
; 3032 :             {
; 3033 :               ycc_perm[n] = state->codestream->comp_info[n].apparent_idx;

	cmp	BYTE PTR _want_codestream$1$[ebp], 0
	mov	edi, DWORD PTR _this$GSCopy$1$[ebp]
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+256]
	mov	eax, DWORD PTR [eax+184]
	mov	DWORD PTR _ycc_perm$2$[ebp], eax

; 3034 :               assert(ycc_perm[n] >= 0);
; 3035 :               if ((!want_codestream) &&

	jne	SHORT $LN170@get_mct_bl
	mov	eax, DWORD PTR _cs$1$[ebp]
	mov	eax, DWORD PTR [eax+260]
	mov	eax, DWORD PTR [eax+52]
	test	eax, eax
	js	SHORT $LN169@get_mct_bl
	imul	ecx, eax, 188
	mov	eax, DWORD PTR [edx+208]
	cmp	BYTE PTR [eax+ecx+153], 0
	jne	SHORT $LN170@get_mct_bl
$LN169@get_mct_bl:

; 3036 :                   (((k=cs->output_comp_info[n].apparent_idx) < 0) ||
; 3037 :                    !state->comps[k].is_of_interest))
; 3038 :                 num_stage_inputs++; // Need more codestream components than

	inc	DWORD PTR [ebx]
$LN170@get_mct_bl:

; 3034 :               assert(ycc_perm[n] >= 0);
; 3035 :               if ((!want_codestream) &&

	cmp	BYTE PTR _want_codestream$1$[ebp], 0
	mov	edx, DWORD PTR [edi]
	mov	eax, DWORD PTR [edx]
	mov	eax, DWORD PTR [eax+256]
	mov	eax, DWORD PTR [eax+280]
	mov	DWORD PTR _ycc_perm$3$[ebp], eax
	jne	SHORT $LN173@get_mct_bl
	mov	eax, DWORD PTR _cs$1$[ebp]
	mov	eax, DWORD PTR [eax+260]
	mov	eax, DWORD PTR [eax+92]
	test	eax, eax
	js	SHORT $LN172@get_mct_bl
	imul	ecx, eax, 188
	mov	eax, DWORD PTR [edx+208]
	cmp	BYTE PTR [eax+ecx+153], 0
	jne	SHORT $LN173@get_mct_bl
$LN172@get_mct_bl:

; 3036 :                   (((k=cs->output_comp_info[n].apparent_idx) < 0) ||
; 3037 :                    !state->comps[k].is_of_interest))
; 3038 :                 num_stage_inputs++; // Need more codestream components than

	inc	DWORD PTR [ebx]
$LN173@get_mct_bl:

; 3045 :       for (n=0; n < num_stage_outputs; n++)

	mov	edi, DWORD PTR _num_stage_outputs$GSCopy$1$[ebp]
	xor	edx, edx
	mov	eax, DWORD PTR [ebx]
	mov	DWORD PTR _span_stage_inputs$1$[ebp], eax
	cmp	DWORD PTR [edi], edx
	jle	SHORT $LN9@get_mct_bl

; 3039 :                                     // output components
; 3040 :             }
; 3041 :         }
; 3042 : 
; 3043 :       // See if there are any stage outputs which are not of interest.
; 3044 :       int span_stage_inputs = num_stage_inputs; // Remember this value

	mov	esi, DWORD PTR _num_block_inputs$GSCopy$1$[ebp]
	xor	ecx, ecx
	npad	7
$LL10@get_mct_bl:

; 3046 :         if (!state->comps[n].is_of_interest)

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+208]
	cmp	BYTE PTR [eax+ecx+153], 0
	jne	SHORT $LN8@get_mct_bl

; 3047 :           {
; 3048 :             num_stage_inputs--;
; 3049 :             num_block_inputs--;
; 3050 :             num_block_outputs--;

	mov	eax, DWORD PTR _num_block_outputs$GSCopy$1$[ebp]
	dec	DWORD PTR [ebx]
	dec	DWORD PTR [esi]
	dec	DWORD PTR [eax]
$LN8@get_mct_bl:

; 3045 :       for (n=0; n < num_stage_outputs; n++)

	inc	edx
	add	ecx, 188				; 000000bcH
	cmp	edx, DWORD PTR [edi]
	jl	SHORT $LL10@get_mct_bl
	mov	esi, DWORD PTR _block_output_indices$GSCopy$1$[ebp]
$LN9@get_mct_bl:

; 3051 :               // Note that if the YCC transform is to be used, all of its
; 3052 :               // components are necessarily of interest.
; 3053 :           }
; 3054 : 
; 3055 :       if (block_output_indices != NULL)

	test	esi, esi
	je	SHORT $LN12@get_mct_bl

; 3056 :         {
; 3057 :           for (n=k=0; n < num_stage_outputs; n++)

	xor	ecx, ecx
	cmp	DWORD PTR [edi], ecx
	jle	SHORT $LN12@get_mct_bl
	xor	edx, edx
	npad	8
$LL13@get_mct_bl:

; 3058 :             if (state->comps[n].is_of_interest)

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+208]
	cmp	BYTE PTR [eax+edx+153], 0
	je	SHORT $LN11@get_mct_bl

; 3059 :               block_output_indices[k++] = n;

	mov	DWORD PTR [esi], ecx
	add	esi, 4
$LN11@get_mct_bl:

; 3056 :         {
; 3057 :           for (n=k=0; n < num_stage_outputs; n++)

	inc	ecx
	add	edx, 188				; 000000bcH
	cmp	ecx, DWORD PTR [edi]
	jl	SHORT $LL13@get_mct_bl
$LN12@get_mct_bl:

; 3060 :           assert(k == num_block_outputs);
; 3061 :         }
; 3062 : 
; 3063 :       if ((irrev_block_offsets != NULL) || (rev_block_offsets != NULL))

	mov	edx, DWORD PTR _irrev_block_offsets$GSCopy$1$[ebp]
	mov	eax, DWORD PTR _rev_block_offsets$GSCopy$1$[ebp]
	test	edx, edx
	jne	SHORT $LN66@get_mct_bl
	test	eax, eax
	je	$LN200@get_mct_bl
$LN66@get_mct_bl:

; 3064 :         {
; 3065 :           for (n=k=0; n < num_stage_outputs; n++)

	xor	esi, esi
	cmp	DWORD PTR [edi], esi
	jle	$LN200@get_mct_bl
	xor	ecx, ecx
	xor	edi, edi
	xor	ebx, ebx
	mov	DWORD PTR tv1697[ebp], ecx
	sub	eax, edx
	mov	DWORD PTR tv1693[ebp], eax
	npad	1
$LL16@get_mct_bl:

; 3066 :             {
; 3067 :               if (!state->comps[n].is_of_interest)

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+208]
	cmp	BYTE PTR [eax+ebx+153], 0
	je	$LN14@get_mct_bl

; 3068 :                 continue;
; 3069 :               kd_comp_info *ci = NULL;
; 3070 :               if (want_codestream)

	cmp	BYTE PTR _want_codestream$1$[ebp], 0

; 3071 :                 ci = cs->comp_info[n].from_apparent;

	mov	eax, DWORD PTR _cs$1$[ebp]
	je	SHORT $LN68@get_mct_bl
	mov	eax, DWORD PTR [eax+256]
	mov	ecx, DWORD PTR [eax+edi+92]

; 3072 :               else

	jmp	SHORT $LN69@get_mct_bl
$LN68@get_mct_bl:

; 3073 :                 {
; 3074 :                   m = cs->output_comp_info[n].from_apparent;

	mov	ecx, DWORD PTR [eax+260]

; 3075 :                   ci = cs->output_comp_info[m].subsampling_ref;

	mov	eax, DWORD PTR tv1697[ebp]
	mov	eax, DWORD PTR [eax+ecx+16]
	lea	eax, DWORD PTR [eax+eax*4]
	mov	ecx, DWORD PTR [ecx+eax*8+8]
$LN69@get_mct_bl:

; 3076 :                 }
; 3077 :               int off = (ci->is_signed)?0:(1<<(ci->precision-1));

	cmp	BYTE PTR [ecx+20], 0
	je	SHORT $LN112@get_mct_bl
	xor	eax, eax
	jmp	SHORT $LN113@get_mct_bl
$LN112@get_mct_bl:
	mov	ecx, DWORD PTR [ecx+16]
	mov	eax, 1
	dec	ecx
	shl	eax, cl
$LN113@get_mct_bl:

; 3078 :               if (rev_block_offsets != NULL)

	cmp	DWORD PTR _rev_block_offsets$GSCopy$1$[ebp], 0
	je	SHORT $LN70@get_mct_bl

; 3079 :                 rev_block_offsets[k] = off;

	mov	ecx, DWORD PTR tv1693[ebp]
	mov	DWORD PTR [ecx+edx], eax
$LN70@get_mct_bl:

; 3080 :               if (irrev_block_offsets != NULL)

	cmp	DWORD PTR _irrev_block_offsets$GSCopy$1$[ebp], 0
	je	SHORT $LN71@get_mct_bl

; 3081 :                 irrev_block_offsets[k] = (float) off;

	movd	xmm0, eax
	cvtdq2ps xmm0, xmm0
	movss	DWORD PTR [edx], xmm0
$LN71@get_mct_bl:

; 3082 :               k++;

	mov	ecx, DWORD PTR tv1697[ebp]
	add	edx, 4
$LN14@get_mct_bl:

; 3064 :         {
; 3065 :           for (n=k=0; n < num_stage_outputs; n++)

	mov	eax, DWORD PTR _num_stage_outputs$GSCopy$1$[ebp]
	inc	esi
	add	ecx, 40					; 00000028H
	add	ebx, 188				; 000000bcH
	add	edi, 96					; 00000060H
	mov	DWORD PTR tv1697[ebp], ecx
	cmp	esi, DWORD PTR [eax]
	jl	$LL16@get_mct_bl
	jmp	SHORT $LN15@get_mct_bl
$LN200@get_mct_bl:
	mov	eax, edi
$LN15@get_mct_bl:

; 3083 :             }
; 3084 :           assert(k == num_block_outputs);
; 3085 :         }
; 3086 : 
; 3087 :       if ((stage_input_indices == NULL) && (block_input_indices == NULL))

	mov	ebx, DWORD PTR _stage_input_indices$GSCopy$1$[ebp]
	mov	esi, DWORD PTR _block_input_indices$GSCopy$1$[ebp]
	test	ebx, ebx
	jne	SHORT $LN72@get_mct_bl
	test	esi, esi
	je	$LN24@get_mct_bl
$LN72@get_mct_bl:

; 3088 :         return true;
; 3089 : 
; 3090 :       if (want_codestream)

	cmp	BYTE PTR _want_codestream$1$[ebp], 0
	je	$LN73@get_mct_bl

; 3091 :         { // Codestream indices may be permuted; arrange for the first three
; 3092 :           // entries of the `stage_input_indices' array to reference the
; 3093 :           // first 3 original components (via their modified indices if
; 3094 :           // necessary), and for `block_input_indices' to undo any permutation
; 3095 :           // required to make this happen.
; 3096 :           int non_ycc_idx = (need_ycc)?3:0;

	xor	edx, edx
	mov	eax, 3
	cmp	BYTE PTR tv1641[ebp], dl
	cmovne	edx, eax

; 3097 :           for (n=m=k=0; n < span_stage_inputs; n++)

	xor	ecx, ecx
	cmp	DWORD PTR _span_stage_inputs$1$[ebp], ecx
	jle	$LN24@get_mct_bl

; 3098 :             {
; 3099 :               if (n == ycc_perm[0])

	xor	edi, edi
	npad	1
$LL19@get_mct_bl:
	cmp	ecx, DWORD PTR _ycc_perm$1$[ebp]
	jne	SHORT $LN75@get_mct_bl

; 3100 :                 m = 0;

	xor	eax, eax
	jmp	SHORT $LN80@get_mct_bl
$LN75@get_mct_bl:

; 3101 :               else if (n == ycc_perm[1])

	cmp	ecx, DWORD PTR _ycc_perm$2$[ebp]
	jne	SHORT $LN77@get_mct_bl

; 3102 :                 m = 1;

	mov	eax, 1
	jmp	SHORT $LN80@get_mct_bl
$LN77@get_mct_bl:

; 3103 :               else if (n == ycc_perm[2])

	cmp	ecx, DWORD PTR _ycc_perm$3$[ebp]
	jne	SHORT $LN79@get_mct_bl

; 3104 :                 m = 2;

	mov	eax, 2

; 3105 :               else

	jmp	SHORT $LN80@get_mct_bl
$LN79@get_mct_bl:

; 3106 :                 {
; 3107 :                   if (!state->comps[n].is_of_interest)

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+208]
	cmp	BYTE PTR [eax+edi+153], 0
	je	SHORT $LN17@get_mct_bl

; 3108 :                     continue;
; 3109 :                   m = non_ycc_idx++;

	mov	eax, edx
	inc	edx
$LN80@get_mct_bl:

; 3110 :                 }
; 3111 :               if (stage_input_indices != NULL)

	test	ebx, ebx
	je	SHORT $LN82@get_mct_bl

; 3112 :                 stage_input_indices[m] = n;

	mov	DWORD PTR [ebx+eax*4], ecx
$LN82@get_mct_bl:

; 3113 :               if (block_input_indices != NULL)

	cmp	DWORD PTR _block_input_indices$GSCopy$1$[ebp], 0
	je	SHORT $LN83@get_mct_bl

; 3114 :                 block_input_indices[k] = m;

	mov	DWORD PTR [esi], eax
$LN83@get_mct_bl:

; 3115 :               k++;

	add	esi, 4
$LN17@get_mct_bl:

; 3097 :           for (n=m=k=0; n < span_stage_inputs; n++)

	inc	ecx
	add	edi, 188				; 000000bcH
	cmp	ecx, DWORD PTR _span_stage_inputs$1$[ebp]
	jl	SHORT $LL19@get_mct_bl

; 3144 :             }
; 3145 :           assert(non_ycc_idx == num_stage_inputs);
; 3146 :           assert(k == num_block_inputs);
; 3147 :         }
; 3148 : 
; 3149 :       return true;

	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx

; 3249 : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
$LN73@get_mct_bl:

; 3116 :             }
; 3117 :           assert(k == num_block_inputs);
; 3118 :         }
; 3119 :       else
; 3120 :         { // In this case, the codestream components are in order already, but
; 3121 :           // if there is a YCC transform, it is possible that only some of
; 3122 :           // its outputs are used.
; 3123 :           if (need_ycc && (stage_input_indices != NULL))

	mov	ecx, DWORD PTR tv1641[ebp]
	test	cl, cl
	je	SHORT $LN174@get_mct_bl
	test	ebx, ebx
	je	SHORT $LN174@get_mct_bl

; 3124 :             for (n=0; n < 3; n++)
; 3125 :               stage_input_indices[n] = n;

	mov	DWORD PTR [ebx], 0
	mov	DWORD PTR [ebx+4], 1
	mov	DWORD PTR [ebx+8], 2
$LN174@get_mct_bl:

; 3126 :           int si_idx, non_ycc_idx = (need_ycc)?3:0;

	xor	edx, edx
	mov	edi, 3
	test	cl, cl
	cmovne	edx, edi

; 3127 :           for (n=k=0; n < num_stage_outputs; n++)

	xor	edi, edi
	mov	DWORD PTR _n$12$[ebp], edi
	cmp	DWORD PTR [eax], edi
	jle	$LN24@get_mct_bl

; 3126 :           int si_idx, non_ycc_idx = (need_ycc)?3:0;

	xor	ebx, ebx
	xor	ecx, ecx
	mov	DWORD PTR tv1689[ebp], ecx
$LL25@get_mct_bl:

; 3128 :             {
; 3129 :               if (!state->comps[n].is_of_interest)

	mov	eax, DWORD PTR _this$GSCopy$1$[ebp]
	mov	eax, DWORD PTR [eax]
	mov	eax, DWORD PTR [eax+208]
	cmp	BYTE PTR [eax+ecx+153], 0
	je	SHORT $LN23@get_mct_bl

; 3130 :                 continue;
; 3131 :               m = cs->output_comp_info[n].from_apparent;
; 3132 :                  // m holds the true codestream input index
; 3133 :               if ((need_ycc) && (m < 3))

	cmp	BYTE PTR tv1641[ebp], 0
	mov	eax, DWORD PTR _cs$1$[ebp]
	mov	eax, DWORD PTR [eax+260]
	mov	ecx, DWORD PTR [eax+ebx+16]
	mov	DWORD PTR _m$6$[ebp], ecx
	je	SHORT $LN86@get_mct_bl
	cmp	ecx, 3
	jge	SHORT $LN86@get_mct_bl

; 3134 :                 si_idx = m;

	mov	eax, ecx

; 3135 :               else

	jmp	SHORT $LN87@get_mct_bl
$LN86@get_mct_bl:

; 3136 :                 si_idx = non_ycc_idx++;

	mov	eax, edx
	inc	edx
$LN87@get_mct_bl:

; 3137 : 
; 3138 :               if (stage_input_indices != NULL)

	cmp	DWORD PTR _stage_input_indices$GSCopy$1$[ebp], 0
	mov	ecx, DWORD PTR _m$6$[ebp]
	je	SHORT $LN88@get_mct_bl

; 3139 :                 stage_input_indices[si_idx] = m;

	mov	edi, DWORD PTR _stage_input_indices$GSCopy$1$[ebp]
	mov	DWORD PTR [edi+eax*4], ecx
	mov	edi, DWORD PTR _n$12$[ebp]
$LN88@get_mct_bl:

; 3140 :               if (block_input_indices != NULL)

	cmp	DWORD PTR _block_input_indices$GSCopy$1$[ebp], 0
	je	SHORT $LN89@get_mct_bl

; 3141 :                 block_input_indices[k] = si_idx;

	mov	DWORD PTR [esi], eax
$LN89@get_mct_bl:
	mov	ecx, DWORD PTR tv1689[ebp]

; 3142 : 
; 3143 :               k++;

	add	esi, 4
$LN23@get_mct_bl:

; 3127 :           for (n=k=0; n < num_stage_outputs; n++)

	mov	eax, DWORD PTR _num_stage_outputs$GSCopy$1$[ebp]
	inc	edi
	add	ecx, 188				; 000000bcH
	mov	DWORD PTR _n$12$[ebp], edi
	add	ebx, 40					; 00000028H
	mov	DWORD PTR tv1689[ebp], ecx
	cmp	edi, DWORD PTR [eax]
	jl	SHORT $LL25@get_mct_bl
$LN24@get_mct_bl:
	pop	edi
	pop	esi

; 3144 :             }
; 3145 :           assert(non_ycc_idx == num_stage_inputs);
; 3146 :           assert(k == num_block_inputs);
; 3147 :         }
; 3148 : 
; 3149 :       return true;

	mov	al, 1
	pop	ebx

; 3249 : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
$LN53@get_mct_bl:
	pop	edi
	pop	esi

; 3006 :         return false;

	xor	al, al
	pop	ebx

; 3249 : }

	mov	esp, ebp
	pop	ebp
	ret	44					; 0000002cH
?get_mct_block_info@kdu_tile@@QAE_NHHAAH000PAH1PAM11@Z ENDP ; kdu_tile::get_mct_block_info
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?set_components_of_interest@kdu_tile@@QAEXHPBH@Z
_TEXT	SEGMENT
_this$1$ = -4						; size = 4
_num_components_of_interest$ = 8			; size = 4
_components_of_interest$ = 12				; size = 4
?set_components_of_interest@kdu_tile@@QAEXHPBH@Z PROC	; kdu_tile::set_components_of_interest, COMDAT
; _this$ = ecx

; 2941 : {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx

; 2942 :   if ((state->codestream->component_access_mode ==
; 2943 :        KDU_WANT_OUTPUT_COMPONENTS) && (state->mct_head != NULL))

	mov	eax, DWORD PTR [ebx]
	mov	ecx, DWORD PTR [eax]
	cmp	DWORD PTR [ecx+128], 0
	jne	SHORT $LN17@set_compon
	cmp	DWORD PTR [eax+200], 0
	je	SHORT $LN17@set_compon

; 2944 :     state->mct_tail->apply_output_restrictions(

	push	DWORD PTR _components_of_interest$[ebp]
	push	DWORD PTR _num_components_of_interest$[ebp]
	push	DWORD PTR [ecx+260]
	mov	ecx, DWORD PTR [eax+204]
	call	?apply_output_restrictions@kd_mct_stage@@QAEXPAUkd_output_comp_info@@HPBH@Z ; kd_mct_stage::apply_output_restrictions

; 2945 :                            state->codestream->output_comp_info,
; 2946 :                            num_components_of_interest,components_of_interest);
; 2947 :   else

	jmp	$LN12@set_compon
$LN17@set_compon:

; 2948 :     { // Record the components which are of interest in the `is_of_interest'
; 2949 :       // members of the `kd_tile::comps' array.
; 2950 :       kd_codestream *cs = state->codestream;
; 2951 :       kd_tile_comp *comps = state->comps;
; 2952 :       int n, num_output_comps;
; 2953 :       if (cs->component_access_mode == KDU_WANT_CODESTREAM_COMPONENTS)

	cmp	DWORD PTR [ecx+128], 1
	push	esi
	mov	esi, DWORD PTR [eax+208]
	jne	SHORT $LN19@set_compon

; 2954 :         num_output_comps = cs->num_apparent_components;

	mov	ecx, DWORD PTR [ecx+116]

; 2955 :       else

	jmp	SHORT $LN20@set_compon
$LN19@set_compon:

; 2956 :         num_output_comps = cs->num_apparent_output_components;

	mov	ecx, DWORD PTR [ecx+124]
$LN20@set_compon:
	push	edi

; 2957 :       if (num_components_of_interest == 0)

	mov	edi, DWORD PTR _num_components_of_interest$[ebp]
	test	edi, edi
	jne	SHORT $LN21@set_compon

; 2958 :         { // All apparent components are of interest
; 2959 :           for (n=0; n < num_output_comps; n++)

	test	ecx, ecx
	jle	$LN54@set_compon
	lea	eax, DWORD PTR [esi+153]
	npad	6
$LL4@set_compon:

; 2960 :             comps[n].is_of_interest = true;

	mov	BYTE PTR [eax], 1
	lea	eax, DWORD PTR [eax+188]
	sub	ecx, 1
	jne	SHORT $LL4@set_compon

; 2961 :         }
; 2962 :       else if (components_of_interest == NULL)

	jmp	SHORT $LN54@set_compon
$LN21@set_compon:
	mov	ebx, DWORD PTR _components_of_interest$[ebp]
	test	ebx, ebx
	jne	SHORT $LN23@set_compon

; 2963 :         { // First `num_components_of_interest' components are of interest
; 2964 :           for (n=0; n < num_output_comps; n++)

	xor	edx, edx
	test	ecx, ecx
	jle	SHORT $LN52@set_compon
	add	esi, 153				; 00000099H
$LL37@set_compon:

; 2965 :             comps[n].is_of_interest = (n < num_components_of_interest);

	cmp	edx, edi
	lea	esi, DWORD PTR [esi+188]
	setl	al
	inc	edx
	mov	BYTE PTR [esi-188], al
	cmp	edx, ecx
	jl	SHORT $LL37@set_compon

; 2966 :         }
; 2967 :       else

	jmp	SHORT $LN52@set_compon
$LN23@set_compon:

; 2968 :         {
; 2969 :           for (n=0; n < num_output_comps; n++)

	test	ecx, ecx
	jle	SHORT $LN9@set_compon
	lea	eax, DWORD PTR [esi+153]
	mov	edx, ecx
	npad	9
$LL10@set_compon:

; 2970 :             comps[n].is_of_interest = false;

	mov	BYTE PTR [eax], 0
	lea	eax, DWORD PTR [eax+188]
	sub	edx, 1
	jne	SHORT $LL10@set_compon
$LN9@set_compon:

; 2971 :           for (n=0; n < num_components_of_interest; n++)

	xor	edx, edx
	test	edi, edi
	jle	SHORT $LN52@set_compon
$LL13@set_compon:

; 2972 :             {
; 2973 :               int idx = components_of_interest[n];

	mov	eax, DWORD PTR [ebx+edx*4]

; 2974 :               if ((idx >= 0) && (idx < num_output_comps))

	test	eax, eax
	js	SHORT $LN11@set_compon
	cmp	eax, ecx
	jge	SHORT $LN11@set_compon

; 2975 :                 comps[idx].is_of_interest = true;

	imul	eax, eax, 188
	mov	BYTE PTR [eax+esi+153], 1
$LN11@set_compon:

; 2971 :           for (n=0; n < num_components_of_interest; n++)

	inc	edx
	cmp	edx, edi
	jl	SHORT $LL13@set_compon
$LN52@set_compon:
	mov	ebx, DWORD PTR _this$1$[ebp]
$LN54@set_compon:
	pop	edi
	pop	esi
$LN12@set_compon:

; 2976 :             }
; 2977 :         }
; 2978 :     }
; 2979 : 
; 2980 :   for (int n=0; n < state->num_components; n++)

	mov	eax, DWORD PTR [ebx]
	xor	ecx, ecx
	cmp	DWORD PTR [eax+128], ecx
	jle	SHORT $LN15@set_compon
	xor	edx, edx
	npad	11
$LL16@set_compon:

; 2981 :     state->comps[n].G_tc_restricted = -1.0F; // Have to regenerate if needed

	mov	eax, DWORD PTR [eax+208]
	lea	edx, DWORD PTR [edx+188]
	inc	ecx
	mov	DWORD PTR [eax+edx-64], -1082130432	; bf800000H
	mov	eax, DWORD PTR [ebx]
	cmp	ecx, DWORD PTR [eax+128]
	jl	SHORT $LL16@set_compon
$LN15@set_compon:
	pop	ebx

; 2982 : }

	mov	esp, ebp
	pop	ebp
	ret	8
?set_components_of_interest@kdu_tile@@QAEXHPBH@Z ENDP	; kdu_tile::set_components_of_interest
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_ycc@kdu_tile@@QAE_NXZ
_TEXT	SEGMENT
?get_ycc@kdu_tile@@QAE_NXZ PROC				; kdu_tile::get_ycc, COMDAT
; _this$ = ecx

; 2913 :   if ((!state->use_ycc) || (state->num_components < 3))

	mov	edx, DWORD PTR [ecx]
	cmp	BYTE PTR [edx+226], 0
	je	SHORT $LN9@get_ycc
	cmp	DWORD PTR [edx+128], 3
	jl	SHORT $LN9@get_ycc

; 2918 :     if (!state->comps[c].enabled)

	push	esi
	mov	esi, DWORD PTR [edx+208]
	xor	ecx, ecx
	lea	eax, DWORD PTR [esi+152]
$LL4@get_ycc:
	cmp	BYTE PTR [eax], 0
	je	SHORT $LN16@get_ycc

; 2915 : 
; 2916 :   int c;
; 2917 :   for (c=0; c < 3; c++)

	inc	ecx
	add	eax, 188				; 000000bcH
	cmp	ecx, 3
	jl	SHORT $LL4@get_ycc

; 2920 : 
; 2921 :   kd_codestream *cs = state->codestream;

	mov	eax, DWORD PTR [edx]

; 2922 :   if (cs->component_access_mode == KDU_WANT_CODESTREAM_COMPONENTS)

	cmp	DWORD PTR [eax+128], 1
	jne	SHORT $LN6@get_ycc

; 2924 :       {
; 2925 :         int apparent_idx = cs->comp_info[c].apparent_idx;

	mov	edx, DWORD PTR [eax+256]
	xor	ecx, ecx
	add	edx, 88					; 00000058H
	npad	7
$LL7@get_ycc:

; 2926 :         assert(apparent_idx >= 0);
; 2927 :         if (!state->comps[apparent_idx].is_of_interest)

	imul	eax, DWORD PTR [edx], 188
	cmp	BYTE PTR [eax+esi+153], 0
	je	SHORT $LN16@get_ycc

; 2923 :     for (c=0; c < 3; c++)

	inc	ecx
	add	edx, 96					; 00000060H
	cmp	ecx, 3
	jl	SHORT $LL7@get_ycc
$LN6@get_ycc:

; 2928 :           return false;
; 2929 :       }
; 2930 : 
; 2931 :   return true;

	mov	al, 1
	pop	esi

; 2932 : }

	ret	0
$LN16@get_ycc:

; 2919 :       return false;

	xor	al, al
	pop	esi

; 2932 : }

	ret	0
$LN9@get_ycc:

; 2914 :     return false;

	xor	al, al

; 2932 : }

	ret	0
?get_ycc@kdu_tile@@QAE_NXZ ENDP				; kdu_tile::get_ycc
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_tile_idx@kdu_tile@@QAE?AUkdu_coords@@XZ
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
?get_tile_idx@kdu_tile@@QAE?AUkdu_coords@@XZ PROC	; kdu_tile::get_tile_idx, COMDAT
; _this$ = ecx

; 2899 : {

	push	ebp
	mov	ebp, esp

; 2900 :   kdu_coords idx = state->t_idx;

	mov	ecx, DWORD PTR [ecx]
	mov	edx, DWORD PTR ___$ReturnUdt$[ebp]
	push	ebx
	mov	eax, DWORD PTR [ecx+8]
	mov	DWORD PTR [edx], eax
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [edx+4], eax

; 2901 :   kd_codestream *cs = state->codestream;

	mov	eax, DWORD PTR [ecx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 275  :         if (transp) transpose();

	cmp	BYTE PTR [eax+329], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2902 :   idx.to_apparent(cs->transpose,cs->vflip,cs->hflip);

	mov	bl, BYTE PTR [eax+331]
	mov	bh, BYTE PTR [eax+330]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 275  :         if (transp) transpose();

	je	SHORT $LN4@get_tile_i

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	ecx, DWORD PTR [edx]
	mov	eax, DWORD PTR [edx+4]
	mov	DWORD PTR [edx], eax
	mov	DWORD PTR [edx+4], ecx
$LN4@get_tile_i:

; 276  :         x = (hflip)?(-x):x;

	mov	eax, DWORD PTR [edx+4]
	test	bl, bl
	je	SHORT $LN7@get_tile_i
	neg	eax
$LN7@get_tile_i:

; 277  :         y = (vflip)?(-y):y;

	test	bh, bh
	mov	DWORD PTR [edx+4], eax
	pop	ebx
	je	SHORT $LN8@get_tile_i
	mov	ecx, DWORD PTR [edx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2903 :   return idx;

	mov	eax, edx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 277  :         y = (vflip)?(-y):y;

	neg	ecx
	mov	DWORD PTR [edx], ecx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2904 : }

	pop	ebp
	ret	4
$LN8@get_tile_i:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 277  :         y = (vflip)?(-y):y;

	mov	eax, DWORD PTR [edx]
	mov	DWORD PTR [edx], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2903 :   return idx;

	mov	eax, edx

; 2904 : }

	pop	ebp
	ret	4
?get_tile_idx@kdu_tile@@QAE?AUkdu_coords@@XZ ENDP	; kdu_tile::get_tile_idx
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?get_tnum@kdu_tile@@QAEHXZ
_TEXT	SEGMENT
?get_tnum@kdu_tile@@QAEHXZ PROC				; kdu_tile::get_tnum, COMDAT
; _this$ = ecx

; 2890 :   return state->t_num;

	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax+4]

; 2891 : }

	ret	0
?get_tnum@kdu_tile@@QAEHXZ ENDP				; kdu_tile::get_tnum
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?close@kdu_tile@@QAEXPAVkdu_thread_env@@@Z
_TEXT	SEGMENT
_this$1$ = -40						; size = 4
_tc$1$ = -36						; size = 4
_offset$2$ = -32					; size = 4
_offset_idx$1$ = -28					; size = 4
tv770 = -24						; size = 4
_c$1$ = -20						; size = 4
tv771 = -16						; size = 4
_r$1$ = -12						; size = 4
_idx$1$ = -8						; size = 4
_offset$1$ = -4						; size = 4
$T1 = 8							; size = 4
_env$ = 8						; size = 4
?close@kdu_tile@@QAEXPAVkdu_thread_env@@@Z PROC		; kdu_tile::close, COMDAT
; _this$ = ecx

; 2822 : {

	push	ebp
	mov	ebp, esp
	sub	esp, 40					; 00000028H
	push	ebx
	push	esi
	push	edi

; 2823 :   if (env != NULL)

	mov	edi, DWORD PTR _env$[ebp]
	mov	ebx, ecx
	mov	DWORD PTR _this$1$[ebp], ebx
	test	edi, edi
	je	SHORT $LN30@close
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [edi+20]
	mov	esi, DWORD PTR [edi+28]
	cmp	BYTE PTR [eax], 0
	jne	$LN103@close
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [esi]
	test	eax, eax
	je	SHORT $LN33@close
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN33@close:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [esi+4], edi
$LN30@close:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2825 :   if (state->is_open)

	mov	eax, DWORD PTR [ebx]
	cmp	BYTE PTR [eax+229], 0
	je	$LN15@close

; 2826 :     state->codestream->num_open_tiles--;

	mov	eax, DWORD PTR [eax]
	dec	DWORD PTR [eax+204]

; 2831 :         env->release_lock(KD_THREADLOCK_GENERAL);
; 2832 :       return; // Avoid catastrophic problems in release mode
; 2833 :     }
; 2834 :   state->is_open = false;

	mov	eax, DWORD PTR [ebx]
	mov	BYTE PTR [eax+229], 0

; 2835 :   assert(!state->closed);
; 2836 :   if (state->codestream->in != NULL)

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx]
	cmp	DWORD PTR [eax+4], 0
	je	$LN3@close

; 2837 :     { // Release all open precincts which lie in the current region of interest
; 2838 :       for (int c=0; c < state->num_components; c++)

	xor	esi, esi
	mov	DWORD PTR _c$1$[ebp], esi
	cmp	DWORD PTR [ecx+128], esi
	jle	$LN3@close
	xor	ecx, ecx
	mov	DWORD PTR tv770[ebp], ecx
	npad	6
$LL4@close:

; 2839 :         {
; 2840 :           kd_tile_comp *tc = state->comps + c;

	mov	eax, DWORD PTR [ebx]
	mov	edx, DWORD PTR [eax+208]
	add	edx, ecx

; 2841 :           for (int r=0; r <= tc->dwt_levels; r++)

	xor	ecx, ecx
	mov	DWORD PTR _tc$1$[ebp], edx
	mov	DWORD PTR _r$1$[ebp], ecx
	cmp	DWORD PTR [edx+56], ecx
	jl	$LN2@close

; 2839 :         {
; 2840 :           kd_tile_comp *tc = state->comps + c;

	xor	eax, eax
	mov	DWORD PTR tv771[ebp], eax
$LL7@close:

; 2843 :               kd_resolution *res = tc->resolutions + r;

	mov	edi, DWORD PTR [edx+144]

; 2849 :               for (idx.y=0; idx.y < res->region_indices.size.y; idx.y++)

	xor	ebx, ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	edx, DWORD PTR [edi+eax+156]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2843 :               kd_resolution *res = tc->resolutions + r;

	add	edi, eax

; 2849 :               for (idx.y=0; idx.y < res->region_indices.size.y; idx.y++)

	mov	DWORD PTR _idx$1$[ebp], ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	mov	eax, DWORD PTR [edi+152]
	sub	edx, DWORD PTR [edi+140]
	sub	eax, DWORD PTR [edi+136]
	mov	DWORD PTR _offset$1$[ebp], edx
	mov	DWORD PTR _offset$2$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2849 :               for (idx.y=0; idx.y < res->region_indices.size.y; idx.y++)

	cmp	DWORD PTR [edi+160], ebx
	jle	$LN5@close
	npad	8
$LL10@close:

; 2850 :                 for (idx.x=0; idx.x < res->region_indices.size.x; idx.x++)

	xor	esi, esi
	cmp	DWORD PTR [edi+164], esi
	jle	$LN8@close
	add	eax, ebx
	mov	DWORD PTR _offset_idx$1$[ebp], eax
	mov	ebx, eax
	npad	11
$LL13@close:

; 2851 :                   {
; 2852 :                     offset_idx = idx + offset;
; 2853 :                     ref = res->precinct_refs + offset_idx.x +

	mov	ecx, DWORD PTR [edi+148]
	mov	eax, DWORD PTR [edi+180]
	imul	ecx, ebx
	add	ecx, edx
	add	ecx, esi
	lea	ecx, DWORD PTR [eax+ecx*8]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 3076 :       { return (state & 1)?NULL:((kd_precinct *) _kdu_long_to_addr(state)); }

	mov	eax, DWORD PTR [ecx]
	and	eax, 1
	or	eax, 0
	jne	SHORT $LN11@close
	mov	eax, DWORD PTR [ecx]
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2856 :                     if (precinct != NULL)

	test	eax, eax
	je	SHORT $LN11@close
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 4151 :         flags |= KD_PFLAG_RELEASED;

	or	DWORD PTR [eax+8], 16			; 00000010H
	mov	ecx, DWORD PTR [eax+8]
	mov	DWORD PTR [eax+24], 0

; 4152 :           // released = true;
; 4153 :         if ((flags & KD_PFLAG_ADDRESSABLE) ||

	test	cl, 8
	jne	SHORT $LN60@close
	test	cl, 4
	je	SHORT $LN11@close
	mov	ecx, DWORD PTR [eax]
	mov	ecx, DWORD PTR [ecx]
	cmp	BYTE PTR [ecx+337], 0
	jne	SHORT $LN11@close
$LN60@close:

; 4154 :             ((flags & KD_PFLAG_DESEQUENCED) &&
; 4155 :                 // if (addressable ||
; 4156 :                 //     (desequenced &&
; 4157 :              !resolution->codestream->persistent))
; 4158 :           ref->release(); // May unload us from memory!

	mov	edx, DWORD PTR [eax+4]

; 4159 :       }
; 4160 :     void finished_desequencing()
; 4161 :       /* Called once we can be sure that no more packets will be available
; 4162 :          for this precinct.  In practice, the function is called when the
; 4163 :          last packet has been desequenced or when the containing tile has
; 4164 :          been completely read.  If no packets at all have been desequenced for
; 4165 :          the precinct when this function is called (must have been invoked
; 4166 :          from within `kd_tile::finished_reading'), the precinct is marked
; 4167 :          as addressable, with an address of 0.  This is because it is safe
; 4168 :          to unload such a precinct and then reload it again regardless of
; 4169 :          the services offered by the compressed data source -- there is no
; 4170 :          data actually available from the compressed source for the
; 4171 :          precinct anyway, so reloading is a no-op.
; 4172 :             It should be noted that this function may unload the precinct
; 4173 :          from memory if it is determined that all code-blocks in the
; 4174 :          region of interest (there may be none) have already been consumed. */
; 4175 :       {
; 4176 :         if (flags & KD_PFLAG_DESEQUENCED)
; 4177 :           return;
; 4178 :         flags |= KD_PFLAG_DESEQUENCED;
; 4179 :           // desequenced = true;
; 4180 :         if (next_layer_idx == 0)
; 4181 :           {
; 4182 :             flags |= KD_PFLAG_ADDRESSABLE;
; 4183 :               // addressable = true;
; 4184 :             unique_address = 0;
; 4185 :           }
; 4186 :         if (num_outstanding_blocks == 0)
; 4187 :           release();
; 4188 :       }
; 4189 :     bool desequence_packet()
; 4190 :       /* This function should be called when a non-NULL `kd_precinct_ref'
; 4191 :          pointer is returned by `kd_packet_sequencer::next_in_sequence' and
; 4192 :          its `kd_precinct_ref::is_sequenced' function returns false.
; 4193 :          The function invokes `read_packet' and, if successful, increments
; 4194 :          the precinct's `next_layer_idx' field and the containing tile's
; 4195 :          `num_sequenced_packets' field.
; 4196 :             The function returns false if `read_packet' returns false,
; 4197 :          in which case, more tile-parts must be read (if there are any) to
; 4198 :          recover the information required to desequence the packet.
; 4199 :             Before returning true, the function checks to see whether all
; 4200 :          packets for the tile have been sequenced.  If so, the tile's
; 4201 :          `finished_reading' function is called. */
; 4202 :       {
; 4203 :         kd_tile *tile = resolution->tile_comp->tile;
; 4204 :         assert(!(flags & (KD_PFLAG_DESEQUENCED | KD_PFLAG_ADDRESSABLE)));
; 4205 :         if (!read_packet()) return false;
; 4206 :         next_layer_idx++;
; 4207 :         if (next_layer_idx == tile->num_layers)
; 4208 :           finished_desequencing();
; 4209 :         tile->next_input_packet_num++;
; 4210 :         if ((flags & KD_PFLAG_RELEVANT) &&
; 4211 :             (next_layer_idx <= tile->max_relevant_layers))
; 4212 :           {
; 4213 :             tile->sequenced_relevant_packets++;
; 4214 :             if (tile->sequenced_relevant_packets==tile->max_relevant_packets)
; 4215 :               tile->finished_reading();
; 4216 :           }
; 4217 :         return true;
; 4218 :       }
; 4219 :     void load_required_packets()
; 4220 :       /* If the precinct is addressable, this function uses its
; 4221 :          `unique_address' to position the compressed data source at the
; 4222 :          beginning of the precinct's first packet; it then loads all required
; 4223 :          packets from the compressed source.  Otherwise, the function does
; 4224 :          nothing at all -- reading is presumed to have occurred during packet
; 4225 :          desequencing. */
; 4226 :       {
; 4227 :         if ((!(flags & KD_PFLAG_ADDRESSABLE)) ||
; 4228 :             (unique_address == 0) || (num_packets_read != 0))
; 4229 :           return;
; 4230 :         assert((flags & KD_PFLAG_DESEQUENCED) &&
; 4231 :                (next_layer_idx >= required_layers));
; 4232 :         resolution->codestream->in->seek(unique_address);
; 4233 :         while (num_packets_read < required_layers)
; 4234 :           if (!read_packet())
; 4235 :             break;
; 4236 :       }
; 4237 :     kdu_long simulate_packet(kdu_long &header_bytes,
; 4238 :                              int layer_idx, kdu_uint16 slope_threshold,
; 4239 :                              bool finalize_layer, bool last_layer,
; 4240 :                              kdu_long max_bytes=KDU_LONG_HUGE,
; 4241 :                              bool trim_to_limit=false);
; 4242 :       /* Implements the functionality of `kd_codestream::simulate_output'
; 4243 :          for a single precinct.  Note that the total number of packet bytes
; 4244 :          is left behind in the internal `layer_bytes' array.  This allows the
; 4245 :          determination of tile-part length fields later on when we come to
; 4246 :          construct the code-stream.  The function returns this total number
; 4247 :          of bytes.  It also returns the number of packet header bytes via
; 4248 :          `header_bytes' (the function return value includes the cost of these
; 4249 :          header bytes).
; 4250 :             If the `max_bytes' limit is exceeded, the function may return
; 4251 :          prematurely, without having completed the simulation.  This is
; 4252 :          unacceptable when finalizing a layer, so you must be sure that
; 4253 :          `max_bytes' is sufficient in that case.
; 4254 :             If `trim_to_limit' is true, `finalize_layer' and `last_layer'
; 4255 :          must also both be true.  The function then trims away all coding
; 4256 :          passes from the precinct's code-blocks which are associated with
; 4257 :          slope values of `slope_threshold'+1 or less, until the limit
; 4258 :          associated with `max_bytes' is satisfied.  This functionality is
; 4259 :          used to implement the `sloppy_bytes' capabilities advertised by the
; 4260 :          `kd_codestream::simulate_output' function. */
; 4261 :     kdu_long write_packet(kdu_uint16 slope_threshold, bool empty_packet=false);
; 4262 :       /* Writes out the next packet for this precinct, using the supplied
; 4263 :          distortion-length slope threshold.  Increments the `next_layer_idx'
; 4264 :          field as well as the containing tile's `num_sequenced_packets'
; 4265 :          field when done.  If `empty_packet' is true, an empty packet should
; 4266 :          be issued, having a length of 1 byte, plus the length of any required
; 4267 :          EPH marker (no SOP marker will be attached to empty packets).  The
; 4268 :          function returns the total number of bytes output for the packet. */
; 4269 :   private: // Member functions
; 4270 :     bool read_packet();
; 4271 :       /* Reads a new layer of this precinct sequentially from the
; 4272 :          compressed data source, incrementing the `num_packets_read' member.
; 4273 :          Note that packet reading may be interleaved with acesses to the
; 4274 :          precinct's code-blocks for various reasons.  For example, we
; 4275 :          may initially open a tile with only a limited number of required
; 4276 :          layers, using its code-block data to decompress an approximate
; 4277 :          representation of the image.  We may then find that the additional
; 4278 :          packets need to be loaded in order to advance to other precincts
; 4279 :          in the code-stream.
; 4280 :             The function returns false if an SOT marker (or an EOC marker) is
; 4281 :          encountered.  Note that when an SOT marker is encountered, its
; 4282 :          segment is fully read into the codestream marker service and the
; 4283 :          precinct's tile must be active (otherwise an error message will be
; 4284 :          generated).  Before returning false in this way, the function sets
; 4285 :          the `active_tile' pointer in the codestream object to NULL.  The
; 4286 :          caller may determine the cause of failure by invoking the codestream
; 4287 :          marker service's `get_code' function, which will return one of SOT,
; 4288 :          EOC or 0, where 0 occurs only if the code-stream has been
; 4289 :          exhausted. */
; 4290 :     bool handle_corrupt_packet();
; 4291 :       /* This function implements alternate processing for the `read_packet'
; 4292 :          function in the event that a packet is found to be corrupt.  It is
; 4293 :          called whenever packet corruption is detected, including when the
; 4294 :          precinct is known to have had previously corrupt packets. The function
; 4295 :          manipulates the containing tile's `skipping_to_sop' and
; 4296 :          `next_sop_sequence_num' fields, advancing to the next SOP or SOT
; 4297 :          marker if necessary (the function may be called after detecting an
; 4298 :          SOP marker already, whose sequence number is not as expected).  If
; 4299 :          an SOT marker is encountered, the function renders the current tile
; 4300 :          inactive and returns false (this is the behaviour expected of
; 4301 :          `read_packet').  Otherwise, it updates the precinct and tile state to
; 4302 :          identify the packet as having been read. */
; 4303 :   public: // Public Links and Identification
; 4304 :     kd_resolution *resolution;
; 4305 :     kd_precinct_ref *ref; // Element of `resolution->precinct_refs' array
; 4306 : 
; 4307 :   public: // Mode flags used for decompression and/or interchange
; 4308 :     int flags; // The following flags are defined.
; 4309 :        // KD_PFLAG_GENERATING -- after 1'st call to `kd_precinct::get_packets'
; 4310 :        // KD_PFLAG_CORRUPTED -- if error occurred during packet reading
; 4311 :        // KD_PFLAG_DESEQUENCED -- if all packets have been desequenced
; 4312 :        // KD_PFLAG_ADDRESSABLE -- if seekable, cached or used for interchange
; 4313 :        // KD_PFLAG_RELEASED -- if `activate' must be called to revive state
; 4314 :        // KD_PFLAG_INACTIVE -- if resides on `kd_precict_server's inactive list
; 4315 :        // KD_PFLAG_RELEVANT -- always true if codestream is for non-persistent
; 4316 :        //     input; otherwise, true only if precinct belongs to the relevant
; 4317 :        //     set of precincts of a relevant tile-component-resolution
; 4318 :        // KD_PFLAG_SIGNIFICANT -- if any code-block bytes have been generated
; 4319 :        //     by `kdu_precinct::size_packets' or `kdu_precinct::get_packets'
; 4320 :        // KD_PFLAG_PARSED -- if the precinct was parsed previously and then
; 4321 :        //     unloaded; prevents multiple accumulation of packet length stats
; 4322 :   public: // State variables
; 4323 :     int required_layers; /* Actual number of layers for output codestream;
; 4324 :                 max apparent layers for input or interchange codestream. */
; 4325 :     int next_layer_idx; // Next layer to be sequenced or generated.
; 4326 :     union { // First field used for input; second interchange; third for output
; 4327 :         int num_packets_read; // Incremented when packets read or interchanged
; 4328 :         int cumulative_bytes; // Size of all packets generated so far.
; 4329 :         int saved_next_layer_idx; // Used by "kd_packet_sequencer::save_state"
; 4330 :       };
; 4331 : 
; 4332 :   public: // Activation state variables
; 4333 :     int num_outstanding_blocks; // See notes below.
; 4334 :     union { // First field used only in reading; second only in writing.
; 4335 :         kdu_long unique_address; // See below
; 4336 :         kdu_long *packet_bytes; // Lengths generated during simulated output
; 4337 :       };
; 4338 :   public: // code-block containers
; 4339 :     kd_precinct_band *subbands; // In practice, this member points into the
; 4340 :        // same block of memory which is allocated to hold the precinct so
; 4341 :        // as to encourage memory locality and allow for manipulation of all
; 4342 :        // aspects of a precinct, including all of its code-blocks, via a
; 4343 :        // single heap block.  Note that the number of entries in this array
; 4344 :        // is given by `resolution->num_subbands'.
; 4345 : 
; 4346 :   public: // See below for an explanation of these links
; 4347 :     kd_precinct *next; // Next in free, inactive or generated list
; 4348 :     kd_precinct *prev; // Previous in inactive or generated list
; 4349 :     kd_precinct_size_class *size_class; // For correctly releasing storage
; 4350 :   };
; 4351 :   /* Notes:
; 4352 :         `unique_address' is valid if and only if the precinct is marked as
; 4353 :      addressable, meaning that the precinct has a unique address from which it
; 4354 :      may be loaded (for input codestream objects) or identified (for
; 4355 :      interchange codestream objects).  If addressable, the `unique_address'
; 4356 :      will be 0 if and only if the precinct is known to be empty, meaning that
; 4357 :      reloading the precinct does not require any actual data transfers from a
; 4358 :      compressed data source.
; 4359 :         Except as described above, when used with seekable compressed data
; 4360 :      sources, the `unique_address' member holds a positive quantity which
; 4361 :      identifies an offset into the code-stream at which the precinct's
; 4362 :      packets may be found.  In the case of cached sources (those advertising
; 4363 :      the KDU_SOURCE_CAP_CACHED capability) or codestream objects created for
; 4364 :      interchange (no compressed data source or target), the `unique_address'
; 4365 :      will be negative and -(1+`unique_address') is the precinct's unique
; 4366 :      identifier, as passed to the `kdu_compressed_source::set_precinct_scope'
; 4367 :      function, or returned by the `kdu_precinct::get_unique_id' function.
; 4368 :         The `num_outstanding_blocks' member is used to monitor the number of
; 4369 :      code-blocks from the application's region of interest which have still
; 4370 :      to be consumed (input codestreams) or the number of code-blocks which
; 4371 :      have still to be written in order to complete the precinct (output
; 4372 :      and interchange codestreams).
; 4373 :         The `next' and `prev' links may be used to manage the precinct's
; 4374 :      location in one of three different lists.  The first list is the
; 4375 :      singly-linked free list maintained by `kd_precinct_size_class', from
; 4376 :      which the `kd_precinct_server' object re-issues previously released
; 4377 :      resources.
; 4378 :         The second list on which this structure may find itself is the
; 4379 :      doubly-linked list of currently inactive precincts, which is managed by
; 4380 :      the `kd_precinct_server' object.  Precincts which find themselves on this
; 4381 :      list have been released, but their resources have not yet been recycled.
; 4382 :      They may be successfully re-activated, if their resources have not been
; 4383 :      re-issued to another precinct.  Precincts on this list may be identified
; 4384 :      by the `inactive' flag.  Every inactive precinct necessarily also has
; 4385 :      its `released' member set to true, but the converse is not necessarily
; 4386 :      true.  This is because precincts which have been partially parsed
; 4387 :      in a context for which they were not directly relevant, will be marked
; 4388 :      as released, even though they are not inactive.
; 4389 :         The third list on which this structure may find itself is the
; 4390 :      doubly-linked list of generated precincts managed by the
; 4391 :      `kd_global_rescomp' structure.  This list contains all precincts
; 4392 :      from a given resolution of a given image component, across all tiles,
; 4393 :      which have been fully generated, but not yet flushed out to the
; 4394 :      code-stream.   The list is used to manage incremental rate allocation
; 4395 :      when processing large images.  Elements on this list have not yet
; 4396 :      been closed. */
; 4397 : 
; 4398 : /*****************************************************************************/
; 4399 : /*                         kd_precinct_size_class                            */
; 4400 : /*****************************************************************************/
; 4401 : 
; 4402 :   /* For an explanation of the role played by precinct size classes, see
; 4403 :      the discussion appearing below the declaration of `kd_precinct_server'. */
; 4404 : 
; 4405 : class kd_precinct_size_class {
; 4406 :   public: // Member functions
; 4407 :     kd_precinct_size_class(int max_blocks, int num_subbands,
; 4408 :                            kd_precinct_server *server,
; 4409 :                            kd_buf_server *buf_server)
; 4410 :       {
; 4411 :         this->max_blocks = max_blocks;
; 4412 :         this->num_subbands = num_subbands;
; 4413 :         this->server = server;  this->buf_server = buf_server;
; 4414 :         total_precincts = 0; free_list = NULL; next = NULL;
; 4415 :         alloc_bytes = (int) sizeof(kd_precinct);
; 4416 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4417 :         alloc_bytes += num_subbands * (int) sizeof(kd_precinct_band);
; 4418 :         alloc_bytes += (-alloc_bytes) & 7; // Round up to 8-byte boundary
; 4419 :         alloc_bytes += 4 + max_blocks * (int) sizeof(kd_block);
; 4420 :       }
; 4421 :     ~kd_precinct_size_class()
; 4422 :       { kd_precinct *tmp;
; 4423 :         while ((tmp=free_list) != NULL)
; 4424 :           { free_list = tmp->next; free(tmp); total_precincts--; }
; 4425 :         assert(total_precincts == 0);
; 4426 :       }
; 4427 :     kd_precinct *get()
; 4428 :       {
; 4429 :         if (free_list == NULL)
; 4430 :           augment_free_list();
; 4431 :         kd_precinct *result = free_list; free_list = free_list->next;
; 4432 :         result->next = result->prev = NULL;
; 4433 :         buf_server->augment_structure_bytes(alloc_bytes);
; 4434 :         return result;
; 4435 :       }
; 4436 :     void release(kd_precinct *precinct)
; 4437 :       {
; 4438 :         if (precinct->flags & KD_PFLAG_INACTIVE)
; 4439 :           withdraw_from_inactive_list(precinct);
; 4440 :         precinct->next = free_list;
; 4441 :         free_list = precinct;
; 4442 :         buf_server->augment_structure_bytes(-alloc_bytes);
; 4443 :       }
; 4444 :     void move_to_inactive_list(kd_precinct *precinct);
; 4445 :     void withdraw_from_inactive_list(kd_precinct *precinct);
; 4446 :       /* Used to move precincts onto or off the inactive list maintained
; 4447 :          by the `kd_precinct_server' object to which the present object
; 4448 :          belongs. */
; 4449 :   private: // Helper function
; 4450 :     void augment_free_list();
; 4451 :   private: // Data
; 4452 :     friend class kd_precinct_server;
; 4453 :     kd_precinct_server *server;
; 4454 :     kd_buf_server *buf_server;
; 4455 :     int max_blocks;
; 4456 :     int num_subbands;
; 4457 :     int alloc_bytes; // Num bytes to allocate per precinct.
; 4458 :     kdu_long total_precincts; // Number of precincts allocated with this size
; 4459 :     kd_precinct *free_list; // List of precincts which have been released
; 4460 :     kd_precinct_size_class *next; // Next size class
; 4461 :   };
; 4462 : 
; 4463 : /*****************************************************************************/
; 4464 : /*                           kd_precinct_server                              */
; 4465 : /*****************************************************************************/
; 4466 : 
; 4467 : class kd_precinct_server {
; 4468 :   public: // Member functions
; 4469 :     kd_precinct_server(kd_buf_server *buf_server)
; 4470 :       { size_classes = NULL; total_allocated_bytes = 0;
; 4471 :         inactive_head = inactive_tail = NULL; this->buf_server = buf_server; }
; 4472 :     ~kd_precinct_server()
; 4473 :       {
; 4474 :         kd_precinct_size_class *tmp;
; 4475 :         while ((tmp=size_classes) != NULL)
; 4476 :           { size_classes = tmp->next; delete tmp; }
; 4477 :       }
; 4478 :     kd_precinct *get(int max_blocks, int num_subbands);
; 4479 :     kdu_long get_total_allocated_bytes()
; 4480 :       { return total_allocated_bytes; }
; 4481 :   private: // Data
; 4482 :     friend class kd_precinct_size_class;
; 4483 :     kd_precinct_size_class *size_classes; // List of different size classes.
; 4484 :     kdu_long total_allocated_bytes;
; 4485 :     kd_precinct *inactive_head, *inactive_tail;
; 4486 :     kd_buf_server *buf_server; // Used to manage cacheing, as described below
; 4487 :   };
; 4488 :   /* Notes:
; 4489 :         This object is used to serve up empty precincts and to recycle their
; 4490 :      storage when they are no longer required.  Precinct memory blocks are
; 4491 :      organized into size classes, based on the maximum number of code-blocks
; 4492 :      and precinct-bands in the precinct, where these quantities are consistent
; 4493 :      for all precincts associated with any given `kd_resolution' object.  In
; 4494 :      many cases, it can happen that all precincts from the entire image have
; 4495 :      exactly the same size class.  This maximizes the potential for recycling
; 4496 :      precinct storage, since precincts may only be allocated from and
; 4497 :      recycled back to their own size class.  The reason for this dependence on
; 4498 :      size classes is that the block of memory associated with each precinct
; 4499 :      is large enough to accommodate all `max_blocks' code-blocks which might
; 4500 :      be required to populate the `kd_precinct_band::blocks' arrays and all
; 4501 :      precinct-bands which are required to populate the `kd_precinct::subbands'
; 4502 :      array.  This gets us out of having to maintain separate mechanisms
; 4503 :      to serve up code-block storage as a recyclable resource.  It also helps
; 4504 :      with memory localization.
; 4505 :         The object also manages a cacheing service for precincts and their
; 4506 :      data.  When precincts are released using `kd_precinct_ref::release',
; 4507 :      they are appended to a list of inactive precincts headed by
; 4508 :      `inactive_head' and concluded by `inactive_tail'.  The list is doubly
; 4509 :      linked via the `kd_precinct::next' and `kd_precinct::prev' members.  When
; 4510 :      a previously released precinct is opened using `kd_precinct_ref::open',
; 4511 :      it is removed from this list and its `kd_precinct::activate' function is
; 4512 :      called.  Note that the KD_PFLAG_RELEASED flag is not a reliable
; 4513 :      indicator of whether or not a precinct is on the inactive list, since
; 4514 :      precincts which have been released using `kd_precinct::release', but
; 4515 :      have not yet been completely desequenced (all packets have not yet been
; 4516 :      parsed from or located in the code-stream), will also have this flag
; 4517 :      set, but will not be on an inactive list.  The KD_PFLAG_INACTIVE
; 4518 :      flag should be used to determine whether or not a precinct is on the
; 4519 :      inactive list.
; 4520 :         When `kd_precinct_server::get' function is called, it queries the
; 4521 :      codestream object's `kd_buf_server' service to determine whether or not
; 4522 :      a cache threshold has been exceeded.  If so, it closes down precincts
; 4523 :      on the inactive list until the `kd_buf_server' object reports that
; 4524 :      sufficient resources are in hand. */
; 4525 : 
; 4526 : /*****************************************************************************/
; 4527 : /*                          kd_thread_block_state                            */
; 4528 : /*****************************************************************************/
; 4529 : 
; 4530 : struct kd_thread_block_state {
; 4531 :     kd_block block;
; 4532 :     kd_precinct *target_precinct;
; 4533 :     kd_block *target_block; // see below
; 4534 :   };
; 4535 :   /* An array of these structures is used to maintain information about
; 4536 :      processed code-blocks in thread-local storage, reflecting this information
; 4537 :      only every so often to the `kdu_codestream' machinery, so as to minimize
; 4538 :      thread blocking and cache coherency management overhead.  Each object of
; 4539 :      this class represents a single code-block, identified via the
; 4540 :      `target_precinct' and `target_block' members.
; 4541 :         If `target_precinct' is NULL, the record is empty.  Non-empty records
; 4542 :      may appear anywhere within the `outstanding_blocks' array in
; 4543 :      `kd_thread_env'. */
; 4544 : 
; 4545 : /*****************************************************************************/
; 4546 : /*                              kd_thread_env                                */
; 4547 : /*****************************************************************************/
; 4548 : 
; 4549 : #define KD_THREAD_MAX_OUTSTANDING_BLOCKS 8
; 4550 : 
; 4551 : class kd_thread_env {
; 4552 :   public: // Member functions
; 4553 :     kd_thread_env(kdu_thread_env *owner)
; 4554 :       {
; 4555 :         this->owner=owner;  buf_server.init(this);
; 4556 :         num_outstanding_blocks=0;  stats_codestream = NULL;
; 4557 :         memset(outstanding_blocks,0,
; 4558 :                sizeof(kd_thread_block_state)*KD_THREAD_MAX_OUTSTANDING_BLOCKS);
; 4559 :       }
; 4560 :     kd_thread_block_state *get_block_state(kd_codestream *cs,
; 4561 :                                            kd_precinct *precinct,
; 4562 :                                            kd_block *block)
; 4563 :       {
; 4564 :         if (num_outstanding_blocks == KD_THREAD_MAX_OUTSTANDING_BLOCKS)
; 4565 :           flush(true);
; 4566 :         kd_thread_block_state *scan=outstanding_blocks;
; 4567 :         for (int n=0; n < KD_THREAD_MAX_OUTSTANDING_BLOCKS; n++, scan++)
; 4568 :           if (scan->target_precinct == NULL)
; 4569 :             {
; 4570 :               num_outstanding_blocks++;
; 4571 :               scan->target_precinct=precinct;  scan->target_block=block;
; 4572 :               owner->have_outstanding_blocks = true;
; 4573 :               return scan;
; 4574 :             }
; 4575 :         return NULL; // Should not be possible!!
; 4576 :       }
; 4577 :     void update_stats(kdu_block *blk, kd_codestream *cs)
; 4578 :       { /* Called during encoding after each code-block of data has been
; 4579 :            generated, whenever coding statistics are being kept by the
; 4580 :            relevant codestream.  This function updates the internal coding
; 4581 :            statistics record managed by the `stats' member, which is
; 4582 :            reconciled against the underlying codestream only at appropriate
; 4583 :            intervals, so as to minimize thread blocking conditions. */
; 4584 :         if ((stats_codestream != cs) && (stats_codestream != NULL))
; 4585 :           {
; 4586 :             reconcile_stats();
; 4587 :             stats_codestream = cs;
; 4588 :           }
; 4589 :         stats.update_stats(blk);
; 4590 :       }
; 4591 :     void reconcile_stats();
; 4592 :       /* This function is used to reconcile the temporary information in
; 4593 :          the `stats' member with the coding statistics manager in the
; 4594 :          `kd_codestream' object referenced by the `stats_codestream' member.
; 4595 :          After reconciliation, the `stats' member will be empty and the
; 4596 :          `stats_codestream' member is reset to NULL so that we are free to
; 4597 :          accumulate statistics for a different codestream in the future.
; 4598 :          This function is invoked from `flush' and also if a call to
; 4599 :          `update_stats' specifies a different codestream to that for which
; 4600 :          coding statistics are currently being recorded in the `stats'
; 4601 :          member. */
; 4602 :     void flush(bool force_flush);
; 4603 :       /* Clears the `outstanding_blocks' queue and reconciles any outstanding
; 4604 :          `stats' information.  This function should not be called while
; 4605 :          holding any lock, since it typically needs to acquire its own lock or
; 4606 :          locks.
; 4607 :             If `force_flush' is false, the function may return without
; 4608 :          flushing anything, if it finds that the necessary mutex is already
; 4609 :          held by another thread.  This helps to keep threads alive for as long
; 4610 :          as possible.  A thread will typically try to flush its block queue
; 4611 :          each time it is augmented, once it starts getting close to full.
; 4612 :          A forced flush is required only once the queue becomes completely
; 4613 :          full -- this is performed automatically from within
; 4614 :          `get_block_state'. */
; 4615 :     void discard_all();
; 4616 :       /* This function is called from `kdu_thread_env::do_sync' or
; 4617 :          `kdu_thread_env::on_finished' if an exception has been handled
; 4618 :          by any thread in the working group.  It discards all processed
; 4619 :          code-blocks, returning any associated storage to the internal
; 4620 :          queue, being careful to do so in such a way as to avoid throwing
; 4621 :          further exceptions while acquiring locks. */
; 4622 :   private: // Padding
; 4623 :     kdu_byte _leadin[KDU_MAX_L2_CACHE_LINE];
; 4624 :   public: // Links
; 4625 :     kdu_thread_env *owner;
; 4626 :   public: // Public resources
; 4627 :     kdu_block block; // Thread-local code-block storage
; 4628 :     kd_compressed_stats stats; // Used to temporarily record statistics
; 4629 :     kd_codestream *stats_codestream; // Codestream to which statistics belong
; 4630 :     kd_thread_buf_server buf_server;
; 4631 :     int num_outstanding_blocks;
; 4632 :   private: // Private resources
; 4633 :     kd_thread_block_state outstanding_blocks[KD_THREAD_MAX_OUTSTANDING_BLOCKS];
; 4634 :   private: // Padding
; 4635 :     kdu_byte _trailer[KDU_MAX_L2_CACHE_LINE];
; 4636 :   };
; 4637 : 
; 4638 : 
; 4639 : /* ========================================================================= */
; 4640 : /*         Inlined Member Functions Delayed to Satisfy Dependencies          */
; 4641 : /* ========================================================================= */
; 4642 : 
; 4643 : inline void
; 4644 :   kd_thread_buf_server::set_codestream_buf_server(kd_buf_server *buf_server)
; 4645 : {
; 4646 :   if (buf_server != this->ultimate_buf_server)
; 4647 :     {
; 4648 :       env->owner->acquire_lock(KD_THREADLOCK_GENERAL);
; 4649 :       if (ultimate_buf_server != NULL)
; 4650 :         ultimate_buf_server->detach_thread_buf_server(this);
; 4651 :       if (buf_server != NULL)
; 4652 :         buf_server->attach_thread_buf_server(this);
; 4653 :       assert(buf_server == ultimate_buf_server);
; 4654 :       env->owner->release_lock(KD_THREADLOCK_GENERAL);
; 4655 :     }
; 4656 : }
; 4657 : 
; 4658 : inline bool
; 4659 :   kd_precinct_ref::is_desequenced()
; 4660 : {
; 4661 :   register kdu_long state_val = state;
; 4662 :   return ((state_val != 0) &&
; 4663 :           ((state_val & 1) ||
; 4664 :            (((kd_precinct *) _kdu_long_to_addr(state_val))->flags &
; 4665 :             KD_PFLAG_DESEQUENCED)));
; 4666 : }
; 4667 : 
; 4668 : inline void
; 4669 :   kd_precinct_ref::clear()
; 4670 : {
; 4671 :   if (state && !(state & 1))
; 4672 :     {
; 4673 :       kd_precinct *precinct = (kd_precinct *) _kdu_long_to_addr(state);
; 4674 :       precinct->ref = NULL; // Satisfy the test in `kd_precinct::closing'
; 4675 :       precinct->closing();
; 4676 :       precinct->size_class->release(precinct);
; 4677 :     }
; 4678 :   state = 0;
; 4679 : }
; 4680 : 
; 4681 : inline void
; 4682 :   kd_precinct_ref::close_and_reset()
; 4683 : {
; 4684 :   if (state & 1)
; 4685 :     {
; 4686 :       if (state != 3)
; 4687 :         state &= ~((kdu_long) 2);
; 4688 :     }
; 4689 :   else if (state != 0)
; 4690 :     {
; 4691 :       kd_precinct *prec = (kd_precinct *) _kdu_long_to_addr(state);
; 4692 :       if ((prec->flags & KD_PFLAG_PARSED)||(prec->num_packets_read > 0))
; 4693 :         {
; 4694 :           close();
; 4695 :           state &= ~((kdu_long) 2);
; 4696 :         }
; 4697 :     }
; 4698 : }
; 4699 : 
; 4700 : inline void
; 4701 :   kd_precinct_ref::release()
; 4702 : {
; 4703 :   kd_precinct *precinct = (kd_precinct *) _kdu_long_to_addr(state);

	mov	ecx, DWORD PTR [edx]

; 4704 :   assert((state != 0) && !(state & 1));
; 4705 :   if (precinct->flags & KD_PFLAG_INACTIVE)

	mov	eax, DWORD PTR [ecx+8]
	test	al, 32					; 00000020H
	jne	SHORT $LN99@close

; 4706 :     return; // Already on the inactive list.
; 4707 :   precinct->flags |= KD_PFLAG_RELEASED;

	or	eax, 16					; 00000010H
	mov	DWORD PTR [ecx+8], eax

; 4708 :     // precinct->released = true; // In case not already set.
; 4709 :   if ((precinct->flags & KD_PFLAG_ADDRESSABLE) &&
; 4710 :       (!precinct->resolution->codestream->cached) &&

	test	al, 8
	je	SHORT $LN64@close
	mov	eax, DWORD PTR [ecx]
	mov	eax, DWORD PTR [eax]
	cmp	BYTE PTR [eax+338], 0
	jne	SHORT $LN64@close
	mov	eax, DWORD PTR [ecx+20]
	test	eax, eax
	je	SHORT $LN66@close
	cmp	eax, DWORD PTR [ecx+16]
	jne	SHORT $LN64@close
$LN66@close:

; 4711 :       ((precinct->num_packets_read == 0) ||
; 4712 :        (precinct->num_packets_read == precinct->next_layer_idx)))
; 4713 :     precinct->size_class->move_to_inactive_list(precinct);

	push	ecx
	mov	ecx, DWORD PTR [ecx+52]
	call	?move_to_inactive_list@kd_precinct_size_class@@QAEXPAUkd_precinct@@@Z ; kd_precinct_size_class::move_to_inactive_list

; 4714 :   else

	jmp	SHORT $LN99@close
$LN64@close:

; 4715 :     close();

	mov	ecx, edx
	call	?close@kd_precinct_ref@@QAEXXZ		; kd_precinct_ref::close
$LN99@close:
	mov	edx, DWORD PTR _offset$1$[ebp]
$LN11@close:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2850 :                 for (idx.x=0; idx.x < res->region_indices.size.x; idx.x++)

	inc	esi
	cmp	esi, DWORD PTR [edi+164]
	jl	$LL13@close
	mov	ebx, DWORD PTR _idx$1$[ebp]
	mov	eax, DWORD PTR _offset$2$[ebp]
$LN8@close:

; 2849 :               for (idx.y=0; idx.y < res->region_indices.size.y; idx.y++)

	inc	ebx
	mov	DWORD PTR _idx$1$[ebp], ebx
	cmp	ebx, DWORD PTR [edi+160]
	jl	$LL10@close
	mov	ecx, DWORD PTR _r$1$[ebp]
$LN5@close:

; 2841 :           for (int r=0; r <= tc->dwt_levels; r++)

	mov	edx, DWORD PTR _tc$1$[ebp]
	inc	ecx
	mov	eax, DWORD PTR tv771[ebp]
	add	eax, 604				; 0000025cH
	mov	DWORD PTR _r$1$[ebp], ecx
	mov	DWORD PTR tv771[ebp], eax
	cmp	ecx, DWORD PTR [edx+56]
	jle	$LL7@close
	mov	ebx, DWORD PTR _this$1$[ebp]
	mov	esi, DWORD PTR _c$1$[ebp]
$LN2@close:

; 2837 :     { // Release all open precincts which lie in the current region of interest
; 2838 :       for (int c=0; c < state->num_components; c++)

	mov	eax, DWORD PTR [ebx]
	inc	esi
	mov	ecx, DWORD PTR tv770[ebp]
	add	ecx, 188				; 000000bcH
	mov	DWORD PTR _c$1$[ebp], esi
	mov	DWORD PTR tv770[ebp], ecx
	cmp	esi, DWORD PTR [eax+128]
	jl	$LL4@close
	mov	edi, DWORD PTR _env$[ebp]
$LN3@close:

; 2857 :                       precinct->release();
; 2858 :                   }
; 2859 :             }
; 2860 :         }
; 2861 :     }
; 2862 : 
; 2863 :   if ((!state->codestream->persistent) || state->empty_shell)

	mov	ecx, DWORD PTR [ebx]
	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+337], 0
	je	SHORT $LN21@close
	cmp	BYTE PTR [ecx+227], 0
	je	SHORT $LN22@close
$LN21@close:

; 2864 :     { // Note, codestreams created for interchange are considered persistent
; 2865 :       state->closed = true;

	mov	BYTE PTR [ecx+232], 1

; 2866 :       if ((((state->codestream->in != NULL) && state->exhausted) ||
; 2867 :            ((state->codestream->out != NULL) &&
; 2868 :             (state->sequenced_relevant_packets ==
; 2869 :              state->max_relevant_packets))) &&

	mov	ecx, DWORD PTR [ebx]
	mov	esi, DWORD PTR [ecx]
	cmp	DWORD PTR [esi+4], 0
	je	SHORT $LN24@close
	cmp	BYTE PTR [ecx+268], 0
	jne	SHORT $LN23@close
$LN24@close:
	cmp	DWORD PTR [esi+8], 0
	je	SHORT $LN22@close
	mov	eax, DWORD PTR [ecx+248]
	cdq
	cmp	eax, DWORD PTR [ecx+152]
	jne	SHORT $LN22@close
	cmp	edx, DWORD PTR [ecx+156]
	jne	SHORT $LN22@close
$LN23@close:
	cmp	BYTE PTR [esi+328], 0
	jne	SHORT $LN22@close

; 2870 :           !state->codestream->allow_restart)
; 2871 :         {
; 2872 :           state->release();

	call	?release@kd_tile@@QAEXXZ		; kd_tile::release

; 2873 :           state = NULL;

	mov	DWORD PTR [ebx], 0

; 2874 :         }
; 2875 :     }
; 2876 :   if (state != NULL)

	jmp	SHORT $LN74@close
$LN22@close:
	test	ecx, ecx
	je	SHORT $LN74@close
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed_local.h

; 2743 :         if ((!codestream->persistent) ||

	mov	eax, DWORD PTR [ecx]
	cmp	BYTE PTR [eax+337], 0
	je	SHORT $LN74@close
	cmp	DWORD PTR [eax+36], 0
	jne	SHORT $LN69@close
	cmp	BYTE PTR [eax+338], 0
	je	SHORT $LN74@close
$LN69@close:

; 2744 :             ((codestream->tpart_ptr_server==NULL) && !codestream->cached))
; 2745 :           { assert(!is_unloadable); return; }
; 2746 :         if (is_open || (this==codestream->active_tile))

	cmp	BYTE PTR [ecx+229], 0
	jne	SHORT $LN73@close
	cmp	ecx, DWORD PTR [eax+364]
	je	SHORT $LN73@close

; 2750 :           }
; 2751 :         else
; 2752 :           { // Should be on the unloadable list
; 2753 :             if (!is_unloadable)

	cmp	BYTE PTR [ecx+230], 0
	jne	SHORT $LN74@close

; 2754 :               add_to_unloadable_list();

	call	?add_to_unloadable_list@kd_tile@@AAEXXZ	; kd_tile::add_to_unloadable_list
	jmp	SHORT $LN74@close
$LN73@close:

; 2747 :           { // Should not be on the unloadable list
; 2748 :             if (is_unloadable)

	cmp	BYTE PTR [ecx+230], 0
	je	SHORT $LN74@close

; 2749 :               withdraw_from_unloadable_list();

	call	?withdraw_from_unloadable_list@kd_tile@@AAEXXZ ; kd_tile::withdraw_from_unloadable_list
$LN74@close:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2878 :   state = NULL; // Renders the interface impotent.

	mov	DWORD PTR [ebx], 0
$LN15@close:

; 2827 :   else
; 2828 :     {
; 2829 :       assert(0); // Should not happen; catch in debug mode
; 2830 :       if (env != NULL)

	test	edi, edi
	je	SHORT $LN40@close
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	mov	eax, DWORD PTR [edi+28]

; 1064 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder == this));
; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [eax+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [eax]
	test	eax, eax
	je	SHORT $LN40@close
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
$LN40@close:
	pop	edi
	pop	esi
	pop	ebx
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp

; 2881 : }

	mov	esp, ebp
	pop	ebp
	ret	4
$LN103@close:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN105@close:
$LN100@close:
	int	3
?close@kdu_tile@@QAEXPAVkdu_thread_env@@@Z ENDP		; kdu_tile::close
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?to_apparent@kdu_dims@@QAEX_N00@Z
_TEXT	SEGMENT
_transp$ = 8						; size = 1
_vflip$ = 12						; size = 1
_hflip$ = 16						; size = 1
?to_apparent@kdu_dims@@QAEX_N00@Z PROC			; kdu_dims::to_apparent, COMDAT
; _this$ = ecx

; 421  :     { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 422  :            Does the reverse of `kdu_from_apparent', assuming the same
; 423  :            values for `transp', `vflip' and `hflip' are supplied.
; 424  :       */
; 425  :       if (transp) transpose();

	cmp	BYTE PTR _transp$[ebp], 0
	push	esi
	mov	esi, ecx
	je	SHORT $LN2@to_apparen

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	eax, DWORD PTR [esi+12]
	mov	edx, DWORD PTR [esi+8]
	mov	DWORD PTR [esi+8], eax
	mov	DWORD PTR [esi+12], edx
	mov	ecx, DWORD PTR [esi]
	mov	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi], eax
	mov	DWORD PTR [esi+4], ecx
$LN2@to_apparen:

; 426  :       if (hflip) pos.x = -(pos.x+size.x-1);

	cmp	BYTE PTR _hflip$[ebp], 0
	mov	ecx, 1
	je	SHORT $LN3@to_apparen
	mov	eax, ecx
	sub	eax, DWORD PTR [esi+12]
	sub	eax, DWORD PTR [esi+4]
	mov	DWORD PTR [esi+4], eax
$LN3@to_apparen:

; 427  :       if (vflip) pos.y = -(pos.y+size.y-1);

	cmp	BYTE PTR _vflip$[ebp], 0
	je	SHORT $LN4@to_apparen
	sub	ecx, DWORD PTR [esi+8]
	sub	ecx, DWORD PTR [esi]
	mov	DWORD PTR [esi], ecx
$LN4@to_apparen:
	pop	esi

; 428  :     }

	pop	ebp
	ret	12					; 0000000cH
?to_apparent@kdu_dims@@QAEX_N00@Z ENDP			; kdu_dims::to_apparent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?is_empty@kdu_dims@@QAE_NXZ
_TEXT	SEGMENT
?is_empty@kdu_dims@@QAE_NXZ PROC			; kdu_dims::is_empty, COMDAT
; _this$ = ecx

; 385  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	cmp	DWORD PTR [ecx+12], 0
	jle	SHORT $LN3@is_empty
	cmp	DWORD PTR [ecx+8], 0
	jle	SHORT $LN3@is_empty
	xor	al, al
	ret	0
$LN3@is_empty:
	mov	al, 1
	ret	0
?is_empty@kdu_dims@@QAE_NXZ ENDP			; kdu_dims::is_empty
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??7kdu_dims@@QAE_NXZ
_TEXT	SEGMENT
??7kdu_dims@@QAE_NXZ PROC				; kdu_dims::operator!, COMDAT
; _this$ = ecx

; 380  :       { return ((size.x>0)&&(size.y>0))?false:true; }

	cmp	DWORD PTR [ecx+12], 0
	jle	SHORT $LN3@operator
	cmp	DWORD PTR [ecx+8], 0
	jle	SHORT $LN3@operator
	xor	al, al
	ret	0
$LN3@operator:
	mov	al, 1
	ret	0
??7kdu_dims@@QAE_NXZ ENDP				; kdu_dims::operator!
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?intersects@kdu_dims@@QAE_NAAU1@@Z
_TEXT	SEGMENT
tv192 = 8						; size = 4
_rhs$ = 8						; size = 4
?intersects@kdu_dims@@QAE_NAAU1@@Z PROC			; kdu_dims::intersects, COMDAT
; _this$ = ecx

; 362  :       {

	push	ebp
	mov	ebp, esp

; 363  :       /* [SYNOPSIS]
; 364  :            Checks whether or not the region represented by `rhs' has
; 365  :            a non-empty intersection with that represented by the current
; 366  :            object.
; 367  :          [RETURNS]
; 368  :            True if the intersection is non-empty.
; 369  :       */
; 370  :         if ((pos.x+size.x) <= rhs.pos.x) return false;

	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	push	ebx
	push	esi
	mov	esi, DWORD PTR [ecx+12]
	add	eax, esi
	cmp	eax, DWORD PTR [edx+4]
	jg	SHORT $LN2@intersects
	pop	esi
	xor	al, al
	pop	ebx

; 378  :       }

	pop	ebp
	ret	4
$LN2@intersects:

; 371  :         if ((pos.y+size.y) <= rhs.pos.y) return false;

	mov	eax, DWORD PTR [ecx]
	mov	ebx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv192[ebp], eax
	add	eax, ebx
	push	edi
	cmp	eax, DWORD PTR [edx]
	jle	SHORT $LN7@intersects

; 372  :         if (pos.x >= (rhs.pos.x+rhs.size.x)) return false;

	mov	eax, DWORD PTR [edx+4]
	mov	edi, DWORD PTR [edx+12]
	add	eax, edi
	cmp	DWORD PTR [ecx+4], eax
	jge	SHORT $LN7@intersects

; 373  :         if (pos.y >= (rhs.pos.y+rhs.size.y)) return false;

	mov	eax, DWORD PTR [edx]
	mov	ecx, DWORD PTR [edx+8]
	add	eax, ecx
	cmp	DWORD PTR tv192[ebp], eax
	jge	SHORT $LN7@intersects

; 374  :         if ((size.x <= 0) || (size.y <= 0) ||
; 375  :             (rhs.size.x <= 0) || (rhs.size.y <= 0))

	test	esi, esi
	jle	SHORT $LN7@intersects
	test	ebx, ebx
	jle	SHORT $LN7@intersects
	test	edi, edi
	jle	SHORT $LN7@intersects
	test	ecx, ecx
	jle	SHORT $LN7@intersects

; 377  :         return true;

	pop	edi
	pop	esi
	mov	al, 1
	pop	ebx

; 378  :       }

	pop	ebp
	ret	4
$LN7@intersects:
	pop	edi
	pop	esi

; 376  :           return false;

	xor	al, al
	pop	ebx

; 378  :       }

	pop	ebp
	ret	4
?intersects@kdu_dims@@QAE_NAAU1@@Z ENDP			; kdu_dims::intersects
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??_4kdu_dims@@QAE?AU0@AAU0@@Z
_TEXT	SEGMENT
tv336 = -4						; size = 4
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??_4kdu_dims@@QAE?AU0@AAU0@@Z PROC			; kdu_dims::operator&=, COMDAT
; _this$ = ecx

; 344  :       {

	push	ebp
	mov	ebp, esp
	push	ecx
	push	ebx
	push	esi
	mov	esi, ecx

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	mov	ecx, DWORD PTR _rhs$[ebp]
	push	edi
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR [ecx+12]
	mov	edi, DWORD PTR [esi+12]
	add	eax, edx
	add	edi, DWORD PTR [esi+4]
	mov	ebx, DWORD PTR [esi+8]
	add	ebx, DWORD PTR [esi]
	mov	ecx, DWORD PTR [ecx+8]
	mov	DWORD PTR tv336[ebp], edx
	mov	edx, DWORD PTR _rhs$[ebp]
	add	ecx, DWORD PTR [edx]

; 345  :       /* [SYNOPSIS]
; 346  :            Intersects the region represented by `rhs' with that  represented
; 347  :            by the current object.
; 348  :       */
; 349  :         kdu_coords lim = pos+size;
; 350  :         kdu_coords rhs_lim = rhs.pos + rhs.size;
; 351  :         if (lim.x > rhs_lim.x) lim.x = rhs_lim.x;

	cmp	edi, eax
	cmovg	edi, eax

; 352  :         if (lim.y > rhs_lim.y) lim.y  = rhs_lim.y;
; 353  :         if (pos.x < rhs.pos.x) pos.x = rhs.pos.x;

	mov	eax, DWORD PTR tv336[ebp]
	cmp	ebx, ecx
	cmovg	ebx, ecx
	cmp	DWORD PTR [esi+4], eax
	jge	SHORT $LN4@operator
	mov	DWORD PTR [esi+4], eax
$LN4@operator:

; 354  :         if (pos.y < rhs.pos.y) pos.y = rhs.pos.y;

	mov	eax, edx
	mov	eax, DWORD PTR [eax]
	cmp	DWORD PTR [esi], eax
	jge	SHORT $LN5@operator
	mov	DWORD PTR [esi], eax
$LN5@operator:

; 224  :     kdu_coords plus(const kdu_coords &rhs)
; 225  :       { /* [SYNOPSIS] Same as `operator+', but more suitable for
; 226  :                       some language bindings. */
; 227  :            return (*this)+rhs;
; 228  :       }
; 229  :     kdu_coords operator-(const kdu_coords &rhs)
; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	sub	edi, DWORD PTR [esi+4]
	sub	ebx, DWORD PTR [esi]

; 355  :         size = lim-pos;

	mov	DWORD PTR [esi+8], ebx
	mov	DWORD PTR [esi+12], edi

; 356  :         if (size.x < 0) size.x = 0;

	test	edi, edi
	jge	SHORT $LN6@operator
	mov	DWORD PTR [esi+12], 0
$LN6@operator:

; 357  :         if (size.y < 0) size.y = 0;

	test	ebx, ebx
	jge	SHORT $LN7@operator
	mov	DWORD PTR [esi+8], 0
$LN7@operator:

; 358  :         return *this;

	movups	xmm0, XMMWORD PTR [esi]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	pop	edi
	pop	esi
	pop	ebx
	movups	XMMWORD PTR [eax], xmm0

; 359  :       }

	mov	esp, ebp
	pop	ebp
	ret	8
??_4kdu_dims@@QAE?AU0@AAU0@@Z ENDP			; kdu_dims::operator&=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??Ikdu_dims@@QAE?AU0@AAU0@@Z
_TEXT	SEGMENT
$T1 = -16						; size = 16
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??Ikdu_dims@@QAE?AU0@AAU0@@Z PROC			; kdu_dims::operator&, COMDAT
; _this$ = ecx

; 333  :       { kdu_dims result = *this; result &= rhs; return result; }

	push	ebp
	mov	ebp, esp
	movups	xmm0, XMMWORD PTR [ecx]
	sub	esp, 16					; 00000010H
	lea	eax, DWORD PTR $T1[ebp]
	push	esi
	mov	esi, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, esi
	push	DWORD PTR _rhs$[ebp]
	push	eax
	movups	XMMWORD PTR [esi], xmm0
	call	??_4kdu_dims@@QAE?AU0@AAU0@@Z		; kdu_dims::operator&=
	mov	eax, esi
	pop	esi
	mov	esp, ebp
	pop	ebp
	ret	8
??Ikdu_dims@@QAE?AU0@AAU0@@Z ENDP			; kdu_dims::operator&
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?transpose@kdu_dims@@QAEXXZ
_TEXT	SEGMENT
?transpose@kdu_dims@@QAEXXZ PROC			; kdu_dims::transpose, COMDAT
; _this$ = ecx

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	edx, DWORD PTR [ecx+8]
	mov	eax, DWORD PTR [ecx+12]
	mov	DWORD PTR [ecx+8], eax
	mov	DWORD PTR [ecx+12], edx
	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx

; 329  :       { size.transpose(); pos.transpose(); }

	ret	0
?transpose@kdu_dims@@QAEXXZ ENDP			; kdu_dims::transpose
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?area@kdu_dims@@QAE_JXZ
_TEXT	SEGMENT
?area@kdu_dims@@QAE_JXZ PROC				; kdu_dims::area, COMDAT
; _this$ = ecx

; 325  :       { return ((kdu_long) size.x) * ((kdu_long) size.y); }

	mov	eax, DWORD PTR [ecx+12]
	imul	DWORD PTR [ecx+8]
	ret	0
?area@kdu_dims@@QAE_JXZ ENDP				; kdu_dims::area
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_dims@@QAE@XZ
_TEXT	SEGMENT
??0kdu_dims@@QAE@XZ PROC				; kdu_dims::kdu_dims, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0

; 304  :     kdu_dims() {};

	mov	eax, ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx+4], 0
	mov	DWORD PTR [ecx+8], 0
	mov	DWORD PTR [ecx+12], 0

; 304  :     kdu_dims() {};

	ret	0
??0kdu_dims@@QAE@XZ ENDP				; kdu_dims::kdu_dims
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?to_apparent@kdu_coords@@QAEX_N00@Z
_TEXT	SEGMENT
_transp$ = 8						; size = 1
_vflip$ = 12						; size = 1
_hflip$ = 16						; size = 1
?to_apparent@kdu_coords@@QAEX_N00@Z PROC		; kdu_coords::to_apparent, COMDAT
; _this$ = ecx

; 271  :       { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 272  :              Does the reverse of `from_apparent', assuming the same values
; 273  :              for `transp', `vflip' and `hflip' are supplied.
; 274  :         */
; 275  :         if (transp) transpose();

	cmp	BYTE PTR _transp$[ebp], 0
	je	SHORT $LN2@to_apparen

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx
$LN2@to_apparen:

; 276  :         x = (hflip)?(-x):x;

	cmp	BYTE PTR _hflip$[ebp], 0
	mov	eax, DWORD PTR [ecx+4]
	je	SHORT $LN5@to_apparen
	neg	eax
$LN5@to_apparen:

; 277  :         y = (vflip)?(-y):y;

	cmp	BYTE PTR _vflip$[ebp], 0
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [ecx]
	je	SHORT $LN6@to_apparen
	neg	eax
$LN6@to_apparen:
	mov	DWORD PTR [ecx], eax

; 278  :       }

	pop	ebp
	ret	12					; 0000000cH
?to_apparent@kdu_coords@@QAEX_N00@Z ENDP		; kdu_coords::to_apparent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?from_apparent@kdu_coords@@QAEX_N00@Z
_TEXT	SEGMENT
_transp$ = 8						; size = 1
_vflip$ = 12						; size = 1
_hflip$ = 16						; size = 1
?from_apparent@kdu_coords@@QAEX_N00@Z PROC		; kdu_coords::from_apparent, COMDAT
; _this$ = ecx

; 260  :       { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 261  :              Converts a point from the apparent coordinate system established
; 262  :              by `kdu_codestream::change_appearance' to the real coordinates.
; 263  :              The `transp', `vflip' and `hflip' parameters are identical to
; 264  :              those supplied to `kdu_codestream::change_appearance'.
; 265  :         */
; 266  :         x=(hflip)?(-x):x;

	cmp	BYTE PTR _hflip$[ebp], 0
	mov	eax, DWORD PTR [ecx+4]
	je	SHORT $LN5@from_appar
	neg	eax
$LN5@from_appar:

; 267  :         y=(vflip)?(-y):y;

	cmp	BYTE PTR _vflip$[ebp], 0
	mov	edx, DWORD PTR [ecx]
	mov	DWORD PTR [ecx+4], eax
	je	SHORT $LN7@from_appar
	neg	edx
$LN7@from_appar:

; 268  :         if (transp) transpose();

	cmp	BYTE PTR _transp$[ebp], 0
	mov	DWORD PTR [ecx], edx
	je	SHORT $LN2@from_appar

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx
$LN2@from_appar:

; 269  :       }

	pop	ebp
	ret	12					; 0000000cH
?from_apparent@kdu_coords@@QAEX_N00@Z ENDP		; kdu_coords::from_apparent
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??9kdu_coords@@QAE_NABU0@@Z
_TEXT	SEGMENT
_rhs$ = 8						; size = 4
??9kdu_coords@@QAE_NABU0@@Z PROC			; kdu_coords::operator!=, COMDAT
; _this$ = ecx

; 258  :       { return (x!=rhs.x) || (y!=rhs.y); }

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [ecx+4]
	cmp	eax, DWORD PTR [edx+4]
	jne	SHORT $LN3@operator
	mov	eax, DWORD PTR [ecx]
	cmp	eax, DWORD PTR [edx]
	jne	SHORT $LN3@operator
	xor	al, al
	pop	ebp
	ret	4
$LN3@operator:
	mov	al, 1
	pop	ebp
	ret	4
??9kdu_coords@@QAE_NABU0@@Z ENDP			; kdu_coords::operator!=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??Zkdu_coords@@QAE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??Zkdu_coords@@QAE?AU0@ABU0@@Z PROC			; kdu_coords::operator-=, COMDAT
; _this$ = ecx

; 244  :       { x-=rhs.x; y-=rhs.y; return *this; }

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [edx+4]
	sub	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx]
	sub	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebp
	ret	8
??Zkdu_coords@@QAE?AU0@ABU0@@Z ENDP			; kdu_coords::operator-=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??Ykdu_coords@@QAE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??Ykdu_coords@@QAE?AU0@ABU0@@Z PROC			; kdu_coords::operator+=, COMDAT
; _this$ = ecx

; 237  :       { x+=rhs.x; y+=rhs.y; return *this; }

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR _rhs$[ebp]
	mov	eax, DWORD PTR [edx+4]
	add	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR [edx]
	add	DWORD PTR [ecx], eax
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	edx, DWORD PTR [ecx]
	mov	ecx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax], edx
	mov	DWORD PTR [eax+4], ecx
	pop	ebp
	ret	8
??Ykdu_coords@@QAE?AU0@ABU0@@Z ENDP			; kdu_coords::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??Gkdu_coords@@QAE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??Gkdu_coords@@QAE?AU0@ABU0@@Z PROC			; kdu_coords::operator-, COMDAT
; _this$ = ecx

; 230  :       { kdu_coords result; result.x=x-rhs.x; result.y=y-rhs.y; return result; }

	push	ebp
	mov	ebp, esp
	mov	edx, DWORD PTR [ecx+4]
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	mov	ecx, DWORD PTR [ecx]
	push	esi
	mov	esi, DWORD PTR _rhs$[ebp]
	sub	edx, DWORD PTR [esi+4]
	sub	ecx, DWORD PTR [esi]
	mov	DWORD PTR [eax+4], edx
	mov	DWORD PTR [eax], ecx
	pop	esi
	pop	ebp
	ret	8
??Gkdu_coords@@QAE?AU0@ABU0@@Z ENDP			; kdu_coords::operator-
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??Hkdu_coords@@QAE?AU0@ABU0@@Z
_TEXT	SEGMENT
___$ReturnUdt$ = 8					; size = 4
_rhs$ = 12						; size = 4
??Hkdu_coords@@QAE?AU0@ABU0@@Z PROC			; kdu_coords::operator+, COMDAT
; _this$ = ecx

; 223  :       { kdu_coords result; result.x=x+rhs.x; result.y=y+rhs.y; return result; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR ___$ReturnUdt$[ebp]
	push	esi
	mov	esi, DWORD PTR _rhs$[ebp]
	mov	edx, DWORD PTR [esi+4]
	add	edx, DWORD PTR [ecx+4]
	mov	DWORD PTR [eax+4], edx
	mov	edx, DWORD PTR [esi]
	add	edx, DWORD PTR [ecx]
	mov	DWORD PTR [eax], edx
	pop	esi
	pop	ebp
	ret	8
??Hkdu_coords@@QAE?AU0@ABU0@@Z ENDP			; kdu_coords::operator+
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ?transpose@kdu_coords@@QAEXXZ
_TEXT	SEGMENT
?transpose@kdu_coords@@QAEXXZ PROC			; kdu_coords::transpose, COMDAT
; _this$ = ecx

; 220  :     void transpose() {int tmp=y; y=x; x=tmp; }

	mov	edx, DWORD PTR [ecx]
	mov	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx], eax
	mov	DWORD PTR [ecx+4], edx
	ret	0
?transpose@kdu_coords@@QAEXXZ ENDP			; kdu_coords::transpose
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_coords@@QAE@HH@Z
_TEXT	SEGMENT
_x$ = 8							; size = 4
_y$ = 12						; size = 4
??0kdu_coords@@QAE@HH@Z PROC				; kdu_coords::kdu_coords, COMDAT
; _this$ = ecx

; 210  :     kdu_coords(int x, int y) {this->x=x; this->y=y; }

	push	ebp
	mov	ebp, esp
	mov	eax, DWORD PTR _x$[ebp]
	mov	DWORD PTR [ecx+4], eax
	mov	eax, DWORD PTR _y$[ebp]
	mov	DWORD PTR [ecx], eax
	mov	eax, ecx
	pop	ebp
	ret	8
??0kdu_coords@@QAE@HH@Z ENDP				; kdu_coords::kdu_coords
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_compressed.h
;	COMDAT ??0kdu_coords@@QAE@XZ
_TEXT	SEGMENT
??0kdu_coords@@QAE@XZ PROC				; kdu_coords::kdu_coords, COMDAT
; _this$ = ecx

; 209  :     kdu_coords() { x = y = 0; }

	mov	DWORD PTR [ecx], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx+4], 0
	ret	0
??0kdu_coords@@QAE@XZ ENDP				; kdu_coords::kdu_coords
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?release_lock@kdu_thread_entity@@QAEXH@Z
_TEXT	SEGMENT
_lock_id$ = 8						; size = 4
?release_lock@kdu_thread_entity@@QAEXH@Z PROC		; kdu_thread_entity::release_lock, COMDAT
; _this$ = ecx

; 1063 :       { kd_thread_lock *lock = locks + lock_id;

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+28]
	mov	eax, DWORD PTR _lock_id$[ebp]

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	mov	DWORD PTR [ecx+eax*8+4], 0
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx+eax*8]
	test	eax, eax
	je	SHORT $LN5@release_lo
	mov	DWORD PTR _lock_id$[ebp], eax
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	pop	ebp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	jmp	DWORD PTR __imp__ReleaseMutex@4
$LN5@release_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1065 :         lock->holder = NULL;  lock->mutex.unlock(); }

	pop	ebp
	ret	4
?release_lock@kdu_thread_entity@@QAEXH@Z ENDP		; kdu_thread_entity::release_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h
;	COMDAT ?acquire_lock@kdu_thread_entity@@QAEXH_N@Z
_TEXT	SEGMENT
_lock_id$ = 8						; size = 4
$T1 = 12						; size = 4
_allow_exceptions$ = 12					; size = 1
?acquire_lock@kdu_thread_entity@@QAEXH_N@Z PROC		; kdu_thread_entity::acquire_lock, COMDAT
; _this$ = ecx

; 1024 :       { kd_thread_lock *lock = locks + lock_id;

	push	ebp
	mov	ebp, esp

; 1025 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder != this));
; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	cmp	BYTE PTR _allow_exceptions$[ebp], 0
	mov	eax, DWORD PTR _lock_id$[ebp]
	push	esi
	mov	esi, ecx
	push	edi
	mov	edx, DWORD PTR [esi+28]
	lea	edi, DWORD PTR [edx+eax*8]
	je	SHORT $LN2@acquire_lo
	mov	eax, DWORD PTR [esi+20]
	cmp	BYTE PTR [eax], 0
	jne	SHORT $LN9@acquire_lo
$LN2@acquire_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h

; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [edi]
	test	eax, eax
	je	SHORT $LN6@acquire_lo
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
$LN6@acquire_lo:
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_threads.h

; 1027 :         lock->mutex.lock(); lock->holder = this; }

	mov	DWORD PTR [edi+4], esi
	pop	edi
	pop	esi
	pop	ebp
	ret	8
$LN9@acquire_lo:

; 1025 :         assert((lock_id>=0) && (lock_id<num_locks) && (lock->holder != this));
; 1026 :         if (allow_exceptions && grouperr->failed) throw grouperr->failure_code;

	mov	eax, DWORD PTR [eax+4]
	mov	DWORD PTR $T1[ebp], eax
	lea	eax, DWORD PTR $T1[ebp]
	push	OFFSET __TI1H
	push	eax
	call	__CxxThrowException@8
$LN11@acquire_lo:
$LN8@acquire_lo:
	int	3
?acquire_lock@kdu_thread_entity@@QAEXH_N@Z ENDP		; kdu_thread_entity::acquire_lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
;	COMDAT ?get_lifting_factors@kdu_kernels@@QAEPBMAAHAAM1@Z
_TEXT	SEGMENT
_num_steps$ = 8						; size = 4
_dc_scale$ = 12						; size = 4
_nyq_scale$ = 16					; size = 4
?get_lifting_factors@kdu_kernels@@QAEPBMAAHAAM1@Z PROC	; kdu_kernels::get_lifting_factors, COMDAT
; _this$ = ecx

; 246  :         {

	push	ebp
	mov	ebp, esp

; 247  :           num_steps = this->num_steps; dc_scale = this->low_scale;

	mov	eax, DWORD PTR _num_steps$[ebp]
	mov	edx, DWORD PTR [ecx+8]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR _dc_scale$[ebp]
	mov	edx, DWORD PTR [ecx+24]
	mov	DWORD PTR [eax], edx

; 248  :           nyq_scale = this->high_scale; return lifting_factors;

	mov	eax, DWORD PTR _nyq_scale$[ebp]
	mov	edx, DWORD PTR [ecx+28]
	mov	DWORD PTR [eax], edx
	mov	eax, DWORD PTR [ecx+20]

; 249  :         }

	pop	ebp
	ret	12					; 0000000cH
?get_lifting_factors@kdu_kernels@@QAEPBMAAHAAM1@Z ENDP	; kdu_kernels::get_lifting_factors
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
;	COMDAT ??1kdu_kernels@@QAE@XZ
_TEXT	SEGMENT
__$EHRec$ = -12						; size = 12
??1kdu_kernels@@QAE@XZ PROC				; kdu_kernels::~kdu_kernels, COMDAT
; _this$ = ecx

; 147  :     ~kdu_kernels() { reset(); }

	push	ebp
	mov	ebp, esp
	push	-1
	push	__ehhandler$??1kdu_kernels@@QAE@XZ
	mov	eax, DWORD PTR fs:0
	push	eax
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	push	eax
	lea	eax, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, eax
	call	?reset@kdu_kernels@@AAEXXZ		; kdu_kernels::reset
	mov	ecx, DWORD PTR __$EHRec$[ebp]
	mov	DWORD PTR fs:0, ecx
	pop	ecx
	mov	esp, ebp
	pop	ebp
	ret	0
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
__ehhandler$??1kdu_kernels@@QAE@XZ:
	mov	edx, DWORD PTR [esp+8]
	lea	eax, DWORD PTR [edx+12]
	mov	ecx, DWORD PTR [edx-4]
	xor	ecx, eax
	call	@__security_check_cookie@4
	mov	eax, OFFSET __ehfuncinfo$??1kdu_kernels@@QAE@XZ
	jmp	___CxxFrameHandler3
text$x	ENDS
??1kdu_kernels@@QAE@XZ ENDP				; kdu_kernels::~kdu_kernels
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
;	COMDAT ??0kdu_kernels@@QAE@XZ
_TEXT	SEGMENT
??0kdu_kernels@@QAE@XZ PROC				; kdu_kernels::kdu_kernels, COMDAT
; _this$ = ecx

; 135  :     kdu_kernels() { clear(); }

	push	esi
	mov	esi, ecx
	call	?clear@kdu_kernels@@AAEXXZ		; kdu_kernels::clear
	mov	eax, esi
	pop	esi
	ret	0
??0kdu_kernels@@QAE@XZ ENDP				; kdu_kernels::kdu_kernels
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_kernels.h
;	COMDAT ??0kdu_kernel_step_info@@QAE@XZ
_TEXT	SEGMENT
??0kdu_kernel_step_info@@QAE@XZ PROC			; kdu_kernel_step_info::kdu_kernel_step_info, COMDAT
; _this$ = ecx

; 101  :       { support_length = support_min = 0;  downshift = rounding_offset = 0; }

	mov	DWORD PTR [ecx+4], 0
	mov	eax, ecx
	mov	DWORD PTR [ecx], 0
	mov	DWORD PTR [ecx+12], 0
	mov	DWORD PTR [ecx+8], 0
	ret	0
??0kdu_kernel_step_info@@QAE@XZ ENDP			; kdu_kernel_step_info::kdu_kernel_step_info
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ??_Gkdu_output@@UAEPAXI@Z
_TEXT	SEGMENT
___flags$ = 8						; size = 4
??_Gkdu_output@@UAEPAXI@Z PROC				; kdu_output::`scalar deleting destructor', COMDAT
; _this$ = ecx
	push	ebp
	mov	ebp, esp
	test	BYTE PTR ___flags$[ebp], 1
	push	esi
	mov	esi, ecx

; 132  :     virtual ~kdu_output() { return; }

	mov	DWORD PTR [esi], OFFSET ??_7kdu_output@@6B@
	je	SHORT $LN7@scalar
	push	524					; 0000020cH
	push	esi
	call	??3@YAXPAXI@Z				; operator delete
	add	esp, 8
$LN7@scalar:
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??_Gkdu_output@@UAEPAXI@Z ENDP				; kdu_output::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?put@kdu_output@@QAEHI@Z
_TEXT	SEGMENT
_word$ = 8						; size = 4
?put@kdu_output@@QAEHI@Z PROC				; kdu_output::put, COMDAT
; _this$ = ecx

; 155  :       {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN4@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
$LN4@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 156  :       /* [SYNOPSIS] Writes a 4-byte word in big-endian order.
; 157  :          [RETURNS] Always returns 4. */
; 158  :         put((kdu_byte)(word>>24));

	mov	ebx, DWORD PTR _word$[ebp]
	mov	ecx, ebx
	shr	ecx, 24					; 00000018H

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN7@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN7@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 159  :         put((kdu_byte)(word>>16));

	mov	ecx, ebx
	shr	ecx, 16					; 00000010H

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN10@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN10@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 160  :         put((kdu_byte)(word>>8));

	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN13@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN13@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl

; 161  :         put((kdu_byte)(word>>0));
; 162  :         return 4;

	mov	eax, 4

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
	pop	esi
	pop	ebx

; 163  :       }

	pop	ebp
	ret	4
?put@kdu_output@@QAEHI@Z ENDP				; kdu_output::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?put@kdu_output@@QAEHG@Z
_TEXT	SEGMENT
_word$ = 8						; size = 2
?put@kdu_output@@QAEHG@Z PROC				; kdu_output::put, COMDAT
; _this$ = ecx

; 147  :       {

	push	ebp
	mov	ebp, esp
	push	ebx
	push	esi
	mov	esi, ecx

; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN4@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
$LN4@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]

; 148  :       /* [SYNOPSIS] Writes a 2-byte word in big-endian order.
; 149  :          [RETURNS] Always returns 2. */
; 150  :         put((kdu_byte)(word>>8));

	mov	ebx, DWORD PTR _word$[ebp]
	mov	ecx, ebx
	shr	ecx, 8

; 143  :         *(next_buf++) = byte;

	mov	BYTE PTR [eax], cl
	inc	DWORD PTR [esi+516]
	mov	eax, DWORD PTR [esi+516]

; 141  :         if (next_buf == end_buf)

	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN7@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	mov	ecx, esi
	call	DWORD PTR [eax+4]
$LN7@put:

; 143  :         *(next_buf++) = byte;

	mov	eax, DWORD PTR [esi+516]
	mov	BYTE PTR [eax], bl

; 151  :         put((kdu_byte)(word>>0));
; 152  :         return 2;

	mov	eax, 2

; 143  :         *(next_buf++) = byte;

	inc	DWORD PTR [esi+516]
	pop	esi
	pop	ebx

; 153  :       }

	pop	ebp
	ret	4
?put@kdu_output@@QAEHG@Z ENDP				; kdu_output::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ?put@kdu_output@@QAEHE@Z
_TEXT	SEGMENT
_byte$ = 8						; size = 1
?put@kdu_output@@QAEHE@Z PROC				; kdu_output::put, COMDAT
; _this$ = ecx

; 138  :       {

	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, ecx

; 139  :       /* [SYNOPSIS] Writes a single byte.
; 140  :          [RETURNS] Always returns 1. */
; 141  :         if (next_buf == end_buf)

	mov	eax, DWORD PTR [esi+516]
	cmp	eax, DWORD PTR [esi+520]
	jne	SHORT $LN2@put

; 142  :           { flush_buf(); assert(next_buf < end_buf); }

	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+4]
$LN2@put:

; 143  :         *(next_buf++) = byte;

	mov	ecx, DWORD PTR [esi+516]
	mov	al, BYTE PTR _byte$[ebp]
	mov	BYTE PTR [ecx], al

; 144  :         return 1;

	mov	eax, 1
	inc	DWORD PTR [esi+516]
	pop	esi

; 145  :       }

	pop	ebp
	ret	4
?put@kdu_output@@QAEHE@Z ENDP				; kdu_output::put
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ??1kdu_output@@UAE@XZ
_TEXT	SEGMENT
??1kdu_output@@UAE@XZ PROC				; kdu_output::~kdu_output, COMDAT
; _this$ = ecx

; 132  :     virtual ~kdu_output() { return; }

	mov	DWORD PTR [ecx], OFFSET ??_7kdu_output@@6B@
	ret	0
??1kdu_output@@UAE@XZ ENDP				; kdu_output::~kdu_output
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_params.h
;	COMDAT ??0kdu_output@@QAE@XZ
_TEXT	SEGMENT
??0kdu_output@@QAE@XZ PROC				; kdu_output::kdu_output, COMDAT
; _this$ = ecx

; 131  :       { next_buf = buffer; end_buf = buffer+KDU_OBUF_SIZE; }

	lea	edx, DWORD PTR [ecx+516]
	mov	DWORD PTR [ecx], OFFSET ??_7kdu_output@@6B@
	lea	eax, DWORD PTR [ecx+4]
	mov	DWORD PTR [ecx+520], edx
	mov	DWORD PTR [edx], eax
	mov	eax, ecx
	ret	0
??0kdu_output@@QAE@XZ ENDP				; kdu_output::kdu_output
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
;	COMDAT ?floor_ratio@@YAHHH@Z
_TEXT	SEGMENT
_num$ = 8						; size = 4
_den$ = 12						; size = 4
?floor_ratio@@YAHHH@Z PROC				; floor_ratio, COMDAT

; 191  : { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 192  :        Returns the floor function of the ratio `num' / `den', where
; 193  :        the denominator is required to be strictly positive.
; 194  :      [RETURNS] Non-negative ratio.
; 195  :      [ARG: num] Non-negative numerator.
; 196  :      [ARG: den] Non-negative denomenator.
; 197  :   */
; 198  :   assert(den > 0);
; 199  :   if (num < 0)

	mov	edx, DWORD PTR _num$[ebp]
	test	edx, edx
	jns	SHORT $LN2@floor_rati

; 200  :     return -(1+((-num-1)/den));

	or	ecx, -1
	mov	eax, ecx
	sub	eax, edx
	cdq
	idiv	DWORD PTR _den$[ebp]
	sub	ecx, eax
	mov	eax, ecx

; 203  : }

	pop	ebp
	ret	0
$LN2@floor_rati:

; 201  :   else
; 202  :     return num/den;

	mov	eax, edx
	cdq
	idiv	DWORD PTR _den$[ebp]

; 203  : }

	pop	ebp
	ret	0
?floor_ratio@@YAHHH@Z ENDP				; floor_ratio
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
;	COMDAT ?ceil_ratio@@YAHHH@Z
_TEXT	SEGMENT
_num$ = 8						; size = 4
_den$ = 12						; size = 4
?ceil_ratio@@YAHHH@Z PROC				; ceil_ratio, COMDAT

; 171  : { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 172  :        Returns the ceiling function of the ratio `num' / `den', where
; 173  :        the denominator is required to be strictly positive.
; 174  :      [RETURNS] Non-negative ratio.
; 175  :      [ARG: num] Non-negative numerator.
; 176  :      [ARG: den] Non-negative denomenator.
; 177  :   */
; 178  :   assert(den > 0);
; 179  :   if (num <= 0)

	mov	eax, DWORD PTR _num$[ebp]
	test	eax, eax
	jg	SHORT $LN2@ceil_ratio

; 180  :     return -((-num)/den);

	cdq
	idiv	DWORD PTR _den$[ebp]

; 183  : }

	pop	ebp
	ret	0
$LN2@ceil_ratio:

; 181  :   else
; 182  :     return 1+((num-1)/den);

	dec	eax
	cdq
	idiv	DWORD PTR _den$[ebp]
	inc	eax

; 183  : }

	pop	ebp
	ret	0
?ceil_ratio@@YAHHH@Z ENDP				; ceil_ratio
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_utils.h
;	COMDAT ?kdu_read@@YAHAAPAEPAEH@Z
_TEXT	SEGMENT
$T1 = 8							; size = 4
_bp$ = 8						; size = 4
_end$ = 12						; size = 4
_nbytes$ = 16						; size = 4
?kdu_read@@YAHAAPAEPAEH@Z PROC				; kdu_read, COMDAT

; 66   : { /* [SYNOPSIS]

	push	ebp
	mov	ebp, esp

; 67   :        Reads an integer quantity having an `nbytes' bigendian
; 68   :        representation from the array identified by `bp'.  During the process,
; 69   :        `bp' is advanced `nbytes' positions.  If this pushes it up to or past
; 70   :        the `end' pointer, the function throws an exception of type
; 71   :        `kdu_byte *'.
; 72   :        [//]
; 73   :        The byte order is assumed to be big-endian.  If the local machine
; 74   :        architecture is little-endian, the input bytes are reversed.
; 75   :      [RETURNS]
; 76   :        The value of the integer recovered from the first `nbytes' bytes of
; 77   :        the buffer.
; 78   :      [ARG: bp]
; 79   :        Pointer to the first byte in the buffer from which the integer is
; 80   :        to be recovered.
; 81   :      [ARG: end]
; 82   :        Points immediately beyond the last valid entry in the buffer.
; 83   :      [ARG: nbytes]
; 84   :        Number of bytes from the buffer which are to be converted into a
; 85   :        big-endian integer.  Must be one of 1, 2, 3 or 4.
; 86   :   */
; 87   :   int val;
; 88   : 
; 89   :   assert(nbytes <= 4);
; 90   :   if ((end-bp) < nbytes)

	mov	eax, DWORD PTR _end$[ebp]
	mov	edx, DWORD PTR _nbytes$[ebp]
	push	esi
	push	edi
	mov	edi, DWORD PTR _bp$[ebp]
	mov	ecx, DWORD PTR [edi]
	sub	eax, ecx
	cmp	eax, edx
	jl	SHORT $LN8@kdu_read

; 92   :   val = *(bp++);

	movzx	esi, BYTE PTR [ecx]
	inc	ecx
	mov	DWORD PTR [edi], ecx

; 93   :   if (nbytes > 1)

	cmp	edx, 1
	jle	SHORT $LN3@kdu_read

; 94   :     val = (val<<8) + *(bp++);

	movzx	eax, BYTE PTR [ecx]
	shl	esi, 8
	add	esi, eax
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [edi], eax
$LN3@kdu_read:

; 95   :   if (nbytes > 2)

	cmp	edx, 2
	jle	SHORT $LN4@kdu_read

; 96   :     val = (val<<8) + *(bp++);

	mov	ecx, DWORD PTR [edi]
	shl	esi, 8
	movzx	eax, BYTE PTR [ecx]
	add	esi, eax
	lea	eax, DWORD PTR [ecx+1]
	mov	DWORD PTR [edi], eax
$LN4@kdu_read:

; 97   :   if (nbytes > 3)

	cmp	edx, 3
	jle	SHORT $LN5@kdu_read

; 98   :     val = (val<<8) + *(bp++);

	mov	edx, DWORD PTR [edi]
	shl	esi, 8
	movzx	ecx, BYTE PTR [edx]
	add	esi, ecx
	lea	ecx, DWORD PTR [edx+1]
	mov	DWORD PTR [edi], ecx
$LN5@kdu_read:

; 99   :   return val;

	pop	edi
	mov	eax, esi
	pop	esi

; 100  : }

	pop	ebp
	ret	0
$LN8@kdu_read:

; 91   :     throw bp;

	push	OFFSET __TI2PAE
	lea	eax, DWORD PTR $T1[ebp]
	mov	DWORD PTR $T1[ebp], ecx
	push	eax
	call	__CxxThrowException@8
$LN10@kdu_read:
$LN7@kdu_read:
	int	3
?kdu_read@@YAHAAPAEPAEH@Z ENDP				; kdu_read
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_warning@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_warning@@UAEXPBG@Z PROC			; kdu_warning::put_text, COMDAT
; _this$ = ecx

; 655  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_warning@@UAEXPBG@Z ENDP			; kdu_warning::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_error@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_error@@UAEXPBG@Z PROC			; kdu_error::put_text, COMDAT
; _this$ = ecx

; 563  :       { if (handler != NULL) handler->put_text(string); }

	push	ebp
	mov	ebp, esp
	mov	ecx, DWORD PTR [ecx+8]
	test	ecx, ecx
	je	SHORT $LN2@put_text
	mov	eax, DWORD PTR [ecx]
	pop	ebp
	jmp	DWORD PTR [eax+4]
$LN2@put_text:
	pop	ebp
	ret	4
?put_text@kdu_error@@UAEXPBG@Z ENDP			; kdu_error::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message_formatter@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message_formatter@@UAEXPBG@Z PROC		; kdu_message_formatter::put_text, COMDAT
; _this$ = ecx

; 422  :       { kdu_message::put_text(string); }

	ret	4
?put_text@kdu_message_formatter@@UAEXPBG@Z ENDP		; kdu_message_formatter::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ??6kdu_message@@QAEAAV0@H@Z
_TEXT	SEGMENT
_text$ = -84						; size = 80
__$ArrayPad$ = -4					; size = 4
_val$ = 8						; size = 4
??6kdu_message@@QAEAAV0@H@Z PROC			; kdu_message::operator<<, COMDAT
; _this$ = ecx

; 261  :       { char text[80];

	push	ebp
	mov	ebp, esp
	sub	esp, 84					; 00000054H
	mov	eax, DWORD PTR ___security_cookie
	xor	eax, ebp
	mov	DWORD PTR __$ArrayPad$[ebp], eax
	push	esi

; 262  :         sprintf(text,(mode_hex)?"%x":"%d",val);

	push	DWORD PTR _val$[ebp]
	mov	esi, ecx
	mov	eax, OFFSET ??_C@_02NJNOFBBI@?$CFx?$AA@
	mov	ecx, OFFSET ??_C@_02DPKJAMEF@?$CFd?$AA@
	cmp	BYTE PTR [esi+4], 0
	cmove	eax, ecx
	push	eax
	lea	eax, DWORD PTR _text$[ebp]
	push	eax
	call	_sprintf

; 263  :         put_text(text); return *this; }

	mov	edx, DWORD PTR [esi]
	lea	eax, DWORD PTR _text$[ebp]
	add	esp, 12					; 0000000cH
	mov	ecx, esi
	push	eax
	call	DWORD PTR [edx+8]
	mov	ecx, DWORD PTR __$ArrayPad$[ebp]
	mov	eax, esi
	xor	ecx, ebp
	pop	esi
	call	@__security_check_cookie@4
	mov	esp, ebp
	pop	ebp
	ret	4
??6kdu_message@@QAEAAV0@H@Z ENDP			; kdu_message::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ??6kdu_message@@QAEAAV0@PBD@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
??6kdu_message@@QAEAAV0@PBD@Z PROC			; kdu_message::operator<<, COMDAT
; _this$ = ecx

; 257  :       { put_text(string); return *this; }

	push	ebp
	mov	ebp, esp
	push	esi
	push	DWORD PTR _string$[ebp]
	mov	esi, ecx
	mov	eax, DWORD PTR [esi]
	call	DWORD PTR [eax+8]
	mov	eax, esi
	pop	esi
	pop	ebp
	ret	4
??6kdu_message@@QAEAAV0@PBD@Z ENDP			; kdu_message::operator<<
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_messaging.h
;	COMDAT ?put_text@kdu_message@@UAEXPBG@Z
_TEXT	SEGMENT
_string$ = 8						; size = 4
?put_text@kdu_message@@UAEXPBG@Z PROC			; kdu_message::put_text, COMDAT
; _this$ = ecx

; 209  :     virtual void put_text(const kdu_uint16 *string) { return; }

	ret	4
?put_text@kdu_message@@UAEXPBG@Z ENDP			; kdu_message::put_text
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT _sprintf
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
_sprintf PROC						; COMDAT

; 1776 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	lea	eax, DWORD PTR __Format$[ebp+4]
	push	eax
	push	0
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1777 :     int _Result;
; 1778 :     va_list _ArgList;
; 1779 :     __crt_va_start(_ArgList, _Format);
; 1780 : 
; 1781 :     #pragma warning(push)
; 1782 :     #pragma warning(disable: 4996) // Deprecation
; 1783 :     _Result = _vsprintf_l(_Buffer, _Format, NULL, _ArgList);
; 1784 :     #pragma warning(pop)
; 1785 : 
; 1786 :     __crt_va_end(_ArgList);
; 1787 :     return _Result;
; 1788 : }

	pop	ebp
	ret	0
_sprintf ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__Format$ = 12						; size = 4
__Locale$ = 16						; size = 4
__ArgList$ = 20						; size = 4
__vsprintf_l PROC					; COMDAT

; 1455 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	-1
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1456 :     #pragma warning(push)
; 1457 :     #pragma warning(disable: 4996) // Deprecation
; 1458 :     return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
; 1459 :     #pragma warning(pop)
; 1460 : }

	pop	ebp
	ret	0
__vsprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\stdio.h
;	COMDAT __vsnprintf_l
_TEXT	SEGMENT
__Buffer$ = 8						; size = 4
__BufferCount$ = 12					; size = 4
__Format$ = 16						; size = 4
__Locale$ = 20						; size = 4
__ArgList$ = 24						; size = 4
__vsnprintf_l PROC					; COMDAT

; 1385 : {

	push	ebp
	mov	ebp, esp

; 1386 :     int const _Result = __stdio_common_vsprintf(

	push	DWORD PTR __ArgList$[ebp]
	push	DWORD PTR __Locale$[ebp]
	push	DWORD PTR __Format$[ebp]
	push	DWORD PTR __BufferCount$[ebp]
	push	DWORD PTR __Buffer$[ebp]
	call	___local_stdio_printf_options
	mov	ecx, DWORD PTR [eax]
	push	DWORD PTR [eax+4]
	or	ecx, 1
	push	ecx
	call	DWORD PTR __imp____stdio_common_vsprintf

; 1387 :         _CRT_INTERNAL_LOCAL_PRINTF_OPTIONS | _CRT_INTERNAL_PRINTF_LEGACY_VSPRINTF_NULL_TERMINATION,
; 1388 :         _Buffer, _BufferCount, _Format, _Locale, _ArgList);
; 1389 : 
; 1390 :     return _Result < 0 ? -1 : _Result;

	or	ecx, -1
	add	esp, 28					; 0000001cH
	test	eax, eax
	cmovs	eax, ecx

; 1391 : }

	pop	ebp
	ret	0
__vsnprintf_l ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\visual studio\vc\include\vadefs.h
;	COMDAT ??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ
_TEXT	SEGMENT
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ PROC	; __vcrt_va_start_verify_argument_type<char const * const>, COMDAT

; 145  :             static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value, "va_start argument must not have reference type and must not be parenthesized");
; 146  :         }

	ret	0
??$__vcrt_va_start_verify_argument_type@QBD@@YAXXZ ENDP	; __vcrt_va_start_verify_argument_type<char const * const>
_TEXT	ENDS
; Function compile flags: /Ogtp
; File c:\program files (x86)\windows kits\10\include\10.0.10240.0\ucrt\corecrt_stdio_config.h
;	COMDAT ___local_stdio_printf_options
_TEXT	SEGMENT
___local_stdio_printf_options PROC			; COMDAT

; 74   :     static unsigned __int64 _OptionsStorage;
; 75   :     return &_OptionsStorage;

	mov	eax, OFFSET ?_OptionsStorage@?1??__local_stdio_printf_options@@9@4_KA ; `__local_stdio_printf_options'::`2'::_OptionsStorage

; 76   : }

	ret	0
___local_stdio_printf_options ENDP
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?unlock@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?unlock@kdu_mutex@@QAE_NXZ PROC				; kdu_mutex::unlock, COMDAT
; _this$ = ecx

; 561  :              Releases a previously locked mutex and unblocks any other
; 562  :              thread which might be waiting on the mutex.
; 563  :            [RETURNS]
; 564  :              False if the mutex has not been successfully created. */
; 565  : #       if defined KDU_WIN_THREADS
; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@unlock
	push	eax
	call	DWORD PTR __imp__ReleaseMutex@4
	cmp	eax, 1
	jne	SHORT $LN3@unlock
	mov	al, al

; 567  : #       elif defined KDU_PTHREADS
; 568  :           return (mutex_valid && (pthread_mutex_unlock(&mutex)==0));
; 569  : #       else
; 570  :           return false;
; 571  : #       endif
; 572  :       }

	ret	0
$LN3@unlock:

; 561  :              Releases a previously locked mutex and unblocks any other
; 562  :              thread which might be waiting on the mutex.
; 563  :            [RETURNS]
; 564  :              False if the mutex has not been successfully created. */
; 565  : #       if defined KDU_WIN_THREADS
; 566  :           return ((mutex != NULL) && (ReleaseMutex(mutex)==TRUE));

	xor	al, al

; 567  : #       elif defined KDU_PTHREADS
; 568  :           return (mutex_valid && (pthread_mutex_unlock(&mutex)==0));
; 569  : #       else
; 570  :           return false;
; 571  : #       endif
; 572  :       }

	ret	0
?unlock@kdu_mutex@@QAE_NXZ ENDP				; kdu_mutex::unlock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\common\kdu_elementary.h
;	COMDAT ?lock@kdu_mutex@@QAE_NXZ
_TEXT	SEGMENT
?lock@kdu_mutex@@QAE_NXZ PROC				; kdu_mutex::lock, COMDAT
; _this$ = ecx

; 528  :              Blocks the caller until the mutex is available.  You should
; 529  :              take steps to avoid blocking on a mutex which you have already
; 530  :              locked within the same thread of execution.
; 531  :            [RETURNS]
; 532  :              False if the mutex has not been successfully created. */
; 533  : #       if defined KDU_WIN_THREADS
; 534  :           return ((mutex != NULL) &&

	mov	eax, DWORD PTR [ecx]
	test	eax, eax
	je	SHORT $LN3@lock
	push	-1
	push	eax
	call	DWORD PTR __imp__WaitForSingleObject@8
	test	eax, eax
	jne	SHORT $LN3@lock
	mov	al, 1

; 535  :                   (WaitForSingleObject(mutex,INFINITE) == WAIT_OBJECT_0));
; 536  : #       elif defined KDU_PTHREADS
; 537  :           return (mutex_valid && (pthread_mutex_lock(&mutex)==0));
; 538  : #       else
; 539  :           return false;
; 540  : #       endif
; 541  :       }

	ret	0
$LN3@lock:

; 528  :              Blocks the caller until the mutex is available.  You should
; 529  :              take steps to avoid blocking on a mutex which you have already
; 530  :              locked within the same thread of execution.
; 531  :            [RETURNS]
; 532  :              False if the mutex has not been successfully created. */
; 533  : #       if defined KDU_WIN_THREADS
; 534  :           return ((mutex != NULL) &&

	xor	al, al

; 535  :                   (WaitForSingleObject(mutex,INFINITE) == WAIT_OBJECT_0));
; 536  : #       elif defined KDU_PTHREADS
; 537  :           return (mutex_valid && (pthread_mutex_lock(&mutex)==0));
; 538  : #       else
; 539  :           return false;
; 540  : #       endif
; 541  :       }

	ret	0
?lock@kdu_mutex@@QAE_NXZ ENDP				; kdu_mutex::lock
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?__empty_global_delete@@YAXPAXI@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
___formal$ = 12						; size = 4
?__empty_global_delete@@YAXPAXI@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAXI@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
; File e:\study\jpeg2000\visually_lossless_jpeg2000\modifiedkakadu\coresys\compressed\compressed.cpp
;	COMDAT ?__empty_global_delete@@YAXPAX@Z
_TEXT	SEGMENT
___formal$ = 8						; size = 4
?__empty_global_delete@@YAXPAX@Z PROC			; __empty_global_delete, COMDAT

	ret	0
?__empty_global_delete@@YAXPAX@Z ENDP			; __empty_global_delete
_TEXT	ENDS
; Function compile flags: /Ogtp
;	COMDAT ??_H@YGXPAXIIP6EPAX0@Z@Z
_TEXT	SEGMENT
___t$ = 8						; size = 4
___s$ = 12						; size = 4
___n$ = 16						; size = 4
___f$ = 20						; size = 4
??_H@YGXPAXIIP6EPAX0@Z@Z PROC				; `vector constructor iterator', COMDAT
	push	ebp
	mov	ebp, esp
	push	esi
	mov	esi, DWORD PTR ___n$[ebp]
	test	esi, esi
	je	SHORT $LN6@vector
	push	ebx
	mov	ebx, DWORD PTR ___f$[ebp]
	push	edi
	mov	edi, DWORD PTR ___t$[ebp]
$LL2@vector:
	mov	ecx, edi
	call	ebx
	add	edi, DWORD PTR ___s$[ebp]
	sub	esi, 1
	jne	SHORT $LL2@vector
	pop	edi
	pop	ebx
$LN6@vector:
	pop	esi
	pop	ebp
	ret	16					; 00000010H
??_H@YGXPAXIIP6EPAX0@Z@Z ENDP				; `vector constructor iterator'
_TEXT	ENDS
END
